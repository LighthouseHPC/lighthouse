<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Lighthouse: lapack/zhseqr.f File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!--<div id="titlearea">
</div>-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_42b7da8b2ebcfce3aea4b69198a0a9ad.html">lapack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">zhseqr.f File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a72a026b11daa19641a162d05b8b1e0c9"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="zhseqr_8f.html#a72a026b11daa19641a162d05b8b1e0c9">zhseqr</a> (JOB, COMPZ, N, ILO, IHI, H, LDH, W, Z, LDZ, WORK, LWORK, INFO)</td></tr>
<tr class="memdesc:a72a026b11daa19641a162d05b8b1e0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>ZHSEQR</b>  <a href="#a72a026b11daa19641a162d05b8b1e0c9"></a><br/></td></tr>
<tr class="separator:a72a026b11daa19641a162d05b8b1e0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a class="anchor" id="a72a026b11daa19641a162d05b8b1e0c9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine zhseqr </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>COMPZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IHI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex*16, dimension( ldh, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex*16, dimension( * )&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex*16, dimension( ldz, * )&#160;</td>
          <td class="paramname"><em>Z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDZ</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">complex*16, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>ZHSEQR</b> </p>
 
 Download ZHSEQR + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/zhseqr.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/zhseqr.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/zhseqr.f"> 
 [TXT]</a>
  <dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment">    ZHSEQR computes the eigenvalues of a Hessenberg matrix H
    and, optionally, the matrices T and Z from the Schur decomposition
    H = Z T Z**H, where T is an upper triangular matrix (the
    Schur form), and Z is the unitary matrix of Schur vectors.

    Optionally Z may be postmultiplied into an input unitary
    matrix Q so that this routine can give the Schur factorization
    of a matrix A which has been reduced to the Hessenberg form H
    by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*T*(QZ)**H.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">JOB</td><td><pre class="fragment">          JOB is CHARACTER*1
           = 'E':  compute eigenvalues only;
           = 'S':  compute eigenvalues and the Schur form T.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">COMPZ</td><td><pre class="fragment">          COMPZ is CHARACTER*1
           = 'N':  no Schur vectors are computed;
           = 'I':  Z is initialized to the unit matrix and the matrix Z
                   of Schur vectors of H is returned;
           = 'V':  Z must contain an unitary matrix Q on entry, and
                   the product Q*Z is returned.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
           The order of the matrix H.  N .GE. 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ILO</td><td><pre class="fragment">          ILO is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">IHI</td><td><pre class="fragment">          IHI is INTEGER

           It is assumed that H is already upper triangular in rows
           and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
           set by a previous call to ZGEBAL, and then passed to ZGEHRD
           when the matrix output by ZGEBAL is reduced to Hessenberg
           form. Otherwise ILO and IHI should be set to 1 and N
           respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
           If N = 0, then ILO = 1 and IHI = 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">H</td><td><pre class="fragment">          H is COMPLEX*16 array, dimension (LDH,N)
           On entry, the upper Hessenberg matrix H.
           On exit, if INFO = 0 and JOB = 'S', H contains the upper
           triangular matrix T from the Schur decomposition (the
           Schur form). If INFO = 0 and JOB = 'E', the contents of
           H are unspecified on exit.  (The output value of H when
           INFO.GT.0 is given under the description of INFO below.)

           Unlike earlier versions of ZHSEQR, this subroutine may
           explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1
           or j = IHI+1, IHI+2, ... N.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDH</td><td><pre class="fragment">          LDH is INTEGER
           The leading dimension of the array H. LDH .GE. max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">W</td><td><pre class="fragment">          W is COMPLEX*16 array, dimension (N)
           The computed eigenvalues. If JOB = 'S', the eigenvalues are
           stored in the same order as on the diagonal of the Schur
           form returned in H, with W(i) = H(i,i).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">Z</td><td><pre class="fragment">          Z is COMPLEX*16 array, dimension (LDZ,N)
           If COMPZ = 'N', Z is not referenced.
           If COMPZ = 'I', on entry Z need not be set and on exit,
           if INFO = 0, Z contains the unitary matrix Z of the Schur
           vectors of H.  If COMPZ = 'V', on entry Z must contain an
           N-by-N matrix Q, which is assumed to be equal to the unit
           matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
           if INFO = 0, Z contains Q*Z.
           Normally Q is the unitary matrix generated by ZUNGHR
           after the call to ZGEHRD which formed the Hessenberg matrix
           H. (The output value of Z when INFO.GT.0 is given under
           the description of INFO below.)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDZ</td><td><pre class="fragment">          LDZ is INTEGER
           The leading dimension of the array Z.  if COMPZ = 'I' or
           COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is COMPLEX*16 array, dimension (LWORK)
           On exit, if INFO = 0, WORK(1) returns an estimate of
           the optimal value for LWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
           The dimension of the array WORK.  LWORK .GE. max(1,N)
           is sufficient and delivers very good and sometimes
           optimal performance.  However, LWORK as large as 11*N
           may be required for optimal performance.  A workspace
           query is recommended to determine the optimal workspace
           size.

           If LWORK = -1, then ZHSEQR does a workspace query.
           In this case, ZHSEQR checks the input parameters and
           estimates the optimal workspace size for the given
           values of N, ILO and IHI.  The estimate is returned
           in WORK(1).  No error message related to LWORK is
           issued by XERBLA.  Neither H nor Z are accessed.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
             =  0:  successful exit
           .LT. 0:  if INFO = -i, the i-th argument had an illegal
                    value
           .GT. 0:  if INFO = i, ZHSEQR failed to compute all of
                the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                and WI contain those eigenvalues which have been
                successfully computed.  (Failures are rare.)

                If INFO .GT. 0 and JOB = 'E', then on exit, the
                remaining unconverged eigenvalues are the eigen-
                values of the upper Hessenberg matrix rows and
                columns ILO through INFO of the final, output
                value of H.

                If INFO .GT. 0 and JOB   = 'S', then on exit

           (*)  (initial value of H)*U  = U*(final value of H)

                where U is a unitary matrix.  The final
                value of  H is upper Hessenberg and triangular in
                rows and columns INFO+1 through IHI.

                If INFO .GT. 0 and COMPZ = 'V', then on exit

                  (final value of Z)  =  (initial value of Z)*U

                where U is the unitary matrix in (*) (regard-
                less of the value of JOB.)

                If INFO .GT. 0 and COMPZ = 'I', then on exit
                      (final value of Z)  = U
                where U is the unitary matrix in (*) (regard-
                less of the value of JOB.)

                If INFO .GT. 0 and COMPZ = 'N', then Z is not
                accessed.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2013 </dd></dl>
<dl class="section user"><dt>Contributors: </dt><dd>Karen Braman and Ralph Byers, Department of Mathematics, University of Kansas, USA </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">             Default values supplied by
             ILAENV(ISPEC,'ZHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).
             It is suggested that these defaults be adjusted in order
             to attain best performance in each particular
             computational environment.

            ISPEC=12: The ZLAHQR vs ZLAQR0 crossover point.
                      Default: 75. (Must be at least 11.)

            ISPEC=13: Recommended deflation window size.
                      This depends on ILO, IHI and NS.  NS is the
                      number of simultaneous shifts returned
                      by ILAENV(ISPEC=15).  (See ISPEC=15 below.)
                      The default for (IHI-ILO+1).LE.500 is NS.
                      The default for (IHI-ILO+1).GT.500 is 3*NS/2.

            ISPEC=14: Nibble crossover point. (See IPARMQ for
                      details.)  Default: 14% of deflation window
                      size.

            ISPEC=15: Number of simultaneous shifts in a multishift
                      QR iteration.

                      If IHI-ILO+1 is ...

                      greater than      ...but less    ... the
                      or equal to ...      than        default is

                           1               30          NS =   2(+)
                          30               60          NS =   4(+)
                          60              150          NS =  10(+)
                         150              590          NS =  **
                         590             3000          NS =  64
                        3000             6000          NS = 128
                        6000             infinity      NS = 256

                  (+)  By default some or all matrices of this order
                       are passed to the implicit double shift routine
                       ZLAHQR and this parameter is ignored.  See
                       ISPEC=12 above and comments in IPARMQ for
                       details.

                 (**)  The asterisks (**) indicate an ad-hoc
                       function of N increasing from 10 to 64.

            ISPEC=16: Select structured matrix multiply.
                      If the number of simultaneous shifts (specified
                      by ISPEC=15) is less than 14, then the default
                      for ISPEC=16 is 0.  Otherwise the default for
                      ISPEC=16 is 2.</pre> </dd></dl>
<dl class="section user"><dt>References: </dt><dd>K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part I: Maintaining Well Focused Shifts, and Level 3 Performance, SIAM Journal of Matrix Analysis, volume 23, pages 929&ndash;947, 2002. <br/>
 K. Braman, R. Byers and R. Mathias, The Multi-Shift QR Algorithm Part II: Aggressive Early Deflation, SIAM Journal of Matrix Analysis, volume 23, pages 948&ndash;973, 2002. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Apr 14 2014 15:58:53 for Lighthouse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
