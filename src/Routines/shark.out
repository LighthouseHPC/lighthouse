-- MySQL dump 10.13  Distrib 5.1.41, for debian-linux-gnu (x86_64)
--
-- Host: hooray    Database: shark
-- ------------------------------------------------------
-- Server version	5.0.51a-3ubuntu5.7

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Not dumping tablespaces as no INFORMATION_SCHEMA.FILES table on this server
--

--
-- Table structure for table `Articles`
--

DROP TABLE IF EXISTS `Articles`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Articles` (
  `ArticleID` smallint(6) NOT NULL,
  `ArticleTitle` varchar(60) NOT NULL,
  `Copyright` year(4) NOT NULL,
  PRIMARY KEY  (`ArticleID`),
  FULLTEXT KEY `ArticleTitle` (`ArticleTitle`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Articles`
--

LOCK TABLES `Articles` WRITE;
/*!40000 ALTER TABLE `Articles` DISABLE KEYS */;
INSERT INTO `Articles` VALUES (12786,'How write a paper',1934),(13331,'Publish a paper',1919),(14356,'Sell a paper',1966),(15729,'Buy a paper',1932),(16284,'Conferences',1996),(17695,'Journal',1980),(19264,'Information',1992),(19354,'AI',1993);
/*!40000 ALTER TABLE `Articles` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `AuthorArticle`
--

DROP TABLE IF EXISTS `AuthorArticle`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `AuthorArticle` (
  `AuthID` smallint(6) NOT NULL,
  `ArticleID` smallint(6) NOT NULL,
  PRIMARY KEY  (`AuthID`,`ArticleID`),
  KEY `AuthID` (`AuthID`),
  KEY `ArticleID` (`ArticleID`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `AuthorArticle`
--

LOCK TABLES `AuthorArticle` WRITE;
/*!40000 ALTER TABLE `AuthorArticle` DISABLE KEYS */;
INSERT INTO `AuthorArticle` VALUES (1006,14356),(1008,15729),(1009,12786),(1010,17695),(1011,15729),(1012,19264),(1012,19354),(1014,16284);
/*!40000 ALTER TABLE `AuthorArticle` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Authors`
--

DROP TABLE IF EXISTS `Authors`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Authors` (
  `AuthID` smallint(6) NOT NULL,
  `AuthorFirstName` varchar(20) default NULL,
  `AuthorMiddleName` varchar(20) default NULL,
  `AuthorLastName` varchar(20) default NULL,
  PRIMARY KEY  (`AuthID`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Authors`
--

LOCK TABLES `Authors` WRITE;
/*!40000 ALTER TABLE `Authors` DISABLE KEYS */;
INSERT INTO `Authors` VALUES (1006,'Henry','S.','Thompson'),(1007,'Jason','Carol','Oak'),(1008,'James',NULL,'Elk'),(1009,'Tom','M','Ride'),(1010,'Jack','K','Ken'),(1011,'Mary','G.','Lee'),(1012,'Annie',NULL,'Peng'),(1013,'Alan',NULL,'Wang'),(1014,'Nelson',NULL,'Yin');
/*!40000 ALTER TABLE `Authors` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Duty`
--

DROP TABLE IF EXISTS `Duty`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Duty` (
  `id` int(11) default NULL,
  `task` varchar(20) default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Duty`
--

LOCK TABLES `Duty` WRITE;
/*!40000 ALTER TABLE `Duty` DISABLE KEYS */;
INSERT INTO `Duty` VALUES (1,'Test'),(2,'Calculate'),(3,'Program'),(3,'Program'),(5,'Manage'),(6,'Talk'),(7,'Speak'),(8,'Shout'),(9,'Walk');
/*!40000 ALTER TABLE `Duty` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `EMPLOYEE`
--

DROP TABLE IF EXISTS `EMPLOYEE`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `EMPLOYEE` (
  `FIRST_NAME` char(20) NOT NULL,
  `LAST_NAME` char(20) default NULL,
  `AGE` smallint(6) default NULL,
  `SEX` enum('F','M') default NULL,
  `INCOME` float default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `EMPLOYEE`
--

LOCK TABLES `EMPLOYEE` WRITE;
/*!40000 ALTER TABLE `EMPLOYEE` DISABLE KEYS */;
INSERT INTO `EMPLOYEE` VALUES ('Mac','Mohan',20,'M',2000);
/*!40000 ALTER TABLE `EMPLOYEE` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Employee`
--

DROP TABLE IF EXISTS `Employee`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Employee` (
  `id` int(11) default NULL,
  `first_name` varchar(15) default NULL,
  `last_name` varchar(15) default NULL,
  `start_date` date default NULL,
  `end_date` date default NULL,
  `salary` float(8,2) default NULL,
  `city` varchar(10) default NULL,
  `description` varchar(15) default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Employee`
--

LOCK TABLES `Employee` WRITE;
/*!40000 ALTER TABLE `Employee` DISABLE KEYS */;
INSERT INTO `Employee` VALUES (999,'Jason','Martin','1996-07-25','2006-07-25',1234.56,'Toronto','O'),(122,'Alison','Mathews','1976-03-21','1986-02-21',6661.78,'Vancouver','O'),(3,'James','Smith','1978-12-12','1990-03-15',6544.78,'Vancouver','U'),(4,'Celia','Rice','1982-10-24','1999-04-21',2344.78,'Vancouver','U'),(5,'Robert','Black','1984-01-15','1998-08-08',2334.78,'Vancouver','Tester'),(6,'Linda','Green','1987-07-30','1996-01-04',4322.78,'New York','N'),(7,'David','Larry','1990-12-31','1998-02-12',7897.78,'New York','N'),(8,'James','Cat','1996-09-17','2002-04-15',1232.78,'Vancouver','N');
/*!40000 ALTER TABLE `Employee` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Job`
--

DROP TABLE IF EXISTS `Job`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Job` (
  `id` int(11) default NULL,
  `title` varchar(20) default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Job`
--

LOCK TABLES `Job` WRITE;
/*!40000 ALTER TABLE `Job` DISABLE KEYS */;
INSERT INTO `Job` VALUES (1,'Tester'),(2,'Accountant'),(3,'Developer'),(4,'Coder'),(5,'Director'),(6,'Mediator'),(7,'Proffessor'),(8,'Programmer'),(9,'Developer');
/*!40000 ALTER TABLE `Job` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Linear_Equation`
--

DROP TABLE IF EXISTS `Linear_Equation`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Linear_Equation` (
  `id_le` smallint(5) unsigned NOT NULL auto_increment,
  `thePrecision` enum('s','d','c','z') default NULL,
  `routineName` varchar(6) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `structureType` enum('f','b','p','t','g') default NULL,
  `url` varchar(20) default NULL,
  `problem` smallint(5) unsigned NOT NULL,
  `description` varchar(255) default NULL,
  `information` mediumtext,
  PRIMARY KEY  (`id_le`),
  FULLTEXT KEY `routineName` (`routineName`,`matrixType`,`url`,`description`)
) ENGINE=MyISAM AUTO_INCREMENT=161 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Linear_Equation`
--

LOCK TABLES `Linear_Equation` WRITE;
/*!40000 ALTER TABLE `Linear_Equation` DISABLE KEYS */;
INSERT INTO `Linear_Equation` VALUES (1,'s','gesv','general','f','single/sgesv.f',1,'linear equation, simple driver,',NULL),(2,'d','gesv','general','f','double/dgesv.f',1,'linear equation, simple driver,',NULL),(3,'c','gesv','general','f','complex/cgesv.f',1,'linear equation, simple driver,',NULL),(4,'z','gesv','general','f','complex16/zgesv.f',1,'linear equation, simple driver,',NULL),(5,'s','gbsv','general','b','single/sgbsv.f',1,'linear equation, simple driver,',NULL),(6,'d','gbsv','general','b','double/dgbsv.f',1,'linear equation, simple driver,',NULL),(7,'c','gbsv','general','b','complex/cgbsv.f',1,'linear equation, simple driver,',NULL),(8,'z','gbsv','general','b','complex16/zgbsv.f',1,'linear equation, simple driver,',NULL),(9,'s','gtsv','general','t','single/sgtsv.f',1,'linear equation, simple driver,',NULL),(10,'d','gtsv','general','t','double/dgtsv.f',1,'linear equation, simple driver,',NULL),(11,'c','gtsv','general','t','complex/cgtsv.f',1,'linear equation, simple driver,',NULL),(12,'z','gtsv','general','t','complex16/zgtsv.f',1,'linear equation, simple driver,',NULL),(13,'c','hesv','Hermitian','f','complex/chesv.f',1,'linear equation, simple driver,',NULL),(14,'z','hesv','Hermitian','f','complex16/zhesv.f',1,'linear equation, simple driver,',NULL),(15,'c','hpsv','Hermitian','p','complex/chpsv.f',1,'linear equation, simple driver,',NULL),(16,'z','hpsv','Hermitian','p','complex16/zhpsv.f',1,'linear equation, simple driver,',NULL),(17,'s','posv','SPD','f','single/sposv.f',1,'linear equation, simple driver,',NULL),(18,'d','posv','SPD','f','double/dposv.f',1,'linear equation, simple driver,',NULL),(19,'c','posv','SPD','f','complex/cposv.f',1,'linear equation, simple driver,',NULL),(20,'z','posv','SPD','f','complex16/zposv.f',1,'linear equation, simple driver,',NULL),(21,'s','pbsv','SPD','b','single/spbsv.f',1,'linear equation, simple driver,',NULL),(22,'d','pbsv','SPD','b','double/dpbsv.f',1,'linear equation, simple driver,',NULL),(23,'c','pbsv','SPD','b','complex/cpbsv.f',1,'linear equation, simple driver,',NULL),(24,'z','pbsv','SPD','b','complex16/zpbsv.f',1,'linear equation, simple driver,',NULL),(25,'s','ppsv','SPD','p','single/sppsv.f',1,'linear equation, simple driver,',NULL),(26,'d','ppsv','SPD','p','double/dppsv.f',1,'linear equation, simple driver,',NULL),(27,'c','ppsv','SPD','p','complex/cppsv.f',1,'linear equation, simple driver,',NULL),(28,'z','ppsv','SPD','p','complex16/zppsv.f',1,'linear equation, simple driver,',NULL),(29,'s','ptsv','SPD','t','single/sptsv.f',1,'linear equation, simple driver,',NULL),(30,'d','ptsv','SPD','t','double/dptsv.f',1,'linear equation, simple driver,',NULL),(31,'c','ptsv','SPD','t','complex/cptsv.f',1,'linear equation, simple driver,',NULL),(32,'z','ptsv','SPD','t','complex16/zptsv.f',1,'linear equation, simple driver,',NULL),(33,'s','sysv','symmetric','f','single/ssysv.f',1,'linear equation, simple driver,',NULL),(34,'d','sysv','symmetric','f','double/dsysv.f',1,'linear equation, simple driver,',NULL),(35,'c','sysv','symmetric','f','complex/csysv.f',1,'linear equation, simple driver,',NULL),(36,'z','sysv','symmetric','f','complex16/zsysv.f',1,'linear equation, simple driver,',NULL),(37,'s','spsv','symmetric','p','single/sspsv.f',1,'linear equation, simple driver,',NULL),(38,'d','spsv','symmetric','p','double/dspsv.f',1,'linear equation, simple driver,',NULL),(39,'c','spsv','symmetric','p','complex/cspsv.f',1,'linear equation, simple driver,',NULL),(40,'z','spsv','symmetric','p','complex16/zspsv.f',1,'linear equation, simple driver,',NULL),(41,'s','gesvx','general','f','single/sgesvx.f',1,'linear equation, expert driver,',NULL),(42,'d','gesvx','general','f','double/dgesvx.f',1,'linear equation, expert driver,',NULL),(43,'c','gesvx','general','f','complex/cgesvx.f',1,'linear equation, expert driver,',NULL),(44,'z','gesvx','general','f','complex16/zgesvx.f',1,'linear equation, expert driver,',NULL),(45,'s','gbsvx','general','b','single/sgbsvx.f',1,'linear equation, expert driver,',NULL),(46,'d','gbsvx','general','b','double/dgbsvx.f',1,'linear equation, expert driver,',NULL),(47,'c','gbsvx','general','b','complex/cgbsvx.f',1,'linear equation, expert driver,',NULL),(48,'z','gbsvx','general','b','complex16/zgbsvx.f',1,'linear equation, expert driver,',NULL),(49,'s','gtsvx','general','t','single/sgtsvx.f',1,'linear equation, expert driver,',NULL),(50,'d','gtsvx','general','t','double/dgtsvx.f',1,'linear equation, expert driver,',NULL),(51,'c','gtsvx','general','t','complex/cgtsvx.f',1,'linear equation, expert driver,',NULL),(52,'z','gtsvx','general','t','complex16/zgtsvx.f',1,'linear equation, expert driver,',NULL),(53,'c','hesvx','Hermitian','f','complex/chesvx.f',1,'linear equation, expert driver,',NULL),(54,'z','hesvx','Hermitian','f','complex16/zhesvx.f',1,'linear equation, expert driver,',NULL),(55,'c','hpsvx','Hermitian','p','complex/chpsvx.f',1,'linear equation, expert driver,',NULL),(56,'z','hpsvx','Hermitian','p','complex16/zhpsvx.f',1,'linear equation, expert driver,',NULL),(57,'s','posvx','SPD','f','single/sposvx.f',1,'linear equation, expert driver,',NULL),(58,'d','posvx','SPD','f','double/dposvx.f',1,'linear equation, expert driver,',NULL),(59,'c','posvx','SPD','f','complex/cposvx.f',1,'linear equation, expert driver,',NULL),(60,'z','posvx','SPD','f','complex16/zposvx.f',1,'linear equation, expert driver,',NULL),(61,'s','pbsvx','SPD','b','single/spbsvx.f',1,'linear equation, expert driver,',NULL),(62,'d','pbsvx','SPD','b','double/dpbsvx.f',1,'linear equation, expert driver,',NULL),(63,'c','pbsvx','SPD','b','complex/cpbsvx.f',1,'linear equation, expert driver,',NULL),(64,'z','pbsvx','SPD','b','complex16/zpbsvx.f',1,'linear equation, expert driver,',NULL),(65,'s','ppsvx','SPD','p','single/sppsvx.f',1,'linear equation, expert driver,',NULL),(66,'d','ppsvx','SPD','p','double/dppsvx.f',1,'linear equation, expert driver,',NULL),(67,'c','ppsvx','SPD','p','complex/cppsvx.f',1,'linear equation, expert driver,',NULL),(68,'z','ppsvx','SPD','p','complex16/zppsvx.f',1,'linear equation, expert driver,',NULL),(69,'s','ptsvx','SPD','t','single/sptsvx.f',1,'linear equation, expert driver,',NULL),(70,'d','ptsvx','SPD','t','double/dptsvx.f',1,'linear equation, expert driver,',NULL),(71,'c','ptsvx','SPD','t','complex/cptsvx.f',1,'linear equation, expert driver,',NULL),(72,'z','ptsvx','SPD','t','complex16/zptsvx.f',1,'linear equation, expert driver,',NULL),(73,'s','sysvx','symmetric','f','single/ssysvx.f',1,'linear equation, expert driver,',NULL),(74,'d','sysvx','symmetric','f','double/dsysvx.f',1,'linear equation, expert driver,',NULL),(75,'c','sysvx','symmetric','f','complex/csysvx.f',1,'linear equation, expert driver,',NULL),(76,'z','sysvx','symmetric','f','complex16/zsysvx.f',1,'linear equation, expert driver,',NULL),(77,'s','spsvx','symmetric','p','single/sspsvx.f',1,'linear equation, expert driver,',NULL),(78,'d','spsvx','symmetric','p','double/dspsvx.f',1,'linear equation, expert driver,',NULL),(79,'c','spsvx','symmetric','p','complex/cspsvx.f',1,'linear equation, expert driver,',NULL),(80,'z','spsvx','symmetric','p','complex16/zspsvx.f',1,'linear equation, expert driver,',NULL),(81,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDA, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               A( LDA, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SGESV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.\n*\n*  The LU decomposition with partial pivoting and row interchanges is\n*  used to factor A as\n*     A = P * L * U,\n*  where P is a permutation matrix, L is unit lower triangular, and U is\n*  upper triangular.  The factored form of A is then used to solve the\n*  system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) REAL array, dimension (LDA,N)\n*          On entry, the N-by-N coefficient matrix A.\n*          On exit, the factors L and U from the factorization\n*          A = P*L*U; the unit diagonal elements of L are not stored.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          The pivot indices that define the permutation matrix P;\n*          row i of the matrix was interchanged with row IPIV(i).\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS matrix of right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n*                has been completed, but the factor U is exactly\n*                singular, so the solution could not be computed.\n*\n'),(82,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDA, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DGESV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.\n*\n*  The LU decomposition with partial pivoting and row interchanges is\n*  used to factor A as\n*     A = P * L * U,\n*  where P is a permutation matrix, L is unit lower triangular, and U is\n*  upper triangular.  The factored form of A is then used to solve the\n*  system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)\n*          On entry, the N-by-N coefficient matrix A.\n*          On exit, the factors L and U from the factorization\n*          A = P*L*U; the unit diagonal elements of L are not stored.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          The pivot indices that define the permutation matrix P;\n*          row i of the matrix was interchanged with row IPIV(i).\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS matrix of right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n*                has been completed, but the factor U is exactly\n*                singular, so the solution could not be computed.\n*\n'),(83,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDA, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX            A( LDA, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CGESV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.\n*\n*  The LU decomposition with partial pivoting and row interchanges is\n*  used to factor A as\n*     A = P * L * U,\n*  where P is a permutation matrix, L is unit lower triangular, and U is\n*  upper triangular.  The factored form of A is then used to solve the\n*  system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX array, dimension (LDA,N)\n*          On entry, the N-by-N coefficient matrix A.\n*          On exit, the factors L and U from the factorization\n*          A = P*L*U; the unit diagonal elements of L are not stored.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          The pivot indices that define the permutation matrix P;\n*          row i of the matrix was interchanged with row IPIV(i).\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS matrix of right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n*                has been completed, but the factor U is exactly\n*                singular, so the solution could not be computed.\n*\n'),(84,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDA, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX*16         A( LDA, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZGESV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.\n*\n*  The LU decomposition with partial pivoting and row interchanges is\n*  used to factor A as\n*     A = P * L * U,\n*  where P is a permutation matrix, L is unit lower triangular, and U is\n*  upper triangular.  The factored form of A is then used to solve the\n*  system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)\n*          On entry, the N-by-N coefficient matrix A.\n*          On exit, the factors L and U from the factorization\n*          A = P*L*U; the unit diagonal elements of L are not stored.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          The pivot indices that define the permutation matrix P;\n*          row i of the matrix was interchanged with row IPIV(i).\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS matrix of right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n*                has been completed, but the factor U is exactly\n*                singular, so the solution could not be computed.\n*\n'),(85,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               AB( LDAB, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SGBSV computes the solution to a real system of linear equations\n*  A * X = B, where A is a band matrix of order N with KL subdiagonals\n*  and KU superdiagonals, and X and B are N-by-NRHS matrices.\n*\n*  The LU decomposition with partial pivoting and row interchanges is\n*  used to factor A as A = L * U, where L is a product of permutation\n*  and unit lower triangular matrices with KL subdiagonals, and U is\n*  upper triangular with KL+KU superdiagonals.  The factored form of A\n*  is then used to solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KL      (input) INTEGER\n*          The number of subdiagonals within the band of A.  KL >= 0.\n*\n*  KU      (input) INTEGER\n*          The number of superdiagonals within the band of A.  KU >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AB      (input/output) REAL array, dimension (LDAB,N)\n*          On entry, the matrix A in band storage, in rows KL+1 to\n*          2*KL+KU+1; rows 1 to KL of the array need not be set.\n*          The j-th column of A is stored in the j-th column of the\n*          array AB as follows:\n*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)\n*          On exit, details of the factorization: U is stored as an\n*          upper triangular band matrix with KL+KU superdiagonals in\n*          rows 1 to KL+KU+1, and the multipliers used during the\n*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n*          See below for further details.\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          The pivot indices that define the permutation matrix P;\n*          row i of the matrix was interchanged with row IPIV(i).\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n*                has been completed, but the factor U is exactly\n*                singular, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  M = N = 6, KL = 2, KU = 1:\n*\n*  On entry:                       On exit:\n*\n*      *    *    *    +    +    +       *    *    *   u14  u25  u36\n*      *    *    +    +    +    +       *    *   u13  u24  u35  u46\n*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56\n*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66\n*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *\n*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *\n*\n*  Array elements marked * are not used by the routine; elements marked\n*  + need not be set on entry, but are required by the routine to store\n*  elements of U because of fill-in resulting from the row interchanges.\n*\n'),(86,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   AB( LDAB, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DGBSV computes the solution to a real system of linear equations\n*  A * X = B, where A is a band matrix of order N with KL subdiagonals\n*  and KU superdiagonals, and X and B are N-by-NRHS matrices.\n*\n*  The LU decomposition with partial pivoting and row interchanges is\n*  used to factor A as A = L * U, where L is a product of permutation\n*  and unit lower triangular matrices with KL subdiagonals, and U is\n*  upper triangular with KL+KU superdiagonals.  The factored form of A\n*  is then used to solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KL      (input) INTEGER\n*          The number of subdiagonals within the band of A.  KL >= 0.\n*\n*  KU      (input) INTEGER\n*          The number of superdiagonals within the band of A.  KU >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)\n*          On entry, the matrix A in band storage, in rows KL+1 to\n*          2*KL+KU+1; rows 1 to KL of the array need not be set.\n*          The j-th column of A is stored in the j-th column of the\n*          array AB as follows:\n*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)\n*          On exit, details of the factorization: U is stored as an\n*          upper triangular band matrix with KL+KU superdiagonals in\n*          rows 1 to KL+KU+1, and the multipliers used during the\n*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n*          See below for further details.\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          The pivot indices that define the permutation matrix P;\n*          row i of the matrix was interchanged with row IPIV(i).\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n*                has been completed, but the factor U is exactly\n*                singular, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  M = N = 6, KL = 2, KU = 1:\n*\n*  On entry:                       On exit:\n*\n*      *    *    *    +    +    +       *    *    *   u14  u25  u36\n*      *    *    +    +    +    +       *    *   u13  u24  u35  u46\n*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56\n*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66\n*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *\n*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *\n*\n*  Array elements marked * are not used by the routine; elements marked\n*  + need not be set on entry, but are required by the routine to store\n*  elements of U because of fill-in resulting from the row interchanges.\n*\n'),(87,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX            AB( LDAB, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CGBSV computes the solution to a complex system of linear equations\n*  A * X = B, where A is a band matrix of order N with KL subdiagonals\n*  and KU superdiagonals, and X and B are N-by-NRHS matrices.\n*\n*  The LU decomposition with partial pivoting and row interchanges is\n*  used to factor A as A = L * U, where L is a product of permutation\n*  and unit lower triangular matrices with KL subdiagonals, and U is\n*  upper triangular with KL+KU superdiagonals.  The factored form of A\n*  is then used to solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KL      (input) INTEGER\n*          The number of subdiagonals within the band of A.  KL >= 0.\n*\n*  KU      (input) INTEGER\n*          The number of superdiagonals within the band of A.  KU >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AB      (input/output) COMPLEX array, dimension (LDAB,N)\n*          On entry, the matrix A in band storage, in rows KL+1 to\n*          2*KL+KU+1; rows 1 to KL of the array need not be set.\n*          The j-th column of A is stored in the j-th column of the\n*          array AB as follows:\n*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)\n*          On exit, details of the factorization: U is stored as an\n*          upper triangular band matrix with KL+KU superdiagonals in\n*          rows 1 to KL+KU+1, and the multipliers used during the\n*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n*          See below for further details.\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          The pivot indices that define the permutation matrix P;\n*          row i of the matrix was interchanged with row IPIV(i).\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n*                has been completed, but the factor U is exactly\n*                singular, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  M = N = 6, KL = 2, KU = 1:\n*\n*  On entry:                       On exit:\n*\n*      *    *    *    +    +    +       *    *    *   u14  u25  u36\n*      *    *    +    +    +    +       *    *   u13  u24  u35  u46\n*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56\n*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66\n*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *\n*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *\n*\n*  Array elements marked * are not used by the routine; elements marked\n*  + need not be set on entry, but are required by the routine to store\n*  elements of U because of fill-in resulting from the row interchanges.\n*\n'),(88,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX*16         AB( LDAB, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZGBSV computes the solution to a complex system of linear equations\n*  A * X = B, where A is a band matrix of order N with KL subdiagonals\n*  and KU superdiagonals, and X and B are N-by-NRHS matrices.\n*\n*  The LU decomposition with partial pivoting and row interchanges is\n*  used to factor A as A = L * U, where L is a product of permutation\n*  and unit lower triangular matrices with KL subdiagonals, and U is\n*  upper triangular with KL+KU superdiagonals.  The factored form of A\n*  is then used to solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KL      (input) INTEGER\n*          The number of subdiagonals within the band of A.  KL >= 0.\n*\n*  KU      (input) INTEGER\n*          The number of superdiagonals within the band of A.  KU >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)\n*          On entry, the matrix A in band storage, in rows KL+1 to\n*          2*KL+KU+1; rows 1 to KL of the array need not be set.\n*          The j-th column of A is stored in the j-th column of the\n*          array AB as follows:\n*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)\n*          On exit, details of the factorization: U is stored as an\n*          upper triangular band matrix with KL+KU superdiagonals in\n*          rows 1 to KL+KU+1, and the multipliers used during the\n*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n*          See below for further details.\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          The pivot indices that define the permutation matrix P;\n*          row i of the matrix was interchanged with row IPIV(i).\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n*                has been completed, but the factor U is exactly\n*                singular, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  M = N = 6, KL = 2, KU = 1:\n*\n*  On entry:                       On exit:\n*\n*      *    *    *    +    +    +       *    *    *   u14  u25  u36\n*      *    *    +    +    +    +       *    *   u13  u24  u35  u46\n*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56\n*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66\n*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *\n*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *\n*\n*  Array elements marked * are not used by the routine; elements marked\n*  + need not be set on entry, but are required by the routine to store\n*  elements of U because of fill-in resulting from the row interchanges.\n*\n'),(89,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SGTSV( N, NRHS, DL, D, DU, B, LDB, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      REAL               B( LDB, * ), D( * ), DL( * ), DU( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SGTSV  solves the equation\n*\n*     A*X = B,\n*\n*  where A is an n by n tridiagonal matrix, by Gaussian elimination with\n*  partial pivoting.\n*\n*  Note that the equation  A\'*X = B  may be solved by interchanging the\n*  order of the arguments DU and DL.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  DL      (input/output) REAL array, dimension (N-1)\n*          On entry, DL must contain the (n-1) sub-diagonal elements of\n*          A.\n*\n*          On exit, DL is overwritten by the (n-2) elements of the\n*          second super-diagonal of the upper triangular matrix U from\n*          the LU factorization of A, in DL(1), ..., DL(n-2).\n*\n*  D       (input/output) REAL array, dimension (N)\n*          On entry, D must contain the diagonal elements of A.\n*\n*          On exit, D is overwritten by the n diagonal elements of U.\n*\n*  DU      (input/output) REAL array, dimension (N-1)\n*          On entry, DU must contain the (n-1) super-diagonal elements\n*          of A.\n*\n*          On exit, DU is overwritten by the (n-1) elements of the first\n*          super-diagonal of U.\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N by NRHS matrix of right hand side matrix B.\n*          On exit, if INFO = 0, the N by NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, U(i,i) is exactly zero, and the solution\n*               has not been computed.  The factorization has not been\n*               completed unless i = N.\n*\n'),(90,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DGTSV( N, NRHS, DL, D, DU, B, LDB, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   B( LDB, * ), D( * ), DL( * ), DU( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DGTSV  solves the equation\n*\n*     A*X = B,\n*\n*  where A is an n by n tridiagonal matrix, by Gaussian elimination with\n*  partial pivoting.\n*\n*  Note that the equation  A\'*X = B  may be solved by interchanging the\n*  order of the arguments DU and DL.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  DL      (input/output) DOUBLE PRECISION array, dimension (N-1)\n*          On entry, DL must contain the (n-1) sub-diagonal elements of\n*          A.\n*\n*          On exit, DL is overwritten by the (n-2) elements of the\n*          second super-diagonal of the upper triangular matrix U from\n*          the LU factorization of A, in DL(1), ..., DL(n-2).\n*\n*  D       (input/output) DOUBLE PRECISION array, dimension (N)\n*          On entry, D must contain the diagonal elements of A.\n*\n*          On exit, D is overwritten by the n diagonal elements of U.\n*\n*  DU      (input/output) DOUBLE PRECISION array, dimension (N-1)\n*          On entry, DU must contain the (n-1) super-diagonal elements\n*          of A.\n*\n*          On exit, DU is overwritten by the (n-1) elements of the first\n*          super-diagonal of U.\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N by NRHS matrix of right hand side matrix B.\n*          On exit, if INFO = 0, the N by NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, U(i,i) is exactly zero, and the solution\n*               has not been computed.  The factorization has not been\n*               completed unless i = N.\n*\n'),(91,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CGTSV( N, NRHS, DL, D, DU, B, LDB, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      COMPLEX            B( LDB, * ), D( * ), DL( * ), DU( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CGTSV  solves the equation\n*\n*     A*X = B,\n*\n*  where A is an N-by-N tridiagonal matrix, by Gaussian elimination with\n*  partial pivoting.\n*\n*  Note that the equation  A\'*X = B  may be solved by interchanging the\n*  order of the arguments DU and DL.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  DL      (input/output) COMPLEX array, dimension (N-1)\n*          On entry, DL must contain the (n-1) subdiagonal elements of\n*          A.\n*          On exit, DL is overwritten by the (n-2) elements of the\n*          second superdiagonal of the upper triangular matrix U from\n*          the LU factorization of A, in DL(1), ..., DL(n-2).\n*\n*  D       (input/output) COMPLEX array, dimension (N)\n*          On entry, D must contain the diagonal elements of A.\n*          On exit, D is overwritten by the n diagonal elements of U.\n*\n*  DU      (input/output) COMPLEX array, dimension (N-1)\n*          On entry, DU must contain the (n-1) superdiagonal elements\n*          of A.\n*          On exit, DU is overwritten by the (n-1) elements of the first\n*          superdiagonal of U.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, U(i,i) is exactly zero, and the solution\n*                has not been computed.  The factorization has not been\n*                completed unless i = N.\n*\n'),(92,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZGTSV( N, NRHS, DL, D, DU, B, LDB, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      COMPLEX*16         B( LDB, * ), D( * ), DL( * ), DU( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZGTSV  solves the equation\n*\n*     A*X = B,\n*\n*  where A is an N-by-N tridiagonal matrix, by Gaussian elimination with\n*  partial pivoting.\n*\n*  Note that the equation  A\'*X = B  may be solved by interchanging the\n*  order of the arguments DU and DL.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  DL      (input/output) COMPLEX*16 array, dimension (N-1)\n*          On entry, DL must contain the (n-1) subdiagonal elements of\n*          A.\n*          On exit, DL is overwritten by the (n-2) elements of the\n*          second superdiagonal of the upper triangular matrix U from\n*          the LU factorization of A, in DL(1), ..., DL(n-2).\n*\n*  D       (input/output) COMPLEX*16 array, dimension (N)\n*          On entry, D must contain the diagonal elements of A.\n*          On exit, D is overwritten by the n diagonal elements of U.\n*\n*  DU      (input/output) COMPLEX*16 array, dimension (N-1)\n*          On entry, DU must contain the (n-1) superdiagonal elements\n*          of A.\n*          On exit, DU is overwritten by the (n-1) elements of the first\n*          superdiagonal of U.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, U(i,i) is exactly zero, and the solution\n*                has not been computed.  The factorization has not been\n*                completed unless i = N.\n*\n'),(93,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CHESV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,\n     $                  LWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.3.0) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2010\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CHESV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**H,  if UPLO = \'U\', or\n*     A = L * D * L**H,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, and D is Hermitian and block diagonal with \n*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\n*  used to solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX array, dimension (LDA,N)\n*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.\n*\n*          On exit, if INFO = 0, the block diagonal matrix D and the\n*          multipliers used to obtain the factor U or L from the\n*          factorization A = U*D*U**H or A = L*D*L**H as computed by\n*          CHETRF.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by CHETRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= 1, and for best performance\n*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n*          CHETRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n*               has been completed, but the block diagonal matrix D is\n*               exactly singular, so the solution could not be computed.\n*\n'),(94,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZHESV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,\n     $                  LWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.3.0) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2010\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZHESV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**H,  if UPLO = \'U\', or\n*     A = L * D * L**H,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, and D is Hermitian and block diagonal with\n*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\n*  used to solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)\n*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.\n*\n*          On exit, if INFO = 0, the block diagonal matrix D and the\n*          multipliers used to obtain the factor U or L from the\n*          factorization A = U*D*U**H or A = L*D*L**H as computed by\n*          ZHETRF.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by ZHETRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= 1, and for best performance\n*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n*          ZHETRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n*               has been completed, but the block diagonal matrix D is\n*               exactly singular, so the solution could not be computed.\n*\n'),(95,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CHPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX            AP( * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CHPSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian matrix stored in packed format and X\n*  and B are N-by-NRHS matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**H,  if UPLO = \'U\', or\n*     A = L * D * L**H,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, D is Hermitian and block diagonal with 1-by-1\n*  and 2-by-2 diagonal blocks.  The factored form of A is then used to\n*  solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the Hermitian matrix\n*          A, packed columnwise in a linear array.  The j-th column of A\n*          is stored in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*          On exit, the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by CHPTRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n*                has been completed, but the block diagonal matrix D is\n*                exactly singular, so the solution could not be\n*                computed.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the Hermitian matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(96,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZHPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX*16         AP( * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZHPSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian matrix stored in packed format and X\n*  and B are N-by-NRHS matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**H,  if UPLO = \'U\', or\n*     A = L * D * L**H,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, D is Hermitian and block diagonal with 1-by-1\n*  and 2-by-2 diagonal blocks.  The factored form of A is then used to\n*  solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the Hermitian matrix\n*          A, packed columnwise in a linear array.  The j-th column of A\n*          is stored in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*          On exit, the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by ZHPTRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n*                has been completed, but the block diagonal matrix D is\n*                exactly singular, so the solution could not be\n*                computed.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the Hermitian matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(97,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SPOSV( UPLO, N, NRHS, A, LDA, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDA, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      REAL               A( LDA, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SPOSV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite matrix and X and B\n*  are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**T* U,  if UPLO = \'U\', or\n*     A = L * L**T,  if UPLO = \'L\',\n*  where U is an upper triangular matrix and L is a lower triangular\n*  matrix.  The factored form of A is then used to solve the system of\n*  equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) REAL array, dimension (LDA,N)\n*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.\n*\n*          On exit, if INFO = 0, the factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n'),(98,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DPOSV( UPLO, N, NRHS, A, LDA, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDA, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DPOSV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite matrix and X and B\n*  are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**T* U,  if UPLO = \'U\', or\n*     A = L * L**T,  if UPLO = \'L\',\n*  where U is an upper triangular matrix and L is a lower triangular\n*  matrix.  The factored form of A is then used to solve the system of\n*  equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)\n*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.\n*\n*          On exit, if INFO = 0, the factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n'),(99,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CPOSV( UPLO, N, NRHS, A, LDA, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDA, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      COMPLEX            A( LDA, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CPOSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite matrix and X and B\n*  are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**H* U,  if UPLO = \'U\', or\n*     A = L * L**H,  if UPLO = \'L\',\n*  where U is an upper triangular matrix and  L is a lower triangular\n*  matrix.  The factored form of A is then used to solve the system of\n*  equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX array, dimension (LDA,N)\n*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.\n*\n*          On exit, if INFO = 0, the factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n'),(100,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZPOSV( UPLO, N, NRHS, A, LDA, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDA, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      COMPLEX*16         A( LDA, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZPOSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite matrix and X and B\n*  are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**H* U,  if UPLO = \'U\', or\n*     A = L * L**H,  if UPLO = \'L\',\n*  where U is an upper triangular matrix and  L is a lower triangular\n*  matrix.  The factored form of A is then used to solve the system of\n*  equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)\n*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.\n*\n*          On exit, if INFO = 0, the factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n'),(101,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SPBSV( UPLO, N, KD, NRHS, AB, LDAB, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, KD, LDAB, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      REAL               AB( LDAB, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SPBSV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite band matrix and X\n*  and B are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**T * U,  if UPLO = \'U\', or\n*     A = L * L**T,  if UPLO = \'L\',\n*  where U is an upper triangular band matrix, and L is a lower\n*  triangular band matrix, with the same number of superdiagonals or\n*  subdiagonals as A.  The factored form of A is then used to solve the\n*  system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KD      (input) INTEGER\n*          The number of superdiagonals of the matrix A if UPLO = \'U\',\n*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AB      (input/output) REAL array, dimension (LDAB,N)\n*          On entry, the upper or lower triangle of the symmetric band\n*          matrix A, stored in the first KD+1 rows of the array.  The\n*          j-th column of A is stored in the j-th column of the array AB\n*          as follows:\n*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n*          See below for further details.\n*\n*          On exit, if INFO = 0, the triangular factor U or L from the\n*          Cholesky factorization A = U**T*U or A = L*L**T of the band\n*          matrix A, in the same storage format as A.\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= KD+1.\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  N = 6, KD = 2, and UPLO = \'U\':\n*\n*  On entry:                       On exit:\n*\n*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46\n*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56\n*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66\n*\n*  Similarly, if UPLO = \'L\' the format of A is as follows:\n*\n*  On entry:                       On exit:\n*\n*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66\n*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *\n*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *\n*\n*  Array elements marked * are not used by the routine.\n*\n'),(102,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DPBSV( UPLO, N, KD, NRHS, AB, LDAB, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, KD, LDAB, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   AB( LDAB, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DPBSV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite band matrix and X\n*  and B are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**T * U,  if UPLO = \'U\', or\n*     A = L * L**T,  if UPLO = \'L\',\n*  where U is an upper triangular band matrix, and L is a lower\n*  triangular band matrix, with the same number of superdiagonals or\n*  subdiagonals as A.  The factored form of A is then used to solve the\n*  system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KD      (input) INTEGER\n*          The number of superdiagonals of the matrix A if UPLO = \'U\',\n*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)\n*          On entry, the upper or lower triangle of the symmetric band\n*          matrix A, stored in the first KD+1 rows of the array.  The\n*          j-th column of A is stored in the j-th column of the array AB\n*          as follows:\n*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n*          See below for further details.\n*\n*          On exit, if INFO = 0, the triangular factor U or L from the\n*          Cholesky factorization A = U**T*U or A = L*L**T of the band\n*          matrix A, in the same storage format as A.\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= KD+1.\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  N = 6, KD = 2, and UPLO = \'U\':\n*\n*  On entry:                       On exit:\n*\n*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46\n*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56\n*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66\n*\n*  Similarly, if UPLO = \'L\' the format of A is as follows:\n*\n*  On entry:                       On exit:\n*\n*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66\n*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *\n*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *\n*\n*  Array elements marked * are not used by the routine.\n*\n'),(103,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CPBSV( UPLO, N, KD, NRHS, AB, LDAB, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, KD, LDAB, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      COMPLEX            AB( LDAB, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CPBSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite band matrix and X\n*  and B are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**H * U,  if UPLO = \'U\', or\n*     A = L * L**H,  if UPLO = \'L\',\n*  where U is an upper triangular band matrix, and L is a lower\n*  triangular band matrix, with the same number of superdiagonals or\n*  subdiagonals as A.  The factored form of A is then used to solve the\n*  system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KD      (input) INTEGER\n*          The number of superdiagonals of the matrix A if UPLO = \'U\',\n*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AB      (input/output) COMPLEX array, dimension (LDAB,N)\n*          On entry, the upper or lower triangle of the Hermitian band\n*          matrix A, stored in the first KD+1 rows of the array.  The\n*          j-th column of A is stored in the j-th column of the array AB\n*          as follows:\n*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n*          See below for further details.\n*\n*          On exit, if INFO = 0, the triangular factor U or L from the\n*          Cholesky factorization A = U**H*U or A = L*L**H of the band\n*          matrix A, in the same storage format as A.\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= KD+1.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  N = 6, KD = 2, and UPLO = \'U\':\n*\n*  On entry:                       On exit:\n*\n*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46\n*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56\n*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66\n*\n*  Similarly, if UPLO = \'L\' the format of A is as follows:\n*\n*  On entry:                       On exit:\n*\n*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66\n*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *\n*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *\n*\n*  Array elements marked * are not used by the routine.\n*\n'),(104,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZPBSV( UPLO, N, KD, NRHS, AB, LDAB, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, KD, LDAB, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      COMPLEX*16         AB( LDAB, * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZPBSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite band matrix and X\n*  and B are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**H * U,  if UPLO = \'U\', or\n*     A = L * L**H,  if UPLO = \'L\',\n*  where U is an upper triangular band matrix, and L is a lower\n*  triangular band matrix, with the same number of superdiagonals or\n*  subdiagonals as A.  The factored form of A is then used to solve the\n*  system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KD      (input) INTEGER\n*          The number of superdiagonals of the matrix A if UPLO = \'U\',\n*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)\n*          On entry, the upper or lower triangle of the Hermitian band\n*          matrix A, stored in the first KD+1 rows of the array.  The\n*          j-th column of A is stored in the j-th column of the array AB\n*          as follows:\n*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n*          See below for further details.\n*\n*          On exit, if INFO = 0, the triangular factor U or L from the\n*          Cholesky factorization A = U**H*U or A = L*L**H of the band\n*          matrix A, in the same storage format as A.\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= KD+1.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  N = 6, KD = 2, and UPLO = \'U\':\n*\n*  On entry:                       On exit:\n*\n*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46\n*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56\n*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66\n*\n*  Similarly, if UPLO = \'L\' the format of A is as follows:\n*\n*  On entry:                       On exit:\n*\n*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66\n*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *\n*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *\n*\n*  Array elements marked * are not used by the routine.\n*\n'),(105,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SPPSV( UPLO, N, NRHS, AP, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      REAL               AP( * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SPPSV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite matrix stored in\n*  packed format and X and B are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**T* U,  if UPLO = \'U\', or\n*     A = L * L**T,  if UPLO = \'L\',\n*  where U is an upper triangular matrix and L is a lower triangular\n*  matrix.  The factored form of A is then used to solve the system of\n*  equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AP      (input/output) REAL array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the symmetric matrix\n*          A, packed columnwise in a linear array.  The j-th column of A\n*          is stored in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.  \n*\n*          On exit, if INFO = 0, the factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T, in the same storage\n*          format as A.\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(106,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DPPSV( UPLO, N, NRHS, AP, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   AP( * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DPPSV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite matrix stored in\n*  packed format and X and B are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**T* U,  if UPLO = \'U\', or\n*     A = L * L**T,  if UPLO = \'L\',\n*  where U is an upper triangular matrix and L is a lower triangular\n*  matrix.  The factored form of A is then used to solve the system of\n*  equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the symmetric matrix\n*          A, packed columnwise in a linear array.  The j-th column of A\n*          is stored in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*          On exit, if INFO = 0, the factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T, in the same storage\n*          format as A.\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(107,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CPPSV( UPLO, N, NRHS, AP, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      COMPLEX            AP( * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CPPSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite matrix stored in\n*  packed format and X and B are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**H* U,  if UPLO = \'U\', or\n*     A = L * L**H,  if UPLO = \'L\',\n*  where U is an upper triangular matrix and L is a lower triangular\n*  matrix.  The factored form of A is then used to solve the system of\n*  equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the Hermitian matrix\n*          A, packed columnwise in a linear array.  The j-th column of A\n*          is stored in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.  \n*\n*          On exit, if INFO = 0, the factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H, in the same storage\n*          format as A.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the Hermitian matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(108,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZPPSV( UPLO, N, NRHS, AP, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      COMPLEX*16         AP( * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZPPSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite matrix stored in\n*  packed format and X and B are N-by-NRHS matrices.\n*\n*  The Cholesky decomposition is used to factor A as\n*     A = U**H* U,  if UPLO = \'U\', or\n*     A = L * L**H,  if UPLO = \'L\',\n*  where U is an upper triangular matrix and L is a lower triangular\n*  matrix.  The factored form of A is then used to solve the system of\n*  equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the Hermitian matrix\n*          A, packed columnwise in a linear array.  The j-th column of A\n*          is stored in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*          On exit, if INFO = 0, the factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H, in the same storage\n*          format as A.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i of A is not\n*                positive definite, so the factorization could not be\n*                completed, and the solution has not been computed.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the Hermitian matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(109,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SPTSV( N, NRHS, D, E, B, LDB, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      REAL               B( LDB, * ), D( * ), E( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SPTSV computes the solution to a real system of linear equations\n*  A*X = B, where A is an N-by-N symmetric positive definite tridiagonal\n*  matrix, and X and B are N-by-NRHS matrices.\n*\n*  A is factored as A = L*D*L**T, and the factored form of A is then\n*  used to solve the system of equations.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  D       (input/output) REAL array, dimension (N)\n*          On entry, the n diagonal elements of the tridiagonal matrix\n*          A.  On exit, the n diagonal elements of the diagonal matrix\n*          D from the factorization A = L*D*L**T.\n*\n*  E       (input/output) REAL array, dimension (N-1)\n*          On entry, the (n-1) subdiagonal elements of the tridiagonal\n*          matrix A.  On exit, the (n-1) subdiagonal elements of the\n*          unit bidiagonal factor L from the L*D*L**T factorization of\n*          A.  (E can also be regarded as the superdiagonal of the unit\n*          bidiagonal factor U from the U**T*D*U factorization of A.)\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i is not\n*                positive definite, and the solution has not been\n*                computed.  The factorization has not been completed\n*                unless i = N.\n*\n'),(110,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DPTSV( N, NRHS, D, E, B, LDB, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   B( LDB, * ), D( * ), E( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DPTSV computes the solution to a real system of linear equations\n*  A*X = B, where A is an N-by-N symmetric positive definite tridiagonal\n*  matrix, and X and B are N-by-NRHS matrices.\n*\n*  A is factored as A = L*D*L**T, and the factored form of A is then\n*  used to solve the system of equations.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  D       (input/output) DOUBLE PRECISION array, dimension (N)\n*          On entry, the n diagonal elements of the tridiagonal matrix\n*          A.  On exit, the n diagonal elements of the diagonal matrix\n*          D from the factorization A = L*D*L**T.\n*\n*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)\n*          On entry, the (n-1) subdiagonal elements of the tridiagonal\n*          matrix A.  On exit, the (n-1) subdiagonal elements of the\n*          unit bidiagonal factor L from the L*D*L**T factorization of\n*          A.  (E can also be regarded as the superdiagonal of the unit\n*          bidiagonal factor U from the U**T*D*U factorization of A.)\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i is not\n*                positive definite, and the solution has not been\n*                computed.  The factorization has not been completed\n*                unless i = N.\n*\n'),(111,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CPTSV( N, NRHS, D, E, B, LDB, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      REAL               D( * )\n      COMPLEX            B( LDB, * ), E( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CPTSV computes the solution to a complex system of linear equations\n*  A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal\n*  matrix, and X and B are N-by-NRHS matrices.\n*\n*  A is factored as A = L*D*L**H, and the factored form of A is then\n*  used to solve the system of equations.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  D       (input/output) REAL array, dimension (N)\n*          On entry, the n diagonal elements of the tridiagonal matrix\n*          A.  On exit, the n diagonal elements of the diagonal matrix\n*          D from the factorization A = L*D*L**H.\n*\n*  E       (input/output) COMPLEX array, dimension (N-1)\n*          On entry, the (n-1) subdiagonal elements of the tridiagonal\n*          matrix A.  On exit, the (n-1) subdiagonal elements of the\n*          unit bidiagonal factor L from the L*D*L**H factorization of\n*          A.  E can also be regarded as the superdiagonal of the unit\n*          bidiagonal factor U from the U**H*D*U factorization of A.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i is not\n*                positive definite, and the solution has not been\n*                computed.  The factorization has not been completed\n*                unless i = N.\n*\n'),(112,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZPTSV( N, NRHS, D, E, B, LDB, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   D( * )\n      COMPLEX*16         B( LDB, * ), E( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZPTSV computes the solution to a complex system of linear equations\n*  A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal\n*  matrix, and X and B are N-by-NRHS matrices.\n*\n*  A is factored as A = L*D*L**H, and the factored form of A is then\n*  used to solve the system of equations.\n*\n*  Arguments\n*  =========\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  D       (input/output) DOUBLE PRECISION array, dimension (N)\n*          On entry, the n diagonal elements of the tridiagonal matrix\n*          A.  On exit, the n diagonal elements of the diagonal matrix\n*          D from the factorization A = L*D*L**H.\n*\n*  E       (input/output) COMPLEX*16 array, dimension (N-1)\n*          On entry, the (n-1) subdiagonal elements of the tridiagonal\n*          matrix A.  On exit, the (n-1) subdiagonal elements of the\n*          unit bidiagonal factor L from the L*D*L**H factorization of\n*          A.  E can also be regarded as the superdiagonal of the unit\n*          bidiagonal factor U from the U**H*D*U factorization of A.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, the leading minor of order i is not\n*                positive definite, and the solution has not been\n*                computed.  The factorization has not been completed\n*                unless i = N.\n*\n'),(113,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,\n     $                  LWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     May 2010\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               A( LDA, * ), B( LDB, * ), WORK( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SSYSV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**T,  if UPLO = \'U\', or\n*     A = L * D * L**T,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, and D is symmetric and block diagonal with \n*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\n*  used to solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) REAL array, dimension (LDA,N)\n*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.\n*\n*          On exit, if INFO = 0, the block diagonal matrix D and the\n*          multipliers used to obtain the factor U or L from the\n*          factorization A = U*D*U**T or A = L*D*L**T as computed by\n*          SSYTRF.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by SSYTRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= 1, and for best performance\n*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n*          SSYTRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n*               has been completed, but the block diagonal matrix D is\n*               exactly singular, so the solution could not be computed.\n*\n'),(114,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,\n     $                  LWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     May 2010\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), WORK( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DSYSV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**T,  if UPLO = \'U\', or\n*     A = L * D * L**T,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, and D is symmetric and block diagonal with\n*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\n*  used to solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)\n*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.\n*\n*          On exit, if INFO = 0, the block diagonal matrix D and the\n*          multipliers used to obtain the factor U or L from the\n*          factorization A = U*D*U**T or A = L*D*L**T as computed by\n*          DSYTRF.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by DSYTRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= 1, and for best performance\n*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n*          DSYTRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n*               has been completed, but the block diagonal matrix D is\n*               exactly singular, so the solution could not be computed.\n*\n'),(115,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,\n     $                  LWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     June 2010\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CSYSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**T,  if UPLO = \'U\', or\n*     A = L * D * L**T,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, and D is symmetric and block diagonal with \n*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\n*  used to solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX array, dimension (LDA,N)\n*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.\n*\n*          On exit, if INFO = 0, the block diagonal matrix D and the\n*          multipliers used to obtain the factor U or L from the\n*          factorization A = U*D*U**T or A = L*D*L**T as computed by\n*          CSYTRF.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by CSYTRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= 1, and for best performance\n*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n*          CSYTRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n*               has been completed, but the block diagonal matrix D is\n*               exactly singular, so the solution could not be computed.\n*\n'),(116,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,\n     $                  LWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     June 2010\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZSYSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**T,  if UPLO = \'U\', or\n*     A = L * D * L**T,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, and D is symmetric and block diagonal with\n*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\n*  used to solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)\n*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.\n*\n*          On exit, if INFO = 0, the block diagonal matrix D and the\n*          multipliers used to obtain the factor U or L from the\n*          factorization A = U*D*U**T or A = L*D*L**T as computed by\n*          ZSYTRF.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by ZSYTRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= 1, and for best performance\n*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n*          ZSYTRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n*               has been completed, but the block diagonal matrix D is\n*               exactly singular, so the solution could not be computed.\n*\n'),(117,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SSPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               AP( * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SSPSV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric matrix stored in packed format and X\n*  and B are N-by-NRHS matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**T,  if UPLO = \'U\', or\n*     A = L * D * L**T,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, D is symmetric and block diagonal with 1-by-1\n*  and 2-by-2 diagonal blocks.  The factored form of A is then used to\n*  solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AP      (input/output) REAL array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the symmetric matrix\n*          A, packed columnwise in a linear array.  The j-th column of A\n*          is stored in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*          On exit, the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by SSPTRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n*                has been completed, but the block diagonal matrix D is\n*                exactly singular, so the solution could not be\n*                computed.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = aji)\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(118,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DSPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   AP( * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DSPSV computes the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric matrix stored in packed format and X\n*  and B are N-by-NRHS matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**T,  if UPLO = \'U\', or\n*     A = L * D * L**T,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, D is symmetric and block diagonal with 1-by-1\n*  and 2-by-2 diagonal blocks.  The factored form of A is then used to\n*  solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the symmetric matrix\n*          A, packed columnwise in a linear array.  The j-th column of A\n*          is stored in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*          On exit, the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by DSPTRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n*                has been completed, but the block diagonal matrix D is\n*                exactly singular, so the solution could not be\n*                computed.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = aji)\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(119,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CSPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX            AP( * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CSPSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric matrix stored in packed format and X\n*  and B are N-by-NRHS matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**T,  if UPLO = \'U\', or\n*     A = L * D * L**T,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, D is symmetric and block diagonal with 1-by-1\n*  and 2-by-2 diagonal blocks.  The factored form of A is then used to\n*  solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the symmetric matrix\n*          A, packed columnwise in a linear array.  The j-th column of A\n*          is stored in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*          On exit, the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by CSPTRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n*                has been completed, but the block diagonal matrix D is\n*                exactly singular, so the solution could not be\n*                computed.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = aji)\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(120,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZSPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          UPLO\n      INTEGER            INFO, LDB, N, NRHS\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      COMPLEX*16         AP( * ), B( LDB, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZSPSV computes the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric matrix stored in packed format and X\n*  and B are N-by-NRHS matrices.\n*\n*  The diagonal pivoting method is used to factor A as\n*     A = U * D * U**T,  if UPLO = \'U\', or\n*     A = L * D * L**T,  if UPLO = \'L\',\n*  where U (or L) is a product of permutation and unit upper (lower)\n*  triangular matrices, D is symmetric and block diagonal with 1-by-1\n*  and 2-by-2 diagonal blocks.  The factored form of A is then used to\n*  solve the system of equations A * X = B.\n*\n*  Arguments\n*  =========\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the symmetric matrix\n*          A, packed columnwise in a linear array.  The j-th column of A\n*          is stored in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*          On exit, the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (output) INTEGER array, dimension (N)\n*          Details of the interchanges and the block structure of D, as\n*          determined by ZSPTRF.  If IPIV(k) > 0, then rows and columns\n*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n*          then rows and columns k-1 and -IPIV(k) were interchanged and\n*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n*          diagonal block.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n*                has been completed, but the block diagonal matrix D is\n*                exactly singular, so the solution could not be\n*                computed.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = aji)\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(121,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV,\n     $                   EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, TRANS\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * ), IWORK( * )\n      REAL               A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   BERR( * ), C( * ), FERR( * ), R( * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SGESVX uses the LU factorization to compute the solution to a real\n*  system of linear equations\n*     A * X = B,\n*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n*     or diag(C)*B (if TRANS = \'T\' or \'C\').\n*\n*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n*     matrix A (after equilibration if FACT = \'E\') as\n*        A = P * L * U,\n*     where P is a permutation matrix, L is a unit lower triangular\n*     matrix, and U is upper triangular.\n*\n*  3. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n*     that it solves the original system before equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AF and IPIV contain the factored form of A.\n*                  If EQUED is not \'N\', the matrix A has been\n*                  equilibrated with scaling factors given by R and C.\n*                  A, AF, and IPIV are not modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AF and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations:\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Transpose)\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input/output) REAL array, dimension (LDA,N)\n*          On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n*          not \'N\', then A must have been equilibrated by the scaling\n*          factors in R and/or C.  A is not modified if FACT = \'F\' or\n*          \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if EQUED .ne. \'N\', A is scaled as follows:\n*          EQUED = \'R\':  A := diag(R) * A\n*          EQUED = \'C\':  A := A * diag(C)\n*          EQUED = \'B\':  A := diag(R) * A * diag(C).\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) REAL array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the factors L and U from the factorization\n*          A = P*L*U as computed by SGETRF.  If EQUED .ne. \'N\', then\n*          AF is the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the factors L and U from the factorization A = P*L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then AF is an output argument and on exit\n*          returns the factors L and U from the factorization A = P*L*U\n*          of the equilibrated matrix A (see the description of A for\n*          the form of the equilibrated matrix).\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the factorization A = P*L*U\n*          as computed by SGETRF; row i of the matrix was interchanged\n*          with row IPIV(i).\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = P*L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = P*L*U\n*          of the equilibrated matrix A.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'R\':  Row equilibration, i.e., A has been premultiplied by\n*                  diag(R).\n*          = \'C\':  Column equilibration, i.e., A has been postmultiplied\n*                  by diag(C).\n*          = \'B\':  Both row and column equilibration, i.e., A has been\n*                  replaced by diag(R) * A * diag(C).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  R       (input or output) REAL array, dimension (N)\n*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n*          is not accessed.  R is an input argument if FACT = \'F\';\n*          otherwise, R is an output argument.  If FACT = \'F\' and\n*          EQUED = \'R\' or \'B\', each element of R must be positive.\n*\n*  C       (input or output) REAL array, dimension (N)\n*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n*          is not accessed.  C is an input argument if FACT = \'F\';\n*          otherwise, C is an output argument.  If FACT = \'F\' and\n*          EQUED = \'C\' or \'B\', each element of C must be positive.\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit,\n*          if EQUED = \'N\', B is not modified;\n*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n*          diag(R)*B;\n*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n*          overwritten by diag(C)*B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) REAL array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n*          to the original system of equations.  Note that A and B are\n*          modified on exit if EQUED .ne. \'N\', and the solution to the\n*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n*          and EQUED = \'R\' or \'B\'.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace/output) REAL array, dimension (4*N)\n*          On exit, WORK(1) contains the reciprocal pivot growth\n*          factor norm(A)/norm(U). The \"max absolute element\" norm is\n*          used. If WORK(1) is much less than 1, then the stability\n*          of the LU factorization of the (equilibrated) matrix A\n*          could be poor. This also means that the solution X, condition\n*          estimator RCOND, and forward error bound FERR could be\n*          unreliable. If factorization fails with 0<INFO<=N, then\n*          WORK(1) contains the reciprocal pivot growth factor for the\n*          leading INFO columns of A.\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization has\n*                       been completed, but the factor U is exactly\n*                       singular, so the solution and error bounds\n*                       could not be computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(122,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV,\n     $                   EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, TRANS\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * ), IWORK( * )\n      DOUBLE PRECISION   A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   BERR( * ), C( * ), FERR( * ), R( * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DGESVX uses the LU factorization to compute the solution to a real\n*  system of linear equations\n*     A * X = B,\n*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n*     or diag(C)*B (if TRANS = \'T\' or \'C\').\n*\n*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n*     matrix A (after equilibration if FACT = \'E\') as\n*        A = P * L * U,\n*     where P is a permutation matrix, L is a unit lower triangular\n*     matrix, and U is upper triangular.\n*\n*  3. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n*     that it solves the original system before equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AF and IPIV contain the factored form of A.\n*                  If EQUED is not \'N\', the matrix A has been\n*                  equilibrated with scaling factors given by R and C.\n*                  A, AF, and IPIV are not modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AF and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations:\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Transpose)\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)\n*          On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n*          not \'N\', then A must have been equilibrated by the scaling\n*          factors in R and/or C.  A is not modified if FACT = \'F\' or\n*          \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if EQUED .ne. \'N\', A is scaled as follows:\n*          EQUED = \'R\':  A := diag(R) * A\n*          EQUED = \'C\':  A := A * diag(C)\n*          EQUED = \'B\':  A := diag(R) * A * diag(C).\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the factors L and U from the factorization\n*          A = P*L*U as computed by DGETRF.  If EQUED .ne. \'N\', then\n*          AF is the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the factors L and U from the factorization A = P*L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then AF is an output argument and on exit\n*          returns the factors L and U from the factorization A = P*L*U\n*          of the equilibrated matrix A (see the description of A for\n*          the form of the equilibrated matrix).\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the factorization A = P*L*U\n*          as computed by DGETRF; row i of the matrix was interchanged\n*          with row IPIV(i).\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = P*L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = P*L*U\n*          of the equilibrated matrix A.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'R\':  Row equilibration, i.e., A has been premultiplied by\n*                  diag(R).\n*          = \'C\':  Column equilibration, i.e., A has been postmultiplied\n*                  by diag(C).\n*          = \'B\':  Both row and column equilibration, i.e., A has been\n*                  replaced by diag(R) * A * diag(C).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  R       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n*          is not accessed.  R is an input argument if FACT = \'F\';\n*          otherwise, R is an output argument.  If FACT = \'F\' and\n*          EQUED = \'R\' or \'B\', each element of R must be positive.\n*\n*  C       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n*          is not accessed.  C is an input argument if FACT = \'F\';\n*          otherwise, C is an output argument.  If FACT = \'F\' and\n*          EQUED = \'C\' or \'B\', each element of C must be positive.\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit,\n*          if EQUED = \'N\', B is not modified;\n*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n*          diag(R)*B;\n*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n*          overwritten by diag(C)*B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n*          to the original system of equations.  Note that A and B are\n*          modified on exit if EQUED .ne. \'N\', and the solution to the\n*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n*          and EQUED = \'R\' or \'B\'.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (4*N)\n*          On exit, WORK(1) contains the reciprocal pivot growth\n*          factor norm(A)/norm(U). The \"max absolute element\" norm is\n*          used. If WORK(1) is much less than 1, then the stability\n*          of the LU factorization of the (equilibrated) matrix A\n*          could be poor. This also means that the solution X, condition\n*          estimator RCOND, and forward error bound FERR could be\n*          unreliable. If factorization fails with 0<INFO<=N, then\n*          WORK(1) contains the reciprocal pivot growth factor for the\n*          leading INFO columns of A.\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization has\n*                       been completed, but the factor U is exactly\n*                       singular, so the solution and error bounds\n*                       could not be computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(123,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV,\n     $                   EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, TRANS\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               BERR( * ), C( * ), FERR( * ), R( * ),\n     $                   RWORK( * )\n      COMPLEX            A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CGESVX uses the LU factorization to compute the solution to a complex\n*  system of linear equations\n*     A * X = B,\n*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n*     or diag(C)*B (if TRANS = \'T\' or \'C\').\n*\n*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n*     matrix A (after equilibration if FACT = \'E\') as\n*        A = P * L * U,\n*     where P is a permutation matrix, L is a unit lower triangular\n*     matrix, and U is upper triangular.\n*\n*  3. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n*     that it solves the original system before equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AF and IPIV contain the factored form of A.\n*                  If EQUED is not \'N\', the matrix A has been\n*                  equilibrated with scaling factors given by R and C.\n*                  A, AF, and IPIV are not modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AF and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations:\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Conjugate transpose)\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX array, dimension (LDA,N)\n*          On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n*          not \'N\', then A must have been equilibrated by the scaling\n*          factors in R and/or C.  A is not modified if FACT = \'F\' or\n*          \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if EQUED .ne. \'N\', A is scaled as follows:\n*          EQUED = \'R\':  A := diag(R) * A\n*          EQUED = \'C\':  A := A * diag(C)\n*          EQUED = \'B\':  A := diag(R) * A * diag(C).\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) COMPLEX array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the factors L and U from the factorization\n*          A = P*L*U as computed by CGETRF.  If EQUED .ne. \'N\', then\n*          AF is the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the factors L and U from the factorization A = P*L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then AF is an output argument and on exit\n*          returns the factors L and U from the factorization A = P*L*U\n*          of the equilibrated matrix A (see the description of A for\n*          the form of the equilibrated matrix).\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the factorization A = P*L*U\n*          as computed by CGETRF; row i of the matrix was interchanged\n*          with row IPIV(i).\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = P*L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = P*L*U\n*          of the equilibrated matrix A.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'R\':  Row equilibration, i.e., A has been premultiplied by\n*                  diag(R).\n*          = \'C\':  Column equilibration, i.e., A has been postmultiplied\n*                  by diag(C).\n*          = \'B\':  Both row and column equilibration, i.e., A has been\n*                  replaced by diag(R) * A * diag(C).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  R       (input or output) REAL array, dimension (N)\n*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n*          is not accessed.  R is an input argument if FACT = \'F\';\n*          otherwise, R is an output argument.  If FACT = \'F\' and\n*          EQUED = \'R\' or \'B\', each element of R must be positive.\n*\n*  C       (input or output) REAL array, dimension (N)\n*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n*          is not accessed.  C is an input argument if FACT = \'F\';\n*          otherwise, C is an output argument.  If FACT = \'F\' and\n*          EQUED = \'C\' or \'B\', each element of C must be positive.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit,\n*          if EQUED = \'N\', B is not modified;\n*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n*          diag(R)*B;\n*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n*          overwritten by diag(C)*B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n*          to the original system of equations.  Note that A and B are\n*          modified on exit if EQUED .ne. \'N\', and the solution to the\n*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n*          and EQUED = \'R\' or \'B\'.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX array, dimension (2*N)\n*\n*  RWORK   (workspace/output) REAL array, dimension (2*N)\n*          On exit, RWORK(1) contains the reciprocal pivot growth\n*          factor norm(A)/norm(U). The \"max absolute element\" norm is\n*          used. If RWORK(1) is much less than 1, then the stability\n*          of the LU factorization of the (equilibrated) matrix A\n*          could be poor. This also means that the solution X, condition\n*          estimator RCOND, and forward error bound FERR could be\n*          unreliable. If factorization fails with 0<INFO<=N, then\n*          RWORK(1) contains the reciprocal pivot growth factor for the\n*          leading INFO columns of A.\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization has\n*                       been completed, but the factor U is exactly\n*                       singular, so the solution and error bounds\n*                       could not be computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(124,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV,\n     $                   EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, TRANS\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   BERR( * ), C( * ), FERR( * ), R( * ),\n     $                   RWORK( * )\n      COMPLEX*16         A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZGESVX uses the LU factorization to compute the solution to a complex\n*  system of linear equations\n*     A * X = B,\n*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n*     or diag(C)*B (if TRANS = \'T\' or \'C\').\n*\n*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n*     matrix A (after equilibration if FACT = \'E\') as\n*        A = P * L * U,\n*     where P is a permutation matrix, L is a unit lower triangular\n*     matrix, and U is upper triangular.\n*\n*  3. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n*     that it solves the original system before equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AF and IPIV contain the factored form of A.\n*                  If EQUED is not \'N\', the matrix A has been\n*                  equilibrated with scaling factors given by R and C.\n*                  A, AF, and IPIV are not modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AF and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations:\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Conjugate transpose)\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)\n*          On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n*          not \'N\', then A must have been equilibrated by the scaling\n*          factors in R and/or C.  A is not modified if FACT = \'F\' or\n*          \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if EQUED .ne. \'N\', A is scaled as follows:\n*          EQUED = \'R\':  A := diag(R) * A\n*          EQUED = \'C\':  A := A * diag(C)\n*          EQUED = \'B\':  A := diag(R) * A * diag(C).\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the factors L and U from the factorization\n*          A = P*L*U as computed by ZGETRF.  If EQUED .ne. \'N\', then\n*          AF is the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the factors L and U from the factorization A = P*L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then AF is an output argument and on exit\n*          returns the factors L and U from the factorization A = P*L*U\n*          of the equilibrated matrix A (see the description of A for\n*          the form of the equilibrated matrix).\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the factorization A = P*L*U\n*          as computed by ZGETRF; row i of the matrix was interchanged\n*          with row IPIV(i).\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = P*L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = P*L*U\n*          of the equilibrated matrix A.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'R\':  Row equilibration, i.e., A has been premultiplied by\n*                  diag(R).\n*          = \'C\':  Column equilibration, i.e., A has been postmultiplied\n*                  by diag(C).\n*          = \'B\':  Both row and column equilibration, i.e., A has been\n*                  replaced by diag(R) * A * diag(C).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  R       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n*          is not accessed.  R is an input argument if FACT = \'F\';\n*          otherwise, R is an output argument.  If FACT = \'F\' and\n*          EQUED = \'R\' or \'B\', each element of R must be positive.\n*\n*  C       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n*          is not accessed.  C is an input argument if FACT = \'F\';\n*          otherwise, C is an output argument.  If FACT = \'F\' and\n*          EQUED = \'C\' or \'B\', each element of C must be positive.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit,\n*          if EQUED = \'N\', B is not modified;\n*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n*          diag(R)*B;\n*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n*          overwritten by diag(C)*B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n*          to the original system of equations.  Note that A and B are\n*          modified on exit if EQUED .ne. \'N\', and the solution to the\n*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n*          and EQUED = \'R\' or \'B\'.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)\n*\n*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (2*N)\n*          On exit, RWORK(1) contains the reciprocal pivot growth\n*          factor norm(A)/norm(U). The \"max absolute element\" norm is\n*          used. If RWORK(1) is much less than 1, then the stability\n*          of the LU factorization of the (equilibrated) matrix A\n*          could be poor. This also means that the solution X, condition\n*          estimator RCOND, and forward error bound FERR could be\n*          unreliable. If factorization fails with 0<INFO<=N, then\n*          RWORK(1) contains the reciprocal pivot growth factor for the\n*          leading INFO columns of A.\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization has\n*                       been completed, but the factor U is exactly\n*                       singular, so the solution and error bounds\n*                       could not be computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(125,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SGBSVX( FACT, TRANS, N, KL, KU, NRHS, AB, LDAB, AFB,\n     $                   LDAFB, IPIV, EQUED, R, C, B, LDB, X, LDX,\n     $                   RCOND, FERR, BERR, WORK, IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, TRANS\n      INTEGER            INFO, KL, KU, LDAB, LDAFB, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * ), IWORK( * )\n      REAL               AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),\n     $                   BERR( * ), C( * ), FERR( * ), R( * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SGBSVX uses the LU factorization to compute the solution to a real\n*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,\n*  where A is a band matrix of order N with KL subdiagonals and KU\n*  superdiagonals, and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed by this subroutine:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n*     or diag(C)*B (if TRANS = \'T\' or \'C\').\n*\n*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n*     matrix A (after equilibration if FACT = \'E\') as\n*        A = L * U,\n*     where L is a product of permutation and unit lower triangular\n*     matrices with KL subdiagonals, and U is upper triangular with\n*     KL+KU superdiagonals.\n*\n*  3. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n*     that it solves the original system before equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFB and IPIV contain the factored form of\n*                  A.  If EQUED is not \'N\', the matrix A has been\n*                  equilibrated with scaling factors given by R and C.\n*                  AB, AFB, and IPIV are not modified.\n*          = \'N\':  The matrix A will be copied to AFB and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFB and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations.\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Transpose)\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KL      (input) INTEGER\n*          The number of subdiagonals within the band of A.  KL >= 0.\n*\n*  KU      (input) INTEGER\n*          The number of superdiagonals within the band of A.  KU >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AB      (input/output) REAL array, dimension (LDAB,N)\n*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n*          The j-th column of A is stored in the j-th column of the\n*          array AB as follows:\n*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n*\n*          If FACT = \'F\' and EQUED is not \'N\', then A must have been\n*          equilibrated by the scaling factors in R and/or C.  AB is not\n*          modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n*          EQUED = \'N\' on exit.\n*\n*          On exit, if EQUED .ne. \'N\', A is scaled as follows:\n*          EQUED = \'R\':  A := diag(R) * A\n*          EQUED = \'C\':  A := A * diag(C)\n*          EQUED = \'B\':  A := diag(R) * A * diag(C).\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= KL+KU+1.\n*\n*  AFB     (input or output) REAL array, dimension (LDAFB,N)\n*          If FACT = \'F\', then AFB is an input argument and on entry\n*          contains details of the LU factorization of the band matrix\n*          A, as computed by SGBTRF.  U is stored as an upper triangular\n*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n*          and the multipliers used during the factorization are stored\n*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n*          the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFB is an output argument and on exit\n*          returns details of the LU factorization of A.\n*\n*          If FACT = \'E\', then AFB is an output argument and on exit\n*          returns details of the LU factorization of the equilibrated\n*          matrix A (see the description of AB for the form of the\n*          equilibrated matrix).\n*\n*  LDAFB   (input) INTEGER\n*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the factorization A = L*U\n*          as computed by SGBTRF; row i of the matrix was interchanged\n*          with row IPIV(i).\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = L*U\n*          of the equilibrated matrix A.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'R\':  Row equilibration, i.e., A has been premultiplied by\n*                  diag(R).\n*          = \'C\':  Column equilibration, i.e., A has been postmultiplied\n*                  by diag(C).\n*          = \'B\':  Both row and column equilibration, i.e., A has been\n*                  replaced by diag(R) * A * diag(C).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  R       (input or output) REAL array, dimension (N)\n*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n*          is not accessed.  R is an input argument if FACT = \'F\';\n*          otherwise, R is an output argument.  If FACT = \'F\' and\n*          EQUED = \'R\' or \'B\', each element of R must be positive.\n*\n*  C       (input or output) REAL array, dimension (N)\n*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n*          is not accessed.  C is an input argument if FACT = \'F\';\n*          otherwise, C is an output argument.  If FACT = \'F\' and\n*          EQUED = \'C\' or \'B\', each element of C must be positive.\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the right hand side matrix B.\n*          On exit,\n*          if EQUED = \'N\', B is not modified;\n*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n*          diag(R)*B;\n*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n*          overwritten by diag(C)*B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) REAL array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n*          to the original system of equations.  Note that A and B are\n*          modified on exit if EQUED .ne. \'N\', and the solution to the\n*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n*          and EQUED = \'R\' or \'B\'.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace/output) REAL array, dimension (3*N)\n*          On exit, WORK(1) contains the reciprocal pivot growth\n*          factor norm(A)/norm(U). The \"max absolute element\" norm is\n*          used. If WORK(1) is much less than 1, then the stability\n*          of the LU factorization of the (equilibrated) matrix A\n*          could be poor. This also means that the solution X, condition\n*          estimator RCOND, and forward error bound FERR could be\n*          unreliable. If factorization fails with 0<INFO<=N, then\n*          WORK(1) contains the reciprocal pivot growth factor for the\n*          leading INFO columns of A.\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization\n*                       has been completed, but the factor U is exactly\n*                       singular, so the solution and error bounds\n*                       could not be computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*\n*                       value of RCOND would suggest.\n'),(126,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DGBSVX( FACT, TRANS, N, KL, KU, NRHS, AB, LDAB, AFB,\n     $                   LDAFB, IPIV, EQUED, R, C, B, LDB, X, LDX,\n     $                   RCOND, FERR, BERR, WORK, IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, TRANS\n      INTEGER            INFO, KL, KU, LDAB, LDAFB, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * ), IWORK( * )\n      DOUBLE PRECISION   AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),\n     $                   BERR( * ), C( * ), FERR( * ), R( * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DGBSVX uses the LU factorization to compute the solution to a real\n*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,\n*  where A is a band matrix of order N with KL subdiagonals and KU\n*  superdiagonals, and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed by this subroutine:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n*     or diag(C)*B (if TRANS = \'T\' or \'C\').\n*\n*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n*     matrix A (after equilibration if FACT = \'E\') as\n*        A = L * U,\n*     where L is a product of permutation and unit lower triangular\n*     matrices with KL subdiagonals, and U is upper triangular with\n*     KL+KU superdiagonals.\n*\n*  3. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n*     that it solves the original system before equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFB and IPIV contain the factored form of\n*                  A.  If EQUED is not \'N\', the matrix A has been\n*                  equilibrated with scaling factors given by R and C.\n*                  AB, AFB, and IPIV are not modified.\n*          = \'N\':  The matrix A will be copied to AFB and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFB and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations.\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Transpose)\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KL      (input) INTEGER\n*          The number of subdiagonals within the band of A.  KL >= 0.\n*\n*  KU      (input) INTEGER\n*          The number of superdiagonals within the band of A.  KU >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)\n*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n*          The j-th column of A is stored in the j-th column of the\n*          array AB as follows:\n*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n*\n*          If FACT = \'F\' and EQUED is not \'N\', then A must have been\n*          equilibrated by the scaling factors in R and/or C.  AB is not\n*          modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n*          EQUED = \'N\' on exit.\n*\n*          On exit, if EQUED .ne. \'N\', A is scaled as follows:\n*          EQUED = \'R\':  A := diag(R) * A\n*          EQUED = \'C\':  A := A * diag(C)\n*          EQUED = \'B\':  A := diag(R) * A * diag(C).\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= KL+KU+1.\n*\n*  AFB     (input or output) DOUBLE PRECISION array, dimension (LDAFB,N)\n*          If FACT = \'F\', then AFB is an input argument and on entry\n*          contains details of the LU factorization of the band matrix\n*          A, as computed by DGBTRF.  U is stored as an upper triangular\n*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n*          and the multipliers used during the factorization are stored\n*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n*          the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFB is an output argument and on exit\n*          returns details of the LU factorization of A.\n*\n*          If FACT = \'E\', then AFB is an output argument and on exit\n*          returns details of the LU factorization of the equilibrated\n*          matrix A (see the description of AB for the form of the\n*          equilibrated matrix).\n*\n*  LDAFB   (input) INTEGER\n*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the factorization A = L*U\n*          as computed by DGBTRF; row i of the matrix was interchanged\n*          with row IPIV(i).\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = L*U\n*          of the equilibrated matrix A.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'R\':  Row equilibration, i.e., A has been premultiplied by\n*                  diag(R).\n*          = \'C\':  Column equilibration, i.e., A has been postmultiplied\n*                  by diag(C).\n*          = \'B\':  Both row and column equilibration, i.e., A has been\n*                  replaced by diag(R) * A * diag(C).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  R       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n*          is not accessed.  R is an input argument if FACT = \'F\';\n*          otherwise, R is an output argument.  If FACT = \'F\' and\n*          EQUED = \'R\' or \'B\', each element of R must be positive.\n*\n*  C       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n*          is not accessed.  C is an input argument if FACT = \'F\';\n*          otherwise, C is an output argument.  If FACT = \'F\' and\n*          EQUED = \'C\' or \'B\', each element of C must be positive.\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the right hand side matrix B.\n*          On exit,\n*          if EQUED = \'N\', B is not modified;\n*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n*          diag(R)*B;\n*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n*          overwritten by diag(C)*B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n*          to the original system of equations.  Note that A and B are\n*          modified on exit if EQUED .ne. \'N\', and the solution to the\n*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n*          and EQUED = \'R\' or \'B\'.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (3*N)\n*          On exit, WORK(1) contains the reciprocal pivot growth\n*          factor norm(A)/norm(U). The \"max absolute element\" norm is\n*          used. If WORK(1) is much less than 1, then the stability\n*          of the LU factorization of the (equilibrated) matrix A\n*          could be poor. This also means that the solution X, condition\n*          estimator RCOND, and forward error bound FERR could be\n*          unreliable. If factorization fails with 0<INFO<=N, then\n*          WORK(1) contains the reciprocal pivot growth factor for the\n*          leading INFO columns of A.\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization\n*                       has been completed, but the factor U is exactly\n*                       singular, so the solution and error bounds\n*                       could not be computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(127,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CGBSVX( FACT, TRANS, N, KL, KU, NRHS, AB, LDAB, AFB,\n     $                   LDAFB, IPIV, EQUED, R, C, B, LDB, X, LDX,\n     $                   RCOND, FERR, BERR, WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, TRANS\n      INTEGER            INFO, KL, KU, LDAB, LDAFB, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               BERR( * ), C( * ), FERR( * ), R( * ),\n     $                   RWORK( * )\n      COMPLEX            AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CGBSVX uses the LU factorization to compute the solution to a complex\n*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,\n*  where A is a band matrix of order N with KL subdiagonals and KU\n*  superdiagonals, and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed by this subroutine:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n*     or diag(C)*B (if TRANS = \'T\' or \'C\').\n*\n*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n*     matrix A (after equilibration if FACT = \'E\') as\n*        A = L * U,\n*     where L is a product of permutation and unit lower triangular\n*     matrices with KL subdiagonals, and U is upper triangular with\n*     KL+KU superdiagonals.\n*\n*  3. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n*     that it solves the original system before equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFB and IPIV contain the factored form of\n*                  A.  If EQUED is not \'N\', the matrix A has been\n*                  equilibrated with scaling factors given by R and C.\n*                  AB, AFB, and IPIV are not modified.\n*          = \'N\':  The matrix A will be copied to AFB and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFB and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations.\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Conjugate transpose)\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KL      (input) INTEGER\n*          The number of subdiagonals within the band of A.  KL >= 0.\n*\n*  KU      (input) INTEGER\n*          The number of superdiagonals within the band of A.  KU >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AB      (input/output) COMPLEX array, dimension (LDAB,N)\n*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n*          The j-th column of A is stored in the j-th column of the\n*          array AB as follows:\n*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n*\n*          If FACT = \'F\' and EQUED is not \'N\', then A must have been\n*          equilibrated by the scaling factors in R and/or C.  AB is not\n*          modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n*          EQUED = \'N\' on exit.\n*\n*          On exit, if EQUED .ne. \'N\', A is scaled as follows:\n*          EQUED = \'R\':  A := diag(R) * A\n*          EQUED = \'C\':  A := A * diag(C)\n*          EQUED = \'B\':  A := diag(R) * A * diag(C).\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= KL+KU+1.\n*\n*  AFB     (input or output) COMPLEX array, dimension (LDAFB,N)\n*          If FACT = \'F\', then AFB is an input argument and on entry\n*          contains details of the LU factorization of the band matrix\n*          A, as computed by CGBTRF.  U is stored as an upper triangular\n*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n*          and the multipliers used during the factorization are stored\n*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n*          the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFB is an output argument and on exit\n*          returns details of the LU factorization of A.\n*\n*          If FACT = \'E\', then AFB is an output argument and on exit\n*          returns details of the LU factorization of the equilibrated\n*          matrix A (see the description of AB for the form of the\n*          equilibrated matrix).\n*\n*  LDAFB   (input) INTEGER\n*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the factorization A = L*U\n*          as computed by CGBTRF; row i of the matrix was interchanged\n*          with row IPIV(i).\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = L*U\n*          of the equilibrated matrix A.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'R\':  Row equilibration, i.e., A has been premultiplied by\n*                  diag(R).\n*          = \'C\':  Column equilibration, i.e., A has been postmultiplied\n*                  by diag(C).\n*          = \'B\':  Both row and column equilibration, i.e., A has been\n*                  replaced by diag(R) * A * diag(C).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  R       (input or output) REAL array, dimension (N)\n*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n*          is not accessed.  R is an input argument if FACT = \'F\';\n*          otherwise, R is an output argument.  If FACT = \'F\' and\n*          EQUED = \'R\' or \'B\', each element of R must be positive.\n*\n*  C       (input or output) REAL array, dimension (N)\n*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n*          is not accessed.  C is an input argument if FACT = \'F\';\n*          otherwise, C is an output argument.  If FACT = \'F\' and\n*          EQUED = \'C\' or \'B\', each element of C must be positive.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the right hand side matrix B.\n*          On exit,\n*          if EQUED = \'N\', B is not modified;\n*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n*          diag(R)*B;\n*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n*          overwritten by diag(C)*B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n*          to the original system of equations.  Note that A and B are\n*          modified on exit if EQUED .ne. \'N\', and the solution to the\n*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n*          and EQUED = \'R\' or \'B\'.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX array, dimension (2*N)\n*\n*  RWORK   (workspace/output) REAL array, dimension (N)\n*          On exit, RWORK(1) contains the reciprocal pivot growth\n*          factor norm(A)/norm(U). The \"max absolute element\" norm is\n*          used. If RWORK(1) is much less than 1, then the stability\n*          of the LU factorization of the (equilibrated) matrix A\n*          could be poor. This also means that the solution X, condition\n*          estimator RCOND, and forward error bound FERR could be\n*          unreliable. If factorization fails with 0<INFO<=N, then\n*          RWORK(1) contains the reciprocal pivot growth factor for the\n*          leading INFO columns of A.\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization\n*                       has been completed, but the factor U is exactly\n*                       singular, so the solution and error bounds\n*                       could not be computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(128,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZGBSVX( FACT, TRANS, N, KL, KU, NRHS, AB, LDAB, AFB,\n     $                   LDAFB, IPIV, EQUED, R, C, B, LDB, X, LDX,\n     $                   RCOND, FERR, BERR, WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, TRANS\n      INTEGER            INFO, KL, KU, LDAB, LDAFB, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   BERR( * ), C( * ), FERR( * ), R( * ),\n     $                   RWORK( * )\n      COMPLEX*16         AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZGBSVX uses the LU factorization to compute the solution to a complex\n*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,\n*  where A is a band matrix of order N with KL subdiagonals and KU\n*  superdiagonals, and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed by this subroutine:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n*     or diag(C)*B (if TRANS = \'T\' or \'C\').\n*\n*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n*     matrix A (after equilibration if FACT = \'E\') as\n*        A = L * U,\n*     where L is a product of permutation and unit lower triangular\n*     matrices with KL subdiagonals, and U is upper triangular with\n*     KL+KU superdiagonals.\n*\n*  3. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n*     that it solves the original system before equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFB and IPIV contain the factored form of\n*                  A.  If EQUED is not \'N\', the matrix A has been\n*                  equilibrated with scaling factors given by R and C.\n*                  AB, AFB, and IPIV are not modified.\n*          = \'N\':  The matrix A will be copied to AFB and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFB and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations.\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Conjugate transpose)\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KL      (input) INTEGER\n*          The number of subdiagonals within the band of A.  KL >= 0.\n*\n*  KU      (input) INTEGER\n*          The number of superdiagonals within the band of A.  KU >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)\n*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n*          The j-th column of A is stored in the j-th column of the\n*          array AB as follows:\n*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n*\n*          If FACT = \'F\' and EQUED is not \'N\', then A must have been\n*          equilibrated by the scaling factors in R and/or C.  AB is not\n*          modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n*          EQUED = \'N\' on exit.\n*\n*          On exit, if EQUED .ne. \'N\', A is scaled as follows:\n*          EQUED = \'R\':  A := diag(R) * A\n*          EQUED = \'C\':  A := A * diag(C)\n*          EQUED = \'B\':  A := diag(R) * A * diag(C).\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array AB.  LDAB >= KL+KU+1.\n*\n*  AFB     (input or output) COMPLEX*16 array, dimension (LDAFB,N)\n*          If FACT = \'F\', then AFB is an input argument and on entry\n*          contains details of the LU factorization of the band matrix\n*          A, as computed by ZGBTRF.  U is stored as an upper triangular\n*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n*          and the multipliers used during the factorization are stored\n*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n*          the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFB is an output argument and on exit\n*          returns details of the LU factorization of A.\n*\n*          If FACT = \'E\', then AFB is an output argument and on exit\n*          returns details of the LU factorization of the equilibrated\n*          matrix A (see the description of AB for the form of the\n*          equilibrated matrix).\n*\n*  LDAFB   (input) INTEGER\n*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the factorization A = L*U\n*          as computed by ZGBTRF; row i of the matrix was interchanged\n*          with row IPIV(i).\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = L*U\n*          of the original matrix A.\n*\n*          If FACT = \'E\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the factorization A = L*U\n*          of the equilibrated matrix A.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'R\':  Row equilibration, i.e., A has been premultiplied by\n*                  diag(R).\n*          = \'C\':  Column equilibration, i.e., A has been postmultiplied\n*                  by diag(C).\n*          = \'B\':  Both row and column equilibration, i.e., A has been\n*                  replaced by diag(R) * A * diag(C).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  R       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n*          is not accessed.  R is an input argument if FACT = \'F\';\n*          otherwise, R is an output argument.  If FACT = \'F\' and\n*          EQUED = \'R\' or \'B\', each element of R must be positive.\n*\n*  C       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n*          is not accessed.  C is an input argument if FACT = \'F\';\n*          otherwise, C is an output argument.  If FACT = \'F\' and\n*          EQUED = \'C\' or \'B\', each element of C must be positive.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the right hand side matrix B.\n*          On exit,\n*          if EQUED = \'N\', B is not modified;\n*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n*          diag(R)*B;\n*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n*          overwritten by diag(C)*B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n*          to the original system of equations.  Note that A and B are\n*          modified on exit if EQUED .ne. \'N\', and the solution to the\n*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n*          and EQUED = \'R\' or \'B\'.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)\n*\n*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (N)\n*          On exit, RWORK(1) contains the reciprocal pivot growth\n*          factor norm(A)/norm(U). The \"max absolute element\" norm is\n*          used. If RWORK(1) is much less than 1, then the stability\n*          of the LU factorization of the (equilibrated) matrix A\n*          could be poor. This also means that the solution X, condition\n*          estimator RCOND, and forward error bound FERR could be\n*          unreliable. If factorization fails with 0<INFO<=N, then\n*          RWORK(1) contains the reciprocal pivot growth factor for the\n*          leading INFO columns of A.\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization\n*                       has been completed, but the factor U is exactly\n*                       singular, so the solution and error bounds\n*                       could not be computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(129,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SGTSVX( FACT, TRANS, N, NRHS, DL, D, DU, DLF, DF, DUF,\n     $                   DU2, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, TRANS\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * ), IWORK( * )\n      REAL               B( LDB, * ), BERR( * ), D( * ), DF( * ),\n     $                   DL( * ), DLF( * ), DU( * ), DU2( * ), DUF( * ),\n     $                   FERR( * ), WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SGTSVX uses the LU factorization to compute the solution to a real\n*  system of linear equations A * X = B or A**T * X = B,\n*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS\n*  matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the LU decomposition is used to factor the matrix A\n*     as A = L * U, where L is a product of permutation and unit lower\n*     bidiagonal matrices and U is upper triangular with nonzeros in\n*     only the main diagonal and first two superdiagonals.\n*\n*  2. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored\n*                  form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV\n*                  will not be modified.\n*          = \'N\':  The matrix will be copied to DLF, DF, and DUF\n*                  and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations:\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  DL      (input) REAL array, dimension (N-1)\n*          The (n-1) subdiagonal elements of A.\n*\n*  D       (input) REAL array, dimension (N)\n*          The n diagonal elements of A.\n*\n*  DU      (input) REAL array, dimension (N-1)\n*          The (n-1) superdiagonal elements of A.\n*\n*  DLF     (input or output) REAL array, dimension (N-1)\n*          If FACT = \'F\', then DLF is an input argument and on entry\n*          contains the (n-1) multipliers that define the matrix L from\n*          the LU factorization of A as computed by SGTTRF.\n*\n*          If FACT = \'N\', then DLF is an output argument and on exit\n*          contains the (n-1) multipliers that define the matrix L from\n*          the LU factorization of A.\n*\n*  DF      (input or output) REAL array, dimension (N)\n*          If FACT = \'F\', then DF is an input argument and on entry\n*          contains the n diagonal elements of the upper triangular\n*          matrix U from the LU factorization of A.\n*\n*          If FACT = \'N\', then DF is an output argument and on exit\n*          contains the n diagonal elements of the upper triangular\n*          matrix U from the LU factorization of A.\n*\n*  DUF     (input or output) REAL array, dimension (N-1)\n*          If FACT = \'F\', then DUF is an input argument and on entry\n*          contains the (n-1) elements of the first superdiagonal of U.\n*\n*          If FACT = \'N\', then DUF is an output argument and on exit\n*          contains the (n-1) elements of the first superdiagonal of U.\n*\n*  DU2     (input or output) REAL array, dimension (N-2)\n*          If FACT = \'F\', then DU2 is an input argument and on entry\n*          contains the (n-2) elements of the second superdiagonal of\n*          U.\n*\n*          If FACT = \'N\', then DU2 is an output argument and on exit\n*          contains the (n-2) elements of the second superdiagonal of\n*          U.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the LU factorization of A as\n*          computed by SGTTRF.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the LU factorization of A;\n*          row i of the matrix was interchanged with row IPIV(i).\n*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates\n*          a row interchange was not required.\n*\n*  B       (input) REAL array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) REAL array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) REAL array, dimension (3*N)\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization\n*                       has not been completed unless i = N, but the\n*                       factor U is exactly singular, so the solution\n*                       and error bounds could not be computed.\n*                       RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(130,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DGTSVX( FACT, TRANS, N, NRHS, DL, D, DU, DLF, DF, DUF,\n     $                   DU2, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, TRANS\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * ), IWORK( * )\n      DOUBLE PRECISION   B( LDB, * ), BERR( * ), D( * ), DF( * ),\n     $                   DL( * ), DLF( * ), DU( * ), DU2( * ), DUF( * ),\n     $                   FERR( * ), WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DGTSVX uses the LU factorization to compute the solution to a real\n*  system of linear equations A * X = B or A**T * X = B,\n*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS\n*  matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the LU decomposition is used to factor the matrix A\n*     as A = L * U, where L is a product of permutation and unit lower\n*     bidiagonal matrices and U is upper triangular with nonzeros in\n*     only the main diagonal and first two superdiagonals.\n*\n*  2. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored\n*                  form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV\n*                  will not be modified.\n*          = \'N\':  The matrix will be copied to DLF, DF, and DUF\n*                  and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations:\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  DL      (input) DOUBLE PRECISION array, dimension (N-1)\n*          The (n-1) subdiagonal elements of A.\n*\n*  D       (input) DOUBLE PRECISION array, dimension (N)\n*          The n diagonal elements of A.\n*\n*  DU      (input) DOUBLE PRECISION array, dimension (N-1)\n*          The (n-1) superdiagonal elements of A.\n*\n*  DLF     (input or output) DOUBLE PRECISION array, dimension (N-1)\n*          If FACT = \'F\', then DLF is an input argument and on entry\n*          contains the (n-1) multipliers that define the matrix L from\n*          the LU factorization of A as computed by DGTTRF.\n*\n*          If FACT = \'N\', then DLF is an output argument and on exit\n*          contains the (n-1) multipliers that define the matrix L from\n*          the LU factorization of A.\n*\n*  DF      (input or output) DOUBLE PRECISION array, dimension (N)\n*          If FACT = \'F\', then DF is an input argument and on entry\n*          contains the n diagonal elements of the upper triangular\n*          matrix U from the LU factorization of A.\n*\n*          If FACT = \'N\', then DF is an output argument and on exit\n*          contains the n diagonal elements of the upper triangular\n*          matrix U from the LU factorization of A.\n*\n*  DUF     (input or output) DOUBLE PRECISION array, dimension (N-1)\n*          If FACT = \'F\', then DUF is an input argument and on entry\n*          contains the (n-1) elements of the first superdiagonal of U.\n*\n*          If FACT = \'N\', then DUF is an output argument and on exit\n*          contains the (n-1) elements of the first superdiagonal of U.\n*\n*  DU2     (input or output) DOUBLE PRECISION array, dimension (N-2)\n*          If FACT = \'F\', then DU2 is an input argument and on entry\n*          contains the (n-2) elements of the second superdiagonal of\n*          U.\n*\n*          If FACT = \'N\', then DU2 is an output argument and on exit\n*          contains the (n-2) elements of the second superdiagonal of\n*          U.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the LU factorization of A as\n*          computed by DGTTRF.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the LU factorization of A;\n*          row i of the matrix was interchanged with row IPIV(i).\n*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates\n*          a row interchange was not required.\n*\n*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization\n*                       has not been completed unless i = N, but the\n*                       factor U is exactly singular, so the solution\n*                       and error bounds could not be computed.\n*                       RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(131,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CGTSVX( FACT, TRANS, N, NRHS, DL, D, DU, DLF, DF, DUF,\n     $                   DU2, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, RWORK, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, TRANS\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               BERR( * ), FERR( * ), RWORK( * )\n      COMPLEX            B( LDB, * ), D( * ), DF( * ), DL( * ),\n     $                   DLF( * ), DU( * ), DU2( * ), DUF( * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CGTSVX uses the LU factorization to compute the solution to a complex\n*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,\n*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS\n*  matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the LU decomposition is used to factor the matrix A\n*     as A = L * U, where L is a product of permutation and unit lower\n*     bidiagonal matrices and U is upper triangular with nonzeros in\n*     only the main diagonal and first two superdiagonals.\n*\n*  2. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored form\n*                  of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV will not\n*                  be modified.\n*          = \'N\':  The matrix will be copied to DLF, DF, and DUF\n*                  and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations:\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Conjugate transpose)\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  DL      (input) COMPLEX array, dimension (N-1)\n*          The (n-1) subdiagonal elements of A.\n*\n*  D       (input) COMPLEX array, dimension (N)\n*          The n diagonal elements of A.\n*\n*  DU      (input) COMPLEX array, dimension (N-1)\n*          The (n-1) superdiagonal elements of A.\n*\n*  DLF     (input or output) COMPLEX array, dimension (N-1)\n*          If FACT = \'F\', then DLF is an input argument and on entry\n*          contains the (n-1) multipliers that define the matrix L from\n*          the LU factorization of A as computed by CGTTRF.\n*\n*          If FACT = \'N\', then DLF is an output argument and on exit\n*          contains the (n-1) multipliers that define the matrix L from\n*          the LU factorization of A.\n*\n*  DF      (input or output) COMPLEX array, dimension (N)\n*          If FACT = \'F\', then DF is an input argument and on entry\n*          contains the n diagonal elements of the upper triangular\n*          matrix U from the LU factorization of A.\n*\n*          If FACT = \'N\', then DF is an output argument and on exit\n*          contains the n diagonal elements of the upper triangular\n*          matrix U from the LU factorization of A.\n*\n*  DUF     (input or output) COMPLEX array, dimension (N-1)\n*          If FACT = \'F\', then DUF is an input argument and on entry\n*          contains the (n-1) elements of the first superdiagonal of U.\n*\n*          If FACT = \'N\', then DUF is an output argument and on exit\n*          contains the (n-1) elements of the first superdiagonal of U.\n*\n*  DU2     (input or output) COMPLEX array, dimension (N-2)\n*          If FACT = \'F\', then DU2 is an input argument and on entry\n*          contains the (n-2) elements of the second superdiagonal of\n*          U.\n*\n*          If FACT = \'N\', then DU2 is an output argument and on exit\n*          contains the (n-2) elements of the second superdiagonal of\n*          U.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the LU factorization of A as\n*          computed by CGTTRF.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the LU factorization of A;\n*          row i of the matrix was interchanged with row IPIV(i).\n*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates\n*          a row interchange was not required.\n*\n*  B       (input) COMPLEX array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX array, dimension (2*N)\n*\n*  RWORK   (workspace) REAL array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization\n*                       has not been completed unless i = N, but the\n*                       factor U is exactly singular, so the solution\n*                       and error bounds could not be computed.\n*                       RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(132,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZGTSVX( FACT, TRANS, N, NRHS, DL, D, DU, DLF, DF, DUF,\n     $                   DU2, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, RWORK, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, TRANS\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * )\n      COMPLEX*16         B( LDB, * ), D( * ), DF( * ), DL( * ),\n     $                   DLF( * ), DU( * ), DU2( * ), DUF( * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZGTSVX uses the LU factorization to compute the solution to a complex\n*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,\n*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS\n*  matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the LU decomposition is used to factor the matrix A\n*     as A = L * U, where L is a product of permutation and unit lower\n*     bidiagonal matrices and U is upper triangular with nonzeros in\n*     only the main diagonal and first two superdiagonals.\n*\n*  2. If some U(i,i)=0, so that U is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored form\n*                  of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV will not\n*                  be modified.\n*          = \'N\':  The matrix will be copied to DLF, DF, and DUF\n*                  and factored.\n*\n*  TRANS   (input) CHARACTER*1\n*          Specifies the form of the system of equations:\n*          = \'N\':  A * X = B     (No transpose)\n*          = \'T\':  A**T * X = B  (Transpose)\n*          = \'C\':  A**H * X = B  (Conjugate transpose)\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrix B.  NRHS >= 0.\n*\n*  DL      (input) COMPLEX*16 array, dimension (N-1)\n*          The (n-1) subdiagonal elements of A.\n*\n*  D       (input) COMPLEX*16 array, dimension (N)\n*          The n diagonal elements of A.\n*\n*  DU      (input) COMPLEX*16 array, dimension (N-1)\n*          The (n-1) superdiagonal elements of A.\n*\n*  DLF     (input or output) COMPLEX*16 array, dimension (N-1)\n*          If FACT = \'F\', then DLF is an input argument and on entry\n*          contains the (n-1) multipliers that define the matrix L from\n*          the LU factorization of A as computed by ZGTTRF.\n*\n*          If FACT = \'N\', then DLF is an output argument and on exit\n*          contains the (n-1) multipliers that define the matrix L from\n*          the LU factorization of A.\n*\n*  DF      (input or output) COMPLEX*16 array, dimension (N)\n*          If FACT = \'F\', then DF is an input argument and on entry\n*          contains the n diagonal elements of the upper triangular\n*          matrix U from the LU factorization of A.\n*\n*          If FACT = \'N\', then DF is an output argument and on exit\n*          contains the n diagonal elements of the upper triangular\n*          matrix U from the LU factorization of A.\n*\n*  DUF     (input or output) COMPLEX*16 array, dimension (N-1)\n*          If FACT = \'F\', then DUF is an input argument and on entry\n*          contains the (n-1) elements of the first superdiagonal of U.\n*\n*          If FACT = \'N\', then DUF is an output argument and on exit\n*          contains the (n-1) elements of the first superdiagonal of U.\n*\n*  DU2     (input or output) COMPLEX*16 array, dimension (N-2)\n*          If FACT = \'F\', then DU2 is an input argument and on entry\n*          contains the (n-2) elements of the second superdiagonal of\n*          U.\n*\n*          If FACT = \'N\', then DU2 is an output argument and on exit\n*          contains the (n-2) elements of the second superdiagonal of\n*          U.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains the pivot indices from the LU factorization of A as\n*          computed by ZGTTRF.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains the pivot indices from the LU factorization of A;\n*          row i of the matrix was interchanged with row IPIV(i).\n*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates\n*          a row interchange was not required.\n*\n*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)\n*\n*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  U(i,i) is exactly zero.  The factorization\n*                       has not been completed unless i = N, but the\n*                       factor U is exactly singular, so the solution\n*                       and error bounds could not be computed.\n*                       RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(133,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CHESVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,\n     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,\n     $                   RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               BERR( * ), FERR( * ), RWORK( * )\n      COMPLEX            A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CHESVX uses the diagonal pivoting factorization to compute the\n*  solution to a complex system of linear equations A * X = B,\n*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n*     The form of the factorization is\n*        A = U * D * U**H,  if UPLO = \'U\', or\n*        A = L * D * L**H,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices, and D is Hermitian and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AF and IPIV contain the factored form\n*                  of A.  A, AF and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input) COMPLEX array, dimension (LDA,N)\n*          The Hermitian matrix A.  If UPLO = \'U\', the leading N-by-N\n*          upper triangular part of A contains the upper triangular part\n*          of the matrix A, and the strictly lower triangular part of A\n*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n*          triangular part of A contains the lower triangular part of\n*          the matrix A, and the strictly upper triangular part of A is\n*          not referenced.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) COMPLEX array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**H or A = L*D*L**H as computed by CHETRF.\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**H or A = L*D*L**H.\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by CHETRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by CHETRF.\n*\n*  B       (input) COMPLEX array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= max(1,2*N), and for best\n*          performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where\n*          NB is the optimal blocksize for CHETRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  RWORK   (workspace) REAL array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(134,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZHESVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,\n     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,\n     $                   RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * )\n      COMPLEX*16         A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZHESVX uses the diagonal pivoting factorization to compute the\n*  solution to a complex system of linear equations A * X = B,\n*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n*     The form of the factorization is\n*        A = U * D * U**H,  if UPLO = \'U\', or\n*        A = L * D * L**H,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices, and D is Hermitian and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AF and IPIV contain the factored form\n*                  of A.  A, AF and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input) COMPLEX*16 array, dimension (LDA,N)\n*          The Hermitian matrix A.  If UPLO = \'U\', the leading N-by-N\n*          upper triangular part of A contains the upper triangular part\n*          of the matrix A, and the strictly lower triangular part of A\n*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n*          triangular part of A contains the lower triangular part of\n*          the matrix A, and the strictly upper triangular part of A is\n*          not referenced.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**H or A = L*D*L**H as computed by ZHETRF.\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**H or A = L*D*L**H.\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by ZHETRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by ZHETRF.\n*\n*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= max(1,2*N), and for best\n*          performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where\n*          NB is the optimal blocksize for ZHETRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(135,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CHPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,\n     $                   LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               BERR( * ), FERR( * ), RWORK( * )\n      COMPLEX            AFP( * ), AP( * ), B( LDB, * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or\n*  A = L*D*L**H to compute the solution to a complex system of linear\n*  equations A * X = B, where A is an N-by-N Hermitian matrix stored\n*  in packed format and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n*        A = U * D * U**H,  if UPLO = \'U\', or\n*        A = L * D * L**H,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices and D is Hermitian and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AFP and IPIV contain the factored form of\n*                  A.  AFP and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AFP and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)\n*          The upper or lower triangle of the Hermitian matrix A, packed\n*          columnwise in a linear array.  The j-th column of A is stored\n*          in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*  AFP     (input or output) COMPLEX array, dimension (N*(N+1)/2)\n*          If FACT = \'F\', then AFP is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*          If FACT = \'N\', then AFP is an output argument and on exit\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by CHPTRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by CHPTRF.\n*\n*  B       (input) COMPLEX array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX array, dimension (2*N)\n*\n*  RWORK   (workspace) REAL array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the Hermitian matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(136,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZHPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,\n     $                   LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * )\n      COMPLEX*16         AFP( * ), AP( * ), B( LDB, * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZHPSVX uses the diagonal pivoting factorization A = U*D*U**H or\n*  A = L*D*L**H to compute the solution to a complex system of linear\n*  equations A * X = B, where A is an N-by-N Hermitian matrix stored\n*  in packed format and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n*        A = U * D * U**H,  if UPLO = \'U\', or\n*        A = L * D * L**H,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices and D is Hermitian and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AFP and IPIV contain the factored form of\n*                  A.  AFP and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AFP and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)\n*          The upper or lower triangle of the Hermitian matrix A, packed\n*          columnwise in a linear array.  The j-th column of A is stored\n*          in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*  AFP     (input or output) COMPLEX*16 array, dimension (N*(N+1)/2)\n*          If FACT = \'F\', then AFP is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*          If FACT = \'N\', then AFP is an output argument and on exit\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by ZHPTRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by ZHPTRF.\n*\n*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)\n*\n*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the Hermitian matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(137,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SPOSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, EQUED,\n     $                   S, B, LDB, X, LDX, RCOND, FERR, BERR, WORK,\n     $                   IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IWORK( * )\n      REAL               A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   BERR( * ), FERR( * ), S( * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\n*  compute the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite matrix and X and B\n*  are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U**T* U,  if UPLO = \'U\', or\n*        A = L * L**T,  if UPLO = \'L\',\n*     where U is an upper triangular matrix and L is a lower triangular\n*     matrix.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AF contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  A and AF will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AF and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input/output) REAL array, dimension (LDA,N)\n*          On entry, the symmetric matrix A, except if FACT = \'F\' and\n*          EQUED = \'Y\', then A must contain the equilibrated matrix\n*          diag(S)*A*diag(S).  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.  A is not modified if\n*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) REAL array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T, in the same storage\n*          format as A.  If EQUED .ne. \'N\', then AF is the factored form\n*          of the equilibrated matrix diag(S)*A*diag(S).\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T of the original\n*          matrix A.\n*\n*          If FACT = \'E\', then AF is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T of the equilibrated\n*          matrix A (see the description of A for the form of the\n*          equilibrated matrix).\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) REAL array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) REAL array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) REAL array, dimension (3*N)\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(138,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DPOSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, EQUED,\n     $                   S, B, LDB, X, LDX, RCOND, FERR, BERR, WORK,\n     $                   IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IWORK( * )\n      DOUBLE PRECISION   A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   BERR( * ), FERR( * ), S( * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\n*  compute the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite matrix and X and B\n*  are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U**T* U,  if UPLO = \'U\', or\n*        A = L * L**T,  if UPLO = \'L\',\n*     where U is an upper triangular matrix and L is a lower triangular\n*     matrix.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AF contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  A and AF will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AF and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)\n*          On entry, the symmetric matrix A, except if FACT = \'F\' and\n*          EQUED = \'Y\', then A must contain the equilibrated matrix\n*          diag(S)*A*diag(S).  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.  A is not modified if\n*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T, in the same storage\n*          format as A.  If EQUED .ne. \'N\', then AF is the factored form\n*          of the equilibrated matrix diag(S)*A*diag(S).\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T of the original\n*          matrix A.\n*\n*          If FACT = \'E\', then AF is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T of the equilibrated\n*          matrix A (see the description of A for the form of the\n*          equilibrated matrix).\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(139,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CPOSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, EQUED,\n     $                   S, B, LDB, X, LDX, RCOND, FERR, BERR, WORK,\n     $                   RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      REAL               BERR( * ), FERR( * ), RWORK( * ), S( * )\n      COMPLEX            A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\n*  compute the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite matrix and X and B\n*  are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U**H* U,  if UPLO = \'U\', or\n*        A = L * L**H,  if UPLO = \'L\',\n*     where U is an upper triangular matrix and L is a lower triangular\n*     matrix.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AF contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  A and AF will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AF and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX array, dimension (LDA,N)\n*          On entry, the Hermitian matrix A, except if FACT = \'F\' and\n*          EQUED = \'Y\', then A must contain the equilibrated matrix\n*          diag(S)*A*diag(S).  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.  A is not modified if\n*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) COMPLEX array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H, in the same storage\n*          format as A.  If EQUED .ne. \'N\', then AF is the factored form\n*          of the equilibrated matrix diag(S)*A*diag(S).\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the original\n*          matrix A.\n*\n*          If FACT = \'E\', then AF is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the equilibrated\n*          matrix A (see the description of A for the form of the\n*          equilibrated matrix).\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) REAL array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS righthand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX array, dimension (2*N)\n*\n*  RWORK   (workspace) REAL array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(140,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZPOSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, EQUED,\n     $                   S, B, LDB, X, LDX, RCOND, FERR, BERR, WORK,\n     $                   RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * ), S( * )\n      COMPLEX*16         A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\n*  compute the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite matrix and X and B\n*  are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U**H* U,  if UPLO = \'U\', or\n*        A = L * L**H,  if UPLO = \'L\',\n*     where U is an upper triangular matrix and L is a lower triangular\n*     matrix.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AF contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  A and AF will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AF and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)\n*          On entry, the Hermitian matrix A, except if FACT = \'F\' and\n*          EQUED = \'Y\', then A must contain the equilibrated matrix\n*          diag(S)*A*diag(S).  If UPLO = \'U\', the leading\n*          N-by-N upper triangular part of A contains the upper\n*          triangular part of the matrix A, and the strictly lower\n*          triangular part of A is not referenced.  If UPLO = \'L\', the\n*          leading N-by-N lower triangular part of A contains the lower\n*          triangular part of the matrix A, and the strictly upper\n*          triangular part of A is not referenced.  A is not modified if\n*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H, in the same storage\n*          format as A.  If EQUED .ne. \'N\', then AF is the factored form\n*          of the equilibrated matrix diag(S)*A*diag(S).\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the original\n*          matrix A.\n*\n*          If FACT = \'E\', then AF is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the equilibrated\n*          matrix A (see the description of A for the form of the\n*          equilibrated matrix).\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS righthand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)\n*\n*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(141,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SPBSVX( FACT, UPLO, N, KD, NRHS, AB, LDAB, AFB, LDAFB,\n     $                   EQUED, S, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, KD, LDAB, LDAFB, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IWORK( * )\n      REAL               AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),\n     $                   BERR( * ), FERR( * ), S( * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\n*  compute the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite band matrix and X\n*  and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U**T * U,  if UPLO = \'U\', or\n*        A = L * L**T,  if UPLO = \'L\',\n*     where U is an upper triangular band matrix, and L is a lower\n*     triangular band matrix.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFB contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  AB and AFB will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AFB and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFB and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KD      (input) INTEGER\n*          The number of superdiagonals of the matrix A if UPLO = \'U\',\n*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right-hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AB      (input/output) REAL array, dimension (LDAB,N)\n*          On entry, the upper or lower triangle of the symmetric band\n*          matrix A, stored in the first KD+1 rows of the array, except\n*          if FACT = \'F\' and EQUED = \'Y\', then A must contain the\n*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A\n*          is stored in the j-th column of the array AB as follows:\n*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n*          See below for further details.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array A.  LDAB >= KD+1.\n*\n*  AFB     (input or output) REAL array, dimension (LDAFB,N)\n*          If FACT = \'F\', then AFB is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T of the band matrix\n*          A, in the same storage format as A (see AB).  If EQUED = \'Y\',\n*          then AFB is the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFB is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T.\n*\n*          If FACT = \'E\', then AFB is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T of the equilibrated\n*          matrix A (see the description of A for the form of the\n*          equilibrated matrix).\n*\n*  LDAFB   (input) INTEGER\n*          The leading dimension of the array AFB.  LDAFB >= KD+1.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) REAL array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) REAL array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) REAL array, dimension (3*N)\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  N = 6, KD = 2, and UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11  a12  a13\n*          a22  a23  a24\n*               a33  a34  a35\n*                    a44  a45  a46\n*                         a55  a56\n*     (aij=conjg(aji))         a66\n*\n*  Band storage of the upper triangle of A:\n*\n*      *    *   a13  a24  a35  a46\n*      *   a12  a23  a34  a45  a56\n*     a11  a22  a33  a44  a55  a66\n*\n*  Similarly, if UPLO = \'L\' the format of A is as follows:\n*\n*     a11  a22  a33  a44  a55  a66\n*     a21  a32  a43  a54  a65   *\n*     a31  a42  a53  a64   *    *\n*\n*  Array elements marked * are not used by the routine.\n*\n'),(142,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DPBSVX( FACT, UPLO, N, KD, NRHS, AB, LDAB, AFB, LDAFB,\n     $                   EQUED, S, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, KD, LDAB, LDAFB, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IWORK( * )\n      DOUBLE PRECISION   AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),\n     $                   BERR( * ), FERR( * ), S( * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\n*  compute the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite band matrix and X\n*  and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U**T * U,  if UPLO = \'U\', or\n*        A = L * L**T,  if UPLO = \'L\',\n*     where U is an upper triangular band matrix, and L is a lower\n*     triangular band matrix.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFB contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  AB and AFB will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AFB and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFB and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KD      (input) INTEGER\n*          The number of superdiagonals of the matrix A if UPLO = \'U\',\n*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right-hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)\n*          On entry, the upper or lower triangle of the symmetric band\n*          matrix A, stored in the first KD+1 rows of the array, except\n*          if FACT = \'F\' and EQUED = \'Y\', then A must contain the\n*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A\n*          is stored in the j-th column of the array AB as follows:\n*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n*          See below for further details.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array A.  LDAB >= KD+1.\n*\n*  AFB     (input or output) DOUBLE PRECISION array, dimension (LDAFB,N)\n*          If FACT = \'F\', then AFB is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T of the band matrix\n*          A, in the same storage format as A (see AB).  If EQUED = \'Y\',\n*          then AFB is the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFB is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T.\n*\n*          If FACT = \'E\', then AFB is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**T*U or A = L*L**T of the equilibrated\n*          matrix A (see the description of A for the form of the\n*          equilibrated matrix).\n*\n*  LDAFB   (input) INTEGER\n*          The leading dimension of the array AFB.  LDAFB >= KD+1.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  N = 6, KD = 2, and UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11  a12  a13\n*          a22  a23  a24\n*               a33  a34  a35\n*                    a44  a45  a46\n*                         a55  a56\n*     (aij=conjg(aji))         a66\n*\n*  Band storage of the upper triangle of A:\n*\n*      *    *   a13  a24  a35  a46\n*      *   a12  a23  a34  a45  a56\n*     a11  a22  a33  a44  a55  a66\n*\n*  Similarly, if UPLO = \'L\' the format of A is as follows:\n*\n*     a11  a22  a33  a44  a55  a66\n*     a21  a32  a43  a54  a65   *\n*     a31  a42  a53  a64   *    *\n*\n*  Array elements marked * are not used by the routine.\n*\n'),(143,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CPBSVX( FACT, UPLO, N, KD, NRHS, AB, LDAB, AFB, LDAFB,\n     $                   EQUED, S, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, KD, LDAB, LDAFB, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      REAL               BERR( * ), FERR( * ), RWORK( * ), S( * )\n      COMPLEX            AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\n*  compute the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite band matrix and X\n*  and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U**H * U,  if UPLO = \'U\', or\n*        A = L * L**H,  if UPLO = \'L\',\n*     where U is an upper triangular band matrix, and L is a lower\n*     triangular band matrix.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFB contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  AB and AFB will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AFB and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFB and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KD      (input) INTEGER\n*          The number of superdiagonals of the matrix A if UPLO = \'U\',\n*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right-hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AB      (input/output) COMPLEX array, dimension (LDAB,N)\n*          On entry, the upper or lower triangle of the Hermitian band\n*          matrix A, stored in the first KD+1 rows of the array, except\n*          if FACT = \'F\' and EQUED = \'Y\', then A must contain the\n*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A\n*          is stored in the j-th column of the array AB as follows:\n*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n*          See below for further details.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array A.  LDAB >= KD+1.\n*\n*  AFB     (input or output) COMPLEX array, dimension (LDAFB,N)\n*          If FACT = \'F\', then AFB is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the band matrix\n*          A, in the same storage format as A (see AB).  If EQUED = \'Y\',\n*          then AFB is the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFB is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H.\n*\n*          If FACT = \'E\', then AFB is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the equilibrated\n*          matrix A (see the description of A for the form of the\n*          equilibrated matrix).\n*\n*  LDAFB   (input) INTEGER\n*          The leading dimension of the array AFB.  LDAFB >= KD+1.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) REAL array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX array, dimension (2*N)\n*\n*  RWORK   (workspace) REAL array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  N = 6, KD = 2, and UPLO = \'U\':\n*\n*  Two-dimensional storage of the Hermitian matrix A:\n*\n*     a11  a12  a13\n*          a22  a23  a24\n*               a33  a34  a35\n*                    a44  a45  a46\n*                         a55  a56\n*     (aij=conjg(aji))         a66\n*\n*  Band storage of the upper triangle of A:\n*\n*      *    *   a13  a24  a35  a46\n*      *   a12  a23  a34  a45  a56\n*     a11  a22  a33  a44  a55  a66\n*\n*  Similarly, if UPLO = \'L\' the format of A is as follows:\n*\n*     a11  a22  a33  a44  a55  a66\n*     a21  a32  a43  a54  a65   *\n*     a31  a42  a53  a64   *    *\n*\n*  Array elements marked * are not used by the routine.\n*\n'),(144,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZPBSVX( FACT, UPLO, N, KD, NRHS, AB, LDAB, AFB, LDAFB,\n     $                   EQUED, S, B, LDB, X, LDX, RCOND, FERR, BERR,\n     $                   WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, KD, LDAB, LDAFB, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * ), S( * )\n      COMPLEX*16         AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\n*  compute the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite band matrix and X\n*  and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U**H * U,  if UPLO = \'U\', or\n*        A = L * L**H,  if UPLO = \'L\',\n*     where U is an upper triangular band matrix, and L is a lower\n*     triangular band matrix.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFB contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  AB and AFB will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AFB and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFB and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  KD      (input) INTEGER\n*          The number of superdiagonals of the matrix A if UPLO = \'U\',\n*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right-hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)\n*          On entry, the upper or lower triangle of the Hermitian band\n*          matrix A, stored in the first KD+1 rows of the array, except\n*          if FACT = \'F\' and EQUED = \'Y\', then A must contain the\n*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A\n*          is stored in the j-th column of the array AB as follows:\n*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n*          See below for further details.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  LDAB    (input) INTEGER\n*          The leading dimension of the array A.  LDAB >= KD+1.\n*\n*  AFB     (input or output) COMPLEX*16 array, dimension (LDAFB,N)\n*          If FACT = \'F\', then AFB is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the band matrix\n*          A, in the same storage format as A (see AB).  If EQUED = \'Y\',\n*          then AFB is the factored form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFB is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H.\n*\n*          If FACT = \'E\', then AFB is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the equilibrated\n*          matrix A (see the description of A for the form of the\n*          equilibrated matrix).\n*\n*  LDAFB   (input) INTEGER\n*          The leading dimension of the array AFB.  LDAFB >= KD+1.\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)\n*\n*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The band storage scheme is illustrated by the following example, when\n*  N = 6, KD = 2, and UPLO = \'U\':\n*\n*  Two-dimensional storage of the Hermitian matrix A:\n*\n*     a11  a12  a13\n*          a22  a23  a24\n*               a33  a34  a35\n*                    a44  a45  a46\n*                         a55  a56\n*     (aij=conjg(aji))         a66\n*\n*  Band storage of the upper triangle of A:\n*\n*      *    *   a13  a24  a35  a46\n*      *   a12  a23  a34  a45  a56\n*     a11  a22  a33  a44  a55  a66\n*\n*  Similarly, if UPLO = \'L\' the format of A is as follows:\n*\n*     a11  a22  a33  a44  a55  a66\n*     a21  a32  a43  a54  a65   *\n*     a31  a42  a53  a64   *    *\n*\n*  Array elements marked * are not used by the routine.\n*\n'),(145,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SPPSVX( FACT, UPLO, N, NRHS, AP, AFP, EQUED, S, B, LDB,\n     $                   X, LDX, RCOND, FERR, BERR, WORK, IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IWORK( * )\n      REAL               AFP( * ), AP( * ), B( LDB, * ), BERR( * ),\n     $                   FERR( * ), S( * ), WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\n*  compute the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite matrix stored in\n*  packed format and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U**T* U,  if UPLO = \'U\', or\n*        A = L * L**T,  if UPLO = \'L\',\n*     where U is an upper triangular matrix and L is a lower triangular\n*     matrix.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFP contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  AP and AFP will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AFP and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFP and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AP      (input/output) REAL array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the symmetric matrix\n*          A, packed columnwise in a linear array, except if FACT = \'F\'\n*          and EQUED = \'Y\', then A must contain the equilibrated matrix\n*          diag(S)*A*diag(S).  The j-th column of A is stored in the\n*          array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.  A is not modified if\n*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  AFP     (input or output) REAL array, dimension\n*                            (N*(N+1)/2)\n*          If FACT = \'F\', then AFP is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U\'*U or A = L*L\', in the same storage\n*          format as A.  If EQUED .ne. \'N\', then AFP is the factored\n*          form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFP is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U\'*U or A = L*L\' of the original matrix A.\n*\n*          If FACT = \'E\', then AFP is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U\'*U or A = L*L\' of the equilibrated\n*          matrix A (see the description of AP for the form of the\n*          equilibrated matrix).\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) REAL array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) REAL array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) REAL array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) REAL array, dimension (3*N)\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(146,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DPPSVX( FACT, UPLO, N, NRHS, AP, AFP, EQUED, S, B, LDB,\n     $                   X, LDX, RCOND, FERR, BERR, WORK, IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IWORK( * )\n      DOUBLE PRECISION   AFP( * ), AP( * ), B( LDB, * ), BERR( * ),\n     $                   FERR( * ), S( * ), WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\n*  compute the solution to a real system of linear equations\n*     A * X = B,\n*  where A is an N-by-N symmetric positive definite matrix stored in\n*  packed format and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U**T* U,  if UPLO = \'U\', or\n*        A = L * L**T,  if UPLO = \'L\',\n*     where U is an upper triangular matrix and L is a lower triangular\n*     matrix.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFP contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  AP and AFP will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AFP and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFP and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the symmetric matrix\n*          A, packed columnwise in a linear array, except if FACT = \'F\'\n*          and EQUED = \'Y\', then A must contain the equilibrated matrix\n*          diag(S)*A*diag(S).  The j-th column of A is stored in the\n*          array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.  A is not modified if\n*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  AFP     (input or output) DOUBLE PRECISION array, dimension\n*                            (N*(N+1)/2)\n*          If FACT = \'F\', then AFP is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U\'*U or A = L*L\', in the same storage\n*          format as A.  If EQUED .ne. \'N\', then AFP is the factored\n*          form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFP is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U\'*U or A = L*L\' of the original matrix A.\n*\n*          If FACT = \'E\', then AFP is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U\'*U or A = L*L\' of the equilibrated\n*          matrix A (see the description of AP for the form of the\n*          equilibrated matrix).\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(147,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CPPSVX( FACT, UPLO, N, NRHS, AP, AFP, EQUED, S, B, LDB,\n     $                   X, LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      REAL               BERR( * ), FERR( * ), RWORK( * ), S( * )\n      COMPLEX            AFP( * ), AP( * ), B( LDB, * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\n*  compute the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite matrix stored in\n*  packed format and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U\'* U ,  if UPLO = \'U\', or\n*        A = L * L\',  if UPLO = \'L\',\n*     where U is an upper triangular matrix, L is a lower triangular\n*     matrix, and \' indicates conjugate transpose.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFP contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  AP and AFP will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AFP and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFP and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the Hermitian matrix\n*          A, packed columnwise in a linear array, except if FACT = \'F\'\n*          and EQUED = \'Y\', then A must contain the equilibrated matrix\n*          diag(S)*A*diag(S).  The j-th column of A is stored in the\n*          array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.  A is not modified if\n*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  AFP     (input or output) COMPLEX array, dimension (N*(N+1)/2)\n*          If FACT = \'F\', then AFP is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H, in the same storage\n*          format as A.  If EQUED .ne. \'N\', then AFP is the factored\n*          form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFP is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the original\n*          matrix A.\n*\n*          If FACT = \'E\', then AFP is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the equilibrated\n*          matrix A (see the description of AP for the form of the\n*          equilibrated matrix).\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) REAL array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX array, dimension (2*N)\n*\n*  RWORK   (workspace) REAL array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the Hermitian matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(148,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZPPSVX( FACT, UPLO, N, NRHS, AP, AFP, EQUED, S, B, LDB,\n     $                   X, LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          EQUED, FACT, UPLO\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * ), S( * )\n      COMPLEX*16         AFP( * ), AP( * ), B( LDB, * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\n*  compute the solution to a complex system of linear equations\n*     A * X = B,\n*  where A is an N-by-N Hermitian positive definite matrix stored in\n*  packed format and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'E\', real scaling factors are computed to equilibrate\n*     the system:\n*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n*     Whether or not the system will be equilibrated depends on the\n*     scaling of the matrix A, but if equilibration is used, A is\n*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n*\n*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n*     factor the matrix A (after equilibration if FACT = \'E\') as\n*        A = U\'* U ,  if UPLO = \'U\', or\n*        A = L * L\',  if UPLO = \'L\',\n*     where U is an upper triangular matrix, L is a lower triangular\n*     matrix, and \' indicates conjugate transpose.\n*\n*  3. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  4. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  5. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  6. If equilibration was used, the matrix X is premultiplied by\n*     diag(S) so that it solves the original system before\n*     equilibration.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix A is\n*          supplied on entry, and if not, whether the matrix A should be\n*          equilibrated before it is factored.\n*          = \'F\':  On entry, AFP contains the factored form of A.\n*                  If EQUED = \'Y\', the matrix A has been equilibrated\n*                  with scaling factors given by S.  AP and AFP will not\n*                  be modified.\n*          = \'N\':  The matrix A will be copied to AFP and factored.\n*          = \'E\':  The matrix A will be equilibrated if necessary, then\n*                  copied to AFP and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)\n*          On entry, the upper or lower triangle of the Hermitian matrix\n*          A, packed columnwise in a linear array, except if FACT = \'F\'\n*          and EQUED = \'Y\', then A must contain the equilibrated matrix\n*          diag(S)*A*diag(S).  The j-th column of A is stored in the\n*          array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.  A is not modified if\n*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n*\n*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n*          diag(S)*A*diag(S).\n*\n*  AFP     (input or output) COMPLEX*16 array, dimension (N*(N+1)/2)\n*          If FACT = \'F\', then AFP is an input argument and on entry\n*          contains the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H, in the same storage\n*          format as A.  If EQUED .ne. \'N\', then AFP is the factored\n*          form of the equilibrated matrix A.\n*\n*          If FACT = \'N\', then AFP is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the original\n*          matrix A.\n*\n*          If FACT = \'E\', then AFP is an output argument and on exit\n*          returns the triangular factor U or L from the Cholesky\n*          factorization A = U**H*U or A = L*L**H of the equilibrated\n*          matrix A (see the description of AP for the form of the\n*          equilibrated matrix).\n*\n*  EQUED   (input or output) CHARACTER*1\n*          Specifies the form of equilibration that was done.\n*          = \'N\':  No equilibration (always true if FACT = \'N\').\n*          = \'Y\':  Equilibration was done, i.e., A has been replaced by\n*                  diag(S) * A * diag(S).\n*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n*          output argument.\n*\n*  S       (input or output) DOUBLE PRECISION array, dimension (N)\n*          The scale factors for A; not accessed if EQUED = \'N\'.  S is\n*          an input argument if FACT = \'F\'; otherwise, S is an output\n*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n*          must be positive.\n*\n*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)\n*          On entry, the N-by-NRHS right hand side matrix B.\n*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n*          B is overwritten by diag(S) * B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n*          the original system of equations.  Note that if EQUED = \'Y\',\n*          A and B are modified on exit, and the solution to the\n*          equilibrated system is inv(diag(S))*X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A after equilibration (if done).  If RCOND is less than the\n*          machine precision (in particular, if RCOND = 0), the matrix\n*          is singular to working precision.  This condition is\n*          indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)\n*\n*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the Hermitian matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = conjg(aji))\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(149,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SPTSVX( FACT, N, NRHS, D, E, DF, EF, B, LDB, X, LDX,\n     $                   RCOND, FERR, BERR, WORK, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      REAL               B( LDB, * ), BERR( * ), D( * ), DF( * ),\n     $                   E( * ), EF( * ), FERR( * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SPTSVX uses the factorization A = L*D*L**T to compute the solution\n*  to a real system of linear equations A*X = B, where A is an N-by-N\n*  symmetric positive definite tridiagonal matrix and X and B are\n*  N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the matrix A is factored as A = L*D*L**T, where L\n*     is a unit lower bidiagonal matrix and D is diagonal.  The\n*     factorization can also be regarded as having the form\n*     A = U**T*D*U.\n*\n*  2. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, DF and EF contain the factored form of A.\n*                  D, E, DF, and EF will not be modified.\n*          = \'N\':  The matrix A will be copied to DF and EF and\n*                  factored.\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  D       (input) REAL array, dimension (N)\n*          The n diagonal elements of the tridiagonal matrix A.\n*\n*  E       (input) REAL array, dimension (N-1)\n*          The (n-1) subdiagonal elements of the tridiagonal matrix A.\n*\n*  DF      (input or output) REAL array, dimension (N)\n*          If FACT = \'F\', then DF is an input argument and on entry\n*          contains the n diagonal elements of the diagonal matrix D\n*          from the L*D*L**T factorization of A.\n*          If FACT = \'N\', then DF is an output argument and on exit\n*          contains the n diagonal elements of the diagonal matrix D\n*          from the L*D*L**T factorization of A.\n*\n*  EF      (input or output) REAL array, dimension (N-1)\n*          If FACT = \'F\', then EF is an input argument and on entry\n*          contains the (n-1) subdiagonal elements of the unit\n*          bidiagonal factor L from the L*D*L**T factorization of A.\n*          If FACT = \'N\', then EF is an output argument and on exit\n*          contains the (n-1) subdiagonal elements of the unit\n*          bidiagonal factor L from the L*D*L**T factorization of A.\n*\n*  B       (input) REAL array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) REAL array, dimension (LDX,NRHS)\n*          If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The reciprocal condition number of the matrix A.  If RCOND\n*          is less than the machine precision (in particular, if\n*          RCOND = 0), the matrix is singular to working precision.\n*          This condition is indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in any\n*          element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) REAL array, dimension (2*N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(150,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DPTSVX( FACT, N, NRHS, D, E, DF, EF, B, LDB, X, LDX,\n     $                   RCOND, FERR, BERR, WORK, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   B( LDB, * ), BERR( * ), D( * ), DF( * ),\n     $                   E( * ), EF( * ), FERR( * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DPTSVX uses the factorization A = L*D*L**T to compute the solution\n*  to a real system of linear equations A*X = B, where A is an N-by-N\n*  symmetric positive definite tridiagonal matrix and X and B are\n*  N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the matrix A is factored as A = L*D*L**T, where L\n*     is a unit lower bidiagonal matrix and D is diagonal.  The\n*     factorization can also be regarded as having the form\n*     A = U**T*D*U.\n*\n*  2. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, DF and EF contain the factored form of A.\n*                  D, E, DF, and EF will not be modified.\n*          = \'N\':  The matrix A will be copied to DF and EF and\n*                  factored.\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  D       (input) DOUBLE PRECISION array, dimension (N)\n*          The n diagonal elements of the tridiagonal matrix A.\n*\n*  E       (input) DOUBLE PRECISION array, dimension (N-1)\n*          The (n-1) subdiagonal elements of the tridiagonal matrix A.\n*\n*  DF      (input or output) DOUBLE PRECISION array, dimension (N)\n*          If FACT = \'F\', then DF is an input argument and on entry\n*          contains the n diagonal elements of the diagonal matrix D\n*          from the L*D*L**T factorization of A.\n*          If FACT = \'N\', then DF is an output argument and on exit\n*          contains the n diagonal elements of the diagonal matrix D\n*          from the L*D*L**T factorization of A.\n*\n*  EF      (input or output) DOUBLE PRECISION array, dimension (N-1)\n*          If FACT = \'F\', then EF is an input argument and on entry\n*          contains the (n-1) subdiagonal elements of the unit\n*          bidiagonal factor L from the L*D*L**T factorization of A.\n*          If FACT = \'N\', then EF is an output argument and on exit\n*          contains the (n-1) subdiagonal elements of the unit\n*          bidiagonal factor L from the L*D*L**T factorization of A.\n*\n*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)\n*          If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The reciprocal condition number of the matrix A.  If RCOND\n*          is less than the machine precision (in particular, if\n*          RCOND = 0), the matrix is singular to working precision.\n*          This condition is indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in any\n*          element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(151,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CPTSVX( FACT, N, NRHS, D, E, DF, EF, B, LDB, X, LDX,\n     $                   RCOND, FERR, BERR, WORK, RWORK, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      REAL               BERR( * ), D( * ), DF( * ), FERR( * ),\n     $                   RWORK( * )\n      COMPLEX            B( LDB, * ), E( * ), EF( * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CPTSVX uses the factorization A = L*D*L**H to compute the solution\n*  to a complex system of linear equations A*X = B, where A is an\n*  N-by-N Hermitian positive definite tridiagonal matrix and X and B\n*  are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the matrix A is factored as A = L*D*L**H, where L\n*     is a unit lower bidiagonal matrix and D is diagonal.  The\n*     factorization can also be regarded as having the form\n*     A = U**H*D*U.\n*\n*  2. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix\n*          A is supplied on entry.\n*          = \'F\':  On entry, DF and EF contain the factored form of A.\n*                  D, E, DF, and EF will not be modified.\n*          = \'N\':  The matrix A will be copied to DF and EF and\n*                  factored.\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  D       (input) REAL array, dimension (N)\n*          The n diagonal elements of the tridiagonal matrix A.\n*\n*  E       (input) COMPLEX array, dimension (N-1)\n*          The (n-1) subdiagonal elements of the tridiagonal matrix A.\n*\n*  DF      (input or output) REAL array, dimension (N)\n*          If FACT = \'F\', then DF is an input argument and on entry\n*          contains the n diagonal elements of the diagonal matrix D\n*          from the L*D*L**H factorization of A.\n*          If FACT = \'N\', then DF is an output argument and on exit\n*          contains the n diagonal elements of the diagonal matrix D\n*          from the L*D*L**H factorization of A.\n*\n*  EF      (input or output) COMPLEX array, dimension (N-1)\n*          If FACT = \'F\', then EF is an input argument and on entry\n*          contains the (n-1) subdiagonal elements of the unit\n*          bidiagonal factor L from the L*D*L**H factorization of A.\n*          If FACT = \'N\', then EF is an output argument and on exit\n*          contains the (n-1) subdiagonal elements of the unit\n*          bidiagonal factor L from the L*D*L**H factorization of A.\n*\n*  B       (input) COMPLEX array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The reciprocal condition number of the matrix A.  If RCOND\n*          is less than the machine precision (in particular, if\n*          RCOND = 0), the matrix is singular to working precision.\n*          This condition is indicated by a return code of INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in any\n*          element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX array, dimension (N)\n*\n*  RWORK   (workspace) REAL array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(152,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZPTSVX( FACT, N, NRHS, D, E, DF, EF, B, LDB, X, LDX,\n     $                   RCOND, FERR, BERR, WORK, RWORK, INFO )\n*\n*  -- LAPACK routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      DOUBLE PRECISION   BERR( * ), D( * ), DF( * ), FERR( * ),\n     $                   RWORK( * )\n      COMPLEX*16         B( LDB, * ), E( * ), EF( * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZPTSVX uses the factorization A = L*D*L**H to compute the solution\n*  to a complex system of linear equations A*X = B, where A is an\n*  N-by-N Hermitian positive definite tridiagonal matrix and X and B\n*  are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the matrix A is factored as A = L*D*L**H, where L\n*     is a unit lower bidiagonal matrix and D is diagonal.  The\n*     factorization can also be regarded as having the form\n*     A = U**H*D*U.\n*\n*  2. If the leading i-by-i principal minor is not positive definite,\n*     then the routine returns with INFO = i. Otherwise, the factored\n*     form of A is used to estimate the condition number of the matrix\n*     A.  If the reciprocal of the condition number is less than machine\n*     precision, INFO = N+1 is returned as a warning, but the routine\n*     still goes on to solve for X and compute error bounds as\n*     described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of the matrix\n*          A is supplied on entry.\n*          = \'F\':  On entry, DF and EF contain the factored form of A.\n*                  D, E, DF, and EF will not be modified.\n*          = \'N\':  The matrix A will be copied to DF and EF and\n*                  factored.\n*\n*  N       (input) INTEGER\n*          The order of the matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  D       (input) DOUBLE PRECISION array, dimension (N)\n*          The n diagonal elements of the tridiagonal matrix A.\n*\n*  E       (input) COMPLEX*16 array, dimension (N-1)\n*          The (n-1) subdiagonal elements of the tridiagonal matrix A.\n*\n*  DF      (input or output) DOUBLE PRECISION array, dimension (N)\n*          If FACT = \'F\', then DF is an input argument and on entry\n*          contains the n diagonal elements of the diagonal matrix D\n*          from the L*D*L**H factorization of A.\n*          If FACT = \'N\', then DF is an output argument and on exit\n*          contains the n diagonal elements of the diagonal matrix D\n*          from the L*D*L**H factorization of A.\n*\n*  EF      (input or output) COMPLEX*16 array, dimension (N-1)\n*          If FACT = \'F\', then EF is an input argument and on entry\n*          contains the (n-1) subdiagonal elements of the unit\n*          bidiagonal factor L from the L*D*L**H factorization of A.\n*          If FACT = \'N\', then EF is an output argument and on exit\n*          contains the (n-1) subdiagonal elements of the unit\n*          bidiagonal factor L from the L*D*L**H factorization of A.\n*\n*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The reciprocal condition number of the matrix A.  If RCOND\n*          is less than the machine precision (in particular, if\n*          RCOND = 0), the matrix is singular to working precision.\n*          This condition is indicated by a return code of INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in any\n*          element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX*16 array, dimension (N)\n*\n*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0:  successful exit\n*          < 0:  if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  the leading minor of order i of A is\n*                       not positive definite, so the factorization\n*                       could not be completed, and the solution has not\n*                       been computed. RCOND = 0 is returned.\n*                = N+1: U is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(153,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SSYSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,\n     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,\n     $                   IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * ), IWORK( * )\n      REAL               A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   BERR( * ), FERR( * ), WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SSYSVX uses the diagonal pivoting factorization to compute the\n*  solution to a real system of linear equations A * X = B,\n*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n*     The form of the factorization is\n*        A = U * D * U**T,  if UPLO = \'U\', or\n*        A = L * D * L**T,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices, and D is symmetric and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AF and IPIV contain the factored form of\n*                  A.  AF and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input) REAL array, dimension (LDA,N)\n*          The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n*          upper triangular part of A contains the upper triangular part\n*          of the matrix A, and the strictly lower triangular part of A\n*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n*          triangular part of A contains the lower triangular part of\n*          the matrix A, and the strictly upper triangular part of A is\n*          not referenced.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) REAL array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by SSYTRF.\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T.\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by SSYTRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by SSYTRF.\n*\n*  B       (input) REAL array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) REAL array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= max(1,3*N), and for best\n*          performance, when FACT = \'N\', LWORK >= max(1,3*N,N*NB), where\n*          NB is the optimal blocksize for SSYTRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(154,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DSYSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,\n     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,\n     $                   IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * ), IWORK( * )\n      DOUBLE PRECISION   A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   BERR( * ), FERR( * ), WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DSYSVX uses the diagonal pivoting factorization to compute the\n*  solution to a real system of linear equations A * X = B,\n*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n*     The form of the factorization is\n*        A = U * D * U**T,  if UPLO = \'U\', or\n*        A = L * D * L**T,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices, and D is symmetric and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AF and IPIV contain the factored form of\n*                  A.  AF and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)\n*          The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n*          upper triangular part of A contains the upper triangular part\n*          of the matrix A, and the strictly lower triangular part of A\n*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n*          triangular part of A contains the lower triangular part of\n*          the matrix A, and the strictly upper triangular part of A is\n*          not referenced.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by DSYTRF.\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T.\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by DSYTRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by DSYTRF.\n*\n*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= max(1,3*N), and for best\n*          performance, when FACT = \'N\', LWORK >= max(1,3*N,N*NB), where\n*          NB is the optimal blocksize for DSYTRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(155,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CSYSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,\n     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,\n     $                   RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               BERR( * ), FERR( * ), RWORK( * )\n      COMPLEX            A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CSYSVX uses the diagonal pivoting factorization to compute the\n*  solution to a complex system of linear equations A * X = B,\n*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n*     The form of the factorization is\n*        A = U * D * U**T,  if UPLO = \'U\', or\n*        A = L * D * L**T,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices, and D is symmetric and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AF and IPIV contain the factored form\n*                  of A.  A, AF and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input) COMPLEX array, dimension (LDA,N)\n*          The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n*          upper triangular part of A contains the upper triangular part\n*          of the matrix A, and the strictly lower triangular part of A\n*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n*          triangular part of A contains the lower triangular part of\n*          the matrix A, and the strictly upper triangular part of A is\n*          not referenced.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) COMPLEX array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by CSYTRF.\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T.\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by CSYTRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by CSYTRF.\n*\n*  B       (input) COMPLEX array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= max(1,2*N), and for best\n*          performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where\n*          NB is the optimal blocksize for CSYTRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  RWORK   (workspace) REAL array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(156,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZSYSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,\n     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,\n     $                   RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * )\n      COMPLEX*16         A( LDA, * ), AF( LDAF, * ), B( LDB, * ),\n     $                   WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZSYSVX uses the diagonal pivoting factorization to compute the\n*  solution to a complex system of linear equations A * X = B,\n*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n*  matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n*     The form of the factorization is\n*        A = U * D * U**T,  if UPLO = \'U\', or\n*        A = L * D * L**T,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices, and D is symmetric and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AF and IPIV contain the factored form\n*                  of A.  A, AF and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AF and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  A       (input) COMPLEX*16 array, dimension (LDA,N)\n*          The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n*          upper triangular part of A contains the upper triangular part\n*          of the matrix A, and the strictly lower triangular part of A\n*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n*          triangular part of A contains the lower triangular part of\n*          the matrix A, and the strictly upper triangular part of A is\n*          not referenced.\n*\n*  LDA     (input) INTEGER\n*          The leading dimension of the array A.  LDA >= max(1,N).\n*\n*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)\n*          If FACT = \'F\', then AF is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by ZSYTRF.\n*\n*          If FACT = \'N\', then AF is an output argument and on exit\n*          returns the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T.\n*\n*  LDAF    (input) INTEGER\n*          The leading dimension of the array AF.  LDAF >= max(1,N).\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by ZSYTRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by ZSYTRF.\n*\n*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))\n*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n*\n*  LWORK   (input) INTEGER\n*          The length of WORK.  LWORK >= max(1,2*N), and for best\n*          performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where\n*          NB is the optimal blocksize for ZSYTRF.\n*\n*          If LWORK = -1, then a workspace query is assumed; the routine\n*          only calculates the optimal size of the WORK array, returns\n*          this value as the first entry of the WORK array, and no error\n*          message related to LWORK is issued by XERBLA.\n*\n*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0: if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n'),(157,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE SSPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,\n     $                   LDX, RCOND, FERR, BERR, WORK, IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * ), IWORK( * )\n      REAL               AFP( * ), AP( * ), B( LDB, * ), BERR( * ),\n     $                   FERR( * ), WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  SSPSVX uses the diagonal pivoting factorization A = U*D*U**T or\n*  A = L*D*L**T to compute the solution to a real system of linear\n*  equations A * X = B, where A is an N-by-N symmetric matrix stored\n*  in packed format and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n*        A = U * D * U**T,  if UPLO = \'U\', or\n*        A = L * D * L**T,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices and D is symmetric and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AFP and IPIV contain the factored form of\n*                  A.  AP, AFP and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AFP and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AP      (input) REAL array, dimension (N*(N+1)/2)\n*          The upper or lower triangle of the symmetric matrix A, packed\n*          columnwise in a linear array.  The j-th column of A is stored\n*          in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*  AFP     (input or output) REAL array, dimension\n*                            (N*(N+1)/2)\n*          If FACT = \'F\', then AFP is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*          If FACT = \'N\', then AFP is an output argument and on exit\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by SSPTRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by SSPTRF.\n*\n*  B       (input) REAL array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) REAL array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) REAL array, dimension (3*N)\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = aji)\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(158,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE DSPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,\n     $                   LDX, RCOND, FERR, BERR, WORK, IWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * ), IWORK( * )\n      DOUBLE PRECISION   AFP( * ), AP( * ), B( LDB, * ), BERR( * ),\n     $                   FERR( * ), WORK( * ), X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or\n*  A = L*D*L**T to compute the solution to a real system of linear\n*  equations A * X = B, where A is an N-by-N symmetric matrix stored\n*  in packed format and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n*        A = U * D * U**T,  if UPLO = \'U\', or\n*        A = L * D * L**T,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices and D is symmetric and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AFP and IPIV contain the factored form of\n*                  A.  AP, AFP and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AFP and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)\n*          The upper or lower triangle of the symmetric matrix A, packed\n*          columnwise in a linear array.  The j-th column of A is stored\n*          in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*  AFP     (input or output) DOUBLE PRECISION array, dimension\n*                            (N*(N+1)/2)\n*          If FACT = \'F\', then AFP is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*          If FACT = \'N\', then AFP is an output argument and on exit\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by DSPTRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by DSPTRF.\n*\n*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)\n*\n*  IWORK   (workspace) INTEGER array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = aji)\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(159,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE CSPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,\n     $                   LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      REAL               RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      REAL               BERR( * ), FERR( * ), RWORK( * )\n      COMPLEX            AFP( * ), AP( * ), B( LDB, * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  CSPSVX uses the diagonal pivoting factorization A = U*D*U**T or\n*  A = L*D*L**T to compute the solution to a complex system of linear\n*  equations A * X = B, where A is an N-by-N symmetric matrix stored\n*  in packed format and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n*        A = U * D * U**T,  if UPLO = \'U\', or\n*        A = L * D * L**T,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices and D is symmetric and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AFP and IPIV contain the factored form\n*                  of A.  AP, AFP and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AFP and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)\n*          The upper or lower triangle of the symmetric matrix A, packed\n*          columnwise in a linear array.  The j-th column of A is stored\n*          in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*  AFP     (input or output) COMPLEX array, dimension (N*(N+1)/2)\n*          If FACT = \'F\', then AFP is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*          If FACT = \'N\', then AFP is an output argument and on exit\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by CSPTRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by CSPTRF.\n*\n*  B       (input) COMPLEX array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) REAL\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) REAL array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) REAL array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX array, dimension (2*N)\n*\n*  RWORK   (workspace) REAL array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = aji)\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n'),(160,NULL,'','',NULL,NULL,0,NULL,'      SUBROUTINE ZSPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,\n     $                   LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )\n*\n*  -- LAPACK driver routine (version 3.2) --\n*  -- LAPACK is a software package provided by Univ. of Tennessee,    --\n*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--\n*     November 2006\n*\n*     .. Scalar Arguments ..\n      CHARACTER          FACT, UPLO\n      INTEGER            INFO, LDB, LDX, N, NRHS\n      DOUBLE PRECISION   RCOND\n*     ..\n*     .. Array Arguments ..\n      INTEGER            IPIV( * )\n      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * )\n      COMPLEX*16         AFP( * ), AP( * ), B( LDB, * ), WORK( * ),\n     $                   X( LDX, * )\n*     ..\n*\n*  Purpose\n*  =======\n*\n*  ZSPSVX uses the diagonal pivoting factorization A = U*D*U**T or\n*  A = L*D*L**T to compute the solution to a complex system of linear\n*  equations A * X = B, where A is an N-by-N symmetric matrix stored\n*  in packed format and X and B are N-by-NRHS matrices.\n*\n*  Error bounds on the solution and a condition estimate are also\n*  provided.\n*\n*  Description\n*  ===========\n*\n*  The following steps are performed:\n*\n*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n*        A = U * D * U**T,  if UPLO = \'U\', or\n*        A = L * D * L**T,  if UPLO = \'L\',\n*     where U (or L) is a product of permutation and unit upper (lower)\n*     triangular matrices and D is symmetric and block diagonal with\n*     1-by-1 and 2-by-2 diagonal blocks.\n*\n*  2. If some D(i,i)=0, so that D is exactly singular, then the routine\n*     returns with INFO = i. Otherwise, the factored form of A is used\n*     to estimate the condition number of the matrix A.  If the\n*     reciprocal of the condition number is less than machine precision,\n*     INFO = N+1 is returned as a warning, but the routine still goes on\n*     to solve for X and compute error bounds as described below.\n*\n*  3. The system of equations is solved for X using the factored form\n*     of A.\n*\n*  4. Iterative refinement is applied to improve the computed solution\n*     matrix and calculate error bounds and backward error estimates\n*     for it.\n*\n*  Arguments\n*  =========\n*\n*  FACT    (input) CHARACTER*1\n*          Specifies whether or not the factored form of A has been\n*          supplied on entry.\n*          = \'F\':  On entry, AFP and IPIV contain the factored form\n*                  of A.  AP, AFP and IPIV will not be modified.\n*          = \'N\':  The matrix A will be copied to AFP and factored.\n*\n*  UPLO    (input) CHARACTER*1\n*          = \'U\':  Upper triangle of A is stored;\n*          = \'L\':  Lower triangle of A is stored.\n*\n*  N       (input) INTEGER\n*          The number of linear equations, i.e., the order of the\n*          matrix A.  N >= 0.\n*\n*  NRHS    (input) INTEGER\n*          The number of right hand sides, i.e., the number of columns\n*          of the matrices B and X.  NRHS >= 0.\n*\n*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)\n*          The upper or lower triangle of the symmetric matrix A, packed\n*          columnwise in a linear array.  The j-th column of A is stored\n*          in the array AP as follows:\n*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n*          See below for further details.\n*\n*  AFP     (input or output) COMPLEX*16 array, dimension (N*(N+1)/2)\n*          If FACT = \'F\', then AFP is an input argument and on entry\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*          If FACT = \'N\', then AFP is an output argument and on exit\n*          contains the block diagonal matrix D and the multipliers used\n*          to obtain the factor U or L from the factorization\n*          A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as\n*          a packed triangular matrix in the same storage format as A.\n*\n*  IPIV    (input or output) INTEGER array, dimension (N)\n*          If FACT = \'F\', then IPIV is an input argument and on entry\n*          contains details of the interchanges and the block structure\n*          of D, as determined by ZSPTRF.\n*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n*          interchanged and D(k,k) is a 1-by-1 diagonal block.\n*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n*\n*          If FACT = \'N\', then IPIV is an output argument and on exit\n*          contains details of the interchanges and the block structure\n*          of D, as determined by ZSPTRF.\n*\n*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)\n*          The N-by-NRHS right hand side matrix B.\n*\n*  LDB     (input) INTEGER\n*          The leading dimension of the array B.  LDB >= max(1,N).\n*\n*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)\n*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n*\n*  LDX     (input) INTEGER\n*          The leading dimension of the array X.  LDX >= max(1,N).\n*\n*  RCOND   (output) DOUBLE PRECISION\n*          The estimate of the reciprocal condition number of the matrix\n*          A.  If RCOND is less than the machine precision (in\n*          particular, if RCOND = 0), the matrix is singular to working\n*          precision.  This condition is indicated by a return code of\n*          INFO > 0.\n*\n*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The estimated forward error bound for each solution vector\n*          X(j) (the j-th column of the solution matrix X).\n*          If XTRUE is the true solution corresponding to X(j), FERR(j)\n*          is an estimated upper bound for the magnitude of the largest\n*          element in (X(j) - XTRUE) divided by the magnitude of the\n*          largest element in X(j).  The estimate is as reliable as\n*          the estimate for RCOND, and is almost always a slight\n*          overestimate of the true error.\n*\n*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)\n*          The componentwise relative backward error of each solution\n*          vector X(j) (i.e., the smallest relative change in\n*          any element of A or B that makes X(j) an exact solution).\n*\n*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)\n*\n*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)\n*\n*  INFO    (output) INTEGER\n*          = 0: successful exit\n*          < 0: if INFO = -i, the i-th argument had an illegal value\n*          > 0:  if INFO = i, and i is\n*                <= N:  D(i,i) is exactly zero.  The factorization\n*                       has been completed but the factor D is exactly\n*                       singular, so the solution and error bounds could\n*                       not be computed. RCOND = 0 is returned.\n*                = N+1: D is nonsingular, but RCOND is less than machine\n*                       precision, meaning that the matrix is singular\n*                       to working precision.  Nevertheless, the\n*                       solution and error bounds are computed because\n*                       there are a number of situations where the\n*                       computed solution can be more accurate than the\n*                       value of RCOND would suggest.\n*\n*  Further Details\n*  ===============\n*\n*  The packed storage scheme is illustrated by the following example\n*  when N = 4, UPLO = \'U\':\n*\n*  Two-dimensional storage of the symmetric matrix A:\n*\n*     a11 a12 a13 a14\n*         a22 a23 a24\n*             a33 a34     (aij = aji)\n*                 a44\n*\n*  Packed storage of the upper triangle of A:\n*\n*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]\n*\n');
/*!40000 ALTER TABLE `Linear_Equation` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Linear_Least_Squares`
--

DROP TABLE IF EXISTS `Linear_Least_Squares`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Linear_Least_Squares` (
  `id_lls` smallint(5) unsigned NOT NULL auto_increment,
  `thePrecision` enum('s','d','c','z') default NULL,
  `routineName` varchar(6) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `structureType` enum('f','b','p','t','g') default NULL,
  `url` varchar(20) default NULL,
  `problem` smallint(5) unsigned NOT NULL,
  `description` varchar(255) default NULL,
  PRIMARY KEY  (`id_lls`),
  FULLTEXT KEY `routineName` (`routineName`,`matrixType`,`url`,`description`)
) ENGINE=MyISAM AUTO_INCREMENT=25 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Linear_Least_Squares`
--

LOCK TABLES `Linear_Least_Squares` WRITE;
/*!40000 ALTER TABLE `Linear_Least_Squares` DISABLE KEYS */;
INSERT INTO `Linear_Least_Squares` VALUES (1,'s','gels','general','f','single/sgels.f',2,'linear least squares, using QR or LQ Factorization'),(2,'d','gels','general','f','double/dgels.f',2,'linear least squares, using QR or LQ Factorization'),(3,'c','gels','general','f','complex/cgels.f',2,'linear least squares, using QR or LQ Factorization'),(4,'z','gels','general','f','complex16/zgels.f',2,'linear least squares, using QR or LQ Factorization'),(5,'s','gelsy','general','f','single/sgelsy.f',2,'linear least squares, using complete orthogonal factorization'),(6,'d','gelsy','general','f','double/dgelsy.f',2,'linear least squares, using complete orthogonal factorization'),(7,'c','gelsy','general','f','complex/cgelsy.f',2,'linear least squares, using complete orthogonal factorization'),(8,'z','gelsy','general','f','complex16/zgelsy.f',2,'linear least squares, using complete orthogonal factorization'),(9,'s','gelsd','general','f','single/sgelsd.f',2,'linear least squares, using SVD via Divide and Conquer'),(10,'d','gelsd','general','f','double/dgelsd.f',2,'linear least squares, using SVD via Divide and Conquer'),(11,'c','gelsd','general','f','complex/cgelsd.f',2,'linear least squares, using SVD via Divide and Conquer'),(12,'z','gelsd','general','f','complex16/zgelsd.f',2,'linear least squares, using SVD via Divide and Conquer'),(13,'s','gelss','general','f','single/sgelss.f',2,'linear least squares, using SVD via QR'),(14,'d','gelss','general','f','double/dgelss.f',2,'linear least squares, using SVD via QR'),(15,'c','gelss','general','f','complex/cgelss.f',2,'linear least squares, using SVD via QR'),(16,'z','gelss','general','f','complex16/zgelss.f',2,'linear least squares, using SVD via QR'),(17,'s','gglse','general','f','single/sgglse.f',3,'Generalized Linear Least Squares Driver Routines, linear equality-constrained least squares (LSE), using GRQ'),(18,'d','gglse','general','f','double/dgglse.f',3,'Generalized Linear Least Squares Driver Routines, linear equality-constrained least squares (LSE), using GRQ'),(19,'c','gglse','general','f','complex/cgglse.f',3,'Generalized Linear Least Squares Driver Routines, linear equality-constrained least squares (LSE), using GRQ'),(20,'z','gglse','general','f','complex16/zgglse.f',3,'Generalized Linear Least Squares Driver Routines, linear equality-constrained least squares (LSE), using GRQ'),(21,'s','ggglm','general','f','single/sggglm.f',4,'Generalized Linear Least Squares Driver Routines, Gauss-Markov linear model (GLM), using GRQ'),(22,'d','ggglm','general','f','double/dggglm.f',4,'Generalized Linear Least Squares Driver Routines, Gauss-Markov linear model (GLM), using GRQ'),(23,'c','ggglm','general','f','complex/cggglm.f',4,'Generalized Linear Least Squares Driver Routines, Gauss-Markov linear model (GLM), using GRQ'),(24,'z','ggglm','general','f','complex16/zggglm.f',4,'Generalized Linear Least Squares Driver Routines, Gauss-Markov linear model (GLM), using GRQ');
/*!40000 ALTER TABLE `Linear_Least_Squares` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Problem`
--

DROP TABLE IF EXISTS `Problem`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Problem` (
  `id_p` smallint(5) unsigned NOT NULL auto_increment,
  `problem` varchar(100) default NULL,
  PRIMARY KEY  (`id_p`)
) ENGINE=MyISAM AUTO_INCREMENT=10 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Problem`
--

LOCK TABLES `Problem` WRITE;
/*!40000 ALTER TABLE `Problem` DISABLE KEYS */;
INSERT INTO `Problem` VALUES (1,'solve Ax=b'),(2,'Minimize ||b-Ax||2'),(3,'Minimize ||c-Ax||2 subject to Bx=d'),(4,'Minimize ||y||2 subject to d=Ax+By'),(5,'Solve Ax=(lambda)x'),(6,'Solve Ax=(lambda)Mx'),(7,'Schur factorization'),(8,'Generalized Schur factorization'),(9,'singular value decomposition(SVD)');
/*!40000 ALTER TABLE `Problem` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `RoutineInfo`
--

DROP TABLE IF EXISTS `RoutineInfo`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `RoutineInfo` (
  `info` longtext,
  `url` longtext
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `RoutineInfo`
--

LOCK TABLES `RoutineInfo` WRITE;
/*!40000 ALTER TABLE `RoutineInfo` DISABLE KEYS */;
INSERT INTO `RoutineInfo` VALUES ('      SUBROUTINE CGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  -- LAPACK driver routine (version 3.2) --','complex/cgbsv.f'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --','complex/cgbsv.f'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--','complex/cgbsv.f'),('*     November 2006','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*     .. Scalar Arguments ..','complex/cgbsv.f'),('      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS','complex/cgbsv.f'),('*     ..','complex/cgbsv.f'),('*     .. Array Arguments ..','complex/cgbsv.f'),('      INTEGER            IPIV( * )','complex/cgbsv.f'),('      COMPLEX            AB( LDAB, * ), B( LDB, * )','complex/cgbsv.f'),('*     ..','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  Purpose','complex/cgbsv.f'),('*  =======','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  CGBSV computes the solution to a complex system of linear equations','complex/cgbsv.f'),('*  A * X = B, where A is a band matrix of order N with KL subdiagonals','complex/cgbsv.f'),('*  and KU superdiagonals, and X and B are N-by-NRHS matrices.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  The LU decomposition with partial pivoting and row interchanges is','complex/cgbsv.f'),('*  used to factor A as A = L * U, where L is a product of permutation','complex/cgbsv.f'),('*  and unit lower triangular matrices with KL subdiagonals, and U is','complex/cgbsv.f'),('*  upper triangular with KL+KU superdiagonals.  The factored form of A','complex/cgbsv.f'),('*  is then used to solve the system of equations A * X = B.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  Arguments','complex/cgbsv.f'),('*  =========','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  N       (input) INTEGER','complex/cgbsv.f'),('*          The number of linear equations, i.e., the order of the','complex/cgbsv.f'),('*          matrix A.  N >= 0.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  KL      (input) INTEGER','complex/cgbsv.f'),('*          The number of subdiagonals within the band of A.  KL >= 0.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  KU      (input) INTEGER','complex/cgbsv.f'),('*          The number of superdiagonals within the band of A.  KU >= 0.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  NRHS    (input) INTEGER','complex/cgbsv.f'),('*          The number of right hand sides, i.e., the number of columns','complex/cgbsv.f'),('*          of the matrix B.  NRHS >= 0.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  AB      (input/output) COMPLEX array, dimension (LDAB,N)','complex/cgbsv.f'),('*          On entry, the matrix A in band storage, in rows KL+1 to','complex/cgbsv.f'),('*          2*KL+KU+1; rows 1 to KL of the array need not be set.','complex/cgbsv.f'),('*          The j-th column of A is stored in the j-th column of the','complex/cgbsv.f'),('*          array AB as follows:','complex/cgbsv.f'),('*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)','complex/cgbsv.f'),('*          On exit, details of the factorization: U is stored as an','complex/cgbsv.f'),('*          upper triangular band matrix with KL+KU superdiagonals in','complex/cgbsv.f'),('*          rows 1 to KL+KU+1, and the multipliers used during the','complex/cgbsv.f'),('*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.','complex/cgbsv.f'),('*          See below for further details.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  LDAB    (input) INTEGER','complex/cgbsv.f'),('*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  IPIV    (output) INTEGER array, dimension (N)','complex/cgbsv.f'),('*          The pivot indices that define the permutation matrix P;','complex/cgbsv.f'),('*          row i of the matrix was interchanged with row IPIV(i).','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)','complex/cgbsv.f'),('*          On entry, the N-by-NRHS right hand side matrix B.','complex/cgbsv.f'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  LDB     (input) INTEGER','complex/cgbsv.f'),('*          The leading dimension of the array B.  LDB >= max(1,N).','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  INFO    (output) INTEGER','complex/cgbsv.f'),('*          = 0:  successful exit','complex/cgbsv.f'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value','complex/cgbsv.f'),('*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization','complex/cgbsv.f'),('*                has been completed, but the factor U is exactly','complex/cgbsv.f'),('*                singular, and the solution has not been computed.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  Further Details','complex/cgbsv.f'),('*  ===============','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  The band storage scheme is illustrated by the following example, when','complex/cgbsv.f'),('*  M = N = 6, KL = 2, KU = 1:','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  On entry:                       On exit:','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*      *    *    *    +    +    +       *    *    *   u14  u25  u36','complex/cgbsv.f'),('*      *    *    +    +    +    +       *    *   u13  u24  u35  u46','complex/cgbsv.f'),('*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56','complex/cgbsv.f'),('*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66','complex/cgbsv.f'),('*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *','complex/cgbsv.f'),('*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *','complex/cgbsv.f'),('*','complex/cgbsv.f'),('*  Array elements marked * are not used by the routine; elements marked','complex/cgbsv.f'),('*  + need not be set on entry, but are required by the routine to store','complex/cgbsv.f'),('*  elements of U because of fill-in resulting from the row interchanges.','complex/cgbsv.f'),('*','complex/cgbsv.f'),('','complex/cgbsv.f');
/*!40000 ALTER TABLE `RoutineInfo` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `SVD`
--

DROP TABLE IF EXISTS `SVD`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `SVD` (
  `id_svd` smallint(5) unsigned NOT NULL auto_increment,
  `thePrecision` enum('s','d','c','z') default NULL,
  `routineName` varchar(6) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `structureType` enum('f','b','p','t','g') default NULL,
  `url` varchar(20) default NULL,
  `problem` smallint(5) unsigned NOT NULL,
  `description` varchar(255) default NULL,
  PRIMARY KEY  (`id_svd`),
  FULLTEXT KEY `routineName` (`routineName`,`matrixType`,`url`,`description`)
) ENGINE=MyISAM AUTO_INCREMENT=13 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `SVD`
--

LOCK TABLES `SVD` WRITE;
/*!40000 ALTER TABLE `SVD` DISABLE KEYS */;
INSERT INTO `SVD` VALUES (1,'s','gesvd','general','f','single/sgesvd.f',9,'singular value decomposition (SVD), left, right vectors, simple driver'),(2,'d','gesvd','general','f','double/dgesvd.f',9,'singular value decomposition (SVD), left, right vectors, simple driver'),(3,'c','gesvd','general','f','complex/cgesvd.f',9,'singular value decomposition (SVD), left, right vectors, simple driver'),(4,'z','gesvd','general','f','complex16/zgesvd.f',9,'singular value decomposition (SVD), left, right vectors, simple driver'),(5,'s','gesdd','general','f','single/sgesdd.f',9,'singular value decomposition (SVD), divide and conquer, faster but more memory'),(6,'d','gesdd','general','f','double/dgesdd.f',9,'singular value decomposition (SVD), divide and conquer, faster but more memory'),(7,'c','gesdd','general','f','complex/cgesdd.f',9,'singular value decomposition (SVD), divide and conquer, faster but more memory'),(8,'z','gesdd','general','f','complex16/zgesdd.f',9,'singular value decomposition (SVD), divide and conquer, faster but more memory'),(9,'s','ggsvd','general','f','single/sggsvd.f',9,'singular value decomposition (SVD), generalized, left, right vectors'),(10,'d','ggsvd','general','f','double/dggsvd.f',9,'singular value decomposition (SVD), generalized, left, right vectors'),(11,'c','ggsvd','general','f','complex/cggsvd.f',9,'singular value decomposition (SVD), generalized, left, right vectors'),(12,'z','ggsvd','general','f','complex16/zggsvd.f',9,'singular value decomposition (SVD), generalized, left, right vectors');
/*!40000 ALTER TABLE `SVD` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `Sym_Eigen`
--

DROP TABLE IF EXISTS `Sym_Eigen`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Sym_Eigen` (
  `id_sei` smallint(5) unsigned NOT NULL auto_increment,
  `thePrecision` enum('s','d','c','z') default NULL,
  `routineName` varchar(6) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `structureType` enum('f','b','p','t','g') default NULL,
  `url` varchar(20) default NULL,
  `problem` smallint(5) unsigned NOT NULL,
  `description` varchar(255) default NULL,
  PRIMARY KEY  (`id_sei`),
  FULLTEXT KEY `routineName` (`routineName`,`matrixType`,`url`,`description`)
) ENGINE=MyISAM AUTO_INCREMENT=85 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Sym_Eigen`
--

LOCK TABLES `Sym_Eigen` WRITE;
/*!40000 ALTER TABLE `Sym_Eigen` DISABLE KEYS */;
INSERT INTO `Sym_Eigen` VALUES (1,'c','heev','Hermitian','f','complex/cheev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(2,'z','heev','Hermitian','f','complex16/zheev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(3,'c','hbev','Hermitian','b','complex/chbev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(4,'z','hbev','Hermitian','b','complex16/zhbev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(5,'c','hpev','Hermitian','p','complex/chpev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(6,'z','hpev','Hermitian','p','complex16/zhpev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(7,'s','syev','symmetric','f','single/ssyev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(8,'d','syev','symmetric','f','double/dsyev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(9,'s','sbev','symmetric','b','single/ssbev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(10,'d','sbev','symmetric','b','double/dsbev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(11,'s','spev','symmetric','p','single/sspev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(12,'d','spev','symmetric','p','double/dspev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(13,'s','stev','symmetric','t','single/sstev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(14,'d','stev','symmetric','t','double/dstev.f',5,'symmetric all eigenvalues, eigenvectors, simple driver,'),(15,'c','heevx','Hermitian','f','complex/cheevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(16,'z','heevx','Hermitian','f','complex16/zheevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(17,'c','hbevx','Hermitian','b','complex/chbevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(18,'z','hbevx','Hermitian','b','complex16/zhbevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(19,'c','hpevx','Hermitian','p','complex/chpevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(20,'z','hpevx','Hermitian','p','complex16/zhpevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(21,'s','syevx','symmetric','f','single/ssyevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(22,'d','syevx','symmetric','f','double/dsyevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(23,'s','sbevx','symmetric','b','single/ssbevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(24,'d','sbevx','symmetric','b','double/dsbevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(25,'s','spevx','symmetric','p','single/sspevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(26,'d','spevx','symmetric','p','double/dspevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(27,'s','stevx','symmetric','t','single/sstevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(28,'d','stevx','symmetric','t','double/dstevx.f',5,'symmetric all eigenvalues, eigenvectors, expert driver,'),(29,'c','heevd','Hermitian','f','complex/cheevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(30,'z','heevd','Hermitian','f','complex16/zheevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(31,'c','hbevd','Hermitian','b','complex/chbevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(32,'z','hbevd','Hermitian','b','complex16/zhbevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(33,'c','hpevd','Hermitian','p','complex/chpevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(34,'z','hpevd','Hermitian','p','complex16/zhpevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(35,'s','syevd','symmetric','f','single/ssyevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(36,'d','syevd','symmetric','f','double/dsyevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(37,'s','sbevd','symmetric','b','single/ssbevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(38,'d','sbevd','symmetric','b','double/dsbevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(39,'s','spevd','symmetric','p','single/sspevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(40,'d','spevd','symmetric','p','double/dspevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(41,'s','stevd','symmetric','t','single/sstevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(42,'d','stevd','symmetric','t','double/dstevd.f',5,'symmetric eigenvalues, divide and conquer, faster but more memory'),(43,'c','heevr','Hermitian','f','complex/cheevr.f',5,'symmetric eigenvalues, Relatively robust representation, fastest and least memory'),(44,'z','heevr','Hermitian','f','complex16/zheevr.f',5,'symmetric eigenvalues, Relatively robust representation, fastest and least memory'),(45,'s','syevr','symmetric','f','single/ssyevr.f',5,'symmetric eigenvalues, Relatively robust representation, fastest and least memory'),(46,'d','syevr','symmetric','f','double/dsyevr.f',5,'symmetric eigenvalues, Relatively robust representation, fastest and least memory'),(47,'s','stevr','symmetric','t','single/sstevr.f',5,'symmetric eigenvalues, Relatively robust representation, fastest and least memory'),(48,'d','stevr','symmetric','t','double/dstevr.f',5,'symmetric eigenvalues, Relatively robust representation, fastest and least memory'),(49,'c','hegv','Hermitian','f','complex/chegv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(50,'z','hegv','Hermitian','f','complex16/zhegv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(51,'c','hbgv','Hermitian','b','complex/chbgv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(52,'z','hbgv','Hermitian','b','complex16/zhbgv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(53,'c','hpgv','Hermitian','p','complex/chpgv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(54,'z','hpgv','Hermitian','p','complex16/zhpgv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(55,'s','sygv','symmetric','f','single/ssygv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(56,'d','sygv','symmetric','f','double/dsygv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(57,'s','sbgv','symmetric','b','single/ssbgv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(58,'d','sbgv','symmetric','b','double/dsbgv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(59,'s','spgv','symmetric','p','single/sspgv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(60,'d','spgv','symmetric','p','double/dspgv.f',6,'symmetric generalized all eigenvalues, eigenvectors, simple driver,'),(61,'c','hegvx','Hermitian','f','complex/chegvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(62,'z','hegvx','Hermitian','f','complex16/zhegvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(63,'c','hbgvx','Hermitian','b','complex/chbgvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(64,'z','hbgvx','Hermitian','b','complex16/zhbgvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(65,'c','hpgvx','Hermitian','p','complex/chpgvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(66,'z','hpgvx','Hermitian','p','complex16/zhpgvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(67,'s','sygvx','symmetric','f','single/ssygvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(68,'d','sygvx','symmetric','f','double/dsygvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(69,'s','sbgvx','symmetric','b','single/ssbgvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(70,'d','sbgvx','symmetric','b','double/dsbgvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(71,'s','spgvx','symmetric','p','single/sspgvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(72,'d','spgvx','symmetric','p','double/dspgvx.f',6,'symmetric generalized all eigenvalues, eigenvectors, expert driver,'),(73,'c','hegvd','Hermitian','f','complex/chegvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(74,'z','hegvd','Hermitian','f','complex16/zhegvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(75,'c','hbgvd','Hermitian','b','complex/chbgvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(76,'z','hbgvd','Hermitian','b','complex16/zhbgvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(77,'c','hpgvd','Hermitian','p','complex/chpgvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(78,'z','hpgvd','Hermitian','p','complex16/zhpgvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(79,'s','sygvd','symmetric','f','single/ssygvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(80,'d','sygvd','symmetric','f','double/dsygvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(81,'s','sbgvd','symmetric','b','single/ssbgvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(82,'d','sbgvd','symmetric','b','double/dsbgvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(83,'s','spgvd','symmetric','p','single/sspgvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory'),(84,'d','spgvd','symmetric','p','double/dspgvd.f',6,'symmetric generalized eigenvalues, divide and conquer, faster but more memory');
/*!40000 ALTER TABLE `Sym_Eigen` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgbsv_Table7`
--

DROP TABLE IF EXISTS `cgbsv_Table7`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgbsv_Table7` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgbsv_Table7`
--

LOCK TABLES `cgbsv_Table7` WRITE;
/*!40000 ALTER TABLE `cgbsv_Table7` DISABLE KEYS */;
INSERT INTO `cgbsv_Table7` VALUES ('      SUBROUTINE CGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX            AB( LDAB, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGBSV computes the solution to a complex system of linear equations'),('*  A * X = B, where A is a band matrix of order N with KL subdiagonals'),('*  and KU superdiagonals, and X and B are N-by-NRHS matrices.'),('*'),('*  The LU decomposition with partial pivoting and row interchanges is'),('*  used to factor A as A = L * U, where L is a product of permutation'),('*  and unit lower triangular matrices with KL subdiagonals, and U is'),('*  upper triangular with KL+KU superdiagonals.  The factored form of A'),('*  is then used to solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KL      (input) INTEGER'),('*          The number of subdiagonals within the band of A.  KL >= 0.'),('*'),('*  KU      (input) INTEGER'),('*          The number of superdiagonals within the band of A.  KU >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AB      (input/output) COMPLEX array, dimension (LDAB,N)'),('*          On entry, the matrix A in band storage, in rows KL+1 to'),('*          2*KL+KU+1; rows 1 to KL of the array need not be set.'),('*          The j-th column of A is stored in the j-th column of the'),('*          array AB as follows:'),('*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)'),('*          On exit, details of the factorization: U is stored as an'),('*          upper triangular band matrix with KL+KU superdiagonals in'),('*          rows 1 to KL+KU+1, and the multipliers used during the'),('*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.'),('*          See below for further details.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          The pivot indices that define the permutation matrix P;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization'),('*                has been completed, but the factor U is exactly'),('*                singular, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  M = N = 6, KL = 2, KU = 1:'),('*'),('*  On entry:                       On exit:'),('*'),('*      *    *    *    +    +    +       *    *    *   u14  u25  u36'),('*      *    *    +    +    +    +       *    *   u13  u24  u35  u46'),('*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56'),('*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66'),('*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *'),('*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *'),('*'),('*  Array elements marked * are not used by the routine; elements marked'),('*  + need not be set on entry, but are required by the routine to store'),('*  elements of U because of fill-in resulting from the row interchanges.'),('*');
/*!40000 ALTER TABLE `cgbsv_Table7` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgbsvx_Table47`
--

DROP TABLE IF EXISTS `cgbsvx_Table47`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgbsvx_Table47` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgbsvx_Table47`
--

LOCK TABLES `cgbsvx_Table47` WRITE;
/*!40000 ALTER TABLE `cgbsvx_Table47` DISABLE KEYS */;
INSERT INTO `cgbsvx_Table47` VALUES ('      SUBROUTINE CGBSVX( FACT, TRANS, N, KL, KU, NRHS, AB, LDAB, AFB,'),('     $                   LDAFB, IPIV, EQUED, R, C, B, LDB, X, LDX,'),('     $                   RCOND, FERR, BERR, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, TRANS'),('      INTEGER            INFO, KL, KU, LDAB, LDAFB, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               BERR( * ), C( * ), FERR( * ), R( * ),'),('     $                   RWORK( * )'),('      COMPLEX            AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGBSVX uses the LU factorization to compute the solution to a complex'),('*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,'),('*  where A is a band matrix of order N with KL subdiagonals and KU'),('*  superdiagonals, and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed by this subroutine:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B'),('*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B'),('*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')'),('*     or diag(C)*B (if TRANS = \'T\' or \'C\').'),('*'),('*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the'),('*     matrix A (after equilibration if FACT = \'E\') as'),('*        A = L * U,'),('*     where L is a product of permutation and unit lower triangular'),('*     matrices with KL subdiagonals, and U is upper triangular with'),('*     KL+KU superdiagonals.'),('*'),('*  3. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so'),('*     that it solves the original system before equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFB and IPIV contain the factored form of'),('*                  A.  If EQUED is not \'N\', the matrix A has been'),('*                  equilibrated with scaling factors given by R and C.'),('*                  AB, AFB, and IPIV are not modified.'),('*          = \'N\':  The matrix A will be copied to AFB and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFB and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations.'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Conjugate transpose)'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KL      (input) INTEGER'),('*          The number of subdiagonals within the band of A.  KL >= 0.'),('*'),('*  KU      (input) INTEGER'),('*          The number of superdiagonals within the band of A.  KU >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AB      (input/output) COMPLEX array, dimension (LDAB,N)'),('*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.'),('*          The j-th column of A is stored in the j-th column of the'),('*          array AB as follows:'),('*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)'),('*'),('*          If FACT = \'F\' and EQUED is not \'N\', then A must have been'),('*          equilibrated by the scaling factors in R and/or C.  AB is not'),('*          modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and'),('*          EQUED = \'N\' on exit.'),('*'),('*          On exit, if EQUED .ne. \'N\', A is scaled as follows:'),('*          EQUED = \'R\':  A := diag(R) * A'),('*          EQUED = \'C\':  A := A * diag(C)'),('*          EQUED = \'B\':  A := diag(R) * A * diag(C).'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KL+KU+1.'),('*'),('*  AFB     (input or output) COMPLEX array, dimension (LDAFB,N)'),('*          If FACT = \'F\', then AFB is an input argument and on entry'),('*          contains details of the LU factorization of the band matrix'),('*          A, as computed by CGBTRF.  U is stored as an upper triangular'),('*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,'),('*          and the multipliers used during the factorization are stored'),('*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is'),('*          the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFB is an output argument and on exit'),('*          returns details of the LU factorization of A.'),('*'),('*          If FACT = \'E\', then AFB is an output argument and on exit'),('*          returns details of the LU factorization of the equilibrated'),('*          matrix A (see the description of AB for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAFB   (input) INTEGER'),('*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the factorization A = L*U'),('*          as computed by CGBTRF; row i of the matrix was interchanged'),('*          with row IPIV(i).'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = L*U'),('*          of the equilibrated matrix A.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'R\':  Row equilibration, i.e., A has been premultiplied by'),('*                  diag(R).'),('*          = \'C\':  Column equilibration, i.e., A has been postmultiplied'),('*                  by diag(C).'),('*          = \'B\':  Both row and column equilibration, i.e., A has been'),('*                  replaced by diag(R) * A * diag(C).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  R       (input or output) REAL array, dimension (N)'),('*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is'),('*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R'),('*          is not accessed.  R is an input argument if FACT = \'F\';'),('*          otherwise, R is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'R\' or \'B\', each element of R must be positive.'),('*'),('*  C       (input or output) REAL array, dimension (N)'),('*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is'),('*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C'),('*          is not accessed.  C is an input argument if FACT = \'F\';'),('*          otherwise, C is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'C\' or \'B\', each element of C must be positive.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the right hand side matrix B.'),('*          On exit,'),('*          if EQUED = \'N\', B is not modified;'),('*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by'),('*          diag(R)*B;'),('*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is'),('*          overwritten by diag(C)*B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X'),('*          to the original system of equations.  Note that A and B are'),('*          modified on exit if EQUED .ne. \'N\', and the solution to the'),('*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and'),('*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\''),('*          and EQUED = \'R\' or \'B\'.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (2*N)'),('*'),('*  RWORK   (workspace/output) REAL array, dimension (N)'),('*          On exit, RWORK(1) contains the reciprocal pivot growth'),('*          factor norm(A)/norm(U). The \"max absolute element\" norm is'),('*          used. If RWORK(1) is much less than 1, then the stability'),('*          of the LU factorization of the (equilibrated) matrix A'),('*          could be poor. This also means that the solution X, condition'),('*          estimator RCOND, and forward error bound FERR could be'),('*          unreliable. If factorization fails with 0<INFO<=N, then'),('*          RWORK(1) contains the reciprocal pivot growth factor for the'),('*          leading INFO columns of A.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization'),('*                       has been completed, but the factor U is exactly'),('*                       singular, so the solution and error bounds'),('*                       could not be computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `cgbsvx_Table47` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgees_Table199`
--

DROP TABLE IF EXISTS `cgees_Table199`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgees_Table199` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgees_Table199`
--

LOCK TABLES `cgees_Table199` WRITE;
/*!40000 ALTER TABLE `cgees_Table199` DISABLE KEYS */;
INSERT INTO `cgees_Table199` VALUES ('      SUBROUTINE CGEES( JOBVS, SORT, SELECT, N, A, LDA, SDIM, W, VS,'),('     $                  LDVS, WORK, LWORK, RWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVS, SORT'),('      INTEGER            INFO, LDA, LDVS, LWORK, N, SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      REAL               RWORK( * )'),('      COMPLEX            A( LDA, * ), VS( LDVS, * ), W( * ), WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELECT'),('      EXTERNAL           SELECT'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGEES computes for an N-by-N complex nonsymmetric matrix A, the'),('*  eigenvalues, the Schur form T, and, optionally, the matrix of Schur'),('*  vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).'),('*'),('*  Optionally, it also orders the eigenvalues on the diagonal of the'),('*  Schur form so that selected eigenvalues are at the top left.'),('*  The leading columns of Z then form an orthonormal basis for the'),('*  invariant subspace corresponding to the selected eigenvalues.'),(''),('*  A complex matrix is in Schur form if it is upper triangular.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVS   (input) CHARACTER*1'),('*          = \'N\': Schur vectors are not computed;'),('*          = \'V\': Schur vectors are computed.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the Schur form.'),('*          = \'N\': Eigenvalues are not ordered:'),('*          = \'S\': Eigenvalues are ordered (see SELECT).'),('*'),('*  SELECT  (external procedure) LOGICAL FUNCTION of one COMPLEX argument'),('*          SELECT must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'S\', SELECT is used to select eigenvalues to order'),('*          to the top left of the Schur form.'),('*          IF SORT = \'N\', SELECT is not referenced.'),('*          The eigenvalue W(j) is selected if SELECT(W(j)) is true.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten by its Schur form T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues for which'),('*                         SELECT is true.'),('*'),('*  W       (output) COMPLEX array, dimension (N)'),('*          W contains the computed eigenvalues, in the same order that'),('*          they appear on the diagonal of the output Schur form T.'),('*'),('*  VS      (output) COMPLEX array, dimension (LDVS,N)'),('*          If JOBVS = \'V\', VS contains the unitary matrix Z of Schur'),('*          vectors.'),('*          If JOBVS = \'N\', VS is not referenced.'),('*'),('*  LDVS    (input) INTEGER'),('*          The leading dimension of the array VS.  LDVS >= 1; if'),('*          JOBVS = \'V\', LDVS >= N.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,2*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value.'),('*          > 0: if INFO = i, and i is'),('*               <= N:  the QR algorithm failed to compute all the'),('*                      eigenvalues; elements 1:ILO-1 and i+1:N of W'),('*                      contain those eigenvalues which have converged;'),('*                      if JOBVS = \'V\', VS contains the matrix which'),('*                      reduces A to its partially converged Schur form.'),('*               = N+1: the eigenvalues could not be reordered because'),('*                      some eigenvalues were too close to separate (the'),('*                      problem is very ill-conditioned);'),('*               = N+2: after reordering, roundoff changed values of'),('*                      some complex eigenvalues so that leading'),('*                      eigenvalues in the Schur form no longer satisfy'),('*                      SELECT = .TRUE..  This could also be caused by'),('*                      underflow due to scaling.'),('*');
/*!40000 ALTER TABLE `cgees_Table199` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgeesx_Table203`
--

DROP TABLE IF EXISTS `cgeesx_Table203`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgeesx_Table203` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgeesx_Table203`
--

LOCK TABLES `cgeesx_Table203` WRITE;
/*!40000 ALTER TABLE `cgeesx_Table203` DISABLE KEYS */;
INSERT INTO `cgeesx_Table203` VALUES ('      SUBROUTINE CGEESX( JOBVS, SORT, SELECT, SENSE, N, A, LDA, SDIM, W,'),('     $                   VS, LDVS, RCONDE, RCONDV, WORK, LWORK, RWORK,'),('     $                   BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVS, SENSE, SORT'),('      INTEGER            INFO, LDA, LDVS, LWORK, N, SDIM'),('      REAL               RCONDE, RCONDV'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      REAL               RWORK( * )'),('      COMPLEX            A( LDA, * ), VS( LDVS, * ), W( * ), WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELECT'),('      EXTERNAL           SELECT'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGEESX computes for an N-by-N complex nonsymmetric matrix A, the'),('*  eigenvalues, the Schur form T, and, optionally, the matrix of Schur'),('*  vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).'),('*'),('*  Optionally, it also orders the eigenvalues on the diagonal of the'),('*  Schur form so that selected eigenvalues are at the top left;'),('*  computes a reciprocal condition number for the average of the'),('*  selected eigenvalues (RCONDE); and computes a reciprocal condition'),('*  number for the right invariant subspace corresponding to the'),('*  selected eigenvalues (RCONDV).  The leading columns of Z form an'),('*  orthonormal basis for this invariant subspace.'),('*'),('*  For further explanation of the reciprocal condition numbers RCONDE'),('*  and RCONDV, see Section 4.10 of the LAPACK Users\' Guide (where'),('*  these quantities are called s and sep respectively).'),('*'),('*  A complex matrix is in Schur form if it is upper triangular.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVS   (input) CHARACTER*1'),('*          = \'N\': Schur vectors are not computed;'),('*          = \'V\': Schur vectors are computed.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the Schur form.'),('*          = \'N\': Eigenvalues are not ordered;'),('*          = \'S\': Eigenvalues are ordered (see SELECT).'),('*'),('*  SELECT  (external procedure) LOGICAL FUNCTION of one COMPLEX argument'),('*          SELECT must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'S\', SELECT is used to select eigenvalues to order'),('*          to the top left of the Schur form.'),('*          If SORT = \'N\', SELECT is not referenced.'),('*          An eigenvalue W(j) is selected if SELECT(W(j)) is true.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': None are computed;'),('*          = \'E\': Computed for average of selected eigenvalues only;'),('*          = \'V\': Computed for selected right invariant subspace only;'),('*          = \'B\': Computed for both.'),('*          If SENSE = \'E\', \'V\' or \'B\', SORT must equal \'S\'.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A is overwritten by its Schur form T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues for which'),('*                         SELECT is true.'),('*'),('*  W       (output) COMPLEX array, dimension (N)'),('*          W contains the computed eigenvalues, in the same order'),('*          that they appear on the diagonal of the output Schur form T.'),('*'),('*  VS      (output) COMPLEX array, dimension (LDVS,N)'),('*          If JOBVS = \'V\', VS contains the unitary matrix Z of Schur'),('*          vectors.'),('*          If JOBVS = \'N\', VS is not referenced.'),('*'),('*  LDVS    (input) INTEGER'),('*          The leading dimension of the array VS.  LDVS >= 1, and if'),('*          JOBVS = \'V\', LDVS >= N.'),('*'),('*  RCONDE  (output) REAL'),('*          If SENSE = \'E\' or \'B\', RCONDE contains the reciprocal'),('*          condition number for the average of the selected eigenvalues.'),('*          Not referenced if SENSE = \'N\' or \'V\'.'),('*'),('*  RCONDV  (output) REAL'),('*          If SENSE = \'V\' or \'B\', RCONDV contains the reciprocal'),('*          condition number for the selected right invariant subspace.'),('*          Not referenced if SENSE = \'N\' or \'E\'.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,2*N).'),('*          Also, if SENSE = \'E\' or \'V\' or \'B\', LWORK >= 2*SDIM*(N-SDIM),'),('*          where SDIM is the number of selected eigenvalues computed by'),('*          this routine.  Note that 2*SDIM*(N-SDIM) <= N*N/2. Note also'),('*          that an error is only returned if LWORK < max(1,2*N), but if'),('*          SENSE = \'E\' or \'V\' or \'B\' this may not be large enough.'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates upper bound on the optimal size of the'),('*          array WORK, returns this value as the first entry of the WORK'),('*          array, and no error message related to LWORK is issued by'),('*          XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value.'),('*          > 0: if INFO = i, and i is'),('*             <= N: the QR algorithm failed to compute all the'),('*                   eigenvalues; elements 1:ILO-1 and i+1:N of W'),('*                   contain those eigenvalues which have converged; if'),('*                   JOBVS = \'V\', VS contains the transformation which'),('*                   reduces A to its partially converged Schur form.'),('*             = N+1: the eigenvalues could not be reordered because some'),('*                   eigenvalues were too close to separate (the problem'),('*                   is very ill-conditioned);'),('*             = N+2: after reordering, roundoff changed values of some'),('*                   complex eigenvalues so that leading eigenvalues in'),('*                   the Schur form no longer satisfy SELECT=.TRUE.  This'),('*                   could also be caused by underflow due to scaling.'),('*');
/*!40000 ALTER TABLE `cgeesx_Table203` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgeev_Table191`
--

DROP TABLE IF EXISTS `cgeev_Table191`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgeev_Table191` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgeev_Table191`
--

LOCK TABLES `cgeev_Table191` WRITE;
/*!40000 ALTER TABLE `cgeev_Table191` DISABLE KEYS */;
INSERT INTO `cgeev_Table191` VALUES ('      SUBROUTINE CGEEV( JOBVL, JOBVR, N, A, LDA, W, VL, LDVL, VR, LDVR,'),('     $                  WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVL, JOBVR'),('      INTEGER            INFO, LDA, LDVL, LDVR, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RWORK( * )'),('      COMPLEX            A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGEEV computes for an N-by-N complex nonsymmetric matrix A, the'),('*  eigenvalues and, optionally, the left and/or right eigenvectors.'),('*'),('*  The right eigenvector v(j) of A satisfies'),('*                   A * v(j) = lambda(j) * v(j)'),('*  where lambda(j) is its eigenvalue.'),('*  The left eigenvector u(j) of A satisfies'),('*                u(j)**H * A = lambda(j) * u(j)**H'),('*  where u(j)**H denotes the conjugate transpose of u(j).'),('*'),('*  The computed eigenvectors are normalized to have Euclidean norm'),('*  equal to 1 and largest component real.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\': left eigenvectors of A are not computed;'),('*          = \'V\': left eigenvectors of are computed.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\': right eigenvectors of A are not computed;'),('*          = \'V\': right eigenvectors of A are computed.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) COMPLEX array, dimension (N)'),('*          W contains the computed eigenvalues.'),('*'),('*  VL      (output) COMPLEX array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order'),('*          as their eigenvalues.'),('*          If JOBVL = \'N\', VL is not referenced.'),('*          u(j) = VL(:,j), the j-th column of VL.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the array VL.  LDVL >= 1; if'),('*          JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) COMPLEX array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order'),('*          as their eigenvalues.'),('*          If JOBVR = \'N\', VR is not referenced.'),('*          v(j) = VR(:,j), the j-th column of VR.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the array VR.  LDVR >= 1; if'),('*          JOBVR = \'V\', LDVR >= N.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,2*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (2*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the QR algorithm failed to compute all the'),('*                eigenvalues, and no eigenvectors have been computed;'),('*                elements and i+1:N of W contain eigenvalues which have'),('*                converged.'),('*');
/*!40000 ALTER TABLE `cgeev_Table191` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgeevx_Table195`
--

DROP TABLE IF EXISTS `cgeevx_Table195`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgeevx_Table195` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgeevx_Table195`
--

LOCK TABLES `cgeevx_Table195` WRITE;
/*!40000 ALTER TABLE `cgeevx_Table195` DISABLE KEYS */;
INSERT INTO `cgeevx_Table195` VALUES ('      SUBROUTINE CGEEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, W, VL,'),('     $                   LDVL, VR, LDVR, ILO, IHI, SCALE, ABNRM, RCONDE,'),('     $                   RCONDV, WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          BALANC, JOBVL, JOBVR, SENSE'),('      INTEGER            IHI, ILO, INFO, LDA, LDVL, LDVR, LWORK, N'),('      REAL               ABNRM'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RCONDE( * ), RCONDV( * ), RWORK( * ),'),('     $                   SCALE( * )'),('      COMPLEX            A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGEEVX computes for an N-by-N complex nonsymmetric matrix A, the'),('*  eigenvalues and, optionally, the left and/or right eigenvectors.'),('*'),('*  Optionally also, it computes a balancing transformation to improve'),('*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,'),('*  SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues'),('*  (RCONDE), and reciprocal condition numbers for the right'),('*  eigenvectors (RCONDV).'),('*'),('*  The right eigenvector v(j) of A satisfies'),('*                   A * v(j) = lambda(j) * v(j)'),('*  where lambda(j) is its eigenvalue.'),('*  The left eigenvector u(j) of A satisfies'),('*                u(j)**H * A = lambda(j) * u(j)**H'),('*  where u(j)**H denotes the conjugate transpose of u(j).'),('*'),('*  The computed eigenvectors are normalized to have Euclidean norm'),('*  equal to 1 and largest component real.'),('*'),('*  Balancing a matrix means permuting the rows and columns to make it'),('*  more nearly upper triangular, and applying a diagonal similarity'),('*  transformation D * A * D**(-1), where D is a diagonal matrix, to'),('*  make its rows and columns closer in norm and the condition numbers'),('*  of its eigenvalues and eigenvectors smaller.  The computed'),('*  reciprocal condition numbers correspond to the balanced matrix.'),('*  Permuting rows and columns will not change the condition numbers'),('*  (in exact arithmetic) but diagonal scaling will.  For further'),('*  explanation of balancing, see section 4.10.2 of the LAPACK'),('*  Users\' Guide.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  BALANC  (input) CHARACTER*1'),('*          Indicates how the input matrix should be diagonally scaled'),('*          and/or permuted to improve the conditioning of its'),('*          eigenvalues.'),('*          = \'N\': Do not diagonally scale or permute;'),('*          = \'P\': Perform permutations to make the matrix more nearly'),('*                 upper triangular. Do not diagonally scale;'),('*          = \'S\': Diagonally scale the matrix, ie. replace A by'),('*                 D*A*D**(-1), where D is a diagonal matrix chosen'),('*                 to make the rows and columns of A more equal in'),('*                 norm. Do not permute;'),('*          = \'B\': Both diagonally scale and permute A.'),('*'),('*          Computed reciprocal condition numbers will be for the matrix'),('*          after balancing and/or permuting. Permuting does not change'),('*          condition numbers (in exact arithmetic), but balancing does.'),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\': left eigenvectors of A are not computed;'),('*          = \'V\': left eigenvectors of A are computed.'),('*          If SENSE = \'E\' or \'B\', JOBVL must = \'V\'.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\': right eigenvectors of A are not computed;'),('*          = \'V\': right eigenvectors of A are computed.'),('*          If SENSE = \'E\' or \'B\', JOBVR must = \'V\'.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': None are computed;'),('*          = \'E\': Computed for eigenvalues only;'),('*          = \'V\': Computed for right eigenvectors only;'),('*          = \'B\': Computed for eigenvalues and right eigenvectors.'),('*'),('*          If SENSE = \'E\' or \'B\', both left and right eigenvectors'),('*          must also be computed (JOBVL = \'V\' and JOBVR = \'V\').'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten.  If JOBVL = \'V\' or'),('*          JOBVR = \'V\', A contains the Schur form of the balanced '),('*          version of the matrix A.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) COMPLEX array, dimension (N)'),('*          W contains the computed eigenvalues.'),('*'),('*  VL      (output) COMPLEX array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order'),('*          as their eigenvalues.'),('*          If JOBVL = \'N\', VL is not referenced.'),('*          u(j) = VL(:,j), the j-th column of VL.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the array VL.  LDVL >= 1; if'),('*          JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) COMPLEX array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order'),('*          as their eigenvalues.'),('*          If JOBVR = \'N\', VR is not referenced.'),('*          v(j) = VR(:,j), the j-th column of VR.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the array VR.  LDVR >= 1; if'),('*          JOBVR = \'V\', LDVR >= N.'),('*'),('*  ILO     (output) INTEGER'),('*  IHI     (output) INTEGER'),('*          ILO and IHI are integer values determined when A was'),('*          balanced.  The balanced A(i,j) = 0 if I > J and'),('*          J = 1,...,ILO-1 or I = IHI+1,...,N.'),('*'),('*  SCALE   (output) REAL array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          when balancing A.  If P(j) is the index of the row and column'),('*          interchanged with row and column j, and D(j) is the scaling'),('*          factor applied to row and column j, then'),('*          SCALE(J) = P(J),    for J = 1,...,ILO-1'),('*                   = D(J),    for J = ILO,...,IHI'),('*                   = P(J)     for J = IHI+1,...,N.'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  ABNRM   (output) REAL'),('*          The one-norm of the balanced matrix (the maximum'),('*          of the sum of absolute values of elements of any column).'),('*'),('*  RCONDE  (output) REAL array, dimension (N)'),('*          RCONDE(j) is the reciprocal condition number of the j-th'),('*          eigenvalue.'),('*'),('*  RCONDV  (output) REAL array, dimension (N)'),('*          RCONDV(j) is the reciprocal condition number of the j-th'),('*          right eigenvector.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  If SENSE = \'N\' or \'E\','),('*          LWORK >= max(1,2*N), and if SENSE = \'V\' or \'B\','),('*          LWORK >= N*N+2*N.'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (2*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the QR algorithm failed to compute all the'),('*                eigenvalues, and no eigenvectors or condition numbers'),('*                have been computed; elements 1:ILO-1 and i+1:N of W'),('*                contain eigenvalues which have converged.'),('*');
/*!40000 ALTER TABLE `cgeevx_Table195` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgels_Table83`
--

DROP TABLE IF EXISTS `cgels_Table83`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgels_Table83` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgels_Table83`
--

LOCK TABLES `cgels_Table83` WRITE;
/*!40000 ALTER TABLE `cgels_Table83` DISABLE KEYS */;
INSERT INTO `cgels_Table83` VALUES ('      SUBROUTINE CGELS( TRANS, M, N, NRHS, A, LDA, B, LDB, WORK, LWORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          TRANS'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGELS solves overdetermined or underdetermined complex linear systems'),('*  involving an M-by-N matrix A, or its conjugate-transpose, using a QR'),('*  or LQ factorization of A.  It is assumed that A has full rank.'),('*'),('*  The following options are provided:'),('*'),('*  1. If TRANS = \'N\' and m >= n:  find the least squares solution of'),('*     an overdetermined system, i.e., solve the least squares problem'),('*                  minimize || B - A*X ||.'),('*'),('*  2. If TRANS = \'N\' and m < n:  find the minimum norm solution of'),('*     an underdetermined system A * X = B.'),('*'),('*  3. If TRANS = \'C\' and m >= n:  find the minimum norm solution of'),('*     an undetermined system A**H * X = B.'),('*'),('*  4. If TRANS = \'C\' and m < n:  find the least squares solution of'),('*     an overdetermined system, i.e., solve the least squares problem'),('*                  minimize || B - A**H * X ||.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  TRANS   (input) CHARACTER*1'),('*          = \'N\': the linear system involves A;'),('*          = \'C\': the linear system involves A**H.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of'),('*          columns of the matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*            if M >= N, A is overwritten by details of its QR'),('*                       factorization as returned by CGEQRF;'),('*            if M <  N, A is overwritten by details of its LQ'),('*                       factorization as returned by CGELQF.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the matrix B of right hand side vectors, stored'),('*          columnwise; B is M-by-NRHS if TRANS = \'N\', or N-by-NRHS'),('*          if TRANS = \'C\'.'),('*          On exit, if INFO = 0, B is overwritten by the solution'),('*          vectors, stored columnwise:'),('*          if TRANS = \'N\' and m >= n, rows 1 to n of B contain the least'),('*          squares solution vectors; the residual sum of squares for the'),('*          solution in each column is given by the sum of squares of the'),('*          modulus of elements N+1 to M in that column;'),('*          if TRANS = \'N\' and m < n, rows 1 to N of B contain the'),('*          minimum norm solution vectors;'),('*          if TRANS = \'C\' and m >= n, rows 1 to M of B contain the'),('*          minimum norm solution vectors;'),('*          if TRANS = \'C\' and m < n, rows 1 to M of B contain the'),('*          least squares solution vectors; the residual sum of squares'),('*          for the solution in each column is given by the sum of'),('*          squares of the modulus of elements M+1 to N in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= MAX(1,M,N).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          LWORK >= max( 1, MN + max( MN, NRHS ) ).'),('*          For optimal performance,'),('*          LWORK >= max( 1, MN + max( MN, NRHS )*NB ).'),('*          where MN = min(M,N) and NB is the optimum block size.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO =  i, the i-th diagonal element of the'),('*                triangular factor of A is zero, so that A does not have'),('*                full rank; the least squares solution could not be'),('*                computed.'),('*');
/*!40000 ALTER TABLE `cgels_Table83` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgelsd_Table91`
--

DROP TABLE IF EXISTS `cgelsd_Table91`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgelsd_Table91` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgelsd_Table91`
--

LOCK TABLES `cgelsd_Table91` WRITE;
/*!40000 ALTER TABLE `cgelsd_Table91` DISABLE KEYS */;
INSERT INTO `cgelsd_Table91` VALUES ('      SUBROUTINE CGELSD( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,'),('     $                   WORK, LWORK, RWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               RWORK( * ), S( * )'),('      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGELSD computes the minimum-norm solution to a real linear least'),('*  squares problem:'),('*      minimize 2-norm(| b - A*x |)'),('*  using the singular value decomposition (SVD) of A. A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  The problem is solved in three steps:'),('*  (1) Reduce the coefficient matrix A to bidiagonal form with'),('*      Householder tranformations, reducing the original problem'),('*      into a \"bidiagonal least squares problem\" (BLS)'),('*  (2) Solve the BLS using a divide and conquer approach.'),('*  (3) Apply back all the Householder tranformations to solve'),('*      the original least squares problem.'),('*'),('*  The effective rank of A is determined by treating as zero those'),('*  singular values which are less than RCOND times the largest singular'),('*  value.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A. M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A. N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A has been destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, B is overwritten by the N-by-NRHS solution matrix X.'),('*          If m >= n and RANK = n, the residual sum-of-squares for'),('*          the solution in the i-th column is given by the sum of'),('*          squares of the modulus of elements n+1:m in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,M,N).'),('*'),('*  S       (output) REAL array, dimension (min(M,N))'),('*          The singular values of A in decreasing order.'),('*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).'),('*'),('*  RCOND   (input) REAL'),('*          RCOND is used to determine the effective rank of A.'),('*          Singular values S(i) <= RCOND*S(1) are treated as zero.'),('*          If RCOND < 0, machine precision is used instead.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the number of singular values'),('*          which are greater than RCOND*S(1).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK must be at least 1.'),('*          The exact minimum amount of workspace needed depends on M,'),('*          N and NRHS. As long as LWORK is at least'),('*              2 * N + N * NRHS'),('*          if M is greater than or equal to N or'),('*              2 * M + M * NRHS'),('*          if M is less than N, the code will execute correctly.'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the array WORK and the'),('*          minimum sizes of the arrays RWORK and IWORK, and returns'),('*          these values as the first entries of the WORK, RWORK and'),('*          IWORK arrays, and no error message related to LWORK is issued'),('*          by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (MAX(1,LRWORK))'),('*          LRWORK >='),('*             10*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +'),('*             MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS )'),('*          if M is greater than or equal to N or'),('*             10*M + 2*M*SMLSIZ + 8*M*NLVL + 3*SMLSIZ*NRHS +'),('*             MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS )'),('*          if M is less than N, the code will execute correctly.'),('*          SMLSIZ is returned by ILAENV and is equal to the maximum'),('*          size of the subproblems at the bottom of the computation'),('*          tree (usually about 25), and'),('*             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )'),('*          On exit, if INFO = 0, RWORK(1) returns the minimum LRWORK.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))'),('*          LIWORK >= max(1, 3*MINMN*NLVL + 11*MINMN),'),('*          where MINMN = MIN( M,N ).'),('*          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  the algorithm for computing the SVD failed to converge;'),('*                if INFO = i, i off-diagonal elements of an intermediate'),('*                bidiagonal form did not converge to zero.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Ming Gu and Ren-Cang Li, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*     Osni Marques, LBNL/NERSC, USA'),('*');
/*!40000 ALTER TABLE `cgelsd_Table91` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgelss_Table95`
--

DROP TABLE IF EXISTS `cgelss_Table95`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgelss_Table95` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgelss_Table95`
--

LOCK TABLES `cgelss_Table95` WRITE;
/*!40000 ALTER TABLE `cgelss_Table95` DISABLE KEYS */;
INSERT INTO `cgelss_Table95` VALUES ('      SUBROUTINE CGELSS( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,'),('     $                   WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RWORK( * ), S( * )'),('      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGELSS computes the minimum norm solution to a complex linear'),('*  least squares problem:'),('*'),('*  Minimize 2-norm(| b - A*x |).'),('*'),('*  using the singular value decomposition (SVD) of A. A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix'),('*  X.'),('*'),('*  The effective rank of A is determined by treating as zero those'),('*  singular values which are less than RCOND times the largest singular'),('*  value.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A. M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A. N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, the first min(m,n) rows of A are overwritten with'),('*          its right singular vectors, stored rowwise.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, B is overwritten by the N-by-NRHS solution matrix X.'),('*          If m >= n and RANK = n, the residual sum-of-squares for'),('*          the solution in the i-th column is given by the sum of'),('*          squares of the modulus of elements n+1:m in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,M,N).'),('*'),('*  S       (output) REAL array, dimension (min(M,N))'),('*          The singular values of A in decreasing order.'),('*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).'),('*'),('*  RCOND   (input) REAL'),('*          RCOND is used to determine the effective rank of A.'),('*          Singular values S(i) <= RCOND*S(1) are treated as zero.'),('*          If RCOND < 0, machine precision is used instead.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the number of singular values'),('*          which are greater than RCOND*S(1).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= 1, and also:'),('*          LWORK >=  2*min(M,N) + max(M,N,NRHS)'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (5*min(M,N))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  the algorithm for computing the SVD failed to converge;'),('*                if INFO = i, i off-diagonal elements of an intermediate'),('*                bidiagonal form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `cgelss_Table95` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgelsy_Table87`
--

DROP TABLE IF EXISTS `cgelsy_Table87`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgelsy_Table87` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgelsy_Table87`
--

LOCK TABLES `cgelsy_Table87` WRITE;
/*!40000 ALTER TABLE `cgelsy_Table87` DISABLE KEYS */;
INSERT INTO `cgelsy_Table87` VALUES ('      SUBROUTINE CGELSY( M, N, NRHS, A, LDA, B, LDB, JPVT, RCOND, RANK,'),('     $                   WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            JPVT( * )'),('      REAL               RWORK( * )'),('      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGELSY computes the minimum-norm solution to a complex linear least'),('*  squares problem:'),('*      minimize || A * X - B ||'),('*  using a complete orthogonal factorization of A.  A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  The routine first computes a QR factorization with column pivoting:'),('*      A * P = Q * [ R11 R12 ]'),('*                  [  0  R22 ]'),('*  with R11 defined as the largest leading submatrix whose estimated'),('*  condition number is less than 1/RCOND.  The order of R11, RANK,'),('*  is the effective rank of A.'),('*'),('*  Then, R22 is considered to be negligible, and R12 is annihilated'),('*  by unitary transformations from the right, arriving at the'),('*  complete orthogonal factorization:'),('*     A * P = Q * [ T11 0 ] * Z'),('*                 [  0  0 ]'),('*  The minimum-norm solution is then'),('*     X = P * Z\' [ inv(T11)*Q1\'*B ]'),('*                [        0       ]'),('*  where Q1 consists of the first RANK columns of Q.'),('*'),('*  This routine is basically identical to the original xGELSX except'),('*  three differences:'),('*    o The permutation of matrix B (the right hand side) is faster and'),('*      more simple.'),('*    o The call to the subroutine xGEQPF has been substituted by the'),('*      the call to the subroutine xGEQP3. This subroutine is a Blas-3'),('*      version of the QR factorization with column pivoting.'),('*    o Matrix B (the right hand side) is updated with Blas-3.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of'),('*          columns of matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A has been overwritten by details of its'),('*          complete orthogonal factorization.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,M,N).'),('*'),('*  JPVT    (input/output) INTEGER array, dimension (N)'),('*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted'),('*          to the front of AP, otherwise column i is a free column.'),('*          On exit, if JPVT(i) = k, then the i-th column of A*P'),('*          was the k-th column of A.'),('*'),('*  RCOND   (input) REAL'),('*          RCOND is used to determine the effective rank of A, which'),('*          is defined as the order of the largest leading triangular'),('*          submatrix R11 in the QR factorization with pivoting of A,'),('*          whose estimated condition number < 1/RCOND.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the order of the submatrix'),('*          R11.  This is the same as the order of the submatrix T11'),('*          in the complete orthogonal factorization of A.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          The unblocked strategy requires that:'),('*            LWORK >= MN + MAX( 2*MN, N+1, MN+NRHS )'),('*          where MN = min(M,N).'),('*          The block algorithm requires that:'),('*            LWORK >= MN + MAX( 2*MN, NB*(N+1), MN+MN*NB, MN+NB*NRHS )'),('*          where NB is an upper bound on the blocksize returned'),('*          by ILAENV for the routines CGEQP3, CTZRZF, CTZRQF, CUNMQR,'),('*          and CUNMRZ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (2*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA'),('*    E. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain'),('*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain'),('*');
/*!40000 ALTER TABLE `cgelsy_Table87` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgesdd_Table225`
--

DROP TABLE IF EXISTS `cgesdd_Table225`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgesdd_Table225` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgesdd_Table225`
--

LOCK TABLES `cgesdd_Table225` WRITE;
/*!40000 ALTER TABLE `cgesdd_Table225` DISABLE KEYS */;
INSERT INTO `cgesdd_Table225` VALUES ('      SUBROUTINE CGESDD( JOBZ, M, N, A, LDA, S, U, LDU, VT, LDVT,'),('     $                   WORK, LWORK, RWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*     8-15-00:  Improve consistency of WS calculations (eca)'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ'),('      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               RWORK( * ), S( * )'),('      COMPLEX            A( LDA, * ), U( LDU, * ), VT( LDVT, * ),'),('     $                   WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGESDD computes the singular value decomposition (SVD) of a complex'),('*  M-by-N matrix A, optionally computing the left and/or right singular'),('*  vectors, by using divide-and-conquer method. The SVD is written'),('*'),('*       A = U * SIGMA * conjugate-transpose(V)'),('*'),('*  where SIGMA is an M-by-N matrix which is zero except for its'),('*  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and'),('*  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA'),('*  are the singular values of A; they are real and non-negative, and'),('*  are returned in descending order.  The first min(m,n) columns of'),('*  U and V are the left and right singular vectors of A.'),('*'),('*  Note that the routine returns VT = V**H, not V.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix U:'),('*          = \'A\':  all M columns of U and all N rows of V**H are'),('*                  returned in the arrays U and VT;'),('*          = \'S\':  the first min(M,N) columns of U and the first'),('*                  min(M,N) rows of V**H are returned in the arrays U'),('*                  and VT;'),('*          = \'O\':  If M >= N, the first N columns of U are overwritten'),('*                  in the array A and all rows of V**H are returned in'),('*                  the array VT;'),('*                  otherwise, all columns of U are returned in the'),('*                  array U and the first M rows of V**H are overwritten'),('*                  in the array A;'),('*          = \'N\':  no columns of U or rows of V**H are computed.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the input matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the input matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit,'),('*          if JOBZ = \'O\',  A is overwritten with the first N columns'),('*                          of U (the left singular vectors, stored'),('*                          columnwise) if M >= N;'),('*                          A is overwritten with the first M rows'),('*                          of V**H (the right singular vectors, stored'),('*                          rowwise) otherwise.'),('*          if JOBZ .ne. \'O\', the contents of A are destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  S       (output) REAL array, dimension (min(M,N))'),('*          The singular values of A, sorted so that S(i) >= S(i+1).'),('*'),('*  U       (output) COMPLEX array, dimension (LDU,UCOL)'),('*          UCOL = M if JOBZ = \'A\' or JOBZ = \'O\' and M < N;'),('*          UCOL = min(M,N) if JOBZ = \'S\'.'),('*          If JOBZ = \'A\' or JOBZ = \'O\' and M < N, U contains the M-by-M'),('*          unitary matrix U;'),('*          if JOBZ = \'S\', U contains the first min(M,N) columns of U'),('*          (the left singular vectors, stored columnwise);'),('*          if JOBZ = \'O\' and M >= N, or JOBZ = \'N\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U.  LDU >= 1; if'),('*          JOBZ = \'S\' or \'A\' or JOBZ = \'O\' and M < N, LDU >= M.'),('*'),('*  VT      (output) COMPLEX array, dimension (LDVT,N)'),('*          If JOBZ = \'A\' or JOBZ = \'O\' and M >= N, VT contains the'),('*          N-by-N unitary matrix V**H;'),('*          if JOBZ = \'S\', VT contains the first min(M,N) rows of'),('*          V**H (the right singular vectors, stored rowwise);'),('*          if JOBZ = \'O\' and M < N, or JOBZ = \'N\', VT is not referenced.'),('*'),('*  LDVT    (input) INTEGER'),('*          The leading dimension of the array VT.  LDVT >= 1; if'),('*          JOBZ = \'A\' or JOBZ = \'O\' and M >= N, LDVT >= N;'),('*          if JOBZ = \'S\', LDVT >= min(M,N).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= 1.'),('*          if JOBZ = \'N\', LWORK >= 2*min(M,N)+max(M,N).'),('*          if JOBZ = \'O\','),('*                LWORK >= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).'),('*          if JOBZ = \'S\' or \'A\','),('*                LWORK >= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, a workspace query is assumed.  The optimal'),('*          size for the WORK array is calculated and stored in WORK(1),'),('*          and no other work except argument checking is performed.'),('*'),('*  RWORK   (workspace) REAL array, dimension (MAX(1,LRWORK))'),('*          If JOBZ = \'N\', LRWORK >= 5*min(M,N).'),('*          Otherwise, '),('*          LRWORK >= min(M,N)*max(5*min(M,N)+7,2*max(M,N)+2*min(M,N)+1)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  The updating process of SBDSDC did not converge.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Ming Gu and Huan Ren, Computer Science Division, University of'),('*     California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `cgesdd_Table225` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgesv_Table3`
--

DROP TABLE IF EXISTS `cgesv_Table3`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgesv_Table3` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgesv_Table3`
--

LOCK TABLES `cgesv_Table3` WRITE;
/*!40000 ALTER TABLE `cgesv_Table3` DISABLE KEYS */;
INSERT INTO `cgesv_Table3` VALUES ('      SUBROUTINE CGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX            A( LDA, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGESV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.'),('*'),('*  The LU decomposition with partial pivoting and row interchanges is'),('*  used to factor A as'),('*     A = P * L * U,'),('*  where P is a permutation matrix, L is unit lower triangular, and U is'),('*  upper triangular.  The factored form of A is then used to solve the'),('*  system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the N-by-N coefficient matrix A.'),('*          On exit, the factors L and U from the factorization'),('*          A = P*L*U; the unit diagonal elements of L are not stored.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          The pivot indices that define the permutation matrix P;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS matrix of right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization'),('*                has been completed, but the factor U is exactly'),('*                singular, so the solution could not be computed.'),('*');
/*!40000 ALTER TABLE `cgesv_Table3` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgesvd_Table221`
--

DROP TABLE IF EXISTS `cgesvd_Table221`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgesvd_Table221` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgesvd_Table221`
--

LOCK TABLES `cgesvd_Table221` WRITE;
/*!40000 ALTER TABLE `cgesvd_Table221` DISABLE KEYS */;
INSERT INTO `cgesvd_Table221` VALUES ('      SUBROUTINE CGESVD( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,'),('     $                   WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBU, JOBVT'),('      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RWORK( * ), S( * )'),('      COMPLEX            A( LDA, * ), U( LDU, * ), VT( LDVT, * ),'),('     $                   WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGESVD computes the singular value decomposition (SVD) of a complex'),('*  M-by-N matrix A, optionally computing the left and/or right singular'),('*  vectors. The SVD is written'),('*'),('*       A = U * SIGMA * conjugate-transpose(V)'),('*'),('*  where SIGMA is an M-by-N matrix which is zero except for its'),('*  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and'),('*  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA'),('*  are the singular values of A; they are real and non-negative, and'),('*  are returned in descending order.  The first min(m,n) columns of'),('*  U and V are the left and right singular vectors of A.'),('*'),('*  Note that the routine returns V**H, not V.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBU    (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix U:'),('*          = \'A\':  all M columns of U are returned in array U:'),('*          = \'S\':  the first min(m,n) columns of U (the left singular'),('*                  vectors) are returned in the array U;'),('*          = \'O\':  the first min(m,n) columns of U (the left singular'),('*                  vectors) are overwritten on the array A;'),('*          = \'N\':  no columns of U (no left singular vectors) are'),('*                  computed.'),('*'),('*  JOBVT   (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix'),('*          V**H:'),('*          = \'A\':  all N rows of V**H are returned in the array VT;'),('*          = \'S\':  the first min(m,n) rows of V**H (the right singular'),('*                  vectors) are returned in the array VT;'),('*          = \'O\':  the first min(m,n) rows of V**H (the right singular'),('*                  vectors) are overwritten on the array A;'),('*          = \'N\':  no rows of V**H (no right singular vectors) are'),('*                  computed.'),('*'),('*          JOBVT and JOBU cannot both be \'O\'.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the input matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the input matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit,'),('*          if JOBU = \'O\',  A is overwritten with the first min(m,n)'),('*                          columns of U (the left singular vectors,'),('*                          stored columnwise);'),('*          if JOBVT = \'O\', A is overwritten with the first min(m,n)'),('*                          rows of V**H (the right singular vectors,'),('*                          stored rowwise);'),('*          if JOBU .ne. \'O\' and JOBVT .ne. \'O\', the contents of A'),('*                          are destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  S       (output) REAL array, dimension (min(M,N))'),('*          The singular values of A, sorted so that S(i) >= S(i+1).'),('*'),('*  U       (output) COMPLEX array, dimension (LDU,UCOL)'),('*          (LDU,M) if JOBU = \'A\' or (LDU,min(M,N)) if JOBU = \'S\'.'),('*          If JOBU = \'A\', U contains the M-by-M unitary matrix U;'),('*          if JOBU = \'S\', U contains the first min(m,n) columns of U'),('*          (the left singular vectors, stored columnwise);'),('*          if JOBU = \'N\' or \'O\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U.  LDU >= 1; if'),('*          JOBU = \'S\' or \'A\', LDU >= M.'),('*'),('*  VT      (output) COMPLEX array, dimension (LDVT,N)'),('*          If JOBVT = \'A\', VT contains the N-by-N unitary matrix'),('*          V**H;'),('*          if JOBVT = \'S\', VT contains the first min(m,n) rows of'),('*          V**H (the right singular vectors, stored rowwise);'),('*          if JOBVT = \'N\' or \'O\', VT is not referenced.'),('*'),('*  LDVT    (input) INTEGER'),('*          The leading dimension of the array VT.  LDVT >= 1; if'),('*          JOBVT = \'A\', LDVT >= N; if JOBVT = \'S\', LDVT >= min(M,N).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          LWORK >=  MAX(1,2*MIN(M,N)+MAX(M,N)).'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (5*min(M,N))'),('*          On exit, if INFO > 0, RWORK(1:MIN(M,N)-1) contains the'),('*          unconverged superdiagonal elements of an upper bidiagonal'),('*          matrix B whose diagonal is in S (not necessarily sorted).'),('*          B satisfies A = U * B * VT, so it has the same singular'),('*          values as A, and singular vectors related by U and VT.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if CBDSQR did not converge, INFO specifies how many'),('*                superdiagonals of an intermediate bidiagonal form B'),('*                did not converge to zero. See the description of RWORK'),('*                above for details.'),('*');
/*!40000 ALTER TABLE `cgesvd_Table221` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgesvx_Table43`
--

DROP TABLE IF EXISTS `cgesvx_Table43`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgesvx_Table43` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgesvx_Table43`
--

LOCK TABLES `cgesvx_Table43` WRITE;
/*!40000 ALTER TABLE `cgesvx_Table43` DISABLE KEYS */;
INSERT INTO `cgesvx_Table43` VALUES ('      SUBROUTINE CGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV,'),('     $                   EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, TRANS'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               BERR( * ), C( * ), FERR( * ), R( * ),'),('     $                   RWORK( * )'),('      COMPLEX            A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGESVX uses the LU factorization to compute the solution to a complex'),('*  system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B'),('*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B'),('*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')'),('*     or diag(C)*B (if TRANS = \'T\' or \'C\').'),('*'),('*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the'),('*     matrix A (after equilibration if FACT = \'E\') as'),('*        A = P * L * U,'),('*     where P is a permutation matrix, L is a unit lower triangular'),('*     matrix, and U is upper triangular.'),('*'),('*  3. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so'),('*     that it solves the original system before equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AF and IPIV contain the factored form of A.'),('*                  If EQUED is not \'N\', the matrix A has been'),('*                  equilibrated with scaling factors given by R and C.'),('*                  A, AF, and IPIV are not modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AF and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations:'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Conjugate transpose)'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is'),('*          not \'N\', then A must have been equilibrated by the scaling'),('*          factors in R and/or C.  A is not modified if FACT = \'F\' or'),('*          \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if EQUED .ne. \'N\', A is scaled as follows:'),('*          EQUED = \'R\':  A := diag(R) * A'),('*          EQUED = \'C\':  A := A * diag(C)'),('*          EQUED = \'B\':  A := diag(R) * A * diag(C).'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) COMPLEX array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the factors L and U from the factorization'),('*          A = P*L*U as computed by CGETRF.  If EQUED .ne. \'N\', then'),('*          AF is the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the factors L and U from the factorization A = P*L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then AF is an output argument and on exit'),('*          returns the factors L and U from the factorization A = P*L*U'),('*          of the equilibrated matrix A (see the description of A for'),('*          the form of the equilibrated matrix).'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          as computed by CGETRF; row i of the matrix was interchanged'),('*          with row IPIV(i).'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          of the equilibrated matrix A.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'R\':  Row equilibration, i.e., A has been premultiplied by'),('*                  diag(R).'),('*          = \'C\':  Column equilibration, i.e., A has been postmultiplied'),('*                  by diag(C).'),('*          = \'B\':  Both row and column equilibration, i.e., A has been'),('*                  replaced by diag(R) * A * diag(C).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  R       (input or output) REAL array, dimension (N)'),('*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is'),('*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R'),('*          is not accessed.  R is an input argument if FACT = \'F\';'),('*          otherwise, R is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'R\' or \'B\', each element of R must be positive.'),('*'),('*  C       (input or output) REAL array, dimension (N)'),('*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is'),('*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C'),('*          is not accessed.  C is an input argument if FACT = \'F\';'),('*          otherwise, C is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'C\' or \'B\', each element of C must be positive.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit,'),('*          if EQUED = \'N\', B is not modified;'),('*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by'),('*          diag(R)*B;'),('*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is'),('*          overwritten by diag(C)*B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X'),('*          to the original system of equations.  Note that A and B are'),('*          modified on exit if EQUED .ne. \'N\', and the solution to the'),('*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and'),('*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\''),('*          and EQUED = \'R\' or \'B\'.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (2*N)'),('*'),('*  RWORK   (workspace/output) REAL array, dimension (2*N)'),('*          On exit, RWORK(1) contains the reciprocal pivot growth'),('*          factor norm(A)/norm(U). The \"max absolute element\" norm is'),('*          used. If RWORK(1) is much less than 1, then the stability'),('*          of the LU factorization of the (equilibrated) matrix A'),('*          could be poor. This also means that the solution X, condition'),('*          estimator RCOND, and forward error bound FERR could be'),('*          unreliable. If factorization fails with 0<INFO<=N, then'),('*          RWORK(1) contains the reciprocal pivot growth factor for the'),('*          leading INFO columns of A.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization has'),('*                       been completed, but the factor U is exactly'),('*                       singular, so the solution and error bounds'),('*                       could not be computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `cgesvx_Table43` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgges_Table213`
--

DROP TABLE IF EXISTS `cgges_Table213`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgges_Table213` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgges_Table213`
--

LOCK TABLES `cgges_Table213` WRITE;
/*!40000 ALTER TABLE `cgges_Table213` DISABLE KEYS */;
INSERT INTO `cgges_Table213` VALUES ('      SUBROUTINE CGGES( JOBVSL, JOBVSR, SORT, SELCTG, N, A, LDA, B, LDB,'),('     $                  SDIM, ALPHA, BETA, VSL, LDVSL, VSR, LDVSR, WORK,'),('     $                  LWORK, RWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVSL, JOBVSR, SORT'),('      INTEGER            INFO, LDA, LDB, LDVSL, LDVSR, LWORK, N, SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      REAL               RWORK( * )'),('      COMPLEX            A( LDA, * ), ALPHA( * ), B( LDB, * ),'),('     $                   BETA( * ), VSL( LDVSL, * ), VSR( LDVSR, * ),'),('     $                   WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELCTG'),('      EXTERNAL           SELCTG'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGGES computes for a pair of N-by-N complex nonsymmetric matrices'),('*  (A,B), the generalized eigenvalues, the generalized complex Schur'),('*  form (S, T), and optionally left and/or right Schur vectors (VSL'),('*  and VSR). This gives the generalized Schur factorization'),('*'),('*          (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )'),('*'),('*  where (VSR)**H is the conjugate-transpose of VSR.'),('*'),('*  Optionally, it also orders the eigenvalues so that a selected cluster'),('*  of eigenvalues appears in the leading diagonal blocks of the upper'),('*  triangular matrix S and the upper triangular matrix T. The leading'),('*  columns of VSL and VSR then form an unitary basis for the'),('*  corresponding left and right eigenspaces (deflating subspaces).'),('*'),('*  (If only the generalized eigenvalues are needed, use the driver'),('*  CGGEV instead, which is faster.)'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w'),('*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is'),('*  usually represented as the pair (alpha,beta), as there is a'),('*  reasonable interpretation for beta=0, and even for both being zero.'),('*'),('*  A pair of matrices (S,T) is in generalized complex Schur form if S'),('*  and T are upper triangular and, in addition, the diagonal elements'),('*  of T are non-negative real numbers.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVSL  (input) CHARACTER*1'),('*          = \'N\':  do not compute the left Schur vectors;'),('*          = \'V\':  compute the left Schur vectors.'),('*'),('*  JOBVSR  (input) CHARACTER*1'),('*          = \'N\':  do not compute the right Schur vectors;'),('*          = \'V\':  compute the right Schur vectors.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the generalized Schur form.'),('*          = \'N\':  Eigenvalues are not ordered;'),('*          = \'S\':  Eigenvalues are ordered (see SELCTG).'),('*'),('*  SELCTG  (external procedure) LOGICAL FUNCTION of two COMPLEX arguments'),('*          SELCTG must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'N\', SELCTG is not referenced.'),('*          If SORT = \'S\', SELCTG is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          An eigenvalue ALPHA(j)/BETA(j) is selected if'),('*          SELCTG(ALPHA(j),BETA(j)) is true.'),('*'),('*          Note that a selected complex eigenvalue may no longer satisfy'),('*          SELCTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since'),('*          ordering may change the value of complex eigenvalues'),('*          (especially if the eigenvalue is ill-conditioned), in this'),('*          case INFO is set to N+2 (See INFO below).'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VSL, and VSR.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the first of the pair of matrices.'),('*          On exit, A has been overwritten by its generalized Schur'),('*          form S.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB, N)'),('*          On entry, the second of the pair of matrices.'),('*          On exit, B has been overwritten by its generalized Schur'),('*          form T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*          for which SELCTG is true.'),('*'),('*  ALPHA   (output) COMPLEX array, dimension (N)'),('*  BETA    (output) COMPLEX array, dimension (N)'),('*          On exit,  ALPHA(j)/BETA(j), j=1,...,N, will be the'),('*          generalized eigenvalues.  ALPHA(j), j=1,...,N  and  BETA(j),'),('*          j=1,...,N  are the diagonals of the complex Schur form (A,B)'),('*          output by CGGES. The  BETA(j) will be non-negative real.'),('*'),('*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or'),('*          underflow, and BETA(j) may even be zero.  Thus, the user'),('*          should avoid naively computing the ratio alpha/beta.'),('*          However, ALPHA will be always less than and usually'),('*          comparable with norm(A) in magnitude, and BETA always less'),('*          than and usually comparable with norm(B).'),('*'),('*  VSL     (output) COMPLEX array, dimension (LDVSL,N)'),('*          If JOBVSL = \'V\', VSL will contain the left Schur vectors.'),('*          Not referenced if JOBVSL = \'N\'.'),('*'),('*  LDVSL   (input) INTEGER'),('*          The leading dimension of the matrix VSL. LDVSL >= 1, and'),('*          if JOBVSL = \'V\', LDVSL >= N.'),('*'),('*  VSR     (output) COMPLEX array, dimension (LDVSR,N)'),('*          If JOBVSR = \'V\', VSR will contain the right Schur vectors.'),('*          Not referenced if JOBVSR = \'N\'.'),('*'),('*  LDVSR   (input) INTEGER'),('*          The leading dimension of the matrix VSR. LDVSR >= 1, and'),('*          if JOBVSR = \'V\', LDVSR >= N.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,2*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (8*N)'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          =1,...,N:'),('*                The QZ iteration failed.  (A,B) are not in Schur'),('*                form, but ALPHA(j) and BETA(j) should be correct for'),('*                j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in CHGEQZ'),('*                =N+2: after reordering, roundoff changed values of'),('*                      some complex eigenvalues so that leading'),('*                      eigenvalues in the Generalized Schur form no'),('*                      longer satisfy SELCTG=.TRUE.  This could also'),('*                      be caused due to scaling.'),('*                =N+3: reordering falied in CTGSEN.'),('*');
/*!40000 ALTER TABLE `cgges_Table213` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cggesx_Table217`
--

DROP TABLE IF EXISTS `cggesx_Table217`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cggesx_Table217` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cggesx_Table217`
--

LOCK TABLES `cggesx_Table217` WRITE;
/*!40000 ALTER TABLE `cggesx_Table217` DISABLE KEYS */;
INSERT INTO `cggesx_Table217` VALUES ('      SUBROUTINE CGGESX( JOBVSL, JOBVSR, SORT, SELCTG, SENSE, N, A, LDA,'),('     $                   B, LDB, SDIM, ALPHA, BETA, VSL, LDVSL, VSR,'),('     $                   LDVSR, RCONDE, RCONDV, WORK, LWORK, RWORK,'),('     $                   IWORK, LIWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVSL, JOBVSR, SENSE, SORT'),('      INTEGER            INFO, LDA, LDB, LDVSL, LDVSR, LIWORK, LWORK, N,'),('     $                   SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      INTEGER            IWORK( * )'),('      REAL               RCONDE( 2 ), RCONDV( 2 ), RWORK( * )'),('      COMPLEX            A( LDA, * ), ALPHA( * ), B( LDB, * ),'),('     $                   BETA( * ), VSL( LDVSL, * ), VSR( LDVSR, * ),'),('     $                   WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELCTG'),('      EXTERNAL           SELCTG'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGGESX computes for a pair of N-by-N complex nonsymmetric matrices'),('*  (A,B), the generalized eigenvalues, the complex Schur form (S,T),'),('*  and, optionally, the left and/or right matrices of Schur vectors (VSL'),('*  and VSR).  This gives the generalized Schur factorization'),('*'),('*       (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )'),('*'),('*  where (VSR)**H is the conjugate-transpose of VSR.'),('*'),('*  Optionally, it also orders the eigenvalues so that a selected cluster'),('*  of eigenvalues appears in the leading diagonal blocks of the upper'),('*  triangular matrix S and the upper triangular matrix T; computes'),('*  a reciprocal condition number for the average of the selected'),('*  eigenvalues (RCONDE); and computes a reciprocal condition number for'),('*  the right and left deflating subspaces corresponding to the selected'),('*  eigenvalues (RCONDV). The leading columns of VSL and VSR then form'),('*  an orthonormal basis for the corresponding left and right eigenspaces'),('*  (deflating subspaces).'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w'),('*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is'),('*  usually represented as the pair (alpha,beta), as there is a'),('*  reasonable interpretation for beta=0 or for both being zero.'),('*'),('*  A pair of matrices (S,T) is in generalized complex Schur form if T is'),('*  upper triangular with non-negative diagonal and S is upper'),('*  triangular.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVSL  (input) CHARACTER*1'),('*          = \'N\':  do not compute the left Schur vectors;'),('*          = \'V\':  compute the left Schur vectors.'),('*'),('*  JOBVSR  (input) CHARACTER*1'),('*          = \'N\':  do not compute the right Schur vectors;'),('*          = \'V\':  compute the right Schur vectors.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the generalized Schur form.'),('*          = \'N\':  Eigenvalues are not ordered;'),('*          = \'S\':  Eigenvalues are ordered (see SELCTG).'),('*'),('*  SELCTG  (external procedure) LOGICAL FUNCTION of two COMPLEX arguments'),('*          SELCTG must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'N\', SELCTG is not referenced.'),('*          If SORT = \'S\', SELCTG is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          Note that a selected complex eigenvalue may no longer satisfy'),('*          SELCTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since'),('*          ordering may change the value of complex eigenvalues'),('*          (especially if the eigenvalue is ill-conditioned), in this'),('*          case INFO is set to N+3 see INFO below).'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\' : None are computed;'),('*          = \'E\' : Computed for average of selected eigenvalues only;'),('*          = \'V\' : Computed for selected deflating subspaces only;'),('*          = \'B\' : Computed for both.'),('*          If SENSE = \'E\', \'V\', or \'B\', SORT must equal \'S\'.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VSL, and VSR.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the first of the pair of matrices.'),('*          On exit, A has been overwritten by its generalized Schur'),('*          form S.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB, N)'),('*          On entry, the second of the pair of matrices.'),('*          On exit, B has been overwritten by its generalized Schur'),('*          form T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*          for which SELCTG is true.'),('*'),('*  ALPHA   (output) COMPLEX array, dimension (N)'),('*  BETA    (output) COMPLEX array, dimension (N)'),('*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the'),('*          generalized eigenvalues.  ALPHA(j) and BETA(j),j=1,...,N  are'),('*          the diagonals of the complex Schur form (S,T).  BETA(j) will'),('*          be non-negative real.'),('*'),('*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or'),('*          underflow, and BETA(j) may even be zero.  Thus, the user'),('*          should avoid naively computing the ratio alpha/beta.'),('*          However, ALPHA will be always less than and usually'),('*          comparable with norm(A) in magnitude, and BETA always less'),('*          than and usually comparable with norm(B).'),('*'),('*  VSL     (output) COMPLEX array, dimension (LDVSL,N)'),('*          If JOBVSL = \'V\', VSL will contain the left Schur vectors.'),('*          Not referenced if JOBVSL = \'N\'.'),('*'),('*  LDVSL   (input) INTEGER'),('*          The leading dimension of the matrix VSL. LDVSL >=1, and'),('*          if JOBVSL = \'V\', LDVSL >= N.'),('*'),('*  VSR     (output) COMPLEX array, dimension (LDVSR,N)'),('*          If JOBVSR = \'V\', VSR will contain the right Schur vectors.'),('*          Not referenced if JOBVSR = \'N\'.'),('*'),('*  LDVSR   (input) INTEGER'),('*          The leading dimension of the matrix VSR. LDVSR >= 1, and'),('*          if JOBVSR = \'V\', LDVSR >= N.'),('*'),('*  RCONDE  (output) REAL array, dimension ( 2 )'),('*          If SENSE = \'E\' or \'B\', RCONDE(1) and RCONDE(2) contain the'),('*          reciprocal condition numbers for the average of the selected'),('*          eigenvalues.'),('*          Not referenced if SENSE = \'N\' or \'V\'.'),('*'),('*  RCONDV  (output) REAL array, dimension ( 2 )'),('*          If SENSE = \'V\' or \'B\', RCONDV(1) and RCONDV(2) contain the'),('*          reciprocal condition number for the selected deflating'),('*          subspaces.'),('*          Not referenced if SENSE = \'N\' or \'E\'.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N = 0, LWORK >= 1, else if SENSE = \'E\', \'V\', or \'B\','),('*          LWORK >= MAX(1,2*N,2*SDIM*(N-SDIM)), else'),('*          LWORK >= MAX(1,2*N).  Note that 2*SDIM*(N-SDIM) <= N*N/2.'),('*          Note also that an error is only returned if'),('*          LWORK < MAX(1,2*N), but if SENSE = \'E\' or \'V\' or \'B\' this may'),('*          not be large enough.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the bound on the optimal size of the WORK'),('*          array and the minimum size of the IWORK array, returns these'),('*          values as the first entries of the WORK and IWORK arrays, and'),('*          no error message related to LWORK or LIWORK is issued by'),('*          XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension ( 8*N )'),('*          Real workspace.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If SENSE = \'N\' or N = 0, LIWORK >= 1, otherwise'),('*          LIWORK >= N+2.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the bound on the optimal size of the'),('*          WORK array and the minimum size of the IWORK array, returns'),('*          these values as the first entries of the WORK and IWORK'),('*          arrays, and no error message related to LWORK or LIWORK is'),('*          issued by XERBLA.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  (A,B) are not in Schur'),('*                form, but ALPHA(j) and BETA(j) should be correct for'),('*                j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in CHGEQZ'),('*                =N+2: after reordering, roundoff changed values of'),('*                      some complex eigenvalues so that leading'),('*                      eigenvalues in the Generalized Schur form no'),('*                      longer satisfy SELCTG=.TRUE.  This could also'),('*                      be caused due to scaling.'),('*                =N+3: reordering failed in CTGSEN.'),('*');
/*!40000 ALTER TABLE `cggesx_Table217` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cggev_Table207`
--

DROP TABLE IF EXISTS `cggev_Table207`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cggev_Table207` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cggev_Table207`
--

LOCK TABLES `cggev_Table207` WRITE;
/*!40000 ALTER TABLE `cggev_Table207` DISABLE KEYS */;
INSERT INTO `cggev_Table207` VALUES ('      SUBROUTINE CGGEV( JOBVL, JOBVR, N, A, LDA, B, LDB, ALPHA, BETA,'),('     $                  VL, LDVL, VR, LDVR, WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVL, JOBVR'),('      INTEGER            INFO, LDA, LDB, LDVL, LDVR, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RWORK( * )'),('      COMPLEX            A( LDA, * ), ALPHA( * ), B( LDB, * ),'),('     $                   BETA( * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGGEV computes for a pair of N-by-N complex nonsymmetric matrices'),('*  (A,B), the generalized eigenvalues, and optionally, the left and/or'),('*  right generalized eigenvectors.'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar'),('*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is'),('*  singular. It is usually represented as the pair (alpha,beta), as'),('*  there is a reasonable interpretation for beta=0, and even for both'),('*  being zero.'),('*'),('*  The right generalized eigenvector v(j) corresponding to the'),('*  generalized eigenvalue lambda(j) of (A,B) satisfies'),('*'),('*               A * v(j) = lambda(j) * B * v(j).'),('*'),('*  The left generalized eigenvector u(j) corresponding to the'),('*  generalized eigenvalues lambda(j) of (A,B) satisfies'),('*'),('*               u(j)**H * A = lambda(j) * u(j)**H * B'),('*'),('*  where u(j)**H is the conjugate-transpose of u(j).'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\':  do not compute the left generalized eigenvectors;'),('*          = \'V\':  compute the left generalized eigenvectors.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\':  do not compute the right generalized eigenvectors;'),('*          = \'V\':  compute the right generalized eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VL, and VR.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the matrix A in the pair (A,B).'),('*          On exit, A has been overwritten.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB, N)'),('*          On entry, the matrix B in the pair (A,B).'),('*          On exit, B has been overwritten.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  ALPHA   (output) COMPLEX array, dimension (N)'),('*  BETA    (output) COMPLEX array, dimension (N)'),('*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the'),('*          generalized eigenvalues.'),('*'),('*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or'),('*          underflow, and BETA(j) may even be zero.  Thus, the user'),('*          should avoid naively computing the ratio alpha/beta.'),('*          However, ALPHA will be always less than and usually'),('*          comparable with norm(A) in magnitude, and BETA always less'),('*          than and usually comparable with norm(B).'),('*'),('*  VL      (output) COMPLEX array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left generalized eigenvectors u(j) are'),('*          stored one after another in the columns of VL, in the same'),('*          order as their eigenvalues.'),('*          Each eigenvector is scaled so the largest component has'),('*          abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVL = \'N\'.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the matrix VL. LDVL >= 1, and'),('*          if JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) COMPLEX array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right generalized eigenvectors v(j) are'),('*          stored one after another in the columns of VR, in the same'),('*          order as their eigenvalues.'),('*          Each eigenvector is scaled so the largest component has'),('*          abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVR = \'N\'.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the matrix VR. LDVR >= 1, and'),('*          if JOBVR = \'V\', LDVR >= N.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,2*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) REAL array, dimension (8*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          =1,...,N:'),('*                The QZ iteration failed.  No eigenvectors have been'),('*                calculated, but ALPHA(j) and BETA(j) should be'),('*                correct for j=INFO+1,...,N.'),('*          > N:  =N+1: other then QZ iteration failed in SHGEQZ,'),('*                =N+2: error return from STGEVC.'),('*');
/*!40000 ALTER TABLE `cggev_Table207` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cggevx_Table231`
--

DROP TABLE IF EXISTS `cggevx_Table231`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cggevx_Table231` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cggevx_Table231`
--

LOCK TABLES `cggevx_Table231` WRITE;
/*!40000 ALTER TABLE `cggevx_Table231` DISABLE KEYS */;
INSERT INTO `cggevx_Table231` VALUES ('      SUBROUTINE CGGEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, B, LDB,'),('     $                   ALPHA, BETA, VL, LDVL, VR, LDVR, ILO, IHI,'),('     $                   LSCALE, RSCALE, ABNRM, BBNRM, RCONDE, RCONDV,'),('     $                   WORK, LWORK, RWORK, IWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          BALANC, JOBVL, JOBVR, SENSE'),('      INTEGER            IHI, ILO, INFO, LDA, LDB, LDVL, LDVR, LWORK, N'),('      REAL               ABNRM, BBNRM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      INTEGER            IWORK( * )'),('      REAL               LSCALE( * ), RCONDE( * ), RCONDV( * ),'),('     $                   RSCALE( * ), RWORK( * )'),('      COMPLEX            A( LDA, * ), ALPHA( * ), B( LDB, * ),'),('     $                   BETA( * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGGEVX computes for a pair of N-by-N complex nonsymmetric matrices'),('*  (A,B) the generalized eigenvalues, and optionally, the left and/or'),('*  right generalized eigenvectors.'),('*'),('*  Optionally, it also computes a balancing transformation to improve'),('*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,'),('*  LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for'),('*  the eigenvalues (RCONDE), and reciprocal condition numbers for the'),('*  right eigenvectors (RCONDV).'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar'),('*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is'),('*  singular. It is usually represented as the pair (alpha,beta), as'),('*  there is a reasonable interpretation for beta=0, and even for both'),('*  being zero.'),('*'),('*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*                   A * v(j) = lambda(j) * B * v(j) .'),('*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*                   u(j)**H * A  = lambda(j) * u(j)**H * B.'),('*  where u(j)**H is the conjugate-transpose of u(j).'),('*'),('*'),('*  Arguments'),('*  ========='),('*'),('*  BALANC  (input) CHARACTER*1'),('*          Specifies the balance option to be performed:'),('*          = \'N\':  do not diagonally scale or permute;'),('*          = \'P\':  permute only;'),('*          = \'S\':  scale only;'),('*          = \'B\':  both permute and scale.'),('*          Computed reciprocal condition numbers will be for the'),('*          matrices after permuting and/or balancing. Permuting does'),('*          not change condition numbers (in exact arithmetic), but'),('*          balancing does.'),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\':  do not compute the left generalized eigenvectors;'),('*          = \'V\':  compute the left generalized eigenvectors.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\':  do not compute the right generalized eigenvectors;'),('*          = \'V\':  compute the right generalized eigenvectors.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': none are computed;'),('*          = \'E\': computed for eigenvalues only;'),('*          = \'V\': computed for eigenvectors only;'),('*          = \'B\': computed for eigenvalues and eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VL, and VR.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the matrix A in the pair (A,B).'),('*          On exit, A has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\''),('*          or both, then A contains the first part of the complex Schur'),('*          form of the \"balanced\" versions of the input A and B.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB, N)'),('*          On entry, the matrix B in the pair (A,B).'),('*          On exit, B has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\''),('*          or both, then B contains the second part of the complex'),('*          Schur form of the \"balanced\" versions of the input A and B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  ALPHA   (output) COMPLEX array, dimension (N)'),('*  BETA    (output) COMPLEX array, dimension (N)'),('*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the generalized'),('*          eigenvalues.'),('*'),('*          Note: the quotient ALPHA(j)/BETA(j) ) may easily over- or'),('*          underflow, and BETA(j) may even be zero.  Thus, the user'),('*          should avoid naively computing the ratio ALPHA/BETA.'),('*          However, ALPHA will be always less than and usually'),('*          comparable with norm(A) in magnitude, and BETA always less'),('*          than and usually comparable with norm(B).'),('*'),('*  VL      (output) COMPLEX array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left generalized eigenvectors u(j) are'),('*          stored one after another in the columns of VL, in the same'),('*          order as their eigenvalues.'),('*          Each eigenvector will be scaled so the largest component'),('*          will have abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVL = \'N\'.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the matrix VL. LDVL >= 1, and'),('*          if JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) COMPLEX array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right generalized eigenvectors v(j) are'),('*          stored one after another in the columns of VR, in the same'),('*          order as their eigenvalues.'),('*          Each eigenvector will be scaled so the largest component'),('*          will have abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVR = \'N\'.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the matrix VR. LDVR >= 1, and'),('*          if JOBVR = \'V\', LDVR >= N.'),('*'),('*  ILO     (output) INTEGER'),('*  IHI     (output) INTEGER'),('*          ILO and IHI are integer values such that on exit'),('*          A(i,j) = 0 and B(i,j) = 0 if i > j and'),('*          j = 1,...,ILO-1 or i = IHI+1,...,N.'),('*          If BALANC = \'N\' or \'S\', ILO = 1 and IHI = N.'),('*'),('*  LSCALE  (output) REAL array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          to the left side of A and B.  If PL(j) is the index of the'),('*          row interchanged with row j, and DL(j) is the scaling'),('*          factor applied to row j, then'),('*            LSCALE(j) = PL(j)  for j = 1,...,ILO-1'),('*                      = DL(j)  for j = ILO,...,IHI'),('*                      = PL(j)  for j = IHI+1,...,N.'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  RSCALE  (output) REAL array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          to the right side of A and B.  If PR(j) is the index of the'),('*          column interchanged with column j, and DR(j) is the scaling'),('*          factor applied to column j, then'),('*            RSCALE(j) = PR(j)  for j = 1,...,ILO-1'),('*                      = DR(j)  for j = ILO,...,IHI'),('*                      = PR(j)  for j = IHI+1,...,N'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  ABNRM   (output) REAL'),('*          The one-norm of the balanced matrix A.'),('*'),('*  BBNRM   (output) REAL'),('*          The one-norm of the balanced matrix B.'),('*'),('*  RCONDE  (output) REAL array, dimension (N)'),('*          If SENSE = \'E\' or \'B\', the reciprocal condition numbers of'),('*          the eigenvalues, stored in consecutive elements of the array.'),('*          If SENSE = \'N\' or \'V\', RCONDE is not referenced.'),('*'),('*  RCONDV  (output) REAL array, dimension (N)'),('*          If SENSE = \'V\' or \'B\', the estimated reciprocal condition'),('*          numbers of the eigenvectors, stored in consecutive elements'),('*          of the array. If the eigenvalues cannot be reordered to'),('*          compute RCONDV(j), RCONDV(j) is set to 0; this can only occur'),('*          when the true value would be very small anyway. '),('*          If SENSE = \'N\' or \'E\', RCONDV is not referenced.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,2*N).'),('*          If SENSE = \'E\', LWORK >= max(1,4*N).'),('*          If SENSE = \'V\' or \'B\', LWORK >= max(1,2*N*N+2*N).'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (lrwork)'),('*          lrwork must be at least max(1,6*N) if BALANC = \'S\' or \'B\','),('*          and at least max(1,2*N) otherwise.'),('*          Real workspace.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N+2)'),('*          If SENSE = \'E\', IWORK is not referenced.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          If SENSE = \'N\', BWORK is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  No eigenvectors have been'),('*                calculated, but ALPHA(j) and BETA(j) should be correct'),('*                for j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in CHGEQZ.'),('*                =N+2: error return from CTGEVC.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Balancing a matrix pair (A,B) includes, first, permuting rows and'),('*  columns to isolate eigenvalues, second, applying diagonal similarity'),('*  transformation to the rows and columns to make the rows and columns'),('*  as close in norm as possible. The computed reciprocal condition'),('*  numbers correspond to the balanced matrix. Permuting rows and columns'),('*  will not change the condition numbers (in exact arithmetic) but'),('*  diagonal scaling will.  For further explanation of balancing, see'),('*  section 4.11.1.2 of LAPACK Users\' Guide.'),('*'),('*  An approximate error bound on the chordal distance between the i-th'),('*  computed generalized eigenvalue w and the corresponding exact'),('*  eigenvalue lambda is'),('*'),('*       chord(w, lambda) <= EPS * norm(ABNRM, BBNRM) / RCONDE(I)'),('*'),('*  An approximate error bound for the angle between the i-th computed'),('*  eigenvector VL(i) or VR(i) is given by'),('*'),('*       EPS * norm(ABNRM, BBNRM) / DIF(i).'),('*'),('*  For further explanation of the reciprocal condition numbers RCONDE'),('*  and RCONDV, see section 4.11 of LAPACK User\'s Guide.'),('*'),('*     .. Parameters ..'),('      REAL               ZERO, ONE'),('      PARAMETER          ( ZERO = 0.0E+0, ONE = 1.0E+0 )'),('      COMPLEX            CZERO, CONE'),('      PARAMETER          ( CZERO = ( 0.0E+0, 0.0E+0 ),'),('     $                   CONE = ( 1.0E+0, 0.0E+0 ) )'),('*     ..'),('*     .. Local Scalars ..'),('      LOGICAL            ILASCL, ILBSCL, ILV, ILVL, ILVR, LQUERY, NOSCL,'),('     $                   WANTSB, WANTSE, WANTSN, WANTSV'),('      CHARACTER          CHTEMP'),('      INTEGER            I, ICOLS, IERR, IJOBVL, IJOBVR, IN, IROWS,'),('     $                   ITAU, IWRK, IWRK1, J, JC, JR, M, MAXWRK, MINWRK'),('      REAL               ANRM, ANRMTO, BIGNUM, BNRM, BNRMTO, EPS,'),('     $                   SMLNUM, TEMP'),('      COMPLEX            X'),('*     ..'),('*     .. Local Arrays ..'),('      LOGICAL            LDUMMA( 1 )'),('*     ..'),('*     .. External Subroutines ..'),('      EXTERNAL           CGEQRF, CGGBAK, CGGBAL, CGGHRD, CHGEQZ, CLACPY,'),('     $                   CLASCL, CLASET, CTGEVC, CTGSNA, CUNGQR, CUNMQR,'),('     $                   SLABAD, SLASCL, XERBLA'),('*     ..'),('*     .. External Functions ..'),('      LOGICAL            LSAME'),('      INTEGER            ILAENV'),('      REAL               CLANGE, SLAMCH'),('      EXTERNAL           LSAME, ILAENV, CLANGE, SLAMCH'),('*     ..'),('*     .. Intrinsic Functions ..'),('      INTRINSIC          ABS, AIMAG, MAX, REAL, SQRT'),('*     ..'),('*     .. Statement Functions ..'),('      REAL               ABS1'),('*     ..'),('*     .. Statement Function definitions ..'),('      ABS1( X ) = ABS( REAL( X ) ) + ABS( AIMAG( X ) )'),('*     ..'),('*     .. Executable Statements ..'),('*'),('*     Decode the input arguments'),('*'),('      IF( LSAME( JOBVL, \'N\' ) ) THEN'),('         IJOBVL = 1'),('         ILVL = .FALSE.'),('      ELSE IF( LSAME( JOBVL, \'V\' ) ) THEN'),('         IJOBVL = 2'),('         ILVL = .TRUE.'),('      ELSE'),('         IJOBVL = -1'),('         ILVL = .FALSE.'),('      END IF'),('*'),('      IF( LSAME( JOBVR, \'N\' ) ) THEN'),('         IJOBVR = 1'),('         ILVR = .FALSE.'),('      ELSE IF( LSAME( JOBVR, \'V\' ) ) THEN'),('         IJOBVR = 2'),('         ILVR = .TRUE.'),('      ELSE'),('         IJOBVR = -1'),('         ILVR = .FALSE.'),('      END IF'),('      ILV = ILVL .OR. ILVR'),('*'),('      NOSCL  = LSAME( BALANC, \'N\' ) .OR. LSAME( BALANC, \'P\' )'),('      WANTSN = LSAME( SENSE, \'N\' )'),('      WANTSE = LSAME( SENSE, \'E\' )'),('      WANTSV = LSAME( SENSE, \'V\' )'),('      WANTSB = LSAME( SENSE, \'B\' )'),('*'),('*     Test the input arguments'),('*'),('      INFO = 0'),('      LQUERY = ( LWORK.EQ.-1 )'),('      IF( .NOT.( NOSCL .OR. LSAME( BALANC,\'S\' ) .OR.'),('     $    LSAME( BALANC, \'B\' ) ) ) THEN'),('         INFO = -1'),('      ELSE IF( IJOBVL.LE.0 ) THEN'),('         INFO = -2'),('      ELSE IF( IJOBVR.LE.0 ) THEN'),('         INFO = -3'),('      ELSE IF( .NOT.( WANTSN .OR. WANTSE .OR. WANTSB .OR. WANTSV ) )'),('     $          THEN'),('         INFO = -4'),('      ELSE IF( N.LT.0 ) THEN'),('         INFO = -5'),('      ELSE IF( LDA.LT.MAX( 1, N ) ) THEN'),('         INFO = -7'),('      ELSE IF( LDB.LT.MAX( 1, N ) ) THEN'),('         INFO = -9'),('      ELSE IF( LDVL.LT.1 .OR. ( ILVL .AND. LDVL.LT.N ) ) THEN'),('         INFO = -13'),('      ELSE IF( LDVR.LT.1 .OR. ( ILVR .AND. LDVR.LT.N ) ) THEN'),('         INFO = -15'),('      END IF'),('*'),('*     Compute workspace'),('*      (Note: Comments in the code beginning \"Workspace:\" describe the'),('*       minimal amount of workspace needed at that point in the code,'),('*       as well as the preferred amount for good performance.'),('*       NB refers to the optimal block size for the immediately'),('*       following subroutine, as returned by ILAENV. The workspace is'),('*       computed assuming ILO = 1 and IHI = N, the worst case.)'),('*'),('      IF( INFO.EQ.0 ) THEN'),('         IF( N.EQ.0 ) THEN'),('            MINWRK = 1'),('            MAXWRK = 1'),('         ELSE'),('            MINWRK = 2*N'),('            IF( WANTSE ) THEN'),('               MINWRK = 4*N'),('            ELSE IF( WANTSV .OR. WANTSB ) THEN'),('               MINWRK = 2*N*( N + 1)'),('            END IF'),('            MAXWRK = MINWRK'),('            MAXWRK = MAX( MAXWRK,'),('     $                    N + N*ILAENV( 1, \'CGEQRF\', \' \', N, 1, N, 0 ) )'),('            MAXWRK = MAX( MAXWRK,'),('     $                    N + N*ILAENV( 1, \'CUNMQR\', \' \', N, 1, N, 0 ) )'),('            IF( ILVL ) THEN'),('               MAXWRK = MAX( MAXWRK, N +'),('     $                       N*ILAENV( 1, \'CUNGQR\', \' \', N, 1, N, 0 ) )'),('            END IF'),('         END IF'),('         WORK( 1 ) = MAXWRK'),('*'),('         IF( LWORK.LT.MINWRK .AND. .NOT.LQUERY ) THEN'),('            INFO = -25'),('         END IF'),('      END IF'),('*'),('      IF( INFO.NE.0 ) THEN'),('         CALL XERBLA( \'CGGEVX\', -INFO )'),('         RETURN'),('      ELSE IF( LQUERY ) THEN'),('         RETURN'),('      END IF'),('*'),('*     Quick return if possible'),('*'),('      IF( N.EQ.0 )'),('     $   RETURN'),('*'),('*     Get machine constants'),('*'),('      EPS = SLAMCH( \'P\' )'),('      SMLNUM = SLAMCH( \'S\' )'),('      BIGNUM = ONE / SMLNUM'),('      CALL SLABAD( SMLNUM, BIGNUM )'),('      SMLNUM = SQRT( SMLNUM ) / EPS'),('      BIGNUM = ONE / SMLNUM'),('*'),('*     Scale A if max element outside range [SMLNUM,BIGNUM]'),('*'),('      ANRM = CLANGE( \'M\', N, N, A, LDA, RWORK )'),('      ILASCL = .FALSE.'),('      IF( ANRM.GT.ZERO .AND. ANRM.LT.SMLNUM ) THEN'),('         ANRMTO = SMLNUM'),('         ILASCL = .TRUE.'),('      ELSE IF( ANRM.GT.BIGNUM ) THEN'),('         ANRMTO = BIGNUM'),('         ILASCL = .TRUE.'),('      END IF'),('      IF( ILASCL )'),('     $   CALL CLASCL( \'G\', 0, 0, ANRM, ANRMTO, N, N, A, LDA, IERR )'),('*'),('*     Scale B if max element outside range [SMLNUM,BIGNUM]'),('*'),('      BNRM = CLANGE( \'M\', N, N, B, LDB, RWORK )'),('      ILBSCL = .FALSE.'),('      IF( BNRM.GT.ZERO .AND. BNRM.LT.SMLNUM ) THEN'),('         BNRMTO = SMLNUM'),('         ILBSCL = .TRUE.'),('      ELSE IF( BNRM.GT.BIGNUM ) THEN'),('         BNRMTO = BIGNUM'),('         ILBSCL = .TRUE.'),('      END IF'),('      IF( ILBSCL )'),('     $   CALL CLASCL( \'G\', 0, 0, BNRM, BNRMTO, N, N, B, LDB, IERR )'),('*'),('*     Permute and/or balance the matrix pair (A,B)'),('*     (Real Workspace: need 6*N if BALANC = \'S\' or \'B\', 1 otherwise)'),('*'),('      CALL CGGBAL( BALANC, N, A, LDA, B, LDB, ILO, IHI, LSCALE, RSCALE,'),('     $             RWORK, IERR )'),('*'),('*     Compute ABNRM and BBNRM'),('*'),('      ABNRM = CLANGE( \'1\', N, N, A, LDA, RWORK( 1 ) )'),('      IF( ILASCL ) THEN'),('         RWORK( 1 ) = ABNRM'),('         CALL SLASCL( \'G\', 0, 0, ANRMTO, ANRM, 1, 1, RWORK( 1 ), 1,'),('     $                IERR )'),('         ABNRM = RWORK( 1 )'),('      END IF'),('*'),('      BBNRM = CLANGE( \'1\', N, N, B, LDB, RWORK( 1 ) )'),('      IF( ILBSCL ) THEN'),('         RWORK( 1 ) = BBNRM'),('         CALL SLASCL( \'G\', 0, 0, BNRMTO, BNRM, 1, 1, RWORK( 1 ), 1,'),('     $                IERR )'),('         BBNRM = RWORK( 1 )'),('      END IF'),('*'),('*     Reduce B to triangular form (QR decomposition of B)'),('*     (Complex Workspace: need N, prefer N*NB )'),('*'),('      IROWS = IHI + 1 - ILO'),('      IF( ILV .OR. .NOT.WANTSN ) THEN'),('         ICOLS = N + 1 - ILO'),('      ELSE'),('         ICOLS = IROWS'),('      END IF'),('      ITAU = 1'),('      IWRK = ITAU + IROWS'),('      CALL CGEQRF( IROWS, ICOLS, B( ILO, ILO ), LDB, WORK( ITAU ),'),('     $             WORK( IWRK ), LWORK+1-IWRK, IERR )'),('*'),('*     Apply the unitary transformation to A'),('*     (Complex Workspace: need N, prefer N*NB)'),('*'),('      CALL CUNMQR( \'L\', \'C\', IROWS, ICOLS, IROWS, B( ILO, ILO ), LDB,'),('     $             WORK( ITAU ), A( ILO, ILO ), LDA, WORK( IWRK ),'),('     $             LWORK+1-IWRK, IERR )'),('*'),('*     Initialize VL and/or VR'),('*     (Workspace: need N, prefer N*NB)'),('*'),('      IF( ILVL ) THEN'),('         CALL CLASET( \'Full\', N, N, CZERO, CONE, VL, LDVL )'),('         IF( IROWS.GT.1 ) THEN'),('            CALL CLACPY( \'L\', IROWS-1, IROWS-1, B( ILO+1, ILO ), LDB,'),('     $                   VL( ILO+1, ILO ), LDVL )'),('         END IF'),('         CALL CUNGQR( IROWS, IROWS, IROWS, VL( ILO, ILO ), LDVL,'),('     $                WORK( ITAU ), WORK( IWRK ), LWORK+1-IWRK, IERR )'),('      END IF'),('*'),('      IF( ILVR )'),('     $   CALL CLASET( \'Full\', N, N, CZERO, CONE, VR, LDVR )'),('*'),('*     Reduce to generalized Hessenberg form'),('*     (Workspace: none needed)'),('*'),('      IF( ILV .OR. .NOT.WANTSN ) THEN'),('*'),('*        Eigenvectors requested -- work on whole matrix.'),('*'),('         CALL CGGHRD( JOBVL, JOBVR, N, ILO, IHI, A, LDA, B, LDB, VL,'),('     $                LDVL, VR, LDVR, IERR )'),('      ELSE'),('         CALL CGGHRD( \'N\', \'N\', IROWS, 1, IROWS, A( ILO, ILO ), LDA,'),('     $                B( ILO, ILO ), LDB, VL, LDVL, VR, LDVR, IERR )'),('      END IF'),('*'),('*     Perform QZ algorithm (Compute eigenvalues, and optionally, the'),('*     Schur forms and Schur vectors)'),('*     (Complex Workspace: need N)'),('*     (Real Workspace: need N)'),('*'),('      IWRK = ITAU'),('      IF( ILV .OR. .NOT.WANTSN ) THEN'),('         CHTEMP = \'S\''),('      ELSE'),('         CHTEMP = \'E\''),('      END IF'),('*'),('      CALL CHGEQZ( CHTEMP, JOBVL, JOBVR, N, ILO, IHI, A, LDA, B, LDB,'),('     $             ALPHA, BETA, VL, LDVL, VR, LDVR, WORK( IWRK ),'),('     $             LWORK+1-IWRK, RWORK, IERR )'),('      IF( IERR.NE.0 ) THEN'),('         IF( IERR.GT.0 .AND. IERR.LE.N ) THEN'),('            INFO = IERR'),('         ELSE IF( IERR.GT.N .AND. IERR.LE.2*N ) THEN'),('            INFO = IERR - N'),('         ELSE'),('            INFO = N + 1'),('         END IF'),('         GO TO 90'),('      END IF'),('*'),('*     Compute Eigenvectors and estimate condition numbers if desired'),('*     CTGEVC: (Complex Workspace: need 2*N )'),('*             (Real Workspace:    need 2*N )'),('*     CTGSNA: (Complex Workspace: need 2*N*N if SENSE=\'V\' or \'B\')'),('*             (Integer Workspace: need N+2 )'),('*'),('      IF( ILV .OR. .NOT.WANTSN ) THEN'),('         IF( ILV ) THEN'),('            IF( ILVL ) THEN'),('               IF( ILVR ) THEN'),('                  CHTEMP = \'B\''),('               ELSE'),('                  CHTEMP = \'L\''),('               END IF'),('            ELSE'),('               CHTEMP = \'R\''),('            END IF'),('*'),('            CALL CTGEVC( CHTEMP, \'B\', LDUMMA, N, A, LDA, B, LDB, VL,'),('     $                   LDVL, VR, LDVR, N, IN, WORK( IWRK ), RWORK,'),('     $                   IERR )'),('            IF( IERR.NE.0 ) THEN'),('               INFO = N + 2'),('               GO TO 90'),('            END IF'),('         END IF'),('*'),('         IF( .NOT.WANTSN ) THEN'),('*'),('*           compute eigenvectors (STGEVC) and estimate condition'),('*           numbers (STGSNA). Note that the definition of the condition'),('*           number is not invariant under transformation (u,v) to'),('*           (Q*u, Z*v), where (u,v) are eigenvectors of the generalized'),('*           Schur form (S,T), Q and Z are orthogonal matrices. In order'),('*           to avoid using extra 2*N*N workspace, we have to'),('*           re-calculate eigenvectors and estimate the condition numbers'),('*           one at a time.'),('*'),('            DO 20 I = 1, N'),('*'),('               DO 10 J = 1, N'),('                  BWORK( J ) = .FALSE.'),('   10          CONTINUE'),('               BWORK( I ) = .TRUE.'),('*'),('               IWRK = N + 1'),('               IWRK1 = IWRK + N'),('*'),('               IF( WANTSE .OR. WANTSB ) THEN'),('                  CALL CTGEVC( \'B\', \'S\', BWORK, N, A, LDA, B, LDB,'),('     $                         WORK( 1 ), N, WORK( IWRK ), N, 1, M,'),('     $                         WORK( IWRK1 ), RWORK, IERR )'),('                  IF( IERR.NE.0 ) THEN'),('                     INFO = N + 2'),('                     GO TO 90'),('                  END IF'),('               END IF'),('*'),('               CALL CTGSNA( SENSE, \'S\', BWORK, N, A, LDA, B, LDB,'),('     $                      WORK( 1 ), N, WORK( IWRK ), N, RCONDE( I ),'),('     $                      RCONDV( I ), 1, M, WORK( IWRK1 ),'),('     $                      LWORK-IWRK1+1, IWORK, IERR )'),('*'),('   20       CONTINUE'),('         END IF'),('      END IF'),('*'),('*     Undo balancing on VL and VR and normalization'),('*     (Workspace: none needed)'),('*'),('      IF( ILVL ) THEN'),('         CALL CGGBAK( BALANC, \'L\', N, ILO, IHI, LSCALE, RSCALE, N, VL,'),('     $                LDVL, IERR )'),('*'),('         DO 50 JC = 1, N'),('            TEMP = ZERO'),('            DO 30 JR = 1, N'),('               TEMP = MAX( TEMP, ABS1( VL( JR, JC ) ) )'),('   30       CONTINUE'),('            IF( TEMP.LT.SMLNUM )'),('     $         GO TO 50'),('            TEMP = ONE / TEMP'),('            DO 40 JR = 1, N'),('               VL( JR, JC ) = VL( JR, JC )*TEMP'),('   40       CONTINUE'),('   50    CONTINUE'),('      END IF'),('*'),('      IF( ILVR ) THEN'),('         CALL CGGBAK( BALANC, \'R\', N, ILO, IHI, LSCALE, RSCALE, N, VR,'),('     $                LDVR, IERR )'),('         DO 80 JC = 1, N'),('            TEMP = ZERO'),('            DO 60 JR = 1, N'),('               TEMP = MAX( TEMP, ABS1( VR( JR, JC ) ) )'),('   60       CONTINUE'),('            IF( TEMP.LT.SMLNUM )'),('     $         GO TO 80'),('            TEMP = ONE / TEMP'),('            DO 70 JR = 1, N'),('               VR( JR, JC ) = VR( JR, JC )*TEMP'),('   70       CONTINUE'),('   80    CONTINUE'),('      END IF'),('*'),('*     Undo scaling if necessary'),('*'),('      IF( ILASCL )'),('     $   CALL CLASCL( \'G\', 0, 0, ANRMTO, ANRM, N, 1, ALPHA, N, IERR )'),('*'),('      IF( ILBSCL )'),('     $   CALL CLASCL( \'G\', 0, 0, BNRMTO, BNRM, N, 1, BETA, N, IERR )'),('*'),('   90 CONTINUE'),('      WORK( 1 ) = MAXWRK'),('*'),('      RETURN'),('*'),('*     End of CGGEVX'),('*'),('      END');
/*!40000 ALTER TABLE `cggevx_Table231` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cggglm_Table103`
--

DROP TABLE IF EXISTS `cggglm_Table103`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cggglm_Table103` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cggglm_Table103`
--

LOCK TABLES `cggglm_Table103` WRITE;
/*!40000 ALTER TABLE `cggglm_Table103` DISABLE KEYS */;
INSERT INTO `cggglm_Table103` VALUES ('      SUBROUTINE CGGGLM( N, M, P, A, LDA, B, LDB, D, X, Y, WORK, LWORK,'),('     $                   INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX            A( LDA, * ), B( LDB, * ), D( * ), WORK( * ),'),('     $                   X( * ), Y( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGGGLM solves a general Gauss-Markov linear model (GLM) problem:'),('*'),('*          minimize || y ||_2   subject to   d = A*x + B*y'),('*              x'),('*'),('*  where A is an N-by-M matrix, B is an N-by-P matrix, and d is a'),('*  given N-vector. It is assumed that M <= N <= M+P, and'),('*'),('*             rank(A) = M    and    rank( A B ) = N.'),('*'),('*  Under these assumptions, the constrained equation is always'),('*  consistent, and there is a unique solution x and a minimal 2-norm'),('*  solution y, which is obtained using a generalized QR factorization'),('*  of the matrices (A, B) given by'),('*'),('*     A = Q*(R),   B = Q*T*Z.'),('*           (0)'),('*'),('*  In particular, if matrix B is square nonsingular, then the problem'),('*  GLM is equivalent to the following weighted linear least squares'),('*  problem'),('*'),('*               minimize || inv(B)*(d-A*x) ||_2'),('*                   x'),('*'),('*  where inv(B) denotes the inverse of B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of rows of the matrices A and B.  N >= 0.'),('*'),('*  M       (input) INTEGER'),('*          The number of columns of the matrix A.  0 <= M <= N.'),('*'),('*  P       (input) INTEGER'),('*          The number of columns of the matrix B.  P >= N-M.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,M)'),('*          On entry, the N-by-M matrix A.'),('*          On exit, the upper triangular part of the array A contains'),('*          the M-by-M upper triangular matrix R.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,P)'),('*          On entry, the N-by-P matrix B.'),('*          On exit, if N <= P, the upper triangle of the subarray'),('*          B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;'),('*          if N > P, the elements on and above the (N-P)th subdiagonal'),('*          contain the N-by-P upper trapezoidal matrix T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,N).'),('*'),('*  D       (input/output) COMPLEX array, dimension (N)'),('*          On entry, D is the left hand side of the GLM equation.'),('*          On exit, D is destroyed.'),('*'),('*  X       (output) COMPLEX array, dimension (M)'),('*  Y       (output) COMPLEX array, dimension (P)'),('*          On exit, X and Y are the solutions of the GLM problem.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,N+M+P).'),('*          For optimum performance, LWORK >= M+min(N,P)+max(N,P)*NB,'),('*          where NB is an upper bound for the optimal blocksizes for'),('*          CGEQRF, CGERQF, CUNMQR and CUNMRQ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1:  the upper triangular factor R associated with A in the'),('*                generalized QR factorization of the pair (A, B) is'),('*                singular, so that rank(A) < M; the least squares'),('*                solution could not be computed.'),('*          = 2:  the bottom (N-M) by (N-M) part of the upper trapezoidal'),('*                factor T associated with B in the generalized QR'),('*                factorization of the pair (A, B) is singular, so that'),('*                rank( A B ) < N; the least squares solution could not'),('*                be computed.'),('*');
/*!40000 ALTER TABLE `cggglm_Table103` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgglse_Table99`
--

DROP TABLE IF EXISTS `cgglse_Table99`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgglse_Table99` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgglse_Table99`
--

LOCK TABLES `cgglse_Table99` WRITE;
/*!40000 ALTER TABLE `cgglse_Table99` DISABLE KEYS */;
INSERT INTO `cgglse_Table99` VALUES ('      SUBROUTINE CGGLSE( M, N, P, A, LDA, B, LDB, C, D, X, WORK, LWORK,'),('     $                   INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX            A( LDA, * ), B( LDB, * ), C( * ), D( * ),'),('     $                   WORK( * ), X( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGGLSE solves the linear equality-constrained least squares (LSE)'),('*  problem:'),('*'),('*          minimize || c - A*x ||_2   subject to   B*x = d'),('*'),('*  where A is an M-by-N matrix, B is a P-by-N matrix, c is a given'),('*  M-vector, and d is a given P-vector. It is assumed that'),('*  P <= N <= M+P, and'),('*'),('*           rank(B) = P and  rank( (A) ) = N.'),('*                                ( (B) )'),('*'),('*  These conditions ensure that the LSE problem has a unique solution,'),('*  which is obtained using a generalized RQ factorization of the'),('*  matrices (B, A) given by'),('*'),('*     B = (0 R)*Q,   A = Z*T*Q.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrices A and B. N >= 0.'),('*'),('*  P       (input) INTEGER'),('*          The number of rows of the matrix B. 0 <= P <= N <= M+P.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, the elements on and above the diagonal of the array'),('*          contain the min(M,N)-by-N upper trapezoidal matrix T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,N)'),('*          On entry, the P-by-N matrix B.'),('*          On exit, the upper triangle of the subarray B(1:P,N-P+1:N)'),('*          contains the P-by-P upper triangular matrix R.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,P).'),('*'),('*  C       (input/output) COMPLEX array, dimension (M)'),('*          On entry, C contains the right hand side vector for the'),('*          least squares part of the LSE problem.'),('*          On exit, the residual sum of squares for the solution'),('*          is given by the sum of squares of elements N-P+1 to M of'),('*          vector C.'),('*'),('*  D       (input/output) COMPLEX array, dimension (P)'),('*          On entry, D contains the right hand side vector for the'),('*          constrained equation.'),('*          On exit, D is destroyed.'),('*'),('*  X       (output) COMPLEX array, dimension (N)'),('*          On exit, X is the solution of the LSE problem.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,M+N+P).'),('*          For optimum performance LWORK >= P+min(M,N)+max(M,N)*NB,'),('*          where NB is an upper bound for the optimal blocksizes for'),('*          CGEQRF, CGERQF, CUNMQR and CUNMRQ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1:  the upper triangular factor R associated with B in the'),('*                generalized RQ factorization of the pair (B, A) is'),('*                singular, so that rank(B) < P; the least squares'),('*                solution could not be computed.'),('*          = 2:  the (N-P) by (N-P) part of the upper trapezoidal factor'),('*                T associated with A in the generalized RQ factorization'),('*                of the pair (B, A) is singular, so that'),('*                rank( (A) ) < N; the least squares solution could not'),('*                    ( (B) )'),('*                be computed.'),('*');
/*!40000 ALTER TABLE `cgglse_Table99` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cggsvd_Table229`
--

DROP TABLE IF EXISTS `cggsvd_Table229`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cggsvd_Table229` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cggsvd_Table229`
--

LOCK TABLES `cggsvd_Table229` WRITE;
/*!40000 ALTER TABLE `cggsvd_Table229` DISABLE KEYS */;
INSERT INTO `cggsvd_Table229` VALUES ('      SUBROUTINE CGGSVD( JOBU, JOBV, JOBQ, M, N, P, K, L, A, LDA, B,'),('     $                   LDB, ALPHA, BETA, U, LDU, V, LDV, Q, LDQ, WORK,'),('     $                   RWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBQ, JOBU, JOBV'),('      INTEGER            INFO, K, L, LDA, LDB, LDQ, LDU, LDV, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               ALPHA( * ), BETA( * ), RWORK( * )'),('      COMPLEX            A( LDA, * ), B( LDB, * ), Q( LDQ, * ),'),('     $                   U( LDU, * ), V( LDV, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGGSVD computes the generalized singular value decomposition (GSVD)'),('*  of an M-by-N complex matrix A and P-by-N complex matrix B:'),('*'),('*        U\'*A*Q = D1*( 0 R ),    V\'*B*Q = D2*( 0 R )'),('*'),('*  where U, V and Q are unitary matrices, and Z\' means the conjugate'),('*  transpose of Z.  Let K+L = the effective numerical rank of the'),('*  matrix (A\',B\')\', then R is a (K+L)-by-(K+L) nonsingular upper'),('*  triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) \"diagonal\"'),('*  matrices and of the following structures, respectively:'),('*'),('*  If M-K-L >= 0,'),('*'),('*                      K  L'),('*         D1 =     K ( I  0 )'),('*                  L ( 0  C )'),('*              M-K-L ( 0  0 )'),('*'),('*                    K  L'),('*         D2 =   L ( 0  S )'),('*              P-L ( 0  0 )'),('*'),('*                  N-K-L  K    L'),('*    ( 0 R ) = K (  0   R11  R12 )'),('*              L (  0    0   R22 )'),('*  where'),('*'),('*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),'),('*    S = diag( BETA(K+1),  ... , BETA(K+L) ),'),('*    C**2 + S**2 = I.'),('*'),('*    R is stored in A(1:K+L,N-K-L+1:N) on exit.'),('*'),('*  If M-K-L < 0,'),('*'),('*                    K M-K K+L-M'),('*         D1 =   K ( I  0    0   )'),('*              M-K ( 0  C    0   )'),('*'),('*                      K M-K K+L-M'),('*         D2 =   M-K ( 0  S    0  )'),('*              K+L-M ( 0  0    I  )'),('*                P-L ( 0  0    0  )'),('*'),('*                     N-K-L  K   M-K  K+L-M'),('*    ( 0 R ) =     K ( 0    R11  R12  R13  )'),('*                M-K ( 0     0   R22  R23  )'),('*              K+L-M ( 0     0    0   R33  )'),('*'),('*  where'),('*'),('*    C = diag( ALPHA(K+1), ... , ALPHA(M) ),'),('*    S = diag( BETA(K+1),  ... , BETA(M) ),'),('*    C**2 + S**2 = I.'),('*'),('*    (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored'),('*    ( 0  R22 R23 )'),('*    in B(M-K+1:L,N+M-K-L+1:N) on exit.'),('*'),('*  The routine computes C, S, R, and optionally the unitary'),('*  transformation matrices U, V and Q.'),('*'),('*  In particular, if B is an N-by-N nonsingular matrix, then the GSVD of'),('*  A and B implicitly gives the SVD of A*inv(B):'),('*                       A*inv(B) = U*(D1*inv(D2))*V\'.'),('*  If ( A\',B\')\' has orthnormal columns, then the GSVD of A and B is also'),('*  equal to the CS decomposition of A and B. Furthermore, the GSVD can'),('*  be used to derive the solution of the eigenvalue problem:'),('*                       A\'*A x = lambda* B\'*B x.'),('*  In some literature, the GSVD of A and B is presented in the form'),('*                   U\'*A*X = ( 0 D1 ),   V\'*B*X = ( 0 D2 )'),('*  where U and V are orthogonal and X is nonsingular, and D1 and D2 are'),('*  ``diagonal\'\'.  The former GSVD form can be converted to the latter'),('*  form by taking the nonsingular matrix X as'),('*'),('*                        X = Q*(  I   0    )'),('*                              (  0 inv(R) )'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBU    (input) CHARACTER*1'),('*          = \'U\':  Unitary matrix U is computed;'),('*          = \'N\':  U is not computed.'),('*'),('*  JOBV    (input) CHARACTER*1'),('*          = \'V\':  Unitary matrix V is computed;'),('*          = \'N\':  V is not computed.'),('*'),('*  JOBQ    (input) CHARACTER*1'),('*          = \'Q\':  Unitary matrix Q is computed;'),('*          = \'N\':  Q is not computed.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrices A and B.  N >= 0.'),('*'),('*  P       (input) INTEGER'),('*          The number of rows of the matrix B.  P >= 0.'),('*'),('*  K       (output) INTEGER'),('*  L       (output) INTEGER'),('*          On exit, K and L specify the dimension of the subblocks'),('*          described in Purpose.'),('*          K + L = effective numerical rank of (A\',B\')\'.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A contains the triangular matrix R, or part of R.'),('*          See Purpose for details.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,N)'),('*          On entry, the P-by-N matrix B.'),('*          On exit, B contains part of the triangular matrix R if'),('*          M-K-L < 0.  See Purpose for details.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,P).'),('*'),('*  ALPHA   (output) REAL array, dimension (N)'),('*  BETA    (output) REAL array, dimension (N)'),('*          On exit, ALPHA and BETA contain the generalized singular'),('*          value pairs of A and B;'),('*            ALPHA(1:K) = 1,'),('*            BETA(1:K)  = 0,'),('*          and if M-K-L >= 0,'),('*            ALPHA(K+1:K+L) = C,'),('*            BETA(K+1:K+L)  = S,'),('*          or if M-K-L < 0,'),('*            ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0'),('*            BETA(K+1:M) = S, BETA(M+1:K+L) = 1'),('*          and'),('*            ALPHA(K+L+1:N) = 0'),('*            BETA(K+L+1:N)  = 0'),('*'),('*  U       (output) COMPLEX array, dimension (LDU,M)'),('*          If JOBU = \'U\', U contains the M-by-M unitary matrix U.'),('*          If JOBU = \'N\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U. LDU >= max(1,M) if'),('*          JOBU = \'U\'; LDU >= 1 otherwise.'),('*'),('*  V       (output) COMPLEX array, dimension (LDV,P)'),('*          If JOBV = \'V\', V contains the P-by-P unitary matrix V.'),('*          If JOBV = \'N\', V is not referenced.'),('*'),('*  LDV     (input) INTEGER'),('*          The leading dimension of the array V. LDV >= max(1,P) if'),('*          JOBV = \'V\'; LDV >= 1 otherwise.'),('*'),('*  Q       (output) COMPLEX array, dimension (LDQ,N)'),('*          If JOBQ = \'Q\', Q contains the N-by-N unitary matrix Q.'),('*          If JOBQ = \'N\', Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q. LDQ >= max(1,N) if'),('*          JOBQ = \'Q\'; LDQ >= 1 otherwise.'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (max(3*N,M,P)+N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (2*N)'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (N)'),('*          On exit, IWORK stores the sorting information. More'),('*          precisely, the following loop will sort ALPHA'),('*             for I = K+1, min(M,K+L)'),('*                 swap ALPHA(I) and ALPHA(IWORK(I))'),('*             endfor'),('*          such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = 1, the Jacobi-type procedure failed to'),('*                converge.  For further details, see subroutine CTGSJA.'),('*'),('*  Internal Parameters'),('*  ==================='),('*'),('*  TOLA    REAL'),('*  TOLB    REAL'),('*          TOLA and TOLB are the thresholds to determine the effective'),('*          rank of (A\',B\')\'. Generally, they are set to'),('*                   TOLA = MAX(M,N)*norm(A)*MACHEPS,'),('*                   TOLB = MAX(P,N)*norm(B)*MACHEPS.'),('*          The size of TOLA and TOLB may affect the size of backward'),('*          errors of the decomposition.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  2-96 Based on modifications by'),('*     Ming Gu and Huan Ren, Computer Science Division, University of'),('*     California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `cggsvd_Table229` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgtsv_Table11`
--

DROP TABLE IF EXISTS `cgtsv_Table11`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgtsv_Table11` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgtsv_Table11`
--

LOCK TABLES `cgtsv_Table11` WRITE;
/*!40000 ALTER TABLE `cgtsv_Table11` DISABLE KEYS */;
INSERT INTO `cgtsv_Table11` VALUES ('      SUBROUTINE CGTSV( N, NRHS, DL, D, DU, B, LDB, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX            B( LDB, * ), D( * ), DL( * ), DU( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGTSV  solves the equation'),('*'),('*     A*X = B,'),('*'),('*  where A is an N-by-N tridiagonal matrix, by Gaussian elimination with'),('*  partial pivoting.'),('*'),('*  Note that the equation  A\'*X = B  may be solved by interchanging the'),('*  order of the arguments DU and DL.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  DL      (input/output) COMPLEX array, dimension (N-1)'),('*          On entry, DL must contain the (n-1) subdiagonal elements of'),('*          A.'),('*          On exit, DL is overwritten by the (n-2) elements of the'),('*          second superdiagonal of the upper triangular matrix U from'),('*          the LU factorization of A, in DL(1), ..., DL(n-2).'),('*'),('*  D       (input/output) COMPLEX array, dimension (N)'),('*          On entry, D must contain the diagonal elements of A.'),('*          On exit, D is overwritten by the n diagonal elements of U.'),('*'),('*  DU      (input/output) COMPLEX array, dimension (N-1)'),('*          On entry, DU must contain the (n-1) superdiagonal elements'),('*          of A.'),('*          On exit, DU is overwritten by the (n-1) elements of the first'),('*          superdiagonal of U.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, U(i,i) is exactly zero, and the solution'),('*                has not been computed.  The factorization has not been'),('*                completed unless i = N.'),('*');
/*!40000 ALTER TABLE `cgtsv_Table11` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cgtsvx_Table51`
--

DROP TABLE IF EXISTS `cgtsvx_Table51`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cgtsvx_Table51` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cgtsvx_Table51`
--

LOCK TABLES `cgtsvx_Table51` WRITE;
/*!40000 ALTER TABLE `cgtsvx_Table51` DISABLE KEYS */;
INSERT INTO `cgtsvx_Table51` VALUES ('      SUBROUTINE CGTSVX( FACT, TRANS, N, NRHS, DL, D, DU, DLF, DF, DUF,'),('     $                   DU2, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, RWORK, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, TRANS'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               BERR( * ), FERR( * ), RWORK( * )'),('      COMPLEX            B( LDB, * ), D( * ), DF( * ), DL( * ),'),('     $                   DLF( * ), DU( * ), DU2( * ), DUF( * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CGTSVX uses the LU factorization to compute the solution to a complex'),('*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,'),('*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the LU decomposition is used to factor the matrix A'),('*     as A = L * U, where L is a product of permutation and unit lower'),('*     bidiagonal matrices and U is upper triangular with nonzeros in'),('*     only the main diagonal and first two superdiagonals.'),('*'),('*  2. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored form'),('*                  of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV will not'),('*                  be modified.'),('*          = \'N\':  The matrix will be copied to DLF, DF, and DUF'),('*                  and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations:'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Conjugate transpose)'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  DL      (input) COMPLEX array, dimension (N-1)'),('*          The (n-1) subdiagonal elements of A.'),('*'),('*  D       (input) COMPLEX array, dimension (N)'),('*          The n diagonal elements of A.'),('*'),('*  DU      (input) COMPLEX array, dimension (N-1)'),('*          The (n-1) superdiagonal elements of A.'),('*'),('*  DLF     (input or output) COMPLEX array, dimension (N-1)'),('*          If FACT = \'F\', then DLF is an input argument and on entry'),('*          contains the (n-1) multipliers that define the matrix L from'),('*          the LU factorization of A as computed by CGTTRF.'),('*'),('*          If FACT = \'N\', then DLF is an output argument and on exit'),('*          contains the (n-1) multipliers that define the matrix L from'),('*          the LU factorization of A.'),('*'),('*  DF      (input or output) COMPLEX array, dimension (N)'),('*          If FACT = \'F\', then DF is an input argument and on entry'),('*          contains the n diagonal elements of the upper triangular'),('*          matrix U from the LU factorization of A.'),('*'),('*          If FACT = \'N\', then DF is an output argument and on exit'),('*          contains the n diagonal elements of the upper triangular'),('*          matrix U from the LU factorization of A.'),('*'),('*  DUF     (input or output) COMPLEX array, dimension (N-1)'),('*          If FACT = \'F\', then DUF is an input argument and on entry'),('*          contains the (n-1) elements of the first superdiagonal of U.'),('*'),('*          If FACT = \'N\', then DUF is an output argument and on exit'),('*          contains the (n-1) elements of the first superdiagonal of U.'),('*'),('*  DU2     (input or output) COMPLEX array, dimension (N-2)'),('*          If FACT = \'F\', then DU2 is an input argument and on entry'),('*          contains the (n-2) elements of the second superdiagonal of'),('*          U.'),('*'),('*          If FACT = \'N\', then DU2 is an output argument and on exit'),('*          contains the (n-2) elements of the second superdiagonal of'),('*          U.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the LU factorization of A as'),('*          computed by CGTTRF.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the LU factorization of A;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates'),('*          a row interchange was not required.'),('*'),('*  B       (input) COMPLEX array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (2*N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization'),('*                       has not been completed unless i = N, but the'),('*                       factor U is exactly singular, so the solution'),('*                       and error bounds could not be computed.'),('*                       RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `cgtsvx_Table51` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chbev_Table107`
--

DROP TABLE IF EXISTS `chbev_Table107`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chbev_Table107` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chbev_Table107`
--

LOCK TABLES `chbev_Table107` WRITE;
/*!40000 ALTER TABLE `chbev_Table107` DISABLE KEYS */;
INSERT INTO `chbev_Table107` VALUES ('      SUBROUTINE CHBEV( JOBZ, UPLO, N, KD, AB, LDAB, W, Z, LDZ, WORK,'),('     $                  RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KD, LDAB, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AB( LDAB, * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHBEV computes all the eigenvalues and, optionally, eigenvectors of'),('*  a complex Hermitian band matrix A.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) COMPLEX array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the first'),('*          superdiagonal and the diagonal of the tridiagonal matrix T'),('*          are returned in rows KD and KD+1 of AB, and if UPLO = \'L\','),('*          the diagonal and first subdiagonal of T are returned in the'),('*          first two rows of AB.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (max(1,3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `chbev_Table107` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chbevd_Table135`
--

DROP TABLE IF EXISTS `chbevd_Table135`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chbevd_Table135` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chbevd_Table135`
--

LOCK TABLES `chbevd_Table135` WRITE;
/*!40000 ALTER TABLE `chbevd_Table135` DISABLE KEYS */;
INSERT INTO `chbevd_Table135` VALUES ('      SUBROUTINE CHBEVD( JOBZ, UPLO, N, KD, AB, LDAB, W, Z, LDZ, WORK,'),('     $                   LWORK, RWORK, LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KD, LDAB, LDZ, LIWORK, LRWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AB( LDAB, * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHBEVD computes all the eigenvalues and, optionally, eigenvectors of'),('*  a complex Hermitian band matrix A.  If eigenvectors are desired, it'),('*  uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) COMPLEX array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the first'),('*          superdiagonal and the diagonal of the tridiagonal matrix T'),('*          are returned in rows KD and KD+1 of AB, and if UPLO = \'L\','),('*          the diagonal and first subdiagonal of T are returned in the'),('*          first two rows of AB.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK must be at least N.'),('*          If JOBZ = \'V\' and N > 1, LWORK must be at least 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) REAL array,'),('*                                         dimension (LRWORK)'),('*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of array RWORK.'),('*          If N <= 1,               LRWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LRWORK must be at least N.'),('*          If JOBZ = \'V\' and N > 1, LRWORK must be at least'),('*                        1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of array IWORK.'),('*          If JOBZ = \'N\' or N <= 1, LIWORK must be at least 1.'),('*          If JOBZ = \'V\' and N > 1, LIWORK must be at least 3 + 5*N .'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `chbevd_Table135` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chbevx_Table121`
--

DROP TABLE IF EXISTS `chbevx_Table121`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chbevx_Table121` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chbevx_Table121`
--

LOCK TABLES `chbevx_Table121` WRITE;
/*!40000 ALTER TABLE `chbevx_Table121` DISABLE KEYS */;
INSERT INTO `chbevx_Table121` VALUES ('      SUBROUTINE CHBEVX( JOBZ, RANGE, UPLO, N, KD, AB, LDAB, Q, LDQ, VL,'),('     $                   VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK, RWORK,'),('     $                   IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, KD, LDAB, LDQ, LDZ, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AB( LDAB, * ), Q( LDQ, * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHBEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a complex Hermitian band matrix A.  Eigenvalues and eigenvectors'),('*  can be selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) COMPLEX array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  Q       (output) COMPLEX array, dimension (LDQ, N)'),('*          If JOBZ = \'V\', the N-by-N unitary matrix used in the'),('*                          reduction to tridiagonal form.'),('*          If JOBZ = \'N\', the array Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q.  If JOBZ = \'V\', then'),('*          LDQ >= max(1,N).'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AB to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `chbevx_Table121` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chbgv_Table155`
--

DROP TABLE IF EXISTS `chbgv_Table155`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chbgv_Table155` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chbgv_Table155`
--

LOCK TABLES `chbgv_Table155` WRITE;
/*!40000 ALTER TABLE `chbgv_Table155` DISABLE KEYS */;
INSERT INTO `chbgv_Table155` VALUES ('      SUBROUTINE CHBGV( JOBZ, UPLO, N, KA, KB, AB, LDAB, BB, LDBB, W, Z,'),('     $                  LDZ, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KA, KB, LDAB, LDBB, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AB( LDAB, * ), BB( LDBB, * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHBGV computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite banded eigenproblem, of'),('*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian'),('*  and banded, and B is also positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KB >= 0.'),('*'),('*  AB      (input/output) COMPLEX array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) COMPLEX array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**H*S, as returned by CPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i). The eigenvectors are'),('*          normalized so that Z**H*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= N.'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (3*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is:'),('*             <= N:  the algorithm failed to converge:'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then CPBSTF'),('*                    returned INFO = i: B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `chbgv_Table155` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chbgvd_Table179`
--

DROP TABLE IF EXISTS `chbgvd_Table179`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chbgvd_Table179` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chbgvd_Table179`
--

LOCK TABLES `chbgvd_Table179` WRITE;
/*!40000 ALTER TABLE `chbgvd_Table179` DISABLE KEYS */;
INSERT INTO `chbgvd_Table179` VALUES ('      SUBROUTINE CHBGVD( JOBZ, UPLO, N, KA, KB, AB, LDAB, BB, LDBB, W,'),('     $                   Z, LDZ, WORK, LWORK, RWORK, LRWORK, IWORK,'),('     $                   LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KA, KB, LDAB, LDBB, LDZ, LIWORK, LRWORK,'),('     $                   LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AB( LDAB, * ), BB( LDBB, * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHBGVD computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite banded eigenproblem, of'),('*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian'),('*  and banded, and B is also positive definite.  If eigenvectors are'),('*  desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KB >= 0.'),('*'),('*  AB      (input/output) COMPLEX array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) COMPLEX array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**H*S, as returned by CPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i). The eigenvectors are'),('*          normalized so that Z**H*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= N.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO=0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK >= N.'),('*          If JOBZ = \'V\' and N > 1, LWORK >= 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) REAL array, dimension (MAX(1,LRWORK))'),('*          On exit, if INFO=0, RWORK(1) returns the optimal LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of array RWORK.'),('*          If N <= 1,               LRWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LRWORK >= N.'),('*          If JOBZ = \'V\' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO=0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of array IWORK.'),('*          If JOBZ = \'N\' or N <= 1, LIWORK >= 1.'),('*          If JOBZ = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is:'),('*             <= N:  the algorithm failed to converge:'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then CPBSTF'),('*                    returned INFO = i: B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `chbgvd_Table179` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chbgvx_Table167`
--

DROP TABLE IF EXISTS `chbgvx_Table167`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chbgvx_Table167` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chbgvx_Table167`
--

LOCK TABLES `chbgvx_Table167` WRITE;
/*!40000 ALTER TABLE `chbgvx_Table167` DISABLE KEYS */;
INSERT INTO `chbgvx_Table167` VALUES ('      SUBROUTINE CHBGVX( JOBZ, RANGE, UPLO, N, KA, KB, AB, LDAB, BB,'),('     $                   LDBB, Q, LDQ, VL, VU, IL, IU, ABSTOL, M, W, Z,'),('     $                   LDZ, WORK, RWORK, IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, KA, KB, LDAB, LDBB, LDQ, LDZ, M,'),('     $                   N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AB( LDAB, * ), BB( LDBB, * ), Q( LDQ, * ),'),('     $                   WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHBGVX computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite banded eigenproblem, of'),('*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian'),('*  and banded, and B is also positive definite.  Eigenvalues and'),('*  eigenvectors can be selected by specifying either all eigenvalues,'),('*  a range of values or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KB >= 0.'),('*'),('*  AB      (input/output) COMPLEX array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) COMPLEX array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**H*S, as returned by CPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  Q       (output) COMPLEX array, dimension (LDQ, N)'),('*          If JOBZ = \'V\', the n-by-n matrix used in the reduction of'),('*          A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,'),('*          and consequently C to tridiagonal form.'),('*          If JOBZ = \'N\', the array Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q.  If JOBZ = \'N\','),('*          LDQ >= 1. If JOBZ = \'V\', LDQ >= max(1,N).'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AP to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i). The eigenvectors are'),('*          normalized so that Z**H*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= N.'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is:'),('*             <= N:  then i eigenvectors failed to converge.  Their'),('*                    indices are stored in array IFAIL.'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then CPBSTF'),('*                    returned INFO = i: B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `chbgvx_Table167` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cheev_Table105`
--

DROP TABLE IF EXISTS `cheev_Table105`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cheev_Table105` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cheev_Table105`
--

LOCK TABLES `cheev_Table105` WRITE;
/*!40000 ALTER TABLE `cheev_Table105` DISABLE KEYS */;
INSERT INTO `cheev_Table105` VALUES ('      SUBROUTINE CHEEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDA, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            A( LDA, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHEEV computes all eigenvalues and, optionally, eigenvectors of a'),('*  complex Hermitian matrix A.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          orthonormal eigenvectors of the matrix A.'),('*          If JOBZ = \'N\', then on exit the lower triangle (if UPLO=\'L\')'),('*          or the upper triangle (if UPLO=\'U\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,2*N-1).'),('*          For optimal efficiency, LWORK >= (NB+1)*N,'),('*          where NB is the blocksize for CHETRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (max(1, 3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `cheev_Table105` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cheevd_Table133`
--

DROP TABLE IF EXISTS `cheevd_Table133`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cheevd_Table133` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cheevd_Table133`
--

LOCK TABLES `cheevd_Table133` WRITE;
/*!40000 ALTER TABLE `cheevd_Table133` DISABLE KEYS */;
INSERT INTO `cheevd_Table133` VALUES ('      SUBROUTINE CHEEVD( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK,'),('     $                   LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDA, LIWORK, LRWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            A( LDA, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHEEVD computes all eigenvalues and, optionally, eigenvectors of a'),('*  complex Hermitian matrix A.  If eigenvectors are desired, it uses a'),('*  divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          orthonormal eigenvectors of the matrix A.'),('*          If JOBZ = \'N\', then on exit the lower triangle (if UPLO=\'L\')'),('*          or the upper triangle (if UPLO=\'U\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.'),('*          If N <= 1,                LWORK must be at least 1.'),('*          If JOBZ  = \'N\' and N > 1, LWORK must be at least N + 1.'),('*          If JOBZ  = \'V\' and N > 1, LWORK must be at least 2*N + N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) REAL array,'),('*                                         dimension (LRWORK)'),('*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of the array RWORK.'),('*          If N <= 1,                LRWORK must be at least 1.'),('*          If JOBZ  = \'N\' and N > 1, LRWORK must be at least N.'),('*          If JOBZ  = \'V\' and N > 1, LRWORK must be at least'),('*                         1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If N <= 1,                LIWORK must be at least 1.'),('*          If JOBZ  = \'N\' and N > 1, LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK must be at least 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i and JOBZ = \'N\', then the algorithm failed'),('*                to converge; i off-diagonal elements of an intermediate'),('*                tridiagonal form did not converge to zero;'),('*                if INFO = i and JOBZ = \'V\', then the algorithm failed'),('*                to compute an eigenvalue while working on the submatrix'),('*                lying in rows and columns INFO/(N+1) through'),('*                mod(INFO,N+1).'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Jeff Rutter, Computer Science Division, University of California'),('*     at Berkeley, USA'),('*'),('*  Modified description of INFO. Sven, 16 Feb 05.');
/*!40000 ALTER TABLE `cheevd_Table133` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cheevr_Table147`
--

DROP TABLE IF EXISTS `cheevr_Table147`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cheevr_Table147` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cheevr_Table147`
--

LOCK TABLES `cheevr_Table147` WRITE;
/*!40000 ALTER TABLE `cheevr_Table147` DISABLE KEYS */;
INSERT INTO `cheevr_Table147` VALUES ('      SUBROUTINE CHEEVR( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, ISUPPZ, WORK, LWORK,'),('     $                   RWORK, LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDA, LDZ, LIWORK, LRWORK, LWORK,'),('     $                   M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            ISUPPZ( * ), IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            A( LDA, * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHEEVR computes selected eigenvalues and, optionally, eigenvectors'),('*  of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can'),('*  be selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  CHEEVR first reduces the matrix A to tridiagonal form T with a call'),('*  to CHETRD.  Then, whenever possible, CHEEVR calls CSTEMR to compute'),('*  the eigenspectrum using Relatively Robust Representations.  CSTEMR'),('*  computes eigenvalues by the dqds algorithm, while orthogonal'),('*  eigenvectors are computed from various \"good\" L D L^T representations'),('*  (also known as Relatively Robust Representations). Gram-Schmidt'),('*  orthogonalization is avoided as far as possible. More specifically,'),('*  the various steps of the algorithm are as follows.'),('*'),('*  For each unreduced block (submatrix) of T,'),('*     (a) Compute T - sigma I  = L D L^T, so that L and D'),('*         define all the wanted eigenvalues to high relative accuracy.'),('*         This means that small relative changes in the entries of D and L'),('*         cause only small relative changes in the eigenvalues and'),('*         eigenvectors. The standard (unfactored) representation of the'),('*         tridiagonal matrix T does not have this property in general.'),('*     (b) Compute the eigenvalues to suitable accuracy.'),('*         If the eigenvectors are desired, the algorithm attains full'),('*         accuracy of the computed eigenvalues only right before'),('*         the corresponding vectors have to be computed, see steps c) and d).'),('*     (c) For each cluster of close eigenvalues, select a new'),('*         shift close to the cluster, find a new factorization, and refine'),('*         the shifted eigenvalues to suitable accuracy.'),('*     (d) For each eigenvalue with a large enough relative separation compute'),('*         the corresponding eigenvector by forming a rank revealing twisted'),('*         factorization. Go back to (c) for any clusters that remain.'),('*'),('*  The desired accuracy of the output can be specified by the input'),('*  parameter ABSTOL.'),('*'),('*  For more details, see DSTEMR\'s documentation and:'),('*  - Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations'),('*    to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"'),('*    Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.'),('*  - Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and'),('*    Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,'),('*    2004.  Also LAPACK Working Note 154.'),('*  - Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric'),('*    tridiagonal eigenvalue/eigenvector problem\",'),('*    Computer Science Division Technical Report No. UCB/CSD-97-971,'),('*    UC Berkeley, May 1997.'),('*'),('*'),('*  Note 1 : CHEEVR calls CSTEMR when the full spectrum is requested'),('*  on machines which conform to the ieee-754 floating point standard.'),('*  CHEEVR calls SSTEBZ and CSTEIN on non-ieee machines and'),('*  when partial spectrum requests are made.'),('*'),('*  Normal execution of CSTEMR may create NaNs and infinities and'),('*  hence may abort due to a floating point exception in environments'),('*  which do not handle NaNs and infinities in the ieee standard default'),('*  manner.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('********** For RANGE = \'V\' or \'I\' and IU - IL < N - 1, SSTEBZ and'),('********** CSTEIN are called'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*          If high relative accuracy is important, set ABSTOL to'),('*          SLAMCH( \'Safe minimum\' ).  Doing so will guarantee that'),('*          eigenvalues are computed to high relative accuracy when'),('*          possible in future releases.  The current code does not'),('*          make any guarantees about high relative accuracy, but'),('*          furutre releases will. See J. Barlow and J. Demmel,'),('*          \"Computing Accurate Eigensystems of Scaled Diagonally'),('*          Dominant Matrices\", LAPACK Working Note #7, for a discussion'),('*          of which matrices define their eigenvalues to high relative'),('*          accuracy.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  ISUPPZ  (output) INTEGER array, dimension ( 2*max(1,M) )'),('*          The support of the eigenvectors in Z, i.e., the indices'),('*          indicating the nonzero elements in Z. The i-th eigenvector'),('*          is nonzero only in elements ISUPPZ( 2*i-1 ) through'),('*          ISUPPZ( 2*i ).'),('********** Implemented only for RANGE = \'A\' or \'I\' and IU - IL = N - 1'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,2*N).'),('*          For optimal efficiency, LWORK >= (NB+1)*N,'),('*          where NB is the max of the blocksize for CHETRD and for'),('*          CUNMTR as returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) REAL array, dimension (MAX(1,LRWORK))'),('*          On exit, if INFO = 0, RWORK(1) returns the optimal'),('*          (and minimal) LRWORK.'),('*'),('* LRWORK   (input) INTEGER'),('*          The length of the array RWORK.  LRWORK >= max(1,24*N).'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal'),('*          (and minimal) LIWORK.'),('*'),('* LIWORK   (input) INTEGER'),('*          The dimension of the array IWORK.  LIWORK >= max(1,10*N).'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  Internal error'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Inderjit Dhillon, IBM Almaden, USA'),('*     Osni Marques, LBNL/NERSC, USA'),('*     Ken Stanley, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*     Jason Riedy, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `cheevr_Table147` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cheevx_Table119`
--

DROP TABLE IF EXISTS `cheevx_Table119`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cheevx_Table119` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cheevx_Table119`
--

LOCK TABLES `cheevx_Table119` WRITE;
/*!40000 ALTER TABLE `cheevx_Table119` DISABLE KEYS */;
INSERT INTO `cheevx_Table119` VALUES ('      SUBROUTINE CHEEVX( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, WORK, LWORK, RWORK,'),('     $                   IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDA, LDZ, LWORK, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            A( LDA, * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHEEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can'),('*  be selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          On normal exit, the first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= 1, when N <= 1;'),('*          otherwise 2*N.'),('*          For optimal efficiency, LWORK >= (NB+1)*N,'),('*          where NB is the max of the blocksize for CHETRD and for'),('*          CUNMTR as returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `cheevx_Table119` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chegv_Table153`
--

DROP TABLE IF EXISTS `chegv_Table153`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chegv_Table153` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chegv_Table153`
--

LOCK TABLES `chegv_Table153` WRITE;
/*!40000 ALTER TABLE `chegv_Table153` DISABLE KEYS */;
INSERT INTO `chegv_Table153` VALUES ('      SUBROUTINE CHEGV( ITYPE, JOBZ, UPLO, N, A, LDA, B, LDB, W, WORK,'),('     $                  LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDA, LDB, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHEGV computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.'),('*  Here A and B are assumed to be Hermitian and B is also'),('*  positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          matrix Z of eigenvectors.  The eigenvectors are normalized'),('*          as follows:'),('*          if ITYPE = 1 or 2, Z**H*B*Z = I;'),('*          if ITYPE = 3, Z**H*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then on exit the upper triangle (if UPLO=\'U\')'),('*          or the lower triangle (if UPLO=\'L\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB, N)'),('*          On entry, the Hermitian positive definite matrix B.'),('*          If UPLO = \'U\', the leading N-by-N upper triangular part of B'),('*          contains the upper triangular part of the matrix B.'),('*          If UPLO = \'L\', the leading N-by-N lower triangular part of B'),('*          contains the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,2*N-1).'),('*          For optimal efficiency, LWORK >= (NB+1)*N,'),('*          where NB is the blocksize for CHETRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (max(1, 3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  CPOTRF or CHEEV returned an error code:'),('*             <= N:  if INFO = i, CHEEV failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `chegv_Table153` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chegvd_Table177`
--

DROP TABLE IF EXISTS `chegvd_Table177`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chegvd_Table177` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chegvd_Table177`
--

LOCK TABLES `chegvd_Table177` WRITE;
/*!40000 ALTER TABLE `chegvd_Table177` DISABLE KEYS */;
INSERT INTO `chegvd_Table177` VALUES ('      SUBROUTINE CHEGVD( ITYPE, JOBZ, UPLO, N, A, LDA, B, LDB, W, WORK,'),('     $                   LWORK, RWORK, LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDA, LDB, LIWORK, LRWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHEGVD computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be Hermitian and B is also positive definite.'),('*  If eigenvectors are desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          matrix Z of eigenvectors.  The eigenvectors are normalized'),('*          as follows:'),('*          if ITYPE = 1 or 2, Z**H*B*Z = I;'),('*          if ITYPE = 3, Z**H*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then on exit the upper triangle (if UPLO=\'U\')'),('*          or the lower triangle (if UPLO=\'L\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB, N)'),('*          On entry, the Hermitian matrix B.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of B contains the'),('*          upper triangular part of the matrix B.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of B contains'),('*          the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.'),('*          If N <= 1,                LWORK >= 1.'),('*          If JOBZ  = \'N\' and N > 1, LWORK >= N + 1.'),('*          If JOBZ  = \'V\' and N > 1, LWORK >= 2*N + N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) REAL array, dimension (MAX(1,LRWORK))'),('*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of the array RWORK.'),('*          If N <= 1,                LRWORK >= 1.'),('*          If JOBZ  = \'N\' and N > 1, LRWORK >= N.'),('*          If JOBZ  = \'V\' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If N <= 1,                LIWORK >= 1.'),('*          If JOBZ  = \'N\' and N > 1, LIWORK >= 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  CPOTRF or CHEEVD returned an error code:'),('*             <= N:  if INFO = i and JOBZ = \'N\', then the algorithm'),('*                    failed to converge; i off-diagonal elements of an'),('*                    intermediate tridiagonal form did not converge to'),('*                    zero;'),('*                    if INFO = i and JOBZ = \'V\', then the algorithm'),('*                    failed to compute an eigenvalue while working on'),('*                    the submatrix lying in rows and columns INFO/(N+1)'),('*                    through mod(INFO,N+1);'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*'),('*  Modified so that no backsubstitution is performed if CHEEVD fails to'),('*  converge (NEIG in old code could be greater than N causing out of'),('*  bounds reference to A - reported by Ralf Meyer).  Also corrected the'),('*  description of INFO and the test on ITYPE. Sven, 16 Feb 05.');
/*!40000 ALTER TABLE `chegvd_Table177` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chegvx_Table165`
--

DROP TABLE IF EXISTS `chegvx_Table165`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chegvx_Table165` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chegvx_Table165`
--

LOCK TABLES `chegvx_Table165` WRITE;
/*!40000 ALTER TABLE `chegvx_Table165` DISABLE KEYS */;
INSERT INTO `chegvx_Table165` VALUES ('      SUBROUTINE CHEGVX( ITYPE, JOBZ, RANGE, UPLO, N, A, LDA, B, LDB,'),('     $                   VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK,'),('     $                   LWORK, RWORK, IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, ITYPE, IU, LDA, LDB, LDZ, LWORK, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHEGVX computes selected eigenvalues, and optionally, eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be Hermitian and B is also positive definite.'),('*  Eigenvalues and eigenvectors can be selected by specifying either a'),('*  range of values or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('**'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit,  the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB, N)'),('*          On entry, the Hermitian matrix B.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of B contains the'),('*          upper triangular part of the matrix B.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of B contains'),('*          the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          The first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,2*N).'),('*          For optimal efficiency, LWORK >= (NB+1)*N,'),('*          where NB is the blocksize for CHETRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  CPOTRF or CHEEVX returned an error code:'),('*             <= N:  if INFO = i, CHEEVX failed to converge;'),('*                    i eigenvectors failed to converge.  Their indices'),('*                    are stored in array IFAIL.'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `chegvx_Table165` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chesv_Table13`
--

DROP TABLE IF EXISTS `chesv_Table13`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chesv_Table13` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chesv_Table13`
--

LOCK TABLES `chesv_Table13` WRITE;
/*!40000 ALTER TABLE `chesv_Table13` DISABLE KEYS */;
INSERT INTO `chesv_Table13` VALUES ('      SUBROUTINE CHESV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,'),('     $                  LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.3.0) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHESV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**H,  if UPLO = \'U\', or'),('*     A = L * D * L**H,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, and D is Hermitian and block diagonal with '),('*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then'),('*  used to solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.'),('*'),('*          On exit, if INFO = 0, the block diagonal matrix D and the'),('*          multipliers used to obtain the factor U or L from the'),('*          factorization A = U*D*U**H or A = L*D*L**H as computed by'),('*          CHETRF.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by CHETRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= 1, and for best performance'),('*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for'),('*          CHETRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization'),('*               has been completed, but the block diagonal matrix D is'),('*               exactly singular, so the solution could not be computed.'),('*');
/*!40000 ALTER TABLE `chesv_Table13` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chesvx_Table53`
--

DROP TABLE IF EXISTS `chesvx_Table53`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chesvx_Table53` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chesvx_Table53`
--

LOCK TABLES `chesvx_Table53` WRITE;
/*!40000 ALTER TABLE `chesvx_Table53` DISABLE KEYS */;
INSERT INTO `chesvx_Table53` VALUES ('      SUBROUTINE CHESVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,'),('     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,'),('     $                   RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               BERR( * ), FERR( * ), RWORK( * )'),('      COMPLEX            A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHESVX uses the diagonal pivoting factorization to compute the'),('*  solution to a complex system of linear equations A * X = B,'),('*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.'),('*     The form of the factorization is'),('*        A = U * D * U**H,  if UPLO = \'U\', or'),('*        A = L * D * L**H,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices, and D is Hermitian and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AF and IPIV contain the factored form'),('*                  of A.  A, AF and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input) COMPLEX array, dimension (LDA,N)'),('*          The Hermitian matrix A.  If UPLO = \'U\', the leading N-by-N'),('*          upper triangular part of A contains the upper triangular part'),('*          of the matrix A, and the strictly lower triangular part of A'),('*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower'),('*          triangular part of A contains the lower triangular part of'),('*          the matrix A, and the strictly upper triangular part of A is'),('*          not referenced.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) COMPLEX array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**H or A = L*D*L**H as computed by CHETRF.'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**H or A = L*D*L**H.'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by CHETRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by CHETRF.'),('*'),('*  B       (input) COMPLEX array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= max(1,2*N), and for best'),('*          performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where'),('*          NB is the optimal blocksize for CHETRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `chesvx_Table53` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chpev_Table109`
--

DROP TABLE IF EXISTS `chpev_Table109`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chpev_Table109` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chpev_Table109`
--

LOCK TABLES `chpev_Table109` WRITE;
/*!40000 ALTER TABLE `chpev_Table109` DISABLE KEYS */;
INSERT INTO `chpev_Table109` VALUES ('      SUBROUTINE CHPEV( JOBZ, UPLO, N, AP, W, Z, LDZ, WORK, RWORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHPEV computes all the eigenvalues and, optionally, eigenvectors of a'),('*  complex Hermitian matrix in packed storage.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (max(1, 2*N-1))'),('*'),('*  RWORK   (workspace) REAL array, dimension (max(1, 3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `chpev_Table109` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chpevd_Table137`
--

DROP TABLE IF EXISTS `chpevd_Table137`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chpevd_Table137` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chpevd_Table137`
--

LOCK TABLES `chpevd_Table137` WRITE;
/*!40000 ALTER TABLE `chpevd_Table137` DISABLE KEYS */;
INSERT INTO `chpevd_Table137` VALUES ('      SUBROUTINE CHPEVD( JOBZ, UPLO, N, AP, W, Z, LDZ, WORK, LWORK,'),('     $                   RWORK, LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDZ, LIWORK, LRWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHPEVD computes all the eigenvalues and, optionally, eigenvectors of'),('*  a complex Hermitian matrix A in packed storage.  If eigenvectors are'),('*  desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the required LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of array WORK.'),('*          If N <= 1,               LWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK must be at least N.'),('*          If JOBZ = \'V\' and N > 1, LWORK must be at least 2*N.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the required sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) REAL array, dimension (MAX(1,LRWORK))'),('*          On exit, if INFO = 0, RWORK(1) returns the required LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of array RWORK.'),('*          If N <= 1,               LRWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LRWORK must be at least N.'),('*          If JOBZ = \'V\' and N > 1, LRWORK must be at least'),('*                    1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the required LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK must be at least 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `chpevd_Table137` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chpevx_Table123`
--

DROP TABLE IF EXISTS `chpevx_Table123`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chpevx_Table123` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chpevx_Table123`
--

LOCK TABLES `chpevx_Table123` WRITE;
/*!40000 ALTER TABLE `chpevx_Table123` DISABLE KEYS */;
INSERT INTO `chpevx_Table123` VALUES ('      SUBROUTINE CHPEVX( JOBZ, RANGE, UPLO, N, AP, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, WORK, RWORK, IWORK,'),('     $                   IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDZ, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHPEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a complex Hermitian matrix A in packed storage.'),('*  Eigenvalues/vectors can be selected by specifying either a range of'),('*  values or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AP to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the selected eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and'),('*          the index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (2*N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `chpevx_Table123` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chpgv_Table157`
--

DROP TABLE IF EXISTS `chpgv_Table157`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chpgv_Table157` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chpgv_Table157`
--

LOCK TABLES `chpgv_Table157` WRITE;
/*!40000 ALTER TABLE `chpgv_Table157` DISABLE KEYS */;
INSERT INTO `chpgv_Table157` VALUES ('      SUBROUTINE CHPGV( ITYPE, JOBZ, UPLO, N, AP, BP, W, Z, LDZ, WORK,'),('     $                  RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AP( * ), BP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHPGV computes all the eigenvalues and, optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.'),('*  Here A and B are assumed to be Hermitian, stored in packed format,'),('*  and B is also positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H, in the same storage'),('*          format as B.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors.  The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**H*B*Z = I;'),('*          if ITYPE = 3, Z**H*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (max(1, 2*N-1))'),('*'),('*  RWORK   (workspace) REAL array, dimension (max(1, 3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  CPPTRF or CHPEV returned an error code:'),('*             <= N:  if INFO = i, CHPEV failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not convergeto zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `chpgv_Table157` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chpgvd_Table181`
--

DROP TABLE IF EXISTS `chpgvd_Table181`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chpgvd_Table181` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chpgvd_Table181`
--

LOCK TABLES `chpgvd_Table181` WRITE;
/*!40000 ALTER TABLE `chpgvd_Table181` DISABLE KEYS */;
INSERT INTO `chpgvd_Table181` VALUES ('      SUBROUTINE CHPGVD( ITYPE, JOBZ, UPLO, N, AP, BP, W, Z, LDZ, WORK,'),('     $                   LWORK, RWORK, LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDZ, LIWORK, LRWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AP( * ), BP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHPGVD computes all the eigenvalues and, optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be Hermitian, stored in packed format, and B is also'),('*  positive definite.'),('*  If eigenvectors are desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H, in the same storage'),('*          format as B.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors.  The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**H*B*Z = I;'),('*          if ITYPE = 3, Z**H*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the required LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of array WORK.'),('*          If N <= 1,               LWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK >= N.'),('*          If JOBZ = \'V\' and N > 1, LWORK >= 2*N.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the required sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (MAX(1,LRWORK))'),('*          On exit, if INFO = 0, RWORK(1) returns the required LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of array RWORK.'),('*          If N <= 1,               LRWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LRWORK >= N.'),('*          If JOBZ = \'V\' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the required LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK >= 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  CPPTRF or CHPEVD returned an error code:'),('*             <= N:  if INFO = i, CHPEVD failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not convergeto zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `chpgvd_Table181` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chpgvx_Table169`
--

DROP TABLE IF EXISTS `chpgvx_Table169`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chpgvx_Table169` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chpgvx_Table169`
--

LOCK TABLES `chpgvx_Table169` WRITE;
/*!40000 ALTER TABLE `chpgvx_Table169` DISABLE KEYS */;
INSERT INTO `chpgvx_Table169` VALUES ('      SUBROUTINE CHPGVX( ITYPE, JOBZ, RANGE, UPLO, N, AP, BP, VL, VU,'),('     $                   IL, IU, ABSTOL, M, W, Z, LDZ, WORK, RWORK,'),('     $                   IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, ITYPE, IU, LDZ, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               RWORK( * ), W( * )'),('      COMPLEX            AP( * ), BP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHPGVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be Hermitian, stored in packed format, and B is also'),('*  positive definite.  Eigenvalues and eigenvectors can be selected by'),('*  specifying either a range of values or a range of indices for the'),('*  desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H, in the same storage'),('*          format as B.'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AP to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          On normal exit, the first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX array, dimension (LDZ, N)'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**H*B*Z = I;'),('*          if ITYPE = 3, Z**H*inv(B)*Z = I.'),('*'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (2*N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  CPPTRF or CHPEVX returned an error code:'),('*             <= N:  if INFO = i, CHPEVX failed to converge;'),('*                    i eigenvectors failed to converge.  Their indices'),('*                    are stored in array IFAIL.'),('*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `chpgvx_Table169` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chpsv_Table15`
--

DROP TABLE IF EXISTS `chpsv_Table15`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chpsv_Table15` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chpsv_Table15`
--

LOCK TABLES `chpsv_Table15` WRITE;
/*!40000 ALTER TABLE `chpsv_Table15` DISABLE KEYS */;
INSERT INTO `chpsv_Table15` VALUES ('      SUBROUTINE CHPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX            AP( * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHPSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian matrix stored in packed format and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**H,  if UPLO = \'U\', or'),('*     A = L * D * L**H,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, D is Hermitian and block diagonal with 1-by-1'),('*  and 2-by-2 diagonal blocks.  The factored form of A is then used to'),('*  solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*          On exit, the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by CHPTRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization'),('*                has been completed, but the block diagonal matrix D is'),('*                exactly singular, so the solution could not be'),('*                computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the Hermitian matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `chpsv_Table15` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `chpsvx_Table55`
--

DROP TABLE IF EXISTS `chpsvx_Table55`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `chpsvx_Table55` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `chpsvx_Table55`
--

LOCK TABLES `chpsvx_Table55` WRITE;
/*!40000 ALTER TABLE `chpsvx_Table55` DISABLE KEYS */;
INSERT INTO `chpsvx_Table55` VALUES ('      SUBROUTINE CHPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,'),('     $                   LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               BERR( * ), FERR( * ), RWORK( * )'),('      COMPLEX            AFP( * ), AP( * ), B( LDB, * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or'),('*  A = L*D*L**H to compute the solution to a complex system of linear'),('*  equations A * X = B, where A is an N-by-N Hermitian matrix stored'),('*  in packed format and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as'),('*        A = U * D * U**H,  if UPLO = \'U\', or'),('*        A = L * D * L**H,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices and D is Hermitian and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AFP and IPIV contain the factored form of'),('*                  A.  AFP and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AFP and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)'),('*          The upper or lower triangle of the Hermitian matrix A, packed'),('*          columnwise in a linear array.  The j-th column of A is stored'),('*          in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*  AFP     (input or output) COMPLEX array, dimension (N*(N+1)/2)'),('*          If FACT = \'F\', then AFP is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*          If FACT = \'N\', then AFP is an output argument and on exit'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by CHPTRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by CHPTRF.'),('*'),('*  B       (input) COMPLEX array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (2*N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the Hermitian matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `chpsvx_Table55` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cpbsv_Table23`
--

DROP TABLE IF EXISTS `cpbsv_Table23`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cpbsv_Table23` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cpbsv_Table23`
--

LOCK TABLES `cpbsv_Table23` WRITE;
/*!40000 ALTER TABLE `cpbsv_Table23` DISABLE KEYS */;
INSERT INTO `cpbsv_Table23` VALUES ('      SUBROUTINE CPBSV( UPLO, N, KD, NRHS, AB, LDAB, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, KD, LDAB, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX            AB( LDAB, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CPBSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite band matrix and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**H * U,  if UPLO = \'U\', or'),('*     A = L * L**H,  if UPLO = \'L\','),('*  where U is an upper triangular band matrix, and L is a lower'),('*  triangular band matrix, with the same number of superdiagonals or'),('*  subdiagonals as A.  The factored form of A is then used to solve the'),('*  system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AB      (input/output) COMPLEX array, dimension (LDAB,N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).'),('*          See below for further details.'),('*'),('*          On exit, if INFO = 0, the triangular factor U or L from the'),('*          Cholesky factorization A = U**H*U or A = L*L**H of the band'),('*          matrix A, in the same storage format as A.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD+1.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  N = 6, KD = 2, and UPLO = \'U\':'),('*'),('*  On entry:                       On exit:'),('*'),('*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46'),('*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56'),('*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66'),('*'),('*  Similarly, if UPLO = \'L\' the format of A is as follows:'),('*'),('*  On entry:                       On exit:'),('*'),('*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66'),('*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *'),('*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *'),('*'),('*  Array elements marked * are not used by the routine.'),('*');
/*!40000 ALTER TABLE `cpbsv_Table23` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cpbsvx_Table63`
--

DROP TABLE IF EXISTS `cpbsvx_Table63`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cpbsvx_Table63` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cpbsvx_Table63`
--

LOCK TABLES `cpbsvx_Table63` WRITE;
/*!40000 ALTER TABLE `cpbsvx_Table63` DISABLE KEYS */;
INSERT INTO `cpbsvx_Table63` VALUES ('      SUBROUTINE CPBSVX( FACT, UPLO, N, KD, NRHS, AB, LDAB, AFB, LDAFB,'),('     $                   EQUED, S, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, KD, LDAB, LDAFB, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               BERR( * ), FERR( * ), RWORK( * ), S( * )'),('      COMPLEX            AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to'),('*  compute the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite band matrix and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U**H * U,  if UPLO = \'U\', or'),('*        A = L * L**H,  if UPLO = \'L\','),('*     where U is an upper triangular band matrix, and L is a lower'),('*     triangular band matrix.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFB contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  AB and AFB will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AFB and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFB and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right-hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AB      (input/output) COMPLEX array, dimension (LDAB,N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first KD+1 rows of the array, except'),('*          if FACT = \'F\' and EQUED = \'Y\', then A must contain the'),('*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A'),('*          is stored in the j-th column of the array AB as follows:'),('*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).'),('*          See below for further details.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array A.  LDAB >= KD+1.'),('*'),('*  AFB     (input or output) COMPLEX array, dimension (LDAFB,N)'),('*          If FACT = \'F\', then AFB is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the band matrix'),('*          A, in the same storage format as A (see AB).  If EQUED = \'Y\','),('*          then AFB is the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFB is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H.'),('*'),('*          If FACT = \'E\', then AFB is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the equilibrated'),('*          matrix A (see the description of A for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAFB   (input) INTEGER'),('*          The leading dimension of the array AFB.  LDAFB >= KD+1.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) REAL array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (2*N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  N = 6, KD = 2, and UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the Hermitian matrix A:'),('*'),('*     a11  a12  a13'),('*          a22  a23  a24'),('*               a33  a34  a35'),('*                    a44  a45  a46'),('*                         a55  a56'),('*     (aij=conjg(aji))         a66'),('*'),('*  Band storage of the upper triangle of A:'),('*'),('*      *    *   a13  a24  a35  a46'),('*      *   a12  a23  a34  a45  a56'),('*     a11  a22  a33  a44  a55  a66'),('*'),('*  Similarly, if UPLO = \'L\' the format of A is as follows:'),('*'),('*     a11  a22  a33  a44  a55  a66'),('*     a21  a32  a43  a54  a65   *'),('*     a31  a42  a53  a64   *    *'),('*'),('*  Array elements marked * are not used by the routine.'),('*');
/*!40000 ALTER TABLE `cpbsvx_Table63` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cposv_Table19`
--

DROP TABLE IF EXISTS `cposv_Table19`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cposv_Table19` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cposv_Table19`
--

LOCK TABLES `cposv_Table19` WRITE;
/*!40000 ALTER TABLE `cposv_Table19` DISABLE KEYS */;
INSERT INTO `cposv_Table19` VALUES ('      SUBROUTINE CPOSV( UPLO, N, NRHS, A, LDA, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDA, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX            A( LDA, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CPOSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite matrix and X and B'),('*  are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**H* U,  if UPLO = \'U\', or'),('*     A = L * L**H,  if UPLO = \'L\','),('*  where U is an upper triangular matrix and  L is a lower triangular'),('*  matrix.  The factored form of A is then used to solve the system of'),('*  equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.'),('*'),('*          On exit, if INFO = 0, the factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*');
/*!40000 ALTER TABLE `cposv_Table19` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cposvx_Table59`
--

DROP TABLE IF EXISTS `cposvx_Table59`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cposvx_Table59` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cposvx_Table59`
--

LOCK TABLES `cposvx_Table59` WRITE;
/*!40000 ALTER TABLE `cposvx_Table59` DISABLE KEYS */;
INSERT INTO `cposvx_Table59` VALUES ('      SUBROUTINE CPOSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, EQUED,'),('     $                   S, B, LDB, X, LDX, RCOND, FERR, BERR, WORK,'),('     $                   RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               BERR( * ), FERR( * ), RWORK( * ), S( * )'),('      COMPLEX            A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to'),('*  compute the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite matrix and X and B'),('*  are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U**H* U,  if UPLO = \'U\', or'),('*        A = L * L**H,  if UPLO = \'L\','),('*     where U is an upper triangular matrix and L is a lower triangular'),('*     matrix.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AF contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  A and AF will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AF and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the Hermitian matrix A, except if FACT = \'F\' and'),('*          EQUED = \'Y\', then A must contain the equilibrated matrix'),('*          diag(S)*A*diag(S).  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.  A is not modified if'),('*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) COMPLEX array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H, in the same storage'),('*          format as A.  If EQUED .ne. \'N\', then AF is the factored form'),('*          of the equilibrated matrix diag(S)*A*diag(S).'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the original'),('*          matrix A.'),('*'),('*          If FACT = \'E\', then AF is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the equilibrated'),('*          matrix A (see the description of A for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) REAL array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS righthand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (2*N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `cposvx_Table59` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cppsv_Table27`
--

DROP TABLE IF EXISTS `cppsv_Table27`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cppsv_Table27` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cppsv_Table27`
--

LOCK TABLES `cppsv_Table27` WRITE;
/*!40000 ALTER TABLE `cppsv_Table27` DISABLE KEYS */;
INSERT INTO `cppsv_Table27` VALUES ('      SUBROUTINE CPPSV( UPLO, N, NRHS, AP, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX            AP( * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CPPSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite matrix stored in'),('*  packed format and X and B are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**H* U,  if UPLO = \'U\', or'),('*     A = L * L**H,  if UPLO = \'L\','),('*  where U is an upper triangular matrix and L is a lower triangular'),('*  matrix.  The factored form of A is then used to solve the system of'),('*  equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.  '),('*'),('*          On exit, if INFO = 0, the factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H, in the same storage'),('*          format as A.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the Hermitian matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `cppsv_Table27` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cppsvx_Table67`
--

DROP TABLE IF EXISTS `cppsvx_Table67`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cppsvx_Table67` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cppsvx_Table67`
--

LOCK TABLES `cppsvx_Table67` WRITE;
/*!40000 ALTER TABLE `cppsvx_Table67` DISABLE KEYS */;
INSERT INTO `cppsvx_Table67` VALUES ('      SUBROUTINE CPPSVX( FACT, UPLO, N, NRHS, AP, AFP, EQUED, S, B, LDB,'),('     $                   X, LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               BERR( * ), FERR( * ), RWORK( * ), S( * )'),('      COMPLEX            AFP( * ), AP( * ), B( LDB, * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to'),('*  compute the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite matrix stored in'),('*  packed format and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U\'* U ,  if UPLO = \'U\', or'),('*        A = L * L\',  if UPLO = \'L\','),('*     where U is an upper triangular matrix, L is a lower triangular'),('*     matrix, and \' indicates conjugate transpose.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFP contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  AP and AFP will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AFP and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFP and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array, except if FACT = \'F\''),('*          and EQUED = \'Y\', then A must contain the equilibrated matrix'),('*          diag(S)*A*diag(S).  The j-th column of A is stored in the'),('*          array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.  A is not modified if'),('*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  AFP     (input or output) COMPLEX array, dimension (N*(N+1)/2)'),('*          If FACT = \'F\', then AFP is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H, in the same storage'),('*          format as A.  If EQUED .ne. \'N\', then AFP is the factored'),('*          form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFP is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the original'),('*          matrix A.'),('*'),('*          If FACT = \'E\', then AFP is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the equilibrated'),('*          matrix A (see the description of AP for the form of the'),('*          equilibrated matrix).'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) REAL array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (2*N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the Hermitian matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `cppsvx_Table67` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cptsv_Table31`
--

DROP TABLE IF EXISTS `cptsv_Table31`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cptsv_Table31` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cptsv_Table31`
--

LOCK TABLES `cptsv_Table31` WRITE;
/*!40000 ALTER TABLE `cptsv_Table31` DISABLE KEYS */;
INSERT INTO `cptsv_Table31` VALUES ('      SUBROUTINE CPTSV( N, NRHS, D, E, B, LDB, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               D( * )'),('      COMPLEX            B( LDB, * ), E( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CPTSV computes the solution to a complex system of linear equations'),('*  A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal'),('*  matrix, and X and B are N-by-NRHS matrices.'),('*'),('*  A is factored as A = L*D*L**H, and the factored form of A is then'),('*  used to solve the system of equations.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  D       (input/output) REAL array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.  On exit, the n diagonal elements of the diagonal matrix'),('*          D from the factorization A = L*D*L**H.'),('*'),('*  E       (input/output) COMPLEX array, dimension (N-1)'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A.  On exit, the (n-1) subdiagonal elements of the'),('*          unit bidiagonal factor L from the L*D*L**H factorization of'),('*          A.  E can also be regarded as the superdiagonal of the unit'),('*          bidiagonal factor U from the U**H*D*U factorization of A.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i is not'),('*                positive definite, and the solution has not been'),('*                computed.  The factorization has not been completed'),('*                unless i = N.'),('*');
/*!40000 ALTER TABLE `cptsv_Table31` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cptsvx_Table71`
--

DROP TABLE IF EXISTS `cptsvx_Table71`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cptsvx_Table71` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cptsvx_Table71`
--

LOCK TABLES `cptsvx_Table71` WRITE;
/*!40000 ALTER TABLE `cptsvx_Table71` DISABLE KEYS */;
INSERT INTO `cptsvx_Table71` VALUES ('      SUBROUTINE CPTSVX( FACT, N, NRHS, D, E, DF, EF, B, LDB, X, LDX,'),('     $                   RCOND, FERR, BERR, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               BERR( * ), D( * ), DF( * ), FERR( * ),'),('     $                   RWORK( * )'),('      COMPLEX            B( LDB, * ), E( * ), EF( * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CPTSVX uses the factorization A = L*D*L**H to compute the solution'),('*  to a complex system of linear equations A*X = B, where A is an'),('*  N-by-N Hermitian positive definite tridiagonal matrix and X and B'),('*  are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the matrix A is factored as A = L*D*L**H, where L'),('*     is a unit lower bidiagonal matrix and D is diagonal.  The'),('*     factorization can also be regarded as having the form'),('*     A = U**H*D*U.'),('*'),('*  2. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix'),('*          A is supplied on entry.'),('*          = \'F\':  On entry, DF and EF contain the factored form of A.'),('*                  D, E, DF, and EF will not be modified.'),('*          = \'N\':  The matrix A will be copied to DF and EF and'),('*                  factored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  D       (input) REAL array, dimension (N)'),('*          The n diagonal elements of the tridiagonal matrix A.'),('*'),('*  E       (input) COMPLEX array, dimension (N-1)'),('*          The (n-1) subdiagonal elements of the tridiagonal matrix A.'),('*'),('*  DF      (input or output) REAL array, dimension (N)'),('*          If FACT = \'F\', then DF is an input argument and on entry'),('*          contains the n diagonal elements of the diagonal matrix D'),('*          from the L*D*L**H factorization of A.'),('*          If FACT = \'N\', then DF is an output argument and on exit'),('*          contains the n diagonal elements of the diagonal matrix D'),('*          from the L*D*L**H factorization of A.'),('*'),('*  EF      (input or output) COMPLEX array, dimension (N-1)'),('*          If FACT = \'F\', then EF is an input argument and on entry'),('*          contains the (n-1) subdiagonal elements of the unit'),('*          bidiagonal factor L from the L*D*L**H factorization of A.'),('*          If FACT = \'N\', then EF is an output argument and on exit'),('*          contains the (n-1) subdiagonal elements of the unit'),('*          bidiagonal factor L from the L*D*L**H factorization of A.'),('*'),('*  B       (input) COMPLEX array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The reciprocal condition number of the matrix A.  If RCOND'),('*          is less than the machine precision (in particular, if'),('*          RCOND = 0), the matrix is singular to working precision.'),('*          This condition is indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in any'),('*          element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `cptsvx_Table71` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cspsv_Table39`
--

DROP TABLE IF EXISTS `cspsv_Table39`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cspsv_Table39` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cspsv_Table39`
--

LOCK TABLES `cspsv_Table39` WRITE;
/*!40000 ALTER TABLE `cspsv_Table39` DISABLE KEYS */;
INSERT INTO `cspsv_Table39` VALUES ('      SUBROUTINE CSPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX            AP( * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CSPSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric matrix stored in packed format and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**T,  if UPLO = \'U\', or'),('*     A = L * D * L**T,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, D is symmetric and block diagonal with 1-by-1'),('*  and 2-by-2 diagonal blocks.  The factored form of A is then used to'),('*  solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AP      (input/output) COMPLEX array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*          On exit, the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by CSPTRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization'),('*                has been completed, but the block diagonal matrix D is'),('*                exactly singular, so the solution could not be'),('*                computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = aji)'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `cspsv_Table39` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `cspsvx_Table79`
--

DROP TABLE IF EXISTS `cspsvx_Table79`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `cspsvx_Table79` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `cspsvx_Table79`
--

LOCK TABLES `cspsvx_Table79` WRITE;
/*!40000 ALTER TABLE `cspsvx_Table79` DISABLE KEYS */;
INSERT INTO `cspsvx_Table79` VALUES ('      SUBROUTINE CSPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,'),('     $                   LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               BERR( * ), FERR( * ), RWORK( * )'),('      COMPLEX            AFP( * ), AP( * ), B( LDB, * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CSPSVX uses the diagonal pivoting factorization A = U*D*U**T or'),('*  A = L*D*L**T to compute the solution to a complex system of linear'),('*  equations A * X = B, where A is an N-by-N symmetric matrix stored'),('*  in packed format and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as'),('*        A = U * D * U**T,  if UPLO = \'U\', or'),('*        A = L * D * L**T,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices and D is symmetric and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AFP and IPIV contain the factored form'),('*                  of A.  AP, AFP and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AFP and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AP      (input) COMPLEX array, dimension (N*(N+1)/2)'),('*          The upper or lower triangle of the symmetric matrix A, packed'),('*          columnwise in a linear array.  The j-th column of A is stored'),('*          in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*  AFP     (input or output) COMPLEX array, dimension (N*(N+1)/2)'),('*          If FACT = \'F\', then AFP is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*          If FACT = \'N\', then AFP is an output argument and on exit'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by CSPTRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by CSPTRF.'),('*'),('*  B       (input) COMPLEX array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX array, dimension (2*N)'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = aji)'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `cspsvx_Table79` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `csysv_Table35`
--

DROP TABLE IF EXISTS `csysv_Table35`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `csysv_Table35` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `csysv_Table35`
--

LOCK TABLES `csysv_Table35` WRITE;
/*!40000 ALTER TABLE `csysv_Table35` DISABLE KEYS */;
INSERT INTO `csysv_Table35` VALUES ('      SUBROUTINE CSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,'),('     $                  LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX            A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CSYSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**T,  if UPLO = \'U\', or'),('*     A = L * D * L**T,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, and D is symmetric and block diagonal with '),('*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then'),('*  used to solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX array, dimension (LDA,N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.'),('*'),('*          On exit, if INFO = 0, the block diagonal matrix D and the'),('*          multipliers used to obtain the factor U or L from the'),('*          factorization A = U*D*U**T or A = L*D*L**T as computed by'),('*          CSYTRF.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by CSYTRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) COMPLEX array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= 1, and for best performance'),('*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for'),('*          CSYTRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization'),('*               has been completed, but the block diagonal matrix D is'),('*               exactly singular, so the solution could not be computed.'),('*');
/*!40000 ALTER TABLE `csysv_Table35` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `csysvx_Table75`
--

DROP TABLE IF EXISTS `csysvx_Table75`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `csysvx_Table75` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `csysvx_Table75`
--

LOCK TABLES `csysvx_Table75` WRITE;
/*!40000 ALTER TABLE `csysvx_Table75` DISABLE KEYS */;
INSERT INTO `csysvx_Table75` VALUES ('      SUBROUTINE CSYSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,'),('     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,'),('     $                   RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               BERR( * ), FERR( * ), RWORK( * )'),('      COMPLEX            A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  CSYSVX uses the diagonal pivoting factorization to compute the'),('*  solution to a complex system of linear equations A * X = B,'),('*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.'),('*     The form of the factorization is'),('*        A = U * D * U**T,  if UPLO = \'U\', or'),('*        A = L * D * L**T,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices, and D is symmetric and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AF and IPIV contain the factored form'),('*                  of A.  A, AF and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input) COMPLEX array, dimension (LDA,N)'),('*          The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N'),('*          upper triangular part of A contains the upper triangular part'),('*          of the matrix A, and the strictly lower triangular part of A'),('*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower'),('*          triangular part of A contains the lower triangular part of'),('*          the matrix A, and the strictly upper triangular part of A is'),('*          not referenced.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) COMPLEX array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by CSYTRF.'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T.'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by CSYTRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by CSYTRF.'),('*'),('*  B       (input) COMPLEX array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace/output) COMPLEX array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= max(1,2*N), and for best'),('*          performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where'),('*          NB is the optimal blocksize for CSYTRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `csysvx_Table75` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgbsv_Table6`
--

DROP TABLE IF EXISTS `dgbsv_Table6`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgbsv_Table6` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgbsv_Table6`
--

LOCK TABLES `dgbsv_Table6` WRITE;
/*!40000 ALTER TABLE `dgbsv_Table6` DISABLE KEYS */;
INSERT INTO `dgbsv_Table6` VALUES ('      SUBROUTINE DGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   AB( LDAB, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGBSV computes the solution to a real system of linear equations'),('*  A * X = B, where A is a band matrix of order N with KL subdiagonals'),('*  and KU superdiagonals, and X and B are N-by-NRHS matrices.'),('*'),('*  The LU decomposition with partial pivoting and row interchanges is'),('*  used to factor A as A = L * U, where L is a product of permutation'),('*  and unit lower triangular matrices with KL subdiagonals, and U is'),('*  upper triangular with KL+KU superdiagonals.  The factored form of A'),('*  is then used to solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KL      (input) INTEGER'),('*          The number of subdiagonals within the band of A.  KL >= 0.'),('*'),('*  KU      (input) INTEGER'),('*          The number of superdiagonals within the band of A.  KU >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)'),('*          On entry, the matrix A in band storage, in rows KL+1 to'),('*          2*KL+KU+1; rows 1 to KL of the array need not be set.'),('*          The j-th column of A is stored in the j-th column of the'),('*          array AB as follows:'),('*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)'),('*          On exit, details of the factorization: U is stored as an'),('*          upper triangular band matrix with KL+KU superdiagonals in'),('*          rows 1 to KL+KU+1, and the multipliers used during the'),('*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.'),('*          See below for further details.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          The pivot indices that define the permutation matrix P;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization'),('*                has been completed, but the factor U is exactly'),('*                singular, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  M = N = 6, KL = 2, KU = 1:'),('*'),('*  On entry:                       On exit:'),('*'),('*      *    *    *    +    +    +       *    *    *   u14  u25  u36'),('*      *    *    +    +    +    +       *    *   u13  u24  u35  u46'),('*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56'),('*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66'),('*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *'),('*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *'),('*'),('*  Array elements marked * are not used by the routine; elements marked'),('*  + need not be set on entry, but are required by the routine to store'),('*  elements of U because of fill-in resulting from the row interchanges.'),('*');
/*!40000 ALTER TABLE `dgbsv_Table6` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgbsvx_Table46`
--

DROP TABLE IF EXISTS `dgbsvx_Table46`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgbsvx_Table46` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgbsvx_Table46`
--

LOCK TABLES `dgbsvx_Table46` WRITE;
/*!40000 ALTER TABLE `dgbsvx_Table46` DISABLE KEYS */;
INSERT INTO `dgbsvx_Table46` VALUES ('      SUBROUTINE DGBSVX( FACT, TRANS, N, KL, KU, NRHS, AB, LDAB, AFB,'),('     $                   LDAFB, IPIV, EQUED, R, C, B, LDB, X, LDX,'),('     $                   RCOND, FERR, BERR, WORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, TRANS'),('      INTEGER            INFO, KL, KU, LDAB, LDAFB, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * ), IWORK( * )'),('      DOUBLE PRECISION   AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),'),('     $                   BERR( * ), C( * ), FERR( * ), R( * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGBSVX uses the LU factorization to compute the solution to a real'),('*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,'),('*  where A is a band matrix of order N with KL subdiagonals and KU'),('*  superdiagonals, and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed by this subroutine:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B'),('*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B'),('*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')'),('*     or diag(C)*B (if TRANS = \'T\' or \'C\').'),('*'),('*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the'),('*     matrix A (after equilibration if FACT = \'E\') as'),('*        A = L * U,'),('*     where L is a product of permutation and unit lower triangular'),('*     matrices with KL subdiagonals, and U is upper triangular with'),('*     KL+KU superdiagonals.'),('*'),('*  3. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so'),('*     that it solves the original system before equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFB and IPIV contain the factored form of'),('*                  A.  If EQUED is not \'N\', the matrix A has been'),('*                  equilibrated with scaling factors given by R and C.'),('*                  AB, AFB, and IPIV are not modified.'),('*          = \'N\':  The matrix A will be copied to AFB and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFB and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations.'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Transpose)'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KL      (input) INTEGER'),('*          The number of subdiagonals within the band of A.  KL >= 0.'),('*'),('*  KU      (input) INTEGER'),('*          The number of superdiagonals within the band of A.  KU >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)'),('*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.'),('*          The j-th column of A is stored in the j-th column of the'),('*          array AB as follows:'),('*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)'),('*'),('*          If FACT = \'F\' and EQUED is not \'N\', then A must have been'),('*          equilibrated by the scaling factors in R and/or C.  AB is not'),('*          modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and'),('*          EQUED = \'N\' on exit.'),('*'),('*          On exit, if EQUED .ne. \'N\', A is scaled as follows:'),('*          EQUED = \'R\':  A := diag(R) * A'),('*          EQUED = \'C\':  A := A * diag(C)'),('*          EQUED = \'B\':  A := diag(R) * A * diag(C).'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KL+KU+1.'),('*'),('*  AFB     (input or output) DOUBLE PRECISION array, dimension (LDAFB,N)'),('*          If FACT = \'F\', then AFB is an input argument and on entry'),('*          contains details of the LU factorization of the band matrix'),('*          A, as computed by DGBTRF.  U is stored as an upper triangular'),('*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,'),('*          and the multipliers used during the factorization are stored'),('*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is'),('*          the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFB is an output argument and on exit'),('*          returns details of the LU factorization of A.'),('*'),('*          If FACT = \'E\', then AFB is an output argument and on exit'),('*          returns details of the LU factorization of the equilibrated'),('*          matrix A (see the description of AB for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAFB   (input) INTEGER'),('*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the factorization A = L*U'),('*          as computed by DGBTRF; row i of the matrix was interchanged'),('*          with row IPIV(i).'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = L*U'),('*          of the equilibrated matrix A.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'R\':  Row equilibration, i.e., A has been premultiplied by'),('*                  diag(R).'),('*          = \'C\':  Column equilibration, i.e., A has been postmultiplied'),('*                  by diag(C).'),('*          = \'B\':  Both row and column equilibration, i.e., A has been'),('*                  replaced by diag(R) * A * diag(C).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  R       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is'),('*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R'),('*          is not accessed.  R is an input argument if FACT = \'F\';'),('*          otherwise, R is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'R\' or \'B\', each element of R must be positive.'),('*'),('*  C       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is'),('*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C'),('*          is not accessed.  C is an input argument if FACT = \'F\';'),('*          otherwise, C is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'C\' or \'B\', each element of C must be positive.'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the right hand side matrix B.'),('*          On exit,'),('*          if EQUED = \'N\', B is not modified;'),('*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by'),('*          diag(R)*B;'),('*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is'),('*          overwritten by diag(C)*B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X'),('*          to the original system of equations.  Note that A and B are'),('*          modified on exit if EQUED .ne. \'N\', and the solution to the'),('*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and'),('*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\''),('*          and EQUED = \'R\' or \'B\'.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (3*N)'),('*          On exit, WORK(1) contains the reciprocal pivot growth'),('*          factor norm(A)/norm(U). The \"max absolute element\" norm is'),('*          used. If WORK(1) is much less than 1, then the stability'),('*          of the LU factorization of the (equilibrated) matrix A'),('*          could be poor. This also means that the solution X, condition'),('*          estimator RCOND, and forward error bound FERR could be'),('*          unreliable. If factorization fails with 0<INFO<=N, then'),('*          WORK(1) contains the reciprocal pivot growth factor for the'),('*          leading INFO columns of A.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization'),('*                       has been completed, but the factor U is exactly'),('*                       singular, so the solution and error bounds'),('*                       could not be computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `dgbsvx_Table46` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgees_Table198`
--

DROP TABLE IF EXISTS `dgees_Table198`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgees_Table198` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgees_Table198`
--

LOCK TABLES `dgees_Table198` WRITE;
/*!40000 ALTER TABLE `dgees_Table198` DISABLE KEYS */;
INSERT INTO `dgees_Table198` VALUES ('      SUBROUTINE DGEES( JOBVS, SORT, SELECT, N, A, LDA, SDIM, WR, WI,'),('     $                  VS, LDVS, WORK, LWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVS, SORT'),('      INTEGER            INFO, LDA, LDVS, LWORK, N, SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), VS( LDVS, * ), WI( * ), WORK( * ),'),('     $                   WR( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELECT'),('      EXTERNAL           SELECT'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGEES computes for an N-by-N real nonsymmetric matrix A, the'),('*  eigenvalues, the real Schur form T, and, optionally, the matrix of'),('*  Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).'),('*'),('*  Optionally, it also orders the eigenvalues on the diagonal of the'),('*  real Schur form so that selected eigenvalues are at the top left.'),('*  The leading columns of Z then form an orthonormal basis for the'),('*  invariant subspace corresponding to the selected eigenvalues.'),('*'),('*  A matrix is in real Schur form if it is upper quasi-triangular with'),('*  1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the'),('*  form'),('*          [  a  b  ]'),('*          [  c  a  ]'),('*'),('*  where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVS   (input) CHARACTER*1'),('*          = \'N\': Schur vectors are not computed;'),('*          = \'V\': Schur vectors are computed.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the Schur form.'),('*          = \'N\': Eigenvalues are not ordered;'),('*          = \'S\': Eigenvalues are ordered (see SELECT).'),('*'),('*  SELECT  (external procedure) LOGICAL FUNCTION of two DOUBLE PRECISION arguments'),('*          SELECT must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'S\', SELECT is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          If SORT = \'N\', SELECT is not referenced.'),('*          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if'),('*          SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex'),('*          conjugate pair of eigenvalues is selected, then both complex'),('*          eigenvalues are selected.'),('*          Note that a selected complex eigenvalue may no longer'),('*          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since'),('*          ordering may change the value of complex eigenvalues'),('*          (especially if the eigenvalue is ill-conditioned); in this'),('*          case INFO is set to N+2 (see INFO below).'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten by its real Schur form T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*                         for which SELECT is true. (Complex conjugate'),('*                         pairs for which SELECT is true for either'),('*                         eigenvalue count as 2.)'),('*'),('*  WR      (output) DOUBLE PRECISION array, dimension (N)'),('*  WI      (output) DOUBLE PRECISION array, dimension (N)'),('*          WR and WI contain the real and imaginary parts,'),('*          respectively, of the computed eigenvalues in the same order'),('*          that they appear on the diagonal of the output Schur form T.'),('*          Complex conjugate pairs of eigenvalues will appear'),('*          consecutively with the eigenvalue having the positive'),('*          imaginary part first.'),('*'),('*  VS      (output) DOUBLE PRECISION array, dimension (LDVS,N)'),('*          If JOBVS = \'V\', VS contains the orthogonal matrix Z of Schur'),('*          vectors.'),('*          If JOBVS = \'N\', VS is not referenced.'),('*'),('*  LDVS    (input) INTEGER'),('*          The leading dimension of the array VS.  LDVS >= 1; if'),('*          JOBVS = \'V\', LDVS >= N.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) contains the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,3*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value.'),('*          > 0: if INFO = i, and i is'),('*             <= N: the QR algorithm failed to compute all the'),('*                   eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI'),('*                   contain those eigenvalues which have converged; if'),('*                   JOBVS = \'V\', VS contains the matrix which reduces A'),('*                   to its partially converged Schur form.'),('*             = N+1: the eigenvalues could not be reordered because some'),('*                   eigenvalues were too close to separate (the problem'),('*                   is very ill-conditioned);'),('*             = N+2: after reordering, roundoff changed values of some'),('*                   complex eigenvalues so that leading eigenvalues in'),('*                   the Schur form no longer satisfy SELECT=.TRUE.  This'),('*                   could also be caused by underflow due to scaling.'),('*');
/*!40000 ALTER TABLE `dgees_Table198` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgeesx_Table202`
--

DROP TABLE IF EXISTS `dgeesx_Table202`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgeesx_Table202` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgeesx_Table202`
--

LOCK TABLES `dgeesx_Table202` WRITE;
/*!40000 ALTER TABLE `dgeesx_Table202` DISABLE KEYS */;
INSERT INTO `dgeesx_Table202` VALUES ('      SUBROUTINE DGEESX( JOBVS, SORT, SELECT, SENSE, N, A, LDA, SDIM,'),('     $                   WR, WI, VS, LDVS, RCONDE, RCONDV, WORK, LWORK,'),('     $                   IWORK, LIWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVS, SENSE, SORT'),('      INTEGER            INFO, LDA, LDVS, LIWORK, LWORK, N, SDIM'),('      DOUBLE PRECISION   RCONDE, RCONDV'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), VS( LDVS, * ), WI( * ), WORK( * ),'),('     $                   WR( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELECT'),('      EXTERNAL           SELECT'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGEESX computes for an N-by-N real nonsymmetric matrix A, the'),('*  eigenvalues, the real Schur form T, and, optionally, the matrix of'),('*  Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).'),('*'),('*  Optionally, it also orders the eigenvalues on the diagonal of the'),('*  real Schur form so that selected eigenvalues are at the top left;'),('*  computes a reciprocal condition number for the average of the'),('*  selected eigenvalues (RCONDE); and computes a reciprocal condition'),('*  number for the right invariant subspace corresponding to the'),('*  selected eigenvalues (RCONDV).  The leading columns of Z form an'),('*  orthonormal basis for this invariant subspace.'),('*'),('*  For further explanation of the reciprocal condition numbers RCONDE'),('*  and RCONDV, see Section 4.10 of the LAPACK Users\' Guide (where'),('*  these quantities are called s and sep respectively).'),('*'),('*  A real matrix is in real Schur form if it is upper quasi-triangular'),('*  with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in'),('*  the form'),('*            [  a  b  ]'),('*            [  c  a  ]'),('*'),('*  where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVS   (input) CHARACTER*1'),('*          = \'N\': Schur vectors are not computed;'),('*          = \'V\': Schur vectors are computed.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the Schur form.'),('*          = \'N\': Eigenvalues are not ordered;'),('*          = \'S\': Eigenvalues are ordered (see SELECT).'),('*'),('*  SELECT  (external procedure) LOGICAL FUNCTION of two DOUBLE PRECISION arguments'),('*          SELECT must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'S\', SELECT is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          If SORT = \'N\', SELECT is not referenced.'),('*          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if'),('*          SELECT(WR(j),WI(j)) is true; i.e., if either one of a'),('*          complex conjugate pair of eigenvalues is selected, then both'),('*          are.  Note that a selected complex eigenvalue may no longer'),('*          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since'),('*          ordering may change the value of complex eigenvalues'),('*          (especially if the eigenvalue is ill-conditioned); in this'),('*          case INFO may be set to N+3 (see INFO below).'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': None are computed;'),('*          = \'E\': Computed for average of selected eigenvalues only;'),('*          = \'V\': Computed for selected right invariant subspace only;'),('*          = \'B\': Computed for both.'),('*          If SENSE = \'E\', \'V\' or \'B\', SORT must equal \'S\'.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A is overwritten by its real Schur form T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*                         for which SELECT is true. (Complex conjugate'),('*                         pairs for which SELECT is true for either'),('*                         eigenvalue count as 2.)'),('*'),('*  WR      (output) DOUBLE PRECISION array, dimension (N)'),('*  WI      (output) DOUBLE PRECISION array, dimension (N)'),('*          WR and WI contain the real and imaginary parts, respectively,'),('*          of the computed eigenvalues, in the same order that they'),('*          appear on the diagonal of the output Schur form T.  Complex'),('*          conjugate pairs of eigenvalues appear consecutively with the'),('*          eigenvalue having the positive imaginary part first.'),('*'),('*  VS      (output) DOUBLE PRECISION array, dimension (LDVS,N)'),('*          If JOBVS = \'V\', VS contains the orthogonal matrix Z of Schur'),('*          vectors.'),('*          If JOBVS = \'N\', VS is not referenced.'),('*'),('*  LDVS    (input) INTEGER'),('*          The leading dimension of the array VS.  LDVS >= 1, and if'),('*          JOBVS = \'V\', LDVS >= N.'),('*'),('*  RCONDE  (output) DOUBLE PRECISION'),('*          If SENSE = \'E\' or \'B\', RCONDE contains the reciprocal'),('*          condition number for the average of the selected eigenvalues.'),('*          Not referenced if SENSE = \'N\' or \'V\'.'),('*'),('*  RCONDV  (output) DOUBLE PRECISION'),('*          If SENSE = \'V\' or \'B\', RCONDV contains the reciprocal'),('*          condition number for the selected right invariant subspace.'),('*          Not referenced if SENSE = \'N\' or \'E\'.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,3*N).'),('*          Also, if SENSE = \'E\' or \'V\' or \'B\','),('*          LWORK >= N+2*SDIM*(N-SDIM), where SDIM is the number of'),('*          selected eigenvalues computed by this routine.  Note that'),('*          N+2*SDIM*(N-SDIM) <= N+N*N/2. Note also that an error is only'),('*          returned if LWORK < max(1,3*N), but if SENSE = \'E\' or \'V\' or'),('*          \'B\' this may not be large enough.'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates upper bounds on the optimal sizes of the'),('*          arrays WORK and IWORK, returns these values as the first'),('*          entries of the WORK and IWORK arrays, and no error messages'),('*          related to LWORK or LIWORK are issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          LIWORK >= 1; if SENSE = \'V\' or \'B\', LIWORK >= SDIM*(N-SDIM).'),('*          Note that SDIM*(N-SDIM) <= N*N/4. Note also that an error is'),('*          only returned if LIWORK < 1, but if SENSE = \'V\' or \'B\' this'),('*          may not be large enough.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates upper bounds on the optimal sizes of'),('*          the arrays WORK and IWORK, returns these values as the first'),('*          entries of the WORK and IWORK arrays, and no error messages'),('*          related to LWORK or LIWORK are issued by XERBLA.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value.'),('*          > 0: if INFO = i, and i is'),('*             <= N: the QR algorithm failed to compute all the'),('*                   eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI'),('*                   contain those eigenvalues which have converged; if'),('*                   JOBVS = \'V\', VS contains the transformation which'),('*                   reduces A to its partially converged Schur form.'),('*             = N+1: the eigenvalues could not be reordered because some'),('*                   eigenvalues were too close to separate (the problem'),('*                   is very ill-conditioned);'),('*             = N+2: after reordering, roundoff changed values of some'),('*                   complex eigenvalues so that leading eigenvalues in'),('*                   the Schur form no longer satisfy SELECT=.TRUE.  This'),('*                   could also be caused by underflow due to scaling.'),('*');
/*!40000 ALTER TABLE `dgeesx_Table202` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgeev_Table190`
--

DROP TABLE IF EXISTS `dgeev_Table190`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgeev_Table190` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgeev_Table190`
--

LOCK TABLES `dgeev_Table190` WRITE;
/*!40000 ALTER TABLE `dgeev_Table190` DISABLE KEYS */;
INSERT INTO `dgeev_Table190` VALUES ('      SUBROUTINE DGEEV( JOBVL, JOBVR, N, A, LDA, WR, WI, VL, LDVL, VR,'),('     $                  LDVR, WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVL, JOBVR'),('      INTEGER            INFO, LDA, LDVL, LDVR, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   WI( * ), WORK( * ), WR( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGEEV computes for an N-by-N real nonsymmetric matrix A, the'),('*  eigenvalues and, optionally, the left and/or right eigenvectors.'),('*'),('*  The right eigenvector v(j) of A satisfies'),('*                   A * v(j) = lambda(j) * v(j)'),('*  where lambda(j) is its eigenvalue.'),('*  The left eigenvector u(j) of A satisfies'),('*                u(j)**H * A = lambda(j) * u(j)**H'),('*  where u(j)**H denotes the conjugate transpose of u(j).'),('*'),('*  The computed eigenvectors are normalized to have Euclidean norm'),('*  equal to 1 and largest component real.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\': left eigenvectors of A are not computed;'),('*          = \'V\': left eigenvectors of A are computed.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\': right eigenvectors of A are not computed;'),('*          = \'V\': right eigenvectors of A are computed.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  WR      (output) DOUBLE PRECISION array, dimension (N)'),('*  WI      (output) DOUBLE PRECISION array, dimension (N)'),('*          WR and WI contain the real and imaginary parts,'),('*          respectively, of the computed eigenvalues.  Complex'),('*          conjugate pairs of eigenvalues appear consecutively'),('*          with the eigenvalue having the positive imaginary part'),('*          first.'),('*'),('*  VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order'),('*          as their eigenvalues.'),('*          If JOBVL = \'N\', VL is not referenced.'),('*          If the j-th eigenvalue is real, then u(j) = VL(:,j),'),('*          the j-th column of VL.'),('*          If the j-th and (j+1)-st eigenvalues form a complex'),('*          conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and'),('*          u(j+1) = VL(:,j) - i*VL(:,j+1).'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the array VL.  LDVL >= 1; if'),('*          JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order'),('*          as their eigenvalues.'),('*          If JOBVR = \'N\', VR is not referenced.'),('*          If the j-th eigenvalue is real, then v(j) = VR(:,j),'),('*          the j-th column of VR.'),('*          If the j-th and (j+1)-st eigenvalues form a complex'),('*          conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and'),('*          v(j+1) = VR(:,j) - i*VR(:,j+1).'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the array VR.  LDVR >= 1; if'),('*          JOBVR = \'V\', LDVR >= N.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,3*N), and'),('*          if JOBVL = \'V\' or JOBVR = \'V\', LWORK >= 4*N.  For good'),('*          performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the QR algorithm failed to compute all the'),('*                eigenvalues, and no eigenvectors have been computed;'),('*                elements i+1:N of WR and WI contain eigenvalues which'),('*                have converged.'),('*');
/*!40000 ALTER TABLE `dgeev_Table190` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgeevx_Table194`
--

DROP TABLE IF EXISTS `dgeevx_Table194`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgeevx_Table194` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgeevx_Table194`
--

LOCK TABLES `dgeevx_Table194` WRITE;
/*!40000 ALTER TABLE `dgeevx_Table194` DISABLE KEYS */;
INSERT INTO `dgeevx_Table194` VALUES ('      SUBROUTINE DGEEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, WR, WI,'),('     $                   VL, LDVL, VR, LDVR, ILO, IHI, SCALE, ABNRM,'),('     $                   RCONDE, RCONDV, WORK, LWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          BALANC, JOBVL, JOBVR, SENSE'),('      INTEGER            IHI, ILO, INFO, LDA, LDVL, LDVR, LWORK, N'),('      DOUBLE PRECISION   ABNRM'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), RCONDE( * ), RCONDV( * ),'),('     $                   SCALE( * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   WI( * ), WORK( * ), WR( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGEEVX computes for an N-by-N real nonsymmetric matrix A, the'),('*  eigenvalues and, optionally, the left and/or right eigenvectors.'),('*'),('*  Optionally also, it computes a balancing transformation to improve'),('*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,'),('*  SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues'),('*  (RCONDE), and reciprocal condition numbers for the right'),('*  eigenvectors (RCONDV).'),('*'),('*  The right eigenvector v(j) of A satisfies'),('*                   A * v(j) = lambda(j) * v(j)'),('*  where lambda(j) is its eigenvalue.'),('*  The left eigenvector u(j) of A satisfies'),('*                u(j)**H * A = lambda(j) * u(j)**H'),('*  where u(j)**H denotes the conjugate transpose of u(j).'),('*'),('*  The computed eigenvectors are normalized to have Euclidean norm'),('*  equal to 1 and largest component real.'),('*'),('*  Balancing a matrix means permuting the rows and columns to make it'),('*  more nearly upper triangular, and applying a diagonal similarity'),('*  transformation D * A * D**(-1), where D is a diagonal matrix, to'),('*  make its rows and columns closer in norm and the condition numbers'),('*  of its eigenvalues and eigenvectors smaller.  The computed'),('*  reciprocal condition numbers correspond to the balanced matrix.'),('*  Permuting rows and columns will not change the condition numbers'),('*  (in exact arithmetic) but diagonal scaling will.  For further'),('*  explanation of balancing, see section 4.10.2 of the LAPACK'),('*  Users\' Guide.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  BALANC  (input) CHARACTER*1'),('*          Indicates how the input matrix should be diagonally scaled'),('*          and/or permuted to improve the conditioning of its'),('*          eigenvalues.'),('*          = \'N\': Do not diagonally scale or permute;'),('*          = \'P\': Perform permutations to make the matrix more nearly'),('*                 upper triangular. Do not diagonally scale;'),('*          = \'S\': Diagonally scale the matrix, i.e. replace A by'),('*                 D*A*D**(-1), where D is a diagonal matrix chosen'),('*                 to make the rows and columns of A more equal in'),('*                 norm. Do not permute;'),('*          = \'B\': Both diagonally scale and permute A.'),('*'),('*          Computed reciprocal condition numbers will be for the matrix'),('*          after balancing and/or permuting. Permuting does not change'),('*          condition numbers (in exact arithmetic), but balancing does.'),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\': left eigenvectors of A are not computed;'),('*          = \'V\': left eigenvectors of A are computed.'),('*          If SENSE = \'E\' or \'B\', JOBVL must = \'V\'.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\': right eigenvectors of A are not computed;'),('*          = \'V\': right eigenvectors of A are computed.'),('*          If SENSE = \'E\' or \'B\', JOBVR must = \'V\'.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': None are computed;'),('*          = \'E\': Computed for eigenvalues only;'),('*          = \'V\': Computed for right eigenvectors only;'),('*          = \'B\': Computed for eigenvalues and right eigenvectors.'),('*'),('*          If SENSE = \'E\' or \'B\', both left and right eigenvectors'),('*          must also be computed (JOBVL = \'V\' and JOBVR = \'V\').'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten.  If JOBVL = \'V\' or'),('*          JOBVR = \'V\', A contains the real Schur form of the balanced'),('*          version of the input matrix A.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  WR      (output) DOUBLE PRECISION array, dimension (N)'),('*  WI      (output) DOUBLE PRECISION array, dimension (N)'),('*          WR and WI contain the real and imaginary parts,'),('*          respectively, of the computed eigenvalues.  Complex'),('*          conjugate pairs of eigenvalues will appear consecutively'),('*          with the eigenvalue having the positive imaginary part'),('*          first.'),('*'),('*  VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order'),('*          as their eigenvalues.'),('*          If JOBVL = \'N\', VL is not referenced.'),('*          If the j-th eigenvalue is real, then u(j) = VL(:,j),'),('*          the j-th column of VL.'),('*          If the j-th and (j+1)-st eigenvalues form a complex'),('*          conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and'),('*          u(j+1) = VL(:,j) - i*VL(:,j+1).'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the array VL.  LDVL >= 1; if'),('*          JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order'),('*          as their eigenvalues.'),('*          If JOBVR = \'N\', VR is not referenced.'),('*          If the j-th eigenvalue is real, then v(j) = VR(:,j),'),('*          the j-th column of VR.'),('*          If the j-th and (j+1)-st eigenvalues form a complex'),('*          conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and'),('*          v(j+1) = VR(:,j) - i*VR(:,j+1).'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the array VR.  LDVR >= 1, and if'),('*          JOBVR = \'V\', LDVR >= N.'),('*'),('*  ILO     (output) INTEGER'),('*  IHI     (output) INTEGER'),('*          ILO and IHI are integer values determined when A was'),('*          balanced.  The balanced A(i,j) = 0 if I > J and'),('*          J = 1,...,ILO-1 or I = IHI+1,...,N.'),('*'),('*  SCALE   (output) DOUBLE PRECISION array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          when balancing A.  If P(j) is the index of the row and column'),('*          interchanged with row and column j, and D(j) is the scaling'),('*          factor applied to row and column j, then'),('*          SCALE(J) = P(J),    for J = 1,...,ILO-1'),('*                   = D(J),    for J = ILO,...,IHI'),('*                   = P(J)     for J = IHI+1,...,N.'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  ABNRM   (output) DOUBLE PRECISION'),('*          The one-norm of the balanced matrix (the maximum'),('*          of the sum of absolute values of elements of any column).'),('*'),('*  RCONDE  (output) DOUBLE PRECISION array, dimension (N)'),('*          RCONDE(j) is the reciprocal condition number of the j-th'),('*          eigenvalue.'),('*'),('*  RCONDV  (output) DOUBLE PRECISION array, dimension (N)'),('*          RCONDV(j) is the reciprocal condition number of the j-th'),('*          right eigenvector.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.   If SENSE = \'N\' or \'E\','),('*          LWORK >= max(1,2*N), and if JOBVL = \'V\' or JOBVR = \'V\','),('*          LWORK >= 3*N.  If SENSE = \'V\' or \'B\', LWORK >= N*(N+6).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (2*N-2)'),('*          If SENSE = \'N\' or \'E\', not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the QR algorithm failed to compute all the'),('*                eigenvalues, and no eigenvectors or condition numbers'),('*                have been computed; elements 1:ILO-1 and i+1:N of WR'),('*                and WI contain eigenvalues which have converged.'),('*');
/*!40000 ALTER TABLE `dgeevx_Table194` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgels_Table82`
--

DROP TABLE IF EXISTS `dgels_Table82`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgels_Table82` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgels_Table82`
--

LOCK TABLES `dgels_Table82` WRITE;
/*!40000 ALTER TABLE `dgels_Table82` DISABLE KEYS */;
INSERT INTO `dgels_Table82` VALUES ('      SUBROUTINE DGELS( TRANS, M, N, NRHS, A, LDA, B, LDB, WORK, LWORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          TRANS'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGELS solves overdetermined or underdetermined real linear systems'),('*  involving an M-by-N matrix A, or its transpose, using a QR or LQ'),('*  factorization of A.  It is assumed that A has full rank.'),('*'),('*  The following options are provided:'),('*'),('*  1. If TRANS = \'N\' and m >= n:  find the least squares solution of'),('*     an overdetermined system, i.e., solve the least squares problem'),('*                  minimize || B - A*X ||.'),('*'),('*  2. If TRANS = \'N\' and m < n:  find the minimum norm solution of'),('*     an underdetermined system A * X = B.'),('*'),('*  3. If TRANS = \'T\' and m >= n:  find the minimum norm solution of'),('*     an undetermined system A**T * X = B.'),('*'),('*  4. If TRANS = \'T\' and m < n:  find the least squares solution of'),('*     an overdetermined system, i.e., solve the least squares problem'),('*                  minimize || B - A**T * X ||.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  TRANS   (input) CHARACTER*1'),('*          = \'N\': the linear system involves A;'),('*          = \'T\': the linear system involves A**T.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of'),('*          columns of the matrices B and X. NRHS >=0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit,'),('*            if M >= N, A is overwritten by details of its QR'),('*                       factorization as returned by DGEQRF;'),('*            if M <  N, A is overwritten by details of its LQ'),('*                       factorization as returned by DGELQF.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the matrix B of right hand side vectors, stored'),('*          columnwise; B is M-by-NRHS if TRANS = \'N\', or N-by-NRHS'),('*          if TRANS = \'T\'.'),('*          On exit, if INFO = 0, B is overwritten by the solution'),('*          vectors, stored columnwise:'),('*          if TRANS = \'N\' and m >= n, rows 1 to n of B contain the least'),('*          squares solution vectors; the residual sum of squares for the'),('*          solution in each column is given by the sum of squares of'),('*          elements N+1 to M in that column;'),('*          if TRANS = \'N\' and m < n, rows 1 to N of B contain the'),('*          minimum norm solution vectors;'),('*          if TRANS = \'T\' and m >= n, rows 1 to M of B contain the'),('*          minimum norm solution vectors;'),('*          if TRANS = \'T\' and m < n, rows 1 to M of B contain the'),('*          least squares solution vectors; the residual sum of squares'),('*          for the solution in each column is given by the sum of'),('*          squares of elements M+1 to N in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= MAX(1,M,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          LWORK >= max( 1, MN + max( MN, NRHS ) ).'),('*          For optimal performance,'),('*          LWORK >= max( 1, MN + max( MN, NRHS )*NB ).'),('*          where MN = min(M,N) and NB is the optimum block size.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO =  i, the i-th diagonal element of the'),('*                triangular factor of A is zero, so that A does not have'),('*                full rank; the least squares solution could not be'),('*                computed.'),('*');
/*!40000 ALTER TABLE `dgels_Table82` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgelsd_Table90`
--

DROP TABLE IF EXISTS `dgelsd_Table90`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgelsd_Table90` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgelsd_Table90`
--

LOCK TABLES `dgelsd_Table90` WRITE;
/*!40000 ALTER TABLE `dgelsd_Table90` DISABLE KEYS */;
INSERT INTO `dgelsd_Table90` VALUES ('      SUBROUTINE DGELSD( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,'),('     $                   WORK, LWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), S( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGELSD computes the minimum-norm solution to a real linear least'),('*  squares problem:'),('*      minimize 2-norm(| b - A*x |)'),('*  using the singular value decomposition (SVD) of A. A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  The problem is solved in three steps:'),('*  (1) Reduce the coefficient matrix A to bidiagonal form with'),('*      Householder transformations, reducing the original problem'),('*      into a \"bidiagonal least squares problem\" (BLS)'),('*  (2) Solve the BLS using a divide and conquer approach.'),('*  (3) Apply back all the Householder tranformations to solve'),('*      the original least squares problem.'),('*'),('*  The effective rank of A is determined by treating as zero those'),('*  singular values which are less than RCOND times the largest singular'),('*  value.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of A. M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of A. N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X. NRHS >= 0.'),('*'),('*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A has been destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, B is overwritten by the N-by-NRHS solution'),('*          matrix X.  If m >= n and RANK = n, the residual'),('*          sum-of-squares for the solution in the i-th column is given'),('*          by the sum of squares of elements n+1:m in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,max(M,N)).'),('*'),('*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))'),('*          The singular values of A in decreasing order.'),('*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).'),('*'),('*  RCOND   (input) DOUBLE PRECISION'),('*          RCOND is used to determine the effective rank of A.'),('*          Singular values S(i) <= RCOND*S(1) are treated as zero.'),('*          If RCOND < 0, machine precision is used instead.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the number of singular values'),('*          which are greater than RCOND*S(1).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK must be at least 1.'),('*          The exact minimum amount of workspace needed depends on M,'),('*          N and NRHS. As long as LWORK is at least'),('*              12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2,'),('*          if M is greater than or equal to N or'),('*              12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2,'),('*          if M is less than N, the code will execute correctly.'),('*          SMLSIZ is returned by ILAENV and is equal to the maximum'),('*          size of the subproblems at the bottom of the computation'),('*          tree (usually about 25), and'),('*             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))'),('*          LIWORK >= max(1, 3 * MINMN * NLVL + 11 * MINMN),'),('*          where MINMN = MIN( M,N ).'),('*          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  the algorithm for computing the SVD failed to converge;'),('*                if INFO = i, i off-diagonal elements of an intermediate'),('*                bidiagonal form did not converge to zero.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Ming Gu and Ren-Cang Li, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*     Osni Marques, LBNL/NERSC, USA'),('*');
/*!40000 ALTER TABLE `dgelsd_Table90` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgelss_Table94`
--

DROP TABLE IF EXISTS `dgelss_Table94`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgelss_Table94` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgelss_Table94`
--

LOCK TABLES `dgelss_Table94` WRITE;
/*!40000 ALTER TABLE `dgelss_Table94` DISABLE KEYS */;
INSERT INTO `dgelss_Table94` VALUES ('      SUBROUTINE DGELSS( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,'),('     $                   WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), S( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGELSS computes the minimum norm solution to a real linear least'),('*  squares problem:'),('*'),('*  Minimize 2-norm(| b - A*x |).'),('*'),('*  using the singular value decomposition (SVD) of A. A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix'),('*  X.'),('*'),('*  The effective rank of A is determined by treating as zero those'),('*  singular values which are less than RCOND times the largest singular'),('*  value.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A. M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A. N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, the first min(m,n) rows of A are overwritten with'),('*          its right singular vectors, stored rowwise.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, B is overwritten by the N-by-NRHS solution'),('*          matrix X.  If m >= n and RANK = n, the residual'),('*          sum-of-squares for the solution in the i-th column is given'),('*          by the sum of squares of elements n+1:m in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,max(M,N)).'),('*'),('*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))'),('*          The singular values of A in decreasing order.'),('*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).'),('*'),('*  RCOND   (input) DOUBLE PRECISION'),('*          RCOND is used to determine the effective rank of A.'),('*          Singular values S(i) <= RCOND*S(1) are treated as zero.'),('*          If RCOND < 0, machine precision is used instead.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the number of singular values'),('*          which are greater than RCOND*S(1).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= 1, and also:'),('*          LWORK >= 3*min(M,N) + max( 2*min(M,N), max(M,N), NRHS )'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  the algorithm for computing the SVD failed to converge;'),('*                if INFO = i, i off-diagonal elements of an intermediate'),('*                bidiagonal form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `dgelss_Table94` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgelsy_Table86`
--

DROP TABLE IF EXISTS `dgelsy_Table86`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgelsy_Table86` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgelsy_Table86`
--

LOCK TABLES `dgelsy_Table86` WRITE;
/*!40000 ALTER TABLE `dgelsy_Table86` DISABLE KEYS */;
INSERT INTO `dgelsy_Table86` VALUES ('      SUBROUTINE DGELSY( M, N, NRHS, A, LDA, B, LDB, JPVT, RCOND, RANK,'),('     $                   WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            JPVT( * )'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGELSY computes the minimum-norm solution to a real linear least'),('*  squares problem:'),('*      minimize || A * X - B ||'),('*  using a complete orthogonal factorization of A.  A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  The routine first computes a QR factorization with column pivoting:'),('*      A * P = Q * [ R11 R12 ]'),('*                  [  0  R22 ]'),('*  with R11 defined as the largest leading submatrix whose estimated'),('*  condition number is less than 1/RCOND.  The order of R11, RANK,'),('*  is the effective rank of A.'),('*'),('*  Then, R22 is considered to be negligible, and R12 is annihilated'),('*  by orthogonal transformations from the right, arriving at the'),('*  complete orthogonal factorization:'),('*     A * P = Q * [ T11 0 ] * Z'),('*                 [  0  0 ]'),('*  The minimum-norm solution is then'),('*     X = P * Z\' [ inv(T11)*Q1\'*B ]'),('*                [        0       ]'),('*  where Q1 consists of the first RANK columns of Q.'),('*'),('*  This routine is basically identical to the original xGELSX except'),('*  three differences:'),('*    o The call to the subroutine xGEQPF has been substituted by the'),('*      the call to the subroutine xGEQP3. This subroutine is a Blas-3'),('*      version of the QR factorization with column pivoting.'),('*    o Matrix B (the right hand side) is updated with Blas-3.'),('*    o The permutation of matrix B (the right hand side) is faster and'),('*      more simple.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of'),('*          columns of matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A has been overwritten by details of its'),('*          complete orthogonal factorization.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,M,N).'),('*'),('*  JPVT    (input/output) INTEGER array, dimension (N)'),('*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted'),('*          to the front of AP, otherwise column i is a free column.'),('*          On exit, if JPVT(i) = k, then the i-th column of AP'),('*          was the k-th column of A.'),('*'),('*  RCOND   (input) DOUBLE PRECISION'),('*          RCOND is used to determine the effective rank of A, which'),('*          is defined as the order of the largest leading triangular'),('*          submatrix R11 in the QR factorization with pivoting of A,'),('*          whose estimated condition number < 1/RCOND.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the order of the submatrix'),('*          R11.  This is the same as the order of the submatrix T11'),('*          in the complete orthogonal factorization of A.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          The unblocked strategy requires that:'),('*             LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),'),('*          where MN = min( M, N ).'),('*          The block algorithm requires that:'),('*             LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),'),('*          where NB is an upper bound on the blocksize returned'),('*          by ILAENV for the routines DGEQP3, DTZRZF, STZRQF, DORMQR,'),('*          and DORMRZ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: If INFO = -i, the i-th argument had an illegal value.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA'),('*    E. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain'),('*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain'),('*');
/*!40000 ALTER TABLE `dgelsy_Table86` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgesdd_Table224`
--

DROP TABLE IF EXISTS `dgesdd_Table224`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgesdd_Table224` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgesdd_Table224`
--

LOCK TABLES `dgesdd_Table224` WRITE;
/*!40000 ALTER TABLE `dgesdd_Table224` DISABLE KEYS */;
INSERT INTO `dgesdd_Table224` VALUES ('      SUBROUTINE DGESDD( JOBZ, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK,'),('     $                   LWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.1)                                  --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     March 2009'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ'),('      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), S( * ), U( LDU, * ),'),('     $                   VT( LDVT, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGESDD computes the singular value decomposition (SVD) of a real'),('*  M-by-N matrix A, optionally computing the left and right singular'),('*  vectors.  If singular vectors are desired, it uses a'),('*  divide-and-conquer algorithm.'),('*'),('*  The SVD is written'),('*'),('*       A = U * SIGMA * transpose(V)'),('*'),('*  where SIGMA is an M-by-N matrix which is zero except for its'),('*  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and'),('*  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA'),('*  are the singular values of A; they are real and non-negative, and'),('*  are returned in descending order.  The first min(m,n) columns of'),('*  U and V are the left and right singular vectors of A.'),('*'),('*  Note that the routine returns VT = V**T, not V.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix U:'),('*          = \'A\':  all M columns of U and all N rows of V**T are'),('*                  returned in the arrays U and VT;'),('*          = \'S\':  the first min(M,N) columns of U and the first'),('*                  min(M,N) rows of V**T are returned in the arrays U'),('*                  and VT;'),('*          = \'O\':  If M >= N, the first N columns of U are overwritten'),('*                  on the array A and all rows of V**T are returned in'),('*                  the array VT;'),('*                  otherwise, all columns of U are returned in the'),('*                  array U and the first M rows of V**T are overwritten'),('*                  in the array A;'),('*          = \'N\':  no columns of U or rows of V**T are computed.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the input matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the input matrix A.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit,'),('*          if JOBZ = \'O\',  A is overwritten with the first N columns'),('*                          of U (the left singular vectors, stored'),('*                          columnwise) if M >= N;'),('*                          A is overwritten with the first M rows'),('*                          of V**T (the right singular vectors, stored'),('*                          rowwise) otherwise.'),('*          if JOBZ .ne. \'O\', the contents of A are destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))'),('*          The singular values of A, sorted so that S(i) >= S(i+1).'),('*'),('*  U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)'),('*          UCOL = M if JOBZ = \'A\' or JOBZ = \'O\' and M < N;'),('*          UCOL = min(M,N) if JOBZ = \'S\'.'),('*          If JOBZ = \'A\' or JOBZ = \'O\' and M < N, U contains the M-by-M'),('*          orthogonal matrix U;'),('*          if JOBZ = \'S\', U contains the first min(M,N) columns of U'),('*          (the left singular vectors, stored columnwise);'),('*          if JOBZ = \'O\' and M >= N, or JOBZ = \'N\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U.  LDU >= 1; if'),('*          JOBZ = \'S\' or \'A\' or JOBZ = \'O\' and M < N, LDU >= M.'),('*'),('*  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)'),('*          If JOBZ = \'A\' or JOBZ = \'O\' and M >= N, VT contains the'),('*          N-by-N orthogonal matrix V**T;'),('*          if JOBZ = \'S\', VT contains the first min(M,N) rows of'),('*          V**T (the right singular vectors, stored rowwise);'),('*          if JOBZ = \'O\' and M < N, or JOBZ = \'N\', VT is not referenced.'),('*'),('*  LDVT    (input) INTEGER'),('*          The leading dimension of the array VT.  LDVT >= 1; if'),('*          JOBZ = \'A\' or JOBZ = \'O\' and M >= N, LDVT >= N;'),('*          if JOBZ = \'S\', LDVT >= min(M,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= 1.'),('*          If JOBZ = \'N\','),('*            LWORK >= 3*min(M,N) + max(max(M,N),7*min(M,N)).'),('*          If JOBZ = \'O\','),('*            LWORK >= 3*min(M,N) + '),('*                     max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).'),('*          If JOBZ = \'S\' or \'A\''),('*            LWORK >= 3*min(M,N) +'),('*                     max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).'),('*          For good performance, LWORK should generally be larger.'),('*          If LWORK = -1 but other input arguments are legal, WORK(1)'),('*          returns the optimal LWORK.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  DBDSDC did not converge, updating process failed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Ming Gu and Huan Ren, Computer Science Division, University of'),('*     California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `dgesdd_Table224` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgesv_Table2`
--

DROP TABLE IF EXISTS `dgesv_Table2`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgesv_Table2` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgesv_Table2`
--

LOCK TABLES `dgesv_Table2` WRITE;
/*!40000 ALTER TABLE `dgesv_Table2` DISABLE KEYS */;
INSERT INTO `dgesv_Table2` VALUES ('      SUBROUTINE DGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGESV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.'),('*'),('*  The LU decomposition with partial pivoting and row interchanges is'),('*  used to factor A as'),('*     A = P * L * U,'),('*  where P is a permutation matrix, L is unit lower triangular, and U is'),('*  upper triangular.  The factored form of A is then used to solve the'),('*  system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the N-by-N coefficient matrix A.'),('*          On exit, the factors L and U from the factorization'),('*          A = P*L*U; the unit diagonal elements of L are not stored.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          The pivot indices that define the permutation matrix P;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS matrix of right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization'),('*                has been completed, but the factor U is exactly'),('*                singular, so the solution could not be computed.'),('*');
/*!40000 ALTER TABLE `dgesv_Table2` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgesvd_Table220`
--

DROP TABLE IF EXISTS `dgesvd_Table220`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgesvd_Table220` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgesvd_Table220`
--

LOCK TABLES `dgesvd_Table220` WRITE;
/*!40000 ALTER TABLE `dgesvd_Table220` DISABLE KEYS */;
INSERT INTO `dgesvd_Table220` VALUES ('      SUBROUTINE DGESVD( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,'),('     $                   WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBU, JOBVT'),('      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   A( LDA, * ), S( * ), U( LDU, * ),'),('     $                   VT( LDVT, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGESVD computes the singular value decomposition (SVD) of a real'),('*  M-by-N matrix A, optionally computing the left and/or right singular'),('*  vectors. The SVD is written'),('*'),('*       A = U * SIGMA * transpose(V)'),('*'),('*  where SIGMA is an M-by-N matrix which is zero except for its'),('*  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and'),('*  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA'),('*  are the singular values of A; they are real and non-negative, and'),('*  are returned in descending order.  The first min(m,n) columns of'),('*  U and V are the left and right singular vectors of A.'),('*'),('*  Note that the routine returns V**T, not V.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBU    (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix U:'),('*          = \'A\':  all M columns of U are returned in array U:'),('*          = \'S\':  the first min(m,n) columns of U (the left singular'),('*                  vectors) are returned in the array U;'),('*          = \'O\':  the first min(m,n) columns of U (the left singular'),('*                  vectors) are overwritten on the array A;'),('*          = \'N\':  no columns of U (no left singular vectors) are'),('*                  computed.'),('*'),('*  JOBVT   (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix'),('*          V**T:'),('*          = \'A\':  all N rows of V**T are returned in the array VT;'),('*          = \'S\':  the first min(m,n) rows of V**T (the right singular'),('*                  vectors) are returned in the array VT;'),('*          = \'O\':  the first min(m,n) rows of V**T (the right singular'),('*                  vectors) are overwritten on the array A;'),('*          = \'N\':  no rows of V**T (no right singular vectors) are'),('*                  computed.'),('*'),('*          JOBVT and JOBU cannot both be \'O\'.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the input matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the input matrix A.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit,'),('*          if JOBU = \'O\',  A is overwritten with the first min(m,n)'),('*                          columns of U (the left singular vectors,'),('*                          stored columnwise);'),('*          if JOBVT = \'O\', A is overwritten with the first min(m,n)'),('*                          rows of V**T (the right singular vectors,'),('*                          stored rowwise);'),('*          if JOBU .ne. \'O\' and JOBVT .ne. \'O\', the contents of A'),('*                          are destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))'),('*          The singular values of A, sorted so that S(i) >= S(i+1).'),('*'),('*  U       (output) DOUBLE PRECISION array, dimension (LDU,UCOL)'),('*          (LDU,M) if JOBU = \'A\' or (LDU,min(M,N)) if JOBU = \'S\'.'),('*          If JOBU = \'A\', U contains the M-by-M orthogonal matrix U;'),('*          if JOBU = \'S\', U contains the first min(m,n) columns of U'),('*          (the left singular vectors, stored columnwise);'),('*          if JOBU = \'N\' or \'O\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U.  LDU >= 1; if'),('*          JOBU = \'S\' or \'A\', LDU >= M.'),('*'),('*  VT      (output) DOUBLE PRECISION array, dimension (LDVT,N)'),('*          If JOBVT = \'A\', VT contains the N-by-N orthogonal matrix'),('*          V**T;'),('*          if JOBVT = \'S\', VT contains the first min(m,n) rows of'),('*          V**T (the right singular vectors, stored rowwise);'),('*          if JOBVT = \'N\' or \'O\', VT is not referenced.'),('*'),('*  LDVT    (input) INTEGER'),('*          The leading dimension of the array VT.  LDVT >= 1; if'),('*          JOBVT = \'A\', LDVT >= N; if JOBVT = \'S\', LDVT >= min(M,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;'),('*          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged'),('*          superdiagonal elements of an upper bidiagonal matrix B'),('*          whose diagonal is in S (not necessarily sorted). B'),('*          satisfies A = U * B * VT, so it has the same singular values'),('*          as A, and singular vectors related by U and VT.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          LWORK >= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if DBDSQR did not converge, INFO specifies how many'),('*                superdiagonals of an intermediate bidiagonal form B'),('*                did not converge to zero. See the description of WORK'),('*                above for details.'),('*');
/*!40000 ALTER TABLE `dgesvd_Table220` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgesvx_Table42`
--

DROP TABLE IF EXISTS `dgesvx_Table42`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgesvx_Table42` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgesvx_Table42`
--

LOCK TABLES `dgesvx_Table42` WRITE;
/*!40000 ALTER TABLE `dgesvx_Table42` DISABLE KEYS */;
INSERT INTO `dgesvx_Table42` VALUES ('      SUBROUTINE DGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV,'),('     $                   EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, TRANS'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * ), IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   BERR( * ), C( * ), FERR( * ), R( * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGESVX uses the LU factorization to compute the solution to a real'),('*  system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B'),('*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B'),('*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')'),('*     or diag(C)*B (if TRANS = \'T\' or \'C\').'),('*'),('*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the'),('*     matrix A (after equilibration if FACT = \'E\') as'),('*        A = P * L * U,'),('*     where P is a permutation matrix, L is a unit lower triangular'),('*     matrix, and U is upper triangular.'),('*'),('*  3. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so'),('*     that it solves the original system before equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AF and IPIV contain the factored form of A.'),('*                  If EQUED is not \'N\', the matrix A has been'),('*                  equilibrated with scaling factors given by R and C.'),('*                  A, AF, and IPIV are not modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AF and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations:'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Transpose)'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is'),('*          not \'N\', then A must have been equilibrated by the scaling'),('*          factors in R and/or C.  A is not modified if FACT = \'F\' or'),('*          \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if EQUED .ne. \'N\', A is scaled as follows:'),('*          EQUED = \'R\':  A := diag(R) * A'),('*          EQUED = \'C\':  A := A * diag(C)'),('*          EQUED = \'B\':  A := diag(R) * A * diag(C).'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the factors L and U from the factorization'),('*          A = P*L*U as computed by DGETRF.  If EQUED .ne. \'N\', then'),('*          AF is the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the factors L and U from the factorization A = P*L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then AF is an output argument and on exit'),('*          returns the factors L and U from the factorization A = P*L*U'),('*          of the equilibrated matrix A (see the description of A for'),('*          the form of the equilibrated matrix).'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          as computed by DGETRF; row i of the matrix was interchanged'),('*          with row IPIV(i).'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          of the equilibrated matrix A.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'R\':  Row equilibration, i.e., A has been premultiplied by'),('*                  diag(R).'),('*          = \'C\':  Column equilibration, i.e., A has been postmultiplied'),('*                  by diag(C).'),('*          = \'B\':  Both row and column equilibration, i.e., A has been'),('*                  replaced by diag(R) * A * diag(C).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  R       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is'),('*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R'),('*          is not accessed.  R is an input argument if FACT = \'F\';'),('*          otherwise, R is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'R\' or \'B\', each element of R must be positive.'),('*'),('*  C       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is'),('*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C'),('*          is not accessed.  C is an input argument if FACT = \'F\';'),('*          otherwise, C is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'C\' or \'B\', each element of C must be positive.'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit,'),('*          if EQUED = \'N\', B is not modified;'),('*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by'),('*          diag(R)*B;'),('*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is'),('*          overwritten by diag(C)*B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X'),('*          to the original system of equations.  Note that A and B are'),('*          modified on exit if EQUED .ne. \'N\', and the solution to the'),('*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and'),('*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\''),('*          and EQUED = \'R\' or \'B\'.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (4*N)'),('*          On exit, WORK(1) contains the reciprocal pivot growth'),('*          factor norm(A)/norm(U). The \"max absolute element\" norm is'),('*          used. If WORK(1) is much less than 1, then the stability'),('*          of the LU factorization of the (equilibrated) matrix A'),('*          could be poor. This also means that the solution X, condition'),('*          estimator RCOND, and forward error bound FERR could be'),('*          unreliable. If factorization fails with 0<INFO<=N, then'),('*          WORK(1) contains the reciprocal pivot growth factor for the'),('*          leading INFO columns of A.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization has'),('*                       been completed, but the factor U is exactly'),('*                       singular, so the solution and error bounds'),('*                       could not be computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `dgesvx_Table42` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgges_Table212`
--

DROP TABLE IF EXISTS `dgges_Table212`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgges_Table212` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgges_Table212`
--

LOCK TABLES `dgges_Table212` WRITE;
/*!40000 ALTER TABLE `dgges_Table212` DISABLE KEYS */;
INSERT INTO `dgges_Table212` VALUES ('      SUBROUTINE DGGES( JOBVSL, JOBVSR, SORT, SELCTG, N, A, LDA, B, LDB,'),('     $                  SDIM, ALPHAR, ALPHAI, BETA, VSL, LDVSL, VSR,'),('     $                  LDVSR, WORK, LWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVSL, JOBVSR, SORT'),('      INTEGER            INFO, LDA, LDB, LDVSL, LDVSR, LWORK, N, SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), ALPHAI( * ), ALPHAR( * ),'),('     $                   B( LDB, * ), BETA( * ), VSL( LDVSL, * ),'),('     $                   VSR( LDVSR, * ), WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELCTG'),('      EXTERNAL           SELCTG'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),'),('*  the generalized eigenvalues, the generalized real Schur form (S,T),'),('*  optionally, the left and/or right matrices of Schur vectors (VSL and'),('*  VSR). This gives the generalized Schur factorization'),('*'),('*           (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )'),('*'),('*  Optionally, it also orders the eigenvalues so that a selected cluster'),('*  of eigenvalues appears in the leading diagonal blocks of the upper'),('*  quasi-triangular matrix S and the upper triangular matrix T.The'),('*  leading columns of VSL and VSR then form an orthonormal basis for the'),('*  corresponding left and right eigenspaces (deflating subspaces).'),('*'),('*  (If only the generalized eigenvalues are needed, use the driver'),('*  DGGEV instead, which is faster.)'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w'),('*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is'),('*  usually represented as the pair (alpha,beta), as there is a'),('*  reasonable interpretation for beta=0 or both being zero.'),('*'),('*  A pair of matrices (S,T) is in generalized real Schur form if T is'),('*  upper triangular with non-negative diagonal and S is block upper'),('*  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond'),('*  to real generalized eigenvalues, while 2-by-2 blocks of S will be'),('*  \"standardized\" by making the corresponding elements of T have the'),('*  form:'),('*          [  a  0  ]'),('*          [  0  b  ]'),('*'),('*  and the pair of corresponding 2-by-2 blocks in S and T will have a'),('*  complex conjugate pair of generalized eigenvalues.'),('*'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVSL  (input) CHARACTER*1'),('*          = \'N\':  do not compute the left Schur vectors;'),('*          = \'V\':  compute the left Schur vectors.'),('*'),('*  JOBVSR  (input) CHARACTER*1'),('*          = \'N\':  do not compute the right Schur vectors;'),('*          = \'V\':  compute the right Schur vectors.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the generalized Schur form.'),('*          = \'N\':  Eigenvalues are not ordered;'),('*          = \'S\':  Eigenvalues are ordered (see SELCTG);'),('*'),('*  SELCTG  (external procedure) LOGICAL FUNCTION of three DOUBLE PRECISION arguments'),('*          SELCTG must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'N\', SELCTG is not referenced.'),('*          If SORT = \'S\', SELCTG is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if'),('*          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either'),('*          one of a complex conjugate pair of eigenvalues is selected,'),('*          then both complex eigenvalues are selected.'),('*'),('*          Note that in the ill-conditioned case, a selected complex'),('*          eigenvalue may no longer satisfy SELCTG(ALPHAR(j),ALPHAI(j),'),('*          BETA(j)) = .TRUE. after ordering. INFO is to be set to N+2'),('*          in this case.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VSL, and VSR.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the first of the pair of matrices.'),('*          On exit, A has been overwritten by its generalized Schur'),('*          form S.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)'),('*          On entry, the second of the pair of matrices.'),('*          On exit, B has been overwritten by its generalized Schur'),('*          form T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*          for which SELCTG is true.  (Complex conjugate pairs for which'),('*          SELCTG is true for either eigenvalue count as 2.)'),('*'),('*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)'),('*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)'),('*  BETA    (output) DOUBLE PRECISION array, dimension (N)'),('*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will'),('*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,'),('*          and  BETA(j),j=1,...,N are the diagonals of the complex Schur'),('*          form (S,T) that would result if the 2-by-2 diagonal blocks of'),('*          the real Schur form of (A,B) were further reduced to'),('*          triangular form using 2-by-2 complex unitary transformations.'),('*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if'),('*          positive, then the j-th and (j+1)-st eigenvalues are a'),('*          complex conjugate pair, with ALPHAI(j+1) negative.'),('*'),('*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)'),('*          may easily over- or underflow, and BETA(j) may even be zero.'),('*          Thus, the user should avoid naively computing the ratio.'),('*          However, ALPHAR and ALPHAI will be always less than and'),('*          usually comparable with norm(A) in magnitude, and BETA always'),('*          less than and usually comparable with norm(B).'),('*'),('*  VSL     (output) DOUBLE PRECISION array, dimension (LDVSL,N)'),('*          If JOBVSL = \'V\', VSL will contain the left Schur vectors.'),('*          Not referenced if JOBVSL = \'N\'.'),('*'),('*  LDVSL   (input) INTEGER'),('*          The leading dimension of the matrix VSL. LDVSL >=1, and'),('*          if JOBVSL = \'V\', LDVSL >= N.'),('*'),('*  VSR     (output) DOUBLE PRECISION array, dimension (LDVSR,N)'),('*          If JOBVSR = \'V\', VSR will contain the right Schur vectors.'),('*          Not referenced if JOBVSR = \'N\'.'),('*'),('*  LDVSR   (input) INTEGER'),('*          The leading dimension of the matrix VSR. LDVSR >= 1, and'),('*          if JOBVSR = \'V\', LDVSR >= N.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N = 0, LWORK >= 1, else LWORK >= 8*N+16.'),('*          For good performance , LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  (A,B) are not in Schur'),('*                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should'),('*                be correct for j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in DHGEQZ.'),('*                =N+2: after reordering, roundoff changed values of'),('*                      some complex eigenvalues so that leading'),('*                      eigenvalues in the Generalized Schur form no'),('*                      longer satisfy SELCTG=.TRUE.  This could also'),('*                      be caused due to scaling.'),('*                =N+3: reordering failed in DTGSEN.'),('*');
/*!40000 ALTER TABLE `dgges_Table212` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dggesx_Table216`
--

DROP TABLE IF EXISTS `dggesx_Table216`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dggesx_Table216` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dggesx_Table216`
--

LOCK TABLES `dggesx_Table216` WRITE;
/*!40000 ALTER TABLE `dggesx_Table216` DISABLE KEYS */;
INSERT INTO `dggesx_Table216` VALUES ('      SUBROUTINE DGGESX( JOBVSL, JOBVSR, SORT, SELCTG, SENSE, N, A, LDA,'),('     $                   B, LDB, SDIM, ALPHAR, ALPHAI, BETA, VSL, LDVSL,'),('     $                   VSR, LDVSR, RCONDE, RCONDV, WORK, LWORK, IWORK,'),('     $                   LIWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.1)                           --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*  -- April 2009                                                      --'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVSL, JOBVSR, SENSE, SORT'),('      INTEGER            INFO, LDA, LDB, LDVSL, LDVSR, LIWORK, LWORK, N,'),('     $                   SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), ALPHAI( * ), ALPHAR( * ),'),('     $                   B( LDB, * ), BETA( * ), RCONDE( 2 ),'),('     $                   RCONDV( 2 ), VSL( LDVSL, * ), VSR( LDVSR, * ),'),('     $                   WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELCTG'),('      EXTERNAL           SELCTG'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGGESX computes for a pair of N-by-N real nonsymmetric matrices'),('*  (A,B), the generalized eigenvalues, the real Schur form (S,T), and,'),('*  optionally, the left and/or right matrices of Schur vectors (VSL and'),('*  VSR).  This gives the generalized Schur factorization'),('*'),('*       (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )'),('*'),('*  Optionally, it also orders the eigenvalues so that a selected cluster'),('*  of eigenvalues appears in the leading diagonal blocks of the upper'),('*  quasi-triangular matrix S and the upper triangular matrix T; computes'),('*  a reciprocal condition number for the average of the selected'),('*  eigenvalues (RCONDE); and computes a reciprocal condition number for'),('*  the right and left deflating subspaces corresponding to the selected'),('*  eigenvalues (RCONDV). The leading columns of VSL and VSR then form'),('*  an orthonormal basis for the corresponding left and right eigenspaces'),('*  (deflating subspaces).'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w'),('*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is'),('*  usually represented as the pair (alpha,beta), as there is a'),('*  reasonable interpretation for beta=0 or for both being zero.'),('*'),('*  A pair of matrices (S,T) is in generalized real Schur form if T is'),('*  upper triangular with non-negative diagonal and S is block upper'),('*  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond'),('*  to real generalized eigenvalues, while 2-by-2 blocks of S will be'),('*  \"standardized\" by making the corresponding elements of T have the'),('*  form:'),('*          [  a  0  ]'),('*          [  0  b  ]'),('*'),('*  and the pair of corresponding 2-by-2 blocks in S and T will have a'),('*  complex conjugate pair of generalized eigenvalues.'),('*'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVSL  (input) CHARACTER*1'),('*          = \'N\':  do not compute the left Schur vectors;'),('*          = \'V\':  compute the left Schur vectors.'),('*'),('*  JOBVSR  (input) CHARACTER*1'),('*          = \'N\':  do not compute the right Schur vectors;'),('*          = \'V\':  compute the right Schur vectors.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the generalized Schur form.'),('*          = \'N\':  Eigenvalues are not ordered;'),('*          = \'S\':  Eigenvalues are ordered (see SELCTG).'),('*'),('*  SELCTG  (external procedure) LOGICAL FUNCTION of three DOUBLE PRECISION arguments'),('*          SELCTG must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'N\', SELCTG is not referenced.'),('*          If SORT = \'S\', SELCTG is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if'),('*          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either'),('*          one of a complex conjugate pair of eigenvalues is selected,'),('*          then both complex eigenvalues are selected.'),('*          Note that a selected complex eigenvalue may no longer satisfy'),('*          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) = .TRUE. after ordering,'),('*          since ordering may change the value of complex eigenvalues'),('*          (especially if the eigenvalue is ill-conditioned), in this'),('*          case INFO is set to N+3.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\' : None are computed;'),('*          = \'E\' : Computed for average of selected eigenvalues only;'),('*          = \'V\' : Computed for selected deflating subspaces only;'),('*          = \'B\' : Computed for both.'),('*          If SENSE = \'E\', \'V\', or \'B\', SORT must equal \'S\'.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VSL, and VSR.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the first of the pair of matrices.'),('*          On exit, A has been overwritten by its generalized Schur'),('*          form S.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)'),('*          On entry, the second of the pair of matrices.'),('*          On exit, B has been overwritten by its generalized Schur'),('*          form T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*          for which SELCTG is true.  (Complex conjugate pairs for which'),('*          SELCTG is true for either eigenvalue count as 2.)'),('*'),('*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)'),('*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)'),('*  BETA    (output) DOUBLE PRECISION array, dimension (N)'),('*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will'),('*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i'),('*          and BETA(j),j=1,...,N  are the diagonals of the complex Schur'),('*          form (S,T) that would result if the 2-by-2 diagonal blocks of'),('*          the real Schur form of (A,B) were further reduced to'),('*          triangular form using 2-by-2 complex unitary transformations.'),('*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if'),('*          positive, then the j-th and (j+1)-st eigenvalues are a'),('*          complex conjugate pair, with ALPHAI(j+1) negative.'),('*'),('*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)'),('*          may easily over- or underflow, and BETA(j) may even be zero.'),('*          Thus, the user should avoid naively computing the ratio.'),('*          However, ALPHAR and ALPHAI will be always less than and'),('*          usually comparable with norm(A) in magnitude, and BETA always'),('*          less than and usually comparable with norm(B).'),('*'),('*  VSL     (output) DOUBLE PRECISION array, dimension (LDVSL,N)'),('*          If JOBVSL = \'V\', VSL will contain the left Schur vectors.'),('*          Not referenced if JOBVSL = \'N\'.'),('*'),('*  LDVSL   (input) INTEGER'),('*          The leading dimension of the matrix VSL. LDVSL >=1, and'),('*          if JOBVSL = \'V\', LDVSL >= N.'),('*'),('*  VSR     (output) DOUBLE PRECISION array, dimension (LDVSR,N)'),('*          If JOBVSR = \'V\', VSR will contain the right Schur vectors.'),('*          Not referenced if JOBVSR = \'N\'.'),('*'),('*  LDVSR   (input) INTEGER'),('*          The leading dimension of the matrix VSR. LDVSR >= 1, and'),('*          if JOBVSR = \'V\', LDVSR >= N.'),('*'),('*  RCONDE  (output) DOUBLE PRECISION array, dimension ( 2 )'),('*          If SENSE = \'E\' or \'B\', RCONDE(1) and RCONDE(2) contain the'),('*          reciprocal condition numbers for the average of the selected'),('*          eigenvalues.'),('*          Not referenced if SENSE = \'N\' or \'V\'.'),('*'),('*  RCONDV  (output) DOUBLE PRECISION array, dimension ( 2 )'),('*          If SENSE = \'V\' or \'B\', RCONDV(1) and RCONDV(2) contain the'),('*          reciprocal condition numbers for the selected deflating'),('*          subspaces.'),('*          Not referenced if SENSE = \'N\' or \'E\'.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N = 0, LWORK >= 1, else if SENSE = \'E\', \'V\', or \'B\','),('*          LWORK >= max( 8*N, 6*N+16, 2*SDIM*(N-SDIM) ), else'),('*          LWORK >= max( 8*N, 6*N+16 ).'),('*          Note that 2*SDIM*(N-SDIM) <= N*N/2.'),('*          Note also that an error is only returned if'),('*          LWORK < max( 8*N, 6*N+16), but if SENSE = \'E\' or \'V\' or \'B\''),('*          this may not be large enough.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the bound on the optimal size of the WORK'),('*          array and the minimum size of the IWORK array, returns these'),('*          values as the first entries of the WORK and IWORK arrays, and'),('*          no error message related to LWORK or LIWORK is issued by'),('*          XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If SENSE = \'N\' or N = 0, LIWORK >= 1, otherwise'),('*          LIWORK >= N+6.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the bound on the optimal size of the'),('*          WORK array and the minimum size of the IWORK array, returns'),('*          these values as the first entries of the WORK and IWORK'),('*          arrays, and no error message related to LWORK or LIWORK is'),('*          issued by XERBLA.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  (A,B) are not in Schur'),('*                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should'),('*                be correct for j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in DHGEQZ'),('*                =N+2: after reordering, roundoff changed values of'),('*                      some complex eigenvalues so that leading'),('*                      eigenvalues in the Generalized Schur form no'),('*                      longer satisfy SELCTG=.TRUE.  This could also'),('*                      be caused due to scaling.'),('*                =N+3: reordering failed in DTGSEN.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  An approximate (asymptotic) bound on the average absolute error of'),('*  the selected eigenvalues is'),('*'),('*       EPS * norm((A, B)) / RCONDE( 1 ).'),('*'),('*  An approximate (asymptotic) bound on the maximum angular error in'),('*  the computed deflating subspaces is'),('*'),('*       EPS * norm((A, B)) / RCONDV( 2 ).'),('*'),('*  See LAPACK User\'s Guide, section 4.11 for more information.'),('*');
/*!40000 ALTER TABLE `dggesx_Table216` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dggev_Table206`
--

DROP TABLE IF EXISTS `dggev_Table206`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dggev_Table206` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dggev_Table206`
--

LOCK TABLES `dggev_Table206` WRITE;
/*!40000 ALTER TABLE `dggev_Table206` DISABLE KEYS */;
INSERT INTO `dggev_Table206` VALUES ('      SUBROUTINE DGGEV( JOBVL, JOBVR, N, A, LDA, B, LDB, ALPHAR, ALPHAI,'),('     $                  BETA, VL, LDVL, VR, LDVR, WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVL, JOBVR'),('      INTEGER            INFO, LDA, LDB, LDVL, LDVR, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   A( LDA, * ), ALPHAI( * ), ALPHAR( * ),'),('     $                   B( LDB, * ), BETA( * ), VL( LDVL, * ),'),('     $                   VR( LDVR, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)'),('*  the generalized eigenvalues, and optionally, the left and/or right'),('*  generalized eigenvectors.'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar'),('*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is'),('*  singular. It is usually represented as the pair (alpha,beta), as'),('*  there is a reasonable interpretation for beta=0, and even for both'),('*  being zero.'),('*'),('*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*'),('*                   A * v(j) = lambda(j) * B * v(j).'),('*'),('*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*'),('*                   u(j)**H * A  = lambda(j) * u(j)**H * B .'),('*'),('*  where u(j)**H is the conjugate-transpose of u(j).'),('*'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\':  do not compute the left generalized eigenvectors;'),('*          = \'V\':  compute the left generalized eigenvectors.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\':  do not compute the right generalized eigenvectors;'),('*          = \'V\':  compute the right generalized eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VL, and VR.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the matrix A in the pair (A,B).'),('*          On exit, A has been overwritten.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)'),('*          On entry, the matrix B in the pair (A,B).'),('*          On exit, B has been overwritten.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)'),('*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)'),('*  BETA    (output) DOUBLE PRECISION array, dimension (N)'),('*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will'),('*          be the generalized eigenvalues.  If ALPHAI(j) is zero, then'),('*          the j-th eigenvalue is real; if positive, then the j-th and'),('*          (j+1)-st eigenvalues are a complex conjugate pair, with'),('*          ALPHAI(j+1) negative.'),('*'),('*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)'),('*          may easily over- or underflow, and BETA(j) may even be zero.'),('*          Thus, the user should avoid naively computing the ratio'),('*          alpha/beta.  However, ALPHAR and ALPHAI will be always less'),('*          than and usually comparable with norm(A) in magnitude, and'),('*          BETA always less than and usually comparable with norm(B).'),('*'),('*  VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order as'),('*          their eigenvalues. If the j-th eigenvalue is real, then'),('*          u(j) = VL(:,j), the j-th column of VL. If the j-th and'),('*          (j+1)-th eigenvalues form a complex conjugate pair, then'),('*          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).'),('*          Each eigenvector is scaled so the largest component has'),('*          abs(real part)+abs(imag. part)=1.'),('*          Not referenced if JOBVL = \'N\'.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the matrix VL. LDVL >= 1, and'),('*          if JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order as'),('*          their eigenvalues. If the j-th eigenvalue is real, then'),('*          v(j) = VR(:,j), the j-th column of VR. If the j-th and'),('*          (j+1)-th eigenvalues form a complex conjugate pair, then'),('*          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).'),('*          Each eigenvector is scaled so the largest component has'),('*          abs(real part)+abs(imag. part)=1.'),('*          Not referenced if JOBVR = \'N\'.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the matrix VR. LDVR >= 1, and'),('*          if JOBVR = \'V\', LDVR >= N.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,8*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  No eigenvectors have been'),('*                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)'),('*                should be correct for j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in DHGEQZ.'),('*                =N+2: error return from DTGEVC.'),('*');
/*!40000 ALTER TABLE `dggev_Table206` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dggevx_Table210`
--

DROP TABLE IF EXISTS `dggevx_Table210`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dggevx_Table210` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dggevx_Table210`
--

LOCK TABLES `dggevx_Table210` WRITE;
/*!40000 ALTER TABLE `dggevx_Table210` DISABLE KEYS */;
INSERT INTO `dggevx_Table210` VALUES ('      SUBROUTINE DGGEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, B, LDB,'),('     $                   ALPHAR, ALPHAI, BETA, VL, LDVL, VR, LDVR, ILO,'),('     $                   IHI, LSCALE, RSCALE, ABNRM, BBNRM, RCONDE,'),('     $                   RCONDV, WORK, LWORK, IWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          BALANC, JOBVL, JOBVR, SENSE'),('      INTEGER            IHI, ILO, INFO, LDA, LDB, LDVL, LDVR, LWORK, N'),('      DOUBLE PRECISION   ABNRM, BBNRM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), ALPHAI( * ), ALPHAR( * ),'),('     $                   B( LDB, * ), BETA( * ), LSCALE( * ),'),('     $                   RCONDE( * ), RCONDV( * ), RSCALE( * ),'),('     $                   VL( LDVL, * ), VR( LDVR, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)'),('*  the generalized eigenvalues, and optionally, the left and/or right'),('*  generalized eigenvectors.'),('*'),('*  Optionally also, it computes a balancing transformation to improve'),('*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,'),('*  LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for'),('*  the eigenvalues (RCONDE), and reciprocal condition numbers for the'),('*  right eigenvectors (RCONDV).'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar'),('*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is'),('*  singular. It is usually represented as the pair (alpha,beta), as'),('*  there is a reasonable interpretation for beta=0, and even for both'),('*  being zero.'),('*'),('*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*'),('*                   A * v(j) = lambda(j) * B * v(j) .'),('*'),('*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*'),('*                   u(j)**H * A  = lambda(j) * u(j)**H * B.'),('*'),('*  where u(j)**H is the conjugate-transpose of u(j).'),('*'),('*'),('*  Arguments'),('*  ========='),('*'),('*  BALANC  (input) CHARACTER*1'),('*          Specifies the balance option to be performed.'),('*          = \'N\':  do not diagonally scale or permute;'),('*          = \'P\':  permute only;'),('*          = \'S\':  scale only;'),('*          = \'B\':  both permute and scale.'),('*          Computed reciprocal condition numbers will be for the'),('*          matrices after permuting and/or balancing. Permuting does'),('*          not change condition numbers (in exact arithmetic), but'),('*          balancing does.'),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\':  do not compute the left generalized eigenvectors;'),('*          = \'V\':  compute the left generalized eigenvectors.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\':  do not compute the right generalized eigenvectors;'),('*          = \'V\':  compute the right generalized eigenvectors.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': none are computed;'),('*          = \'E\': computed for eigenvalues only;'),('*          = \'V\': computed for eigenvectors only;'),('*          = \'B\': computed for eigenvalues and eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VL, and VR.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the matrix A in the pair (A,B).'),('*          On exit, A has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\''),('*          or both, then A contains the first part of the real Schur'),('*          form of the \"balanced\" versions of the input A and B.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)'),('*          On entry, the matrix B in the pair (A,B).'),('*          On exit, B has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\''),('*          or both, then B contains the second part of the real Schur'),('*          form of the \"balanced\" versions of the input A and B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  ALPHAR  (output) DOUBLE PRECISION array, dimension (N)'),('*  ALPHAI  (output) DOUBLE PRECISION array, dimension (N)'),('*  BETA    (output) DOUBLE PRECISION array, dimension (N)'),('*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will'),('*          be the generalized eigenvalues.  If ALPHAI(j) is zero, then'),('*          the j-th eigenvalue is real; if positive, then the j-th and'),('*          (j+1)-st eigenvalues are a complex conjugate pair, with'),('*          ALPHAI(j+1) negative.'),('*'),('*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)'),('*          may easily over- or underflow, and BETA(j) may even be zero.'),('*          Thus, the user should avoid naively computing the ratio'),('*          ALPHA/BETA. However, ALPHAR and ALPHAI will be always less'),('*          than and usually comparable with norm(A) in magnitude, and'),('*          BETA always less than and usually comparable with norm(B).'),('*'),('*  VL      (output) DOUBLE PRECISION array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order as'),('*          their eigenvalues. If the j-th eigenvalue is real, then'),('*          u(j) = VL(:,j), the j-th column of VL. If the j-th and'),('*          (j+1)-th eigenvalues form a complex conjugate pair, then'),('*          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).'),('*          Each eigenvector will be scaled so the largest component have'),('*          abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVL = \'N\'.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the matrix VL. LDVL >= 1, and'),('*          if JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) DOUBLE PRECISION array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order as'),('*          their eigenvalues. If the j-th eigenvalue is real, then'),('*          v(j) = VR(:,j), the j-th column of VR. If the j-th and'),('*          (j+1)-th eigenvalues form a complex conjugate pair, then'),('*          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).'),('*          Each eigenvector will be scaled so the largest component have'),('*          abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVR = \'N\'.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the matrix VR. LDVR >= 1, and'),('*          if JOBVR = \'V\', LDVR >= N.'),('*'),('*  ILO     (output) INTEGER'),('*  IHI     (output) INTEGER'),('*          ILO and IHI are integer values such that on exit'),('*          A(i,j) = 0 and B(i,j) = 0 if i > j and'),('*          j = 1,...,ILO-1 or i = IHI+1,...,N.'),('*          If BALANC = \'N\' or \'S\', ILO = 1 and IHI = N.'),('*'),('*  LSCALE  (output) DOUBLE PRECISION array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          to the left side of A and B.  If PL(j) is the index of the'),('*          row interchanged with row j, and DL(j) is the scaling'),('*          factor applied to row j, then'),('*            LSCALE(j) = PL(j)  for j = 1,...,ILO-1'),('*                      = DL(j)  for j = ILO,...,IHI'),('*                      = PL(j)  for j = IHI+1,...,N.'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  RSCALE  (output) DOUBLE PRECISION array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          to the right side of A and B.  If PR(j) is the index of the'),('*          column interchanged with column j, and DR(j) is the scaling'),('*          factor applied to column j, then'),('*            RSCALE(j) = PR(j)  for j = 1,...,ILO-1'),('*                      = DR(j)  for j = ILO,...,IHI'),('*                      = PR(j)  for j = IHI+1,...,N'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  ABNRM   (output) DOUBLE PRECISION'),('*          The one-norm of the balanced matrix A.'),('*'),('*  BBNRM   (output) DOUBLE PRECISION'),('*          The one-norm of the balanced matrix B.'),('*'),('*  RCONDE  (output) DOUBLE PRECISION array, dimension (N)'),('*          If SENSE = \'E\' or \'B\', the reciprocal condition numbers of'),('*          the eigenvalues, stored in consecutive elements of the array.'),('*          For a complex conjugate pair of eigenvalues two consecutive'),('*          elements of RCONDE are set to the same value. Thus RCONDE(j),'),('*          RCONDV(j), and the j-th columns of VL and VR all correspond'),('*          to the j-th eigenpair.'),('*          If SENSE = \'N or \'V\', RCONDE is not referenced.'),('*'),('*  RCONDV  (output) DOUBLE PRECISION array, dimension (N)'),('*          If SENSE = \'V\' or \'B\', the estimated reciprocal condition'),('*          numbers of the eigenvectors, stored in consecutive elements'),('*          of the array. For a complex eigenvector two consecutive'),('*          elements of RCONDV are set to the same value. If the'),('*          eigenvalues cannot be reordered to compute RCONDV(j),'),('*          RCONDV(j) is set to 0; this can only occur when the true'),('*          value would be very small anyway.'),('*          If SENSE = \'N\' or \'E\', RCONDV is not referenced.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,2*N).'),('*          If BALANC = \'S\' or \'B\', or JOBVL = \'V\', or JOBVR = \'V\','),('*          LWORK >= max(1,6*N).'),('*          If SENSE = \'E\' or \'B\', LWORK >= max(1,10*N).'),('*          If SENSE = \'V\' or \'B\', LWORK >= 2*N*N+8*N+16.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N+6)'),('*          If SENSE = \'E\', IWORK is not referenced.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          If SENSE = \'N\', BWORK is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  No eigenvectors have been'),('*                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)'),('*                should be correct for j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in DHGEQZ.'),('*                =N+2: error return from DTGEVC.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Balancing a matrix pair (A,B) includes, first, permuting rows and'),('*  columns to isolate eigenvalues, second, applying diagonal similarity'),('*  transformation to the rows and columns to make the rows and columns'),('*  as close in norm as possible. The computed reciprocal condition'),('*  numbers correspond to the balanced matrix. Permuting rows and columns'),('*  will not change the condition numbers (in exact arithmetic) but'),('*  diagonal scaling will.  For further explanation of balancing, see'),('*  section 4.11.1.2 of LAPACK Users\' Guide.'),('*'),('*  An approximate error bound on the chordal distance between the i-th'),('*  computed generalized eigenvalue w and the corresponding exact'),('*  eigenvalue lambda is'),('*'),('*       chord(w, lambda) <= EPS * norm(ABNRM, BBNRM) / RCONDE(I)'),('*'),('*  An approximate error bound for the angle between the i-th computed'),('*  eigenvector VL(i) or VR(i) is given by'),('*'),('*       EPS * norm(ABNRM, BBNRM) / DIF(i).'),('*'),('*  For further explanation of the reciprocal condition numbers RCONDE'),('*  and RCONDV, see section 4.11 of LAPACK User\'s Guide.'),('*');
/*!40000 ALTER TABLE `dggevx_Table210` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dggglm_Table102`
--

DROP TABLE IF EXISTS `dggglm_Table102`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dggglm_Table102` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dggglm_Table102`
--

LOCK TABLES `dggglm_Table102` WRITE;
/*!40000 ALTER TABLE `dggglm_Table102` DISABLE KEYS */;
INSERT INTO `dggglm_Table102` VALUES ('      SUBROUTINE DGGGLM( N, M, P, A, LDA, B, LDB, D, X, Y, WORK, LWORK,'),('     $                   INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), D( * ), WORK( * ),'),('     $                   X( * ), Y( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGGGLM solves a general Gauss-Markov linear model (GLM) problem:'),('*'),('*          minimize || y ||_2   subject to   d = A*x + B*y'),('*              x'),('*'),('*  where A is an N-by-M matrix, B is an N-by-P matrix, and d is a'),('*  given N-vector. It is assumed that M <= N <= M+P, and'),('*'),('*             rank(A) = M    and    rank( A B ) = N.'),('*'),('*  Under these assumptions, the constrained equation is always'),('*  consistent, and there is a unique solution x and a minimal 2-norm'),('*  solution y, which is obtained using a generalized QR factorization'),('*  of the matrices (A, B) given by'),('*'),('*     A = Q*(R),   B = Q*T*Z.'),('*           (0)'),('*'),('*  In particular, if matrix B is square nonsingular, then the problem'),('*  GLM is equivalent to the following weighted linear least squares'),('*  problem'),('*'),('*               minimize || inv(B)*(d-A*x) ||_2'),('*                   x'),('*'),('*  where inv(B) denotes the inverse of B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of rows of the matrices A and B.  N >= 0.'),('*'),('*  M       (input) INTEGER'),('*          The number of columns of the matrix A.  0 <= M <= N.'),('*'),('*  P       (input) INTEGER'),('*          The number of columns of the matrix B.  P >= N-M.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,M)'),('*          On entry, the N-by-M matrix A.'),('*          On exit, the upper triangular part of the array A contains'),('*          the M-by-M upper triangular matrix R.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,N).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,P)'),('*          On entry, the N-by-P matrix B.'),('*          On exit, if N <= P, the upper triangle of the subarray'),('*          B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;'),('*          if N > P, the elements on and above the (N-P)th subdiagonal'),('*          contain the N-by-P upper trapezoidal matrix T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,N).'),('*'),('*  D       (input/output) DOUBLE PRECISION array, dimension (N)'),('*          On entry, D is the left hand side of the GLM equation.'),('*          On exit, D is destroyed.'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (M)'),('*  Y       (output) DOUBLE PRECISION array, dimension (P)'),('*          On exit, X and Y are the solutions of the GLM problem.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,N+M+P).'),('*          For optimum performance, LWORK >= M+min(N,P)+max(N,P)*NB,'),('*          where NB is an upper bound for the optimal blocksizes for'),('*          DGEQRF, SGERQF, DORMQR and SORMRQ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1:  the upper triangular factor R associated with A in the'),('*                generalized QR factorization of the pair (A, B) is'),('*                singular, so that rank(A) < M; the least squares'),('*                solution could not be computed.'),('*          = 2:  the bottom (N-M) by (N-M) part of the upper trapezoidal'),('*                factor T associated with B in the generalized QR'),('*                factorization of the pair (A, B) is singular, so that'),('*                rank( A B ) < N; the least squares solution could not'),('*                be computed.'),('*');
/*!40000 ALTER TABLE `dggglm_Table102` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgglse_Table98`
--

DROP TABLE IF EXISTS `dgglse_Table98`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgglse_Table98` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgglse_Table98`
--

LOCK TABLES `dgglse_Table98` WRITE;
/*!40000 ALTER TABLE `dgglse_Table98` DISABLE KEYS */;
INSERT INTO `dgglse_Table98` VALUES ('      SUBROUTINE DGGLSE( M, N, P, A, LDA, B, LDB, C, D, X, WORK, LWORK,'),('     $                   INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), C( * ), D( * ),'),('     $                   WORK( * ), X( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGGLSE solves the linear equality-constrained least squares (LSE)'),('*  problem:'),('*'),('*          minimize || c - A*x ||_2   subject to   B*x = d'),('*'),('*  where A is an M-by-N matrix, B is a P-by-N matrix, c is a given'),('*  M-vector, and d is a given P-vector. It is assumed that'),('*  P <= N <= M+P, and'),('*'),('*           rank(B) = P and  rank( (A) ) = N.'),('*                                ( (B) )'),('*'),('*  These conditions ensure that the LSE problem has a unique solution,'),('*  which is obtained using a generalized RQ factorization of the'),('*  matrices (B, A) given by'),('*'),('*     B = (0 R)*Q,   A = Z*T*Q.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrices A and B. N >= 0.'),('*'),('*  P       (input) INTEGER'),('*          The number of rows of the matrix B. 0 <= P <= N <= M+P.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, the elements on and above the diagonal of the array'),('*          contain the min(M,N)-by-N upper trapezoidal matrix T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)'),('*          On entry, the P-by-N matrix B.'),('*          On exit, the upper triangle of the subarray B(1:P,N-P+1:N)'),('*          contains the P-by-P upper triangular matrix R.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,P).'),('*'),('*  C       (input/output) DOUBLE PRECISION array, dimension (M)'),('*          On entry, C contains the right hand side vector for the'),('*          least squares part of the LSE problem.'),('*          On exit, the residual sum of squares for the solution'),('*          is given by the sum of squares of elements N-P+1 to M of'),('*          vector C.'),('*'),('*  D       (input/output) DOUBLE PRECISION array, dimension (P)'),('*          On entry, D contains the right hand side vector for the'),('*          constrained equation.'),('*          On exit, D is destroyed.'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (N)'),('*          On exit, X is the solution of the LSE problem.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,M+N+P).'),('*          For optimum performance LWORK >= P+min(M,N)+max(M,N)*NB,'),('*          where NB is an upper bound for the optimal blocksizes for'),('*          DGEQRF, SGERQF, DORMQR and SORMRQ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1:  the upper triangular factor R associated with B in the'),('*                generalized RQ factorization of the pair (B, A) is'),('*                singular, so that rank(B) < P; the least squares'),('*                solution could not be computed.'),('*          = 2:  the (N-P) by (N-P) part of the upper trapezoidal factor'),('*                T associated with A in the generalized RQ factorization'),('*                of the pair (B, A) is singular, so that'),('*                rank( (A) ) < N; the least squares solution could not'),('*                    ( (B) )'),('*                be computed.'),('*');
/*!40000 ALTER TABLE `dgglse_Table98` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dggsvd_Table228`
--

DROP TABLE IF EXISTS `dggsvd_Table228`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dggsvd_Table228` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dggsvd_Table228`
--

LOCK TABLES `dggsvd_Table228` WRITE;
/*!40000 ALTER TABLE `dggsvd_Table228` DISABLE KEYS */;
INSERT INTO `dggsvd_Table228` VALUES ('      SUBROUTINE DGGSVD( JOBU, JOBV, JOBQ, M, N, P, K, L, A, LDA, B,'),('     $                   LDB, ALPHA, BETA, U, LDU, V, LDV, Q, LDQ, WORK,'),('     $                   IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBQ, JOBU, JOBV'),('      INTEGER            INFO, K, L, LDA, LDB, LDQ, LDU, LDV, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), ALPHA( * ), B( LDB, * ),'),('     $                   BETA( * ), Q( LDQ, * ), U( LDU, * ),'),('     $                   V( LDV, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGGSVD computes the generalized singular value decomposition (GSVD)'),('*  of an M-by-N real matrix A and P-by-N real matrix B:'),('*'),('*      U\'*A*Q = D1*( 0 R ),    V\'*B*Q = D2*( 0 R )'),('*'),('*  where U, V and Q are orthogonal matrices, and Z\' is the transpose'),('*  of Z.  Let K+L = the effective numerical rank of the matrix (A\',B\')\','),('*  then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and'),('*  D2 are M-by-(K+L) and P-by-(K+L) \"diagonal\" matrices and of the'),('*  following structures, respectively:'),('*'),('*  If M-K-L >= 0,'),('*'),('*                      K  L'),('*         D1 =     K ( I  0 )'),('*                  L ( 0  C )'),('*              M-K-L ( 0  0 )'),('*'),('*                    K  L'),('*         D2 =   L ( 0  S )'),('*              P-L ( 0  0 )'),('*'),('*                  N-K-L  K    L'),('*    ( 0 R ) = K (  0   R11  R12 )'),('*              L (  0    0   R22 )'),('*'),('*  where'),('*'),('*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),'),('*    S = diag( BETA(K+1),  ... , BETA(K+L) ),'),('*    C**2 + S**2 = I.'),('*'),('*    R is stored in A(1:K+L,N-K-L+1:N) on exit.'),('*'),('*  If M-K-L < 0,'),('*'),('*                    K M-K K+L-M'),('*         D1 =   K ( I  0    0   )'),('*              M-K ( 0  C    0   )'),('*'),('*                      K M-K K+L-M'),('*         D2 =   M-K ( 0  S    0  )'),('*              K+L-M ( 0  0    I  )'),('*                P-L ( 0  0    0  )'),('*'),('*                     N-K-L  K   M-K  K+L-M'),('*    ( 0 R ) =     K ( 0    R11  R12  R13  )'),('*                M-K ( 0     0   R22  R23  )'),('*              K+L-M ( 0     0    0   R33  )'),('*'),('*  where'),('*'),('*    C = diag( ALPHA(K+1), ... , ALPHA(M) ),'),('*    S = diag( BETA(K+1),  ... , BETA(M) ),'),('*    C**2 + S**2 = I.'),('*'),('*    (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored'),('*    ( 0  R22 R23 )'),('*    in B(M-K+1:L,N+M-K-L+1:N) on exit.'),('*'),('*  The routine computes C, S, R, and optionally the orthogonal'),('*  transformation matrices U, V and Q.'),('*'),('*  In particular, if B is an N-by-N nonsingular matrix, then the GSVD of'),('*  A and B implicitly gives the SVD of A*inv(B):'),('*                       A*inv(B) = U*(D1*inv(D2))*V\'.'),('*  If ( A\',B\')\' has orthonormal columns, then the GSVD of A and B is'),('*  also equal to the CS decomposition of A and B. Furthermore, the GSVD'),('*  can be used to derive the solution of the eigenvalue problem:'),('*                       A\'*A x = lambda* B\'*B x.'),('*  In some literature, the GSVD of A and B is presented in the form'),('*                   U\'*A*X = ( 0 D1 ),   V\'*B*X = ( 0 D2 )'),('*  where U and V are orthogonal and X is nonsingular, D1 and D2 are'),('*  ``diagonal\'\'.  The former GSVD form can be converted to the latter'),('*  form by taking the nonsingular matrix X as'),('*'),('*                       X = Q*( I   0    )'),('*                             ( 0 inv(R) ).'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBU    (input) CHARACTER*1'),('*          = \'U\':  Orthogonal matrix U is computed;'),('*          = \'N\':  U is not computed.'),('*'),('*  JOBV    (input) CHARACTER*1'),('*          = \'V\':  Orthogonal matrix V is computed;'),('*          = \'N\':  V is not computed.'),('*'),('*  JOBQ    (input) CHARACTER*1'),('*          = \'Q\':  Orthogonal matrix Q is computed;'),('*          = \'N\':  Q is not computed.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrices A and B.  N >= 0.'),('*'),('*  P       (input) INTEGER'),('*          The number of rows of the matrix B.  P >= 0.'),('*'),('*  K       (output) INTEGER'),('*  L       (output) INTEGER'),('*          On exit, K and L specify the dimension of the subblocks'),('*          described in the Purpose section.'),('*          K + L = effective numerical rank of (A\',B\')\'.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A contains the triangular matrix R, or part of R.'),('*          See Purpose for details.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,N)'),('*          On entry, the P-by-N matrix B.'),('*          On exit, B contains the triangular matrix R if M-K-L < 0.'),('*          See Purpose for details.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,P).'),('*'),('*  ALPHA   (output) DOUBLE PRECISION array, dimension (N)'),('*  BETA    (output) DOUBLE PRECISION array, dimension (N)'),('*          On exit, ALPHA and BETA contain the generalized singular'),('*          value pairs of A and B;'),('*            ALPHA(1:K) = 1,'),('*            BETA(1:K)  = 0,'),('*          and if M-K-L >= 0,'),('*            ALPHA(K+1:K+L) = C,'),('*            BETA(K+1:K+L)  = S,'),('*          or if M-K-L < 0,'),('*            ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0'),('*            BETA(K+1:M) =S, BETA(M+1:K+L) =1'),('*          and'),('*            ALPHA(K+L+1:N) = 0'),('*            BETA(K+L+1:N)  = 0'),('*'),('*  U       (output) DOUBLE PRECISION array, dimension (LDU,M)'),('*          If JOBU = \'U\', U contains the M-by-M orthogonal matrix U.'),('*          If JOBU = \'N\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U. LDU >= max(1,M) if'),('*          JOBU = \'U\'; LDU >= 1 otherwise.'),('*'),('*  V       (output) DOUBLE PRECISION array, dimension (LDV,P)'),('*          If JOBV = \'V\', V contains the P-by-P orthogonal matrix V.'),('*          If JOBV = \'N\', V is not referenced.'),('*'),('*  LDV     (input) INTEGER'),('*          The leading dimension of the array V. LDV >= max(1,P) if'),('*          JOBV = \'V\'; LDV >= 1 otherwise.'),('*'),('*  Q       (output) DOUBLE PRECISION array, dimension (LDQ,N)'),('*          If JOBQ = \'Q\', Q contains the N-by-N orthogonal matrix Q.'),('*          If JOBQ = \'N\', Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q. LDQ >= max(1,N) if'),('*          JOBQ = \'Q\'; LDQ >= 1 otherwise.'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array,'),('*                      dimension (max(3*N,M,P)+N)'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (N)'),('*          On exit, IWORK stores the sorting information. More'),('*          precisely, the following loop will sort ALPHA'),('*             for I = K+1, min(M,K+L)'),('*                 swap ALPHA(I) and ALPHA(IWORK(I))'),('*             endfor'),('*          such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = 1, the Jacobi-type procedure failed to'),('*                converge.  For further details, see subroutine DTGSJA.'),('*'),('*  Internal Parameters'),('*  ==================='),('*'),('*  TOLA    DOUBLE PRECISION'),('*  TOLB    DOUBLE PRECISION'),('*          TOLA and TOLB are the thresholds to determine the effective'),('*          rank of (A\',B\')\'. Generally, they are set to'),('*                   TOLA = MAX(M,N)*norm(A)*MAZHEPS,'),('*                   TOLB = MAX(P,N)*norm(B)*MAZHEPS.'),('*          The size of TOLA and TOLB may affect the size of backward'),('*          errors of the decomposition.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  2-96 Based on modifications by'),('*     Ming Gu and Huan Ren, Computer Science Division, University of'),('*     California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `dggsvd_Table228` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgtsv_Table10`
--

DROP TABLE IF EXISTS `dgtsv_Table10`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgtsv_Table10` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgtsv_Table10`
--

LOCK TABLES `dgtsv_Table10` WRITE;
/*!40000 ALTER TABLE `dgtsv_Table10` DISABLE KEYS */;
INSERT INTO `dgtsv_Table10` VALUES ('      SUBROUTINE DGTSV( N, NRHS, DL, D, DU, B, LDB, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   B( LDB, * ), D( * ), DL( * ), DU( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGTSV  solves the equation'),('*'),('*     A*X = B,'),('*'),('*  where A is an n by n tridiagonal matrix, by Gaussian elimination with'),('*  partial pivoting.'),('*'),('*  Note that the equation  A\'*X = B  may be solved by interchanging the'),('*  order of the arguments DU and DL.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  DL      (input/output) DOUBLE PRECISION array, dimension (N-1)'),('*          On entry, DL must contain the (n-1) sub-diagonal elements of'),('*          A.'),('*'),('*          On exit, DL is overwritten by the (n-2) elements of the'),('*          second super-diagonal of the upper triangular matrix U from'),('*          the LU factorization of A, in DL(1), ..., DL(n-2).'),('*'),('*  D       (input/output) DOUBLE PRECISION array, dimension (N)'),('*          On entry, D must contain the diagonal elements of A.'),('*'),('*          On exit, D is overwritten by the n diagonal elements of U.'),('*'),('*  DU      (input/output) DOUBLE PRECISION array, dimension (N-1)'),('*          On entry, DU must contain the (n-1) super-diagonal elements'),('*          of A.'),('*'),('*          On exit, DU is overwritten by the (n-1) elements of the first'),('*          super-diagonal of U.'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N by NRHS matrix of right hand side matrix B.'),('*          On exit, if INFO = 0, the N by NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, U(i,i) is exactly zero, and the solution'),('*               has not been computed.  The factorization has not been'),('*               completed unless i = N.'),('*');
/*!40000 ALTER TABLE `dgtsv_Table10` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dgtsvx_Table50`
--

DROP TABLE IF EXISTS `dgtsvx_Table50`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dgtsvx_Table50` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dgtsvx_Table50`
--

LOCK TABLES `dgtsvx_Table50` WRITE;
/*!40000 ALTER TABLE `dgtsvx_Table50` DISABLE KEYS */;
INSERT INTO `dgtsvx_Table50` VALUES ('      SUBROUTINE DGTSVX( FACT, TRANS, N, NRHS, DL, D, DU, DLF, DF, DUF,'),('     $                   DU2, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, IWORK, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, TRANS'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * ), IWORK( * )'),('      DOUBLE PRECISION   B( LDB, * ), BERR( * ), D( * ), DF( * ),'),('     $                   DL( * ), DLF( * ), DU( * ), DU2( * ), DUF( * ),'),('     $                   FERR( * ), WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DGTSVX uses the LU factorization to compute the solution to a real'),('*  system of linear equations A * X = B or A**T * X = B,'),('*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the LU decomposition is used to factor the matrix A'),('*     as A = L * U, where L is a product of permutation and unit lower'),('*     bidiagonal matrices and U is upper triangular with nonzeros in'),('*     only the main diagonal and first two superdiagonals.'),('*'),('*  2. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored'),('*                  form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV'),('*                  will not be modified.'),('*          = \'N\':  The matrix will be copied to DLF, DF, and DUF'),('*                  and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations:'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  DL      (input) DOUBLE PRECISION array, dimension (N-1)'),('*          The (n-1) subdiagonal elements of A.'),('*'),('*  D       (input) DOUBLE PRECISION array, dimension (N)'),('*          The n diagonal elements of A.'),('*'),('*  DU      (input) DOUBLE PRECISION array, dimension (N-1)'),('*          The (n-1) superdiagonal elements of A.'),('*'),('*  DLF     (input or output) DOUBLE PRECISION array, dimension (N-1)'),('*          If FACT = \'F\', then DLF is an input argument and on entry'),('*          contains the (n-1) multipliers that define the matrix L from'),('*          the LU factorization of A as computed by DGTTRF.'),('*'),('*          If FACT = \'N\', then DLF is an output argument and on exit'),('*          contains the (n-1) multipliers that define the matrix L from'),('*          the LU factorization of A.'),('*'),('*  DF      (input or output) DOUBLE PRECISION array, dimension (N)'),('*          If FACT = \'F\', then DF is an input argument and on entry'),('*          contains the n diagonal elements of the upper triangular'),('*          matrix U from the LU factorization of A.'),('*'),('*          If FACT = \'N\', then DF is an output argument and on exit'),('*          contains the n diagonal elements of the upper triangular'),('*          matrix U from the LU factorization of A.'),('*'),('*  DUF     (input or output) DOUBLE PRECISION array, dimension (N-1)'),('*          If FACT = \'F\', then DUF is an input argument and on entry'),('*          contains the (n-1) elements of the first superdiagonal of U.'),('*'),('*          If FACT = \'N\', then DUF is an output argument and on exit'),('*          contains the (n-1) elements of the first superdiagonal of U.'),('*'),('*  DU2     (input or output) DOUBLE PRECISION array, dimension (N-2)'),('*          If FACT = \'F\', then DU2 is an input argument and on entry'),('*          contains the (n-2) elements of the second superdiagonal of'),('*          U.'),('*'),('*          If FACT = \'N\', then DU2 is an output argument and on exit'),('*          contains the (n-2) elements of the second superdiagonal of'),('*          U.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the LU factorization of A as'),('*          computed by DGTTRF.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the LU factorization of A;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates'),('*          a row interchange was not required.'),('*'),('*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization'),('*                       has not been completed unless i = N, but the'),('*                       factor U is exactly singular, so the solution'),('*                       and error bounds could not be computed.'),('*                       RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `dgtsvx_Table50` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dpbsv_Table22`
--

DROP TABLE IF EXISTS `dpbsv_Table22`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dpbsv_Table22` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dpbsv_Table22`
--

LOCK TABLES `dpbsv_Table22` WRITE;
/*!40000 ALTER TABLE `dpbsv_Table22` DISABLE KEYS */;
INSERT INTO `dpbsv_Table22` VALUES ('      SUBROUTINE DPBSV( UPLO, N, KD, NRHS, AB, LDAB, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, KD, LDAB, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   AB( LDAB, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DPBSV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite band matrix and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**T * U,  if UPLO = \'U\', or'),('*     A = L * L**T,  if UPLO = \'L\','),('*  where U is an upper triangular band matrix, and L is a lower'),('*  triangular band matrix, with the same number of superdiagonals or'),('*  subdiagonals as A.  The factored form of A is then used to solve the'),('*  system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).'),('*          See below for further details.'),('*'),('*          On exit, if INFO = 0, the triangular factor U or L from the'),('*          Cholesky factorization A = U**T*U or A = L*L**T of the band'),('*          matrix A, in the same storage format as A.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD+1.'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  N = 6, KD = 2, and UPLO = \'U\':'),('*'),('*  On entry:                       On exit:'),('*'),('*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46'),('*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56'),('*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66'),('*'),('*  Similarly, if UPLO = \'L\' the format of A is as follows:'),('*'),('*  On entry:                       On exit:'),('*'),('*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66'),('*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *'),('*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *'),('*'),('*  Array elements marked * are not used by the routine.'),('*');
/*!40000 ALTER TABLE `dpbsv_Table22` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dpbsvx_Table62`
--

DROP TABLE IF EXISTS `dpbsvx_Table62`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dpbsvx_Table62` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dpbsvx_Table62`
--

LOCK TABLES `dpbsvx_Table62` WRITE;
/*!40000 ALTER TABLE `dpbsvx_Table62` DISABLE KEYS */;
INSERT INTO `dpbsvx_Table62` VALUES ('      SUBROUTINE DPBSVX( FACT, UPLO, N, KD, NRHS, AB, LDAB, AFB, LDAFB,'),('     $                   EQUED, S, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, KD, LDAB, LDAFB, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),'),('     $                   BERR( * ), FERR( * ), S( * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to'),('*  compute the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite band matrix and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U**T * U,  if UPLO = \'U\', or'),('*        A = L * L**T,  if UPLO = \'L\','),('*     where U is an upper triangular band matrix, and L is a lower'),('*     triangular band matrix.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFB contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  AB and AFB will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AFB and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFB and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right-hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB,N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first KD+1 rows of the array, except'),('*          if FACT = \'F\' and EQUED = \'Y\', then A must contain the'),('*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A'),('*          is stored in the j-th column of the array AB as follows:'),('*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).'),('*          See below for further details.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array A.  LDAB >= KD+1.'),('*'),('*  AFB     (input or output) DOUBLE PRECISION array, dimension (LDAFB,N)'),('*          If FACT = \'F\', then AFB is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T of the band matrix'),('*          A, in the same storage format as A (see AB).  If EQUED = \'Y\','),('*          then AFB is the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFB is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T.'),('*'),('*          If FACT = \'E\', then AFB is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T of the equilibrated'),('*          matrix A (see the description of A for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAFB   (input) INTEGER'),('*          The leading dimension of the array AFB.  LDAFB >= KD+1.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  N = 6, KD = 2, and UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11  a12  a13'),('*          a22  a23  a24'),('*               a33  a34  a35'),('*                    a44  a45  a46'),('*                         a55  a56'),('*     (aij=conjg(aji))         a66'),('*'),('*  Band storage of the upper triangle of A:'),('*'),('*      *    *   a13  a24  a35  a46'),('*      *   a12  a23  a34  a45  a56'),('*     a11  a22  a33  a44  a55  a66'),('*'),('*  Similarly, if UPLO = \'L\' the format of A is as follows:'),('*'),('*     a11  a22  a33  a44  a55  a66'),('*     a21  a32  a43  a54  a65   *'),('*     a31  a42  a53  a64   *    *'),('*'),('*  Array elements marked * are not used by the routine.'),('*');
/*!40000 ALTER TABLE `dpbsvx_Table62` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dposv_Table18`
--

DROP TABLE IF EXISTS `dposv_Table18`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dposv_Table18` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dposv_Table18`
--

LOCK TABLES `dposv_Table18` WRITE;
/*!40000 ALTER TABLE `dposv_Table18` DISABLE KEYS */;
INSERT INTO `dposv_Table18` VALUES ('      SUBROUTINE DPOSV( UPLO, N, NRHS, A, LDA, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDA, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DPOSV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite matrix and X and B'),('*  are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**T* U,  if UPLO = \'U\', or'),('*     A = L * L**T,  if UPLO = \'L\','),('*  where U is an upper triangular matrix and L is a lower triangular'),('*  matrix.  The factored form of A is then used to solve the system of'),('*  equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.'),('*'),('*          On exit, if INFO = 0, the factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*');
/*!40000 ALTER TABLE `dposv_Table18` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dposvx_Table58`
--

DROP TABLE IF EXISTS `dposvx_Table58`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dposvx_Table58` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dposvx_Table58`
--

LOCK TABLES `dposvx_Table58` WRITE;
/*!40000 ALTER TABLE `dposvx_Table58` DISABLE KEYS */;
INSERT INTO `dposvx_Table58` VALUES ('      SUBROUTINE DPOSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, EQUED,'),('     $                   S, B, LDB, X, LDX, RCOND, FERR, BERR, WORK,'),('     $                   IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   BERR( * ), FERR( * ), S( * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to'),('*  compute the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite matrix and X and B'),('*  are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U**T* U,  if UPLO = \'U\', or'),('*        A = L * L**T,  if UPLO = \'L\','),('*     where U is an upper triangular matrix and L is a lower triangular'),('*     matrix.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AF contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  A and AF will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AF and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the symmetric matrix A, except if FACT = \'F\' and'),('*          EQUED = \'Y\', then A must contain the equilibrated matrix'),('*          diag(S)*A*diag(S).  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.  A is not modified if'),('*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T, in the same storage'),('*          format as A.  If EQUED .ne. \'N\', then AF is the factored form'),('*          of the equilibrated matrix diag(S)*A*diag(S).'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T of the original'),('*          matrix A.'),('*'),('*          If FACT = \'E\', then AF is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T of the equilibrated'),('*          matrix A (see the description of A for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `dposvx_Table58` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dppsv_Table26`
--

DROP TABLE IF EXISTS `dppsv_Table26`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dppsv_Table26` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dppsv_Table26`
--

LOCK TABLES `dppsv_Table26` WRITE;
/*!40000 ALTER TABLE `dppsv_Table26` DISABLE KEYS */;
INSERT INTO `dppsv_Table26` VALUES ('      SUBROUTINE DPPSV( UPLO, N, NRHS, AP, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   AP( * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DPPSV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite matrix stored in'),('*  packed format and X and B are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**T* U,  if UPLO = \'U\', or'),('*     A = L * L**T,  if UPLO = \'L\','),('*  where U is an upper triangular matrix and L is a lower triangular'),('*  matrix.  The factored form of A is then used to solve the system of'),('*  equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*          On exit, if INFO = 0, the factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T, in the same storage'),('*          format as A.'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `dppsv_Table26` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dppsvx_Table66`
--

DROP TABLE IF EXISTS `dppsvx_Table66`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dppsvx_Table66` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dppsvx_Table66`
--

LOCK TABLES `dppsvx_Table66` WRITE;
/*!40000 ALTER TABLE `dppsvx_Table66` DISABLE KEYS */;
INSERT INTO `dppsvx_Table66` VALUES ('      SUBROUTINE DPPSVX( FACT, UPLO, N, NRHS, AP, AFP, EQUED, S, B, LDB,'),('     $                   X, LDX, RCOND, FERR, BERR, WORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   AFP( * ), AP( * ), B( LDB, * ), BERR( * ),'),('     $                   FERR( * ), S( * ), WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to'),('*  compute the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite matrix stored in'),('*  packed format and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U**T* U,  if UPLO = \'U\', or'),('*        A = L * L**T,  if UPLO = \'L\','),('*     where U is an upper triangular matrix and L is a lower triangular'),('*     matrix.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFP contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  AP and AFP will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AFP and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFP and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array, except if FACT = \'F\''),('*          and EQUED = \'Y\', then A must contain the equilibrated matrix'),('*          diag(S)*A*diag(S).  The j-th column of A is stored in the'),('*          array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.  A is not modified if'),('*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  AFP     (input or output) DOUBLE PRECISION array, dimension'),('*                            (N*(N+1)/2)'),('*          If FACT = \'F\', then AFP is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U\'*U or A = L*L\', in the same storage'),('*          format as A.  If EQUED .ne. \'N\', then AFP is the factored'),('*          form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFP is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U\'*U or A = L*L\' of the original matrix A.'),('*'),('*          If FACT = \'E\', then AFP is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U\'*U or A = L*L\' of the equilibrated'),('*          matrix A (see the description of AP for the form of the'),('*          equilibrated matrix).'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `dppsvx_Table66` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dptsv_Table30`
--

DROP TABLE IF EXISTS `dptsv_Table30`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dptsv_Table30` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dptsv_Table30`
--

LOCK TABLES `dptsv_Table30` WRITE;
/*!40000 ALTER TABLE `dptsv_Table30` DISABLE KEYS */;
INSERT INTO `dptsv_Table30` VALUES ('      SUBROUTINE DPTSV( N, NRHS, D, E, B, LDB, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   B( LDB, * ), D( * ), E( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DPTSV computes the solution to a real system of linear equations'),('*  A*X = B, where A is an N-by-N symmetric positive definite tridiagonal'),('*  matrix, and X and B are N-by-NRHS matrices.'),('*'),('*  A is factored as A = L*D*L**T, and the factored form of A is then'),('*  used to solve the system of equations.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  D       (input/output) DOUBLE PRECISION array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.  On exit, the n diagonal elements of the diagonal matrix'),('*          D from the factorization A = L*D*L**T.'),('*'),('*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A.  On exit, the (n-1) subdiagonal elements of the'),('*          unit bidiagonal factor L from the L*D*L**T factorization of'),('*          A.  (E can also be regarded as the superdiagonal of the unit'),('*          bidiagonal factor U from the U**T*D*U factorization of A.)'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i is not'),('*                positive definite, and the solution has not been'),('*                computed.  The factorization has not been completed'),('*                unless i = N.'),('*');
/*!40000 ALTER TABLE `dptsv_Table30` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dptsvx_Table70`
--

DROP TABLE IF EXISTS `dptsvx_Table70`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dptsvx_Table70` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dptsvx_Table70`
--

LOCK TABLES `dptsvx_Table70` WRITE;
/*!40000 ALTER TABLE `dptsvx_Table70` DISABLE KEYS */;
INSERT INTO `dptsvx_Table70` VALUES ('      SUBROUTINE DPTSVX( FACT, N, NRHS, D, E, DF, EF, B, LDB, X, LDX,'),('     $                   RCOND, FERR, BERR, WORK, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   B( LDB, * ), BERR( * ), D( * ), DF( * ),'),('     $                   E( * ), EF( * ), FERR( * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DPTSVX uses the factorization A = L*D*L**T to compute the solution'),('*  to a real system of linear equations A*X = B, where A is an N-by-N'),('*  symmetric positive definite tridiagonal matrix and X and B are'),('*  N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the matrix A is factored as A = L*D*L**T, where L'),('*     is a unit lower bidiagonal matrix and D is diagonal.  The'),('*     factorization can also be regarded as having the form'),('*     A = U**T*D*U.'),('*'),('*  2. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, DF and EF contain the factored form of A.'),('*                  D, E, DF, and EF will not be modified.'),('*          = \'N\':  The matrix A will be copied to DF and EF and'),('*                  factored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  D       (input) DOUBLE PRECISION array, dimension (N)'),('*          The n diagonal elements of the tridiagonal matrix A.'),('*'),('*  E       (input) DOUBLE PRECISION array, dimension (N-1)'),('*          The (n-1) subdiagonal elements of the tridiagonal matrix A.'),('*'),('*  DF      (input or output) DOUBLE PRECISION array, dimension (N)'),('*          If FACT = \'F\', then DF is an input argument and on entry'),('*          contains the n diagonal elements of the diagonal matrix D'),('*          from the L*D*L**T factorization of A.'),('*          If FACT = \'N\', then DF is an output argument and on exit'),('*          contains the n diagonal elements of the diagonal matrix D'),('*          from the L*D*L**T factorization of A.'),('*'),('*  EF      (input or output) DOUBLE PRECISION array, dimension (N-1)'),('*          If FACT = \'F\', then EF is an input argument and on entry'),('*          contains the (n-1) subdiagonal elements of the unit'),('*          bidiagonal factor L from the L*D*L**T factorization of A.'),('*          If FACT = \'N\', then EF is an output argument and on exit'),('*          contains the (n-1) subdiagonal elements of the unit'),('*          bidiagonal factor L from the L*D*L**T factorization of A.'),('*'),('*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)'),('*          If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The reciprocal condition number of the matrix A.  If RCOND'),('*          is less than the machine precision (in particular, if'),('*          RCOND = 0), the matrix is singular to working precision.'),('*          This condition is indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in any'),('*          element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (2*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `dptsvx_Table70` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsbev_Table114`
--

DROP TABLE IF EXISTS `dsbev_Table114`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsbev_Table114` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsbev_Table114`
--

LOCK TABLES `dsbev_Table114` WRITE;
/*!40000 ALTER TABLE `dsbev_Table114` DISABLE KEYS */;
INSERT INTO `dsbev_Table114` VALUES ('      SUBROUTINE DSBEV( JOBZ, UPLO, N, KD, AB, LDAB, W, Z, LDZ, WORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KD, LDAB, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   AB( LDAB, * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSBEV computes all the eigenvalues and, optionally, eigenvectors of'),('*  a real symmetric band matrix A.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the first'),('*          superdiagonal and the diagonal of the tridiagonal matrix T'),('*          are returned in rows KD and KD+1 of AB, and if UPLO = \'L\','),('*          the diagonal and first subdiagonal of T are returned in the'),('*          first two rows of AB.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (max(1,3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `dsbev_Table114` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsbevd_Table142`
--

DROP TABLE IF EXISTS `dsbevd_Table142`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsbevd_Table142` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsbevd_Table142`
--

LOCK TABLES `dsbevd_Table142` WRITE;
/*!40000 ALTER TABLE `dsbevd_Table142` DISABLE KEYS */;
INSERT INTO `dsbevd_Table142` VALUES ('      SUBROUTINE DSBEVD( JOBZ, UPLO, N, KD, AB, LDAB, W, Z, LDZ, WORK,'),('     $                   LWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KD, LDAB, LDZ, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   AB( LDAB, * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSBEVD computes all the eigenvalues and, optionally, eigenvectors of'),('*  a real symmetric band matrix A. If eigenvectors are desired, it uses'),('*  a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the first'),('*          superdiagonal and the diagonal of the tridiagonal matrix T'),('*          are returned in rows KD and KD+1 of AB, and if UPLO = \'L\','),('*          the diagonal and first subdiagonal of T are returned in the'),('*          first two rows of AB.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array,'),('*                                         dimension (LWORK)'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          IF N <= 1,                LWORK must be at least 1.'),('*          If JOBZ  = \'N\' and N > 2, LWORK must be at least 2*N.'),('*          If JOBZ  = \'V\' and N > 2, LWORK must be at least'),('*                         ( 1 + 5*N + 2*N**2 ).'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array LIWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 2, LIWORK must be at least 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `dsbevd_Table142` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsbevx_Table128`
--

DROP TABLE IF EXISTS `dsbevx_Table128`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsbevx_Table128` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsbevx_Table128`
--

LOCK TABLES `dsbevx_Table128` WRITE;
/*!40000 ALTER TABLE `dsbevx_Table128` DISABLE KEYS */;
INSERT INTO `dsbevx_Table128` VALUES ('      SUBROUTINE DSBEVX( JOBZ, RANGE, UPLO, N, KD, AB, LDAB, Q, LDQ, VL,'),('     $                   VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK, IWORK,'),('     $                   IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, KD, LDAB, LDQ, LDZ, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   AB( LDAB, * ), Q( LDQ, * ), W( * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSBEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric band matrix A.  Eigenvalues and eigenvectors can'),('*  be selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the first'),('*          superdiagonal and the diagonal of the tridiagonal matrix T'),('*          are returned in rows KD and KD+1 of AB, and if UPLO = \'L\','),('*          the diagonal and first subdiagonal of T are returned in the'),('*          first two rows of AB.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)'),('*          If JOBZ = \'V\', the N-by-N orthogonal matrix used in the'),('*                         reduction to tridiagonal form.'),('*          If JOBZ = \'N\', the array Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q.  If JOBZ = \'V\', then'),('*          LDQ >= max(1,N).'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AB to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `dsbevx_Table128` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsbgv_Table162`
--

DROP TABLE IF EXISTS `dsbgv_Table162`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsbgv_Table162` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsbgv_Table162`
--

LOCK TABLES `dsbgv_Table162` WRITE;
/*!40000 ALTER TABLE `dsbgv_Table162` DISABLE KEYS */;
INSERT INTO `dsbgv_Table162` VALUES ('      SUBROUTINE DSBGV( JOBZ, UPLO, N, KA, KB, AB, LDAB, BB, LDBB, W, Z,'),('     $                  LDZ, WORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KA, KB, LDAB, LDBB, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   AB( LDAB, * ), BB( LDBB, * ), W( * ),'),('     $                   WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSBGV computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a real generalized symmetric-definite banded eigenproblem, of'),('*  the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric'),('*  and banded, and B is also positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KB >= 0.'),('*'),('*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) DOUBLE PRECISION array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**T*S, as returned by DPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i). The eigenvectors are'),('*          normalized so that Z**T*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= N.'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is:'),('*             <= N:  the algorithm failed to converge:'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then DPBSTF'),('*                    returned INFO = i: B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `dsbgv_Table162` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsbgvd_Table186`
--

DROP TABLE IF EXISTS `dsbgvd_Table186`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsbgvd_Table186` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsbgvd_Table186`
--

LOCK TABLES `dsbgvd_Table186` WRITE;
/*!40000 ALTER TABLE `dsbgvd_Table186` DISABLE KEYS */;
INSERT INTO `dsbgvd_Table186` VALUES ('      SUBROUTINE DSBGVD( JOBZ, UPLO, N, KA, KB, AB, LDAB, BB, LDBB, W,'),('     $                   Z, LDZ, WORK, LWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KA, KB, LDAB, LDBB, LDZ, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   AB( LDAB, * ), BB( LDBB, * ), W( * ),'),('     $                   WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSBGVD computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a real generalized symmetric-definite banded eigenproblem, of the'),('*  form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and'),('*  banded, and B is also positive definite.  If eigenvectors are'),('*  desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KB >= 0.'),('*'),('*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) DOUBLE PRECISION array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**T*S, as returned by DPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i).  The eigenvectors are'),('*          normalized so Z**T*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK >= 3*N.'),('*          If JOBZ = \'V\' and N > 1, LWORK >= 1 + 5*N + 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if LIWORK > 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK >= 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is:'),('*             <= N:  the algorithm failed to converge:'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then DPBSTF'),('*                    returned INFO = i: B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `dsbgvd_Table186` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsbgvx_Table174`
--

DROP TABLE IF EXISTS `dsbgvx_Table174`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsbgvx_Table174` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsbgvx_Table174`
--

LOCK TABLES `dsbgvx_Table174` WRITE;
/*!40000 ALTER TABLE `dsbgvx_Table174` DISABLE KEYS */;
INSERT INTO `dsbgvx_Table174` VALUES ('      SUBROUTINE DSBGVX( JOBZ, RANGE, UPLO, N, KA, KB, AB, LDAB, BB,'),('     $                   LDBB, Q, LDQ, VL, VU, IL, IU, ABSTOL, M, W, Z,'),('     $                   LDZ, WORK, IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, KA, KB, LDAB, LDBB, LDQ, LDZ, M,'),('     $                   N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   AB( LDAB, * ), BB( LDBB, * ), Q( LDQ, * ),'),('     $                   W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSBGVX computes selected eigenvalues, and optionally, eigenvectors'),('*  of a real generalized symmetric-definite banded eigenproblem, of'),('*  the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric'),('*  and banded, and B is also positive definite.  Eigenvalues and'),('*  eigenvectors can be selected by specifying either all eigenvalues,'),('*  a range of values or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KB >= 0.'),('*'),('*  AB      (input/output) DOUBLE PRECISION array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) DOUBLE PRECISION array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**T*S, as returned by DPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  Q       (output) DOUBLE PRECISION array, dimension (LDQ, N)'),('*          If JOBZ = \'V\', the n-by-n matrix used in the reduction of'),('*          A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,'),('*          and consequently C to tridiagonal form.'),('*          If JOBZ = \'N\', the array Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q.  If JOBZ = \'N\','),('*          LDQ >= 1. If JOBZ = \'V\', LDQ >= max(1,N).'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i).  The eigenvectors are'),('*          normalized so Z**T*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (7*N)'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (M)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvalues that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0 : successful exit'),('*          < 0 : if INFO = -i, the i-th argument had an illegal value'),('*          <= N: if INFO = i, then i eigenvectors failed to converge.'),('*                  Their indices are stored in IFAIL.'),('*          > N : DPBSTF returned an error code; i.e.,'),('*                if INFO = N + i, for 1 <= i <= N, then the leading'),('*                minor of order i of B is not positive definite.'),('*                The factorization of B could not be completed and'),('*                no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `dsbgvx_Table174` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dspev_Table116`
--

DROP TABLE IF EXISTS `dspev_Table116`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dspev_Table116` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dspev_Table116`
--

LOCK TABLES `dspev_Table116` WRITE;
/*!40000 ALTER TABLE `dspev_Table116` DISABLE KEYS */;
INSERT INTO `dspev_Table116` VALUES ('      SUBROUTINE DSPEV( JOBZ, UPLO, N, AP, W, Z, LDZ, WORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   AP( * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSPEV computes all the eigenvalues and, optionally, eigenvectors of a'),('*  real symmetric matrix A in packed storage.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `dspev_Table116` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dspevd_Table144`
--

DROP TABLE IF EXISTS `dspevd_Table144`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dspevd_Table144` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dspevd_Table144`
--

LOCK TABLES `dspevd_Table144` WRITE;
/*!40000 ALTER TABLE `dspevd_Table144` DISABLE KEYS */;
INSERT INTO `dspevd_Table144` VALUES ('      SUBROUTINE DSPEVD( JOBZ, UPLO, N, AP, W, Z, LDZ, WORK, LWORK,'),('     $                   IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDZ, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   AP( * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSPEVD computes all the eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric matrix A in packed storage. If eigenvectors are'),('*  desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array,'),('*                                         dimension (LWORK)'),('*          On exit, if INFO = 0, WORK(1) returns the required LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK must be at least 2*N.'),('*          If JOBZ = \'V\' and N > 1, LWORK must be at least'),('*                                                 1 + 6*N + N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the required sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the required LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK must be at least 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `dspevd_Table144` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dspevx_Table130`
--

DROP TABLE IF EXISTS `dspevx_Table130`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dspevx_Table130` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dspevx_Table130`
--

LOCK TABLES `dspevx_Table130` WRITE;
/*!40000 ALTER TABLE `dspevx_Table130` DISABLE KEYS */;
INSERT INTO `dspevx_Table130` VALUES ('      SUBROUTINE DSPEVX( JOBZ, RANGE, UPLO, N, AP, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, WORK, IWORK, IFAIL,'),('     $                   INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDZ, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   AP( * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSPEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric matrix A in packed storage.  Eigenvalues/vectors'),('*  can be selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AP to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the selected eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (8*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `dspevx_Table130` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dspgv_Table164`
--

DROP TABLE IF EXISTS `dspgv_Table164`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dspgv_Table164` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dspgv_Table164`
--

LOCK TABLES `dspgv_Table164` WRITE;
/*!40000 ALTER TABLE `dspgv_Table164` DISABLE KEYS */;
INSERT INTO `dspgv_Table164` VALUES ('      SUBROUTINE DSPGV( ITYPE, JOBZ, UPLO, N, AP, BP, W, Z, LDZ, WORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   AP( * ), BP( * ), W( * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSPGV computes all the eigenvalues and, optionally, the eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.'),('*  Here A and B are assumed to be symmetric, stored in packed format,'),('*  and B is also positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  AP      (input/output) DOUBLE PRECISION array, dimension'),('*                            (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T, in the same storage'),('*          format as B.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors.  The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  DPPTRF or DSPEV returned an error code:'),('*             <= N:  if INFO = i, DSPEV failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero.'),('*             > N:   if INFO = n + i, for 1 <= i <= n, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `dspgv_Table164` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dspgvd_Table188`
--

DROP TABLE IF EXISTS `dspgvd_Table188`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dspgvd_Table188` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dspgvd_Table188`
--

LOCK TABLES `dspgvd_Table188` WRITE;
/*!40000 ALTER TABLE `dspgvd_Table188` DISABLE KEYS */;
INSERT INTO `dspgvd_Table188` VALUES ('      SUBROUTINE DSPGVD( ITYPE, JOBZ, UPLO, N, AP, BP, W, Z, LDZ, WORK,'),('     $                   LWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDZ, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   AP( * ), BP( * ), W( * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSPGVD computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be symmetric, stored in packed format, and B is also'),('*  positive definite.'),('*  If eigenvectors are desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T, in the same storage'),('*          format as B.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors.  The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the required LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK >= 2*N.'),('*          If JOBZ = \'V\' and N > 1, LWORK >= 1 + 6*N + 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the required sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the required LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK >= 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  DPPTRF or DSPEVD returned an error code:'),('*             <= N:  if INFO = i, DSPEVD failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `dspgvd_Table188` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dspgvx_Table176`
--

DROP TABLE IF EXISTS `dspgvx_Table176`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dspgvx_Table176` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dspgvx_Table176`
--

LOCK TABLES `dspgvx_Table176` WRITE;
/*!40000 ALTER TABLE `dspgvx_Table176` DISABLE KEYS */;
INSERT INTO `dspgvx_Table176` VALUES ('      SUBROUTINE DSPGVX( ITYPE, JOBZ, RANGE, UPLO, N, AP, BP, VL, VU,'),('     $                   IL, IU, ABSTOL, M, W, Z, LDZ, WORK, IWORK,'),('     $                   IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, ITYPE, IU, LDZ, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   AP( * ), BP( * ), W( * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSPGVX computes selected eigenvalues, and optionally, eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A'),('*  and B are assumed to be symmetric, stored in packed storage, and B'),('*  is also positive definite.  Eigenvalues and eigenvectors can be'),('*  selected by specifying either a range of values or a range of indices'),('*  for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A and B are stored;'),('*          = \'L\':  Lower triangle of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix pencil (A,B).  N >= 0.'),('*'),('*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T, in the same storage'),('*          format as B.'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          On normal exit, the first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (8*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  DPPTRF or DSPEVX returned an error code:'),('*             <= N:  if INFO = i, DSPEVX failed to converge;'),('*                    i eigenvectors failed to converge.  Their indices'),('*                    are stored in array IFAIL.'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `dspgvx_Table176` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dspsv_Table38`
--

DROP TABLE IF EXISTS `dspsv_Table38`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dspsv_Table38` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dspsv_Table38`
--

LOCK TABLES `dspsv_Table38` WRITE;
/*!40000 ALTER TABLE `dspsv_Table38` DISABLE KEYS */;
INSERT INTO `dspsv_Table38` VALUES ('      SUBROUTINE DSPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   AP( * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSPSV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric matrix stored in packed format and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**T,  if UPLO = \'U\', or'),('*     A = L * D * L**T,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, D is symmetric and block diagonal with 1-by-1'),('*  and 2-by-2 diagonal blocks.  The factored form of A is then used to'),('*  solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AP      (input/output) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*          On exit, the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by DSPTRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization'),('*                has been completed, but the block diagonal matrix D is'),('*                exactly singular, so the solution could not be'),('*                computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = aji)'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `dspsv_Table38` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dspsvx_Table78`
--

DROP TABLE IF EXISTS `dspsvx_Table78`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dspsvx_Table78` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dspsvx_Table78`
--

LOCK TABLES `dspsvx_Table78` WRITE;
/*!40000 ALTER TABLE `dspsvx_Table78` DISABLE KEYS */;
INSERT INTO `dspsvx_Table78` VALUES ('      SUBROUTINE DSPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,'),('     $                   LDX, RCOND, FERR, BERR, WORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * ), IWORK( * )'),('      DOUBLE PRECISION   AFP( * ), AP( * ), B( LDB, * ), BERR( * ),'),('     $                   FERR( * ), WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or'),('*  A = L*D*L**T to compute the solution to a real system of linear'),('*  equations A * X = B, where A is an N-by-N symmetric matrix stored'),('*  in packed format and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as'),('*        A = U * D * U**T,  if UPLO = \'U\', or'),('*        A = L * D * L**T,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices and D is symmetric and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AFP and IPIV contain the factored form of'),('*                  A.  AP, AFP and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AFP and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AP      (input) DOUBLE PRECISION array, dimension (N*(N+1)/2)'),('*          The upper or lower triangle of the symmetric matrix A, packed'),('*          columnwise in a linear array.  The j-th column of A is stored'),('*          in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*  AFP     (input or output) DOUBLE PRECISION array, dimension'),('*                            (N*(N+1)/2)'),('*          If FACT = \'F\', then AFP is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*          If FACT = \'N\', then AFP is an output argument and on exit'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by DSPTRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by DSPTRF.'),('*'),('*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (3*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = aji)'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `dspsvx_Table78` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dstev_Table118`
--

DROP TABLE IF EXISTS `dstev_Table118`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dstev_Table118` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dstev_Table118`
--

LOCK TABLES `dstev_Table118` WRITE;
/*!40000 ALTER TABLE `dstev_Table118` DISABLE KEYS */;
INSERT INTO `dstev_Table118` VALUES ('      SUBROUTINE DSTEV( JOBZ, N, D, E, Z, LDZ, WORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ'),('      INTEGER            INFO, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   D( * ), E( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSTEV computes all eigenvalues and, optionally, eigenvectors of a'),('*  real symmetric tridiagonal matrix A.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix.  N >= 0.'),('*'),('*  D       (input/output) DOUBLE PRECISION array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.'),('*          On exit, if INFO = 0, the eigenvalues in ascending order.'),('*'),('*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A, stored in elements 1 to N-1 of E.'),('*          On exit, the contents of E are destroyed.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with D(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (max(1,2*N-2))'),('*          If JOBZ = \'N\', WORK is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of E did not converge to zero.'),('*');
/*!40000 ALTER TABLE `dstev_Table118` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dstevd_Table146`
--

DROP TABLE IF EXISTS `dstevd_Table146`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dstevd_Table146` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dstevd_Table146`
--

LOCK TABLES `dstevd_Table146` WRITE;
/*!40000 ALTER TABLE `dstevd_Table146` DISABLE KEYS */;
INSERT INTO `dstevd_Table146` VALUES ('      SUBROUTINE DSTEVD( JOBZ, N, D, E, Z, LDZ, WORK, LWORK, IWORK,'),('     $                   LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ'),('      INTEGER            INFO, LDZ, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   D( * ), E( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSTEVD computes all eigenvalues and, optionally, eigenvectors of a'),('*  real symmetric tridiagonal matrix. If eigenvectors are desired, it'),('*  uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix.  N >= 0.'),('*'),('*  D       (input/output) DOUBLE PRECISION array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.'),('*          On exit, if INFO = 0, the eigenvalues in ascending order.'),('*'),('*  E       (input/output) DOUBLE PRECISION array, dimension (N-1)'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A, stored in elements 1 to N-1 of E.'),('*          On exit, the contents of E are destroyed.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with D(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array,'),('*                                         dimension (LWORK)'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If JOBZ  = \'N\' or N <= 1 then LWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1 then LWORK must be at least'),('*                         ( 1 + 4*N + N**2 ).'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1 then LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1 then LIWORK must be at least 3+5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of E did not converge to zero.'),('*');
/*!40000 ALTER TABLE `dstevd_Table146` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dstevr_Table152`
--

DROP TABLE IF EXISTS `dstevr_Table152`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dstevr_Table152` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dstevr_Table152`
--

LOCK TABLES `dstevr_Table152` WRITE;
/*!40000 ALTER TABLE `dstevr_Table152` DISABLE KEYS */;
INSERT INTO `dstevr_Table152` VALUES ('      SUBROUTINE DSTEVR( JOBZ, RANGE, N, D, E, VL, VU, IL, IU, ABSTOL,'),('     $                   M, W, Z, LDZ, ISUPPZ, WORK, LWORK, IWORK,'),('     $                   LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE'),('      INTEGER            IL, INFO, IU, LDZ, LIWORK, LWORK, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            ISUPPZ( * ), IWORK( * )'),('      DOUBLE PRECISION   D( * ), E( * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSTEVR computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric tridiagonal matrix T.  Eigenvalues and'),('*  eigenvectors can be selected by specifying either a range of values'),('*  or a range of indices for the desired eigenvalues.'),('*'),('*  Whenever possible, DSTEVR calls DSTEMR to compute the'),('*  eigenspectrum using Relatively Robust Representations.  DSTEMR'),('*  computes eigenvalues by the dqds algorithm, while orthogonal'),('*  eigenvectors are computed from various \"good\" L D L^T representations'),('*  (also known as Relatively Robust Representations). Gram-Schmidt'),('*  orthogonalization is avoided as far as possible. More specifically,'),('*  the various steps of the algorithm are as follows. For the i-th'),('*  unreduced block of T,'),('*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T'),('*          is a relatively robust representation,'),('*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high'),('*         relative accuracy by the dqds algorithm,'),('*     (c) If there is a cluster of close eigenvalues, \"choose\" sigma_i'),('*         close to the cluster, and go to step (a),'),('*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,'),('*         compute the corresponding eigenvector by forming a'),('*         rank-revealing twisted factorization.'),('*  The desired accuracy of the output can be specified by the input'),('*  parameter ABSTOL.'),('*'),('*  For more details, see \"A new O(n^2) algorithm for the symmetric'),('*  tridiagonal eigenvalue/eigenvector problem\", by Inderjit Dhillon,'),('*  Computer Science Division Technical Report No. UCB//CSD-97-971,'),('*  UC Berkeley, May 1997.'),('*'),('*'),('*  Note 1 : DSTEVR calls DSTEMR when the full spectrum is requested'),('*  on machines which conform to the ieee-754 floating point standard.'),('*  DSTEVR calls DSTEBZ and DSTEIN on non-ieee machines and'),('*  when partial spectrum requests are made.'),('*'),('*  Normal execution of DSTEMR may create NaNs and infinities and'),('*  hence may abort due to a floating point exception in environments'),('*  which do not handle NaNs and infinities in the ieee standard default'),('*  manner.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('********** For RANGE = \'V\' or \'I\' and IU - IL < N - 1, DSTEBZ and'),('********** DSTEIN are called'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix.  N >= 0.'),('*'),('*  D       (input/output) DOUBLE PRECISION array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.'),('*          On exit, D may be multiplied by a constant factor chosen'),('*          to avoid over/underflow in computing the eigenvalues.'),('*'),('*  E       (input/output) DOUBLE PRECISION array, dimension (max(1,N-1))'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A in elements 1 to N-1 of E.'),('*          On exit, E may be multiplied by a constant factor chosen'),('*          to avoid over/underflow in computing the eigenvalues.'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*          If high relative accuracy is important, set ABSTOL to'),('*          DLAMCH( \'Safe minimum\' ).  Doing so will guarantee that'),('*          eigenvalues are computed to high relative accuracy when'),('*          possible in future releases.  The current code does not'),('*          make any guarantees about high relative accuracy, but'),('*          future releases will. See J. Barlow and J. Demmel,'),('*          \"Computing Accurate Eigensystems of Scaled Diagonally'),('*          Dominant Matrices\", LAPACK Working Note #7, for a discussion'),('*          of which matrices define their eigenvalues to high relative'),('*          accuracy.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M) )'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  ISUPPZ  (output) INTEGER array, dimension ( 2*max(1,M) )'),('*          The support of the eigenvectors in Z, i.e., the indices'),('*          indicating the nonzero elements in Z. The i-th eigenvector'),('*          is nonzero only in elements ISUPPZ( 2*i-1 ) through'),('*          ISUPPZ( 2*i ).'),('********** Implemented only for RANGE = \'A\' or \'I\' and IU - IL = N - 1'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal (and'),('*          minimal) LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,20*N).'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal (and'),('*          minimal) LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.  LIWORK >= max(1,10*N).'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  Internal error'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Inderjit Dhillon, IBM Almaden, USA'),('*     Osni Marques, LBNL/NERSC, USA'),('*     Ken Stanley, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `dstevr_Table152` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dstevx_Table132`
--

DROP TABLE IF EXISTS `dstevx_Table132`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dstevx_Table132` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dstevx_Table132`
--

LOCK TABLES `dstevx_Table132` WRITE;
/*!40000 ALTER TABLE `dstevx_Table132` DISABLE KEYS */;
INSERT INTO `dstevx_Table132` VALUES ('      SUBROUTINE DSTEVX( JOBZ, RANGE, N, D, E, VL, VU, IL, IU, ABSTOL,'),('     $                   M, W, Z, LDZ, WORK, IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE'),('      INTEGER            IL, INFO, IU, LDZ, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   D( * ), E( * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSTEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric tridiagonal matrix A.  Eigenvalues and'),('*  eigenvectors can be selected by specifying either a range of values'),('*  or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix.  N >= 0.'),('*'),('*  D       (input/output) DOUBLE PRECISION array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.'),('*          On exit, D may be multiplied by a constant factor chosen'),('*          to avoid over/underflow in computing the eigenvalues.'),('*'),('*  E       (input/output) DOUBLE PRECISION array, dimension (max(1,N-1))'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A in elements 1 to N-1 of E.'),('*          On exit, E may be multiplied by a constant factor chosen'),('*          to avoid over/underflow in computing the eigenvalues.'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less'),('*          than or equal to zero, then  EPS*|T|  will be used in'),('*          its place, where |T| is the 1-norm of the tridiagonal'),('*          matrix.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M) )'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge (INFO > 0), then that'),('*          column of Z contains the latest approximation to the'),('*          eigenvector, and the index of the eigenvector is returned'),('*          in IFAIL.  If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) DOUBLE PRECISION array, dimension (5*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `dstevx_Table132` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsyev_Table112`
--

DROP TABLE IF EXISTS `dsyev_Table112`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsyev_Table112` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsyev_Table112`
--

LOCK TABLES `dsyev_Table112` WRITE;
/*!40000 ALTER TABLE `dsyev_Table112` DISABLE KEYS */;
INSERT INTO `dsyev_Table112` VALUES ('      SUBROUTINE DSYEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDA, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   A( LDA, * ), W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSYEV computes all eigenvalues and, optionally, eigenvectors of a'),('*  real symmetric matrix A.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          orthonormal eigenvectors of the matrix A.'),('*          If JOBZ = \'N\', then on exit the lower triangle (if UPLO=\'L\')'),('*          or the upper triangle (if UPLO=\'U\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,3*N-1).'),('*          For optimal efficiency, LWORK >= (NB+2)*N,'),('*          where NB is the blocksize for DSYTRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `dsyev_Table112` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsyevd_Table140`
--

DROP TABLE IF EXISTS `dsyevd_Table140`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsyevd_Table140` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsyevd_Table140`
--

LOCK TABLES `dsyevd_Table140` WRITE;
/*!40000 ALTER TABLE `dsyevd_Table140` DISABLE KEYS */;
INSERT INTO `dsyevd_Table140` VALUES ('      SUBROUTINE DSYEVD( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, IWORK,'),('     $                   LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDA, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSYEVD computes all eigenvalues and, optionally, eigenvectors of a'),('*  real symmetric matrix A. If eigenvectors are desired, it uses a'),('*  divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Because of large use of BLAS of level 3, DSYEVD needs N**2 more'),('*  workspace than DSYEVX.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          orthonormal eigenvectors of the matrix A.'),('*          If JOBZ = \'N\', then on exit the lower triangle (if UPLO=\'L\')'),('*          or the upper triangle (if UPLO=\'U\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array,'),('*                                         dimension (LWORK)'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK must be at least 2*N+1.'),('*          If JOBZ = \'V\' and N > 1, LWORK must be at least'),('*                                                1 + 6*N + 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If N <= 1,                LIWORK must be at least 1.'),('*          If JOBZ  = \'N\' and N > 1, LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK must be at least 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i and JOBZ = \'N\', then the algorithm failed'),('*                to converge; i off-diagonal elements of an intermediate'),('*                tridiagonal form did not converge to zero;'),('*                if INFO = i and JOBZ = \'V\', then the algorithm failed'),('*                to compute an eigenvalue while working on the submatrix'),('*                lying in rows and columns INFO/(N+1) through'),('*                mod(INFO,N+1).'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Jeff Rutter, Computer Science Division, University of California'),('*     at Berkeley, USA'),('*  Modified by Francoise Tisseur, University of Tennessee.'),('*'),('*  Modified description of INFO. Sven, 16 Feb 05.');
/*!40000 ALTER TABLE `dsyevd_Table140` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsyevr_Table150`
--

DROP TABLE IF EXISTS `dsyevr_Table150`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsyevr_Table150` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsyevr_Table150`
--

LOCK TABLES `dsyevr_Table150` WRITE;
/*!40000 ALTER TABLE `dsyevr_Table150` DISABLE KEYS */;
INSERT INTO `dsyevr_Table150` VALUES ('      SUBROUTINE DSYEVR( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, ISUPPZ, WORK, LWORK,'),('     $                   IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDA, LDZ, LIWORK, LWORK, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            ISUPPZ( * ), IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSYEVR computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric matrix A.  Eigenvalues and eigenvectors can be'),('*  selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  DSYEVR first reduces the matrix A to tridiagonal form T with a call'),('*  to DSYTRD.  Then, whenever possible, DSYEVR calls DSTEMR to compute'),('*  the eigenspectrum using Relatively Robust Representations.  DSTEMR'),('*  computes eigenvalues by the dqds algorithm, while orthogonal'),('*  eigenvectors are computed from various \"good\" L D L^T representations'),('*  (also known as Relatively Robust Representations). Gram-Schmidt'),('*  orthogonalization is avoided as far as possible. More specifically,'),('*  the various steps of the algorithm are as follows.'),('*'),('*  For each unreduced block (submatrix) of T,'),('*     (a) Compute T - sigma I  = L D L^T, so that L and D'),('*         define all the wanted eigenvalues to high relative accuracy.'),('*         This means that small relative changes in the entries of D and L'),('*         cause only small relative changes in the eigenvalues and'),('*         eigenvectors. The standard (unfactored) representation of the'),('*         tridiagonal matrix T does not have this property in general.'),('*     (b) Compute the eigenvalues to suitable accuracy.'),('*         If the eigenvectors are desired, the algorithm attains full'),('*         accuracy of the computed eigenvalues only right before'),('*         the corresponding vectors have to be computed, see steps c) and d).'),('*     (c) For each cluster of close eigenvalues, select a new'),('*         shift close to the cluster, find a new factorization, and refine'),('*         the shifted eigenvalues to suitable accuracy.'),('*     (d) For each eigenvalue with a large enough relative separation compute'),('*         the corresponding eigenvector by forming a rank revealing twisted'),('*         factorization. Go back to (c) for any clusters that remain.'),('*'),('*  The desired accuracy of the output can be specified by the input'),('*  parameter ABSTOL.'),('*'),('*  For more details, see DSTEMR\'s documentation and:'),('*  - Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations'),('*    to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"'),('*    Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.'),('*  - Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and'),('*    Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,'),('*    2004.  Also LAPACK Working Note 154.'),('*  - Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric'),('*    tridiagonal eigenvalue/eigenvector problem\",'),('*    Computer Science Division Technical Report No. UCB/CSD-97-971,'),('*    UC Berkeley, May 1997.'),('*'),('*'),('*  Note 1 : DSYEVR calls DSTEMR when the full spectrum is requested'),('*  on machines which conform to the ieee-754 floating point standard.'),('*  DSYEVR calls DSTEBZ and SSTEIN on non-ieee machines and'),('*  when partial spectrum requests are made.'),('*'),('*  Normal execution of DSTEMR may create NaNs and infinities and'),('*  hence may abort due to a floating point exception in environments'),('*  which do not handle NaNs and infinities in the ieee standard default'),('*  manner.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('********** For RANGE = \'V\' or \'I\' and IU - IL < N - 1, DSTEBZ and'),('********** DSTEIN are called'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*          If high relative accuracy is important, set ABSTOL to'),('*          DLAMCH( \'Safe minimum\' ).  Doing so will guarantee that'),('*          eigenvalues are computed to high relative accuracy when'),('*          possible in future releases.  The current code does not'),('*          make any guarantees about high relative accuracy, but'),('*          future releases will. See J. Barlow and J. Demmel,'),('*          \"Computing Accurate Eigensystems of Scaled Diagonally'),('*          Dominant Matrices\", LAPACK Working Note #7, for a discussion'),('*          of which matrices define their eigenvalues to high relative'),('*          accuracy.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*          Supplying N columns is always safe.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  ISUPPZ  (output) INTEGER array, dimension ( 2*max(1,M) )'),('*          The support of the eigenvectors in Z, i.e., the indices'),('*          indicating the nonzero elements in Z. The i-th eigenvector'),('*          is nonzero only in elements ISUPPZ( 2*i-1 ) through'),('*          ISUPPZ( 2*i ).'),('********** Implemented only for RANGE = \'A\' or \'I\' and IU - IL = N - 1'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,26*N).'),('*          For optimal efficiency, LWORK >= (NB+6)*N,'),('*          where NB is the max of the blocksize for DSYTRD and DORMTR'),('*          returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.  LIWORK >= max(1,10*N).'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal size of the IWORK array,'),('*          returns this value as the first entry of the IWORK array, and'),('*          no error message related to LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  Internal error'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Inderjit Dhillon, IBM Almaden, USA'),('*     Osni Marques, LBNL/NERSC, USA'),('*     Ken Stanley, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*     Jason Riedy, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `dsyevr_Table150` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsyevx_Table126`
--

DROP TABLE IF EXISTS `dsyevx_Table126`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsyevx_Table126` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsyevx_Table126`
--

LOCK TABLES `dsyevx_Table126` WRITE;
/*!40000 ALTER TABLE `dsyevx_Table126` DISABLE KEYS */;
INSERT INTO `dsyevx_Table126` VALUES ('      SUBROUTINE DSYEVX( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, WORK, LWORK, IWORK,'),('     $                   IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDA, LDZ, LWORK, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSYEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric matrix A.  Eigenvalues and eigenvectors can be'),('*  selected by specifying either a range of values or a range of indices'),('*  for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          On normal exit, the first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= 1, when N <= 1;'),('*          otherwise 8*N.'),('*          For optimal efficiency, LWORK >= (NB+3)*N,'),('*          where NB is the max of the blocksize for DSYTRD and DORMTR'),('*          returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `dsyevx_Table126` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsygv_Table160`
--

DROP TABLE IF EXISTS `dsygv_Table160`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsygv_Table160` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsygv_Table160`
--

LOCK TABLES `dsygv_Table160` WRITE;
/*!40000 ALTER TABLE `dsygv_Table160` DISABLE KEYS */;
INSERT INTO `dsygv_Table160` VALUES ('      SUBROUTINE DSYGV( ITYPE, JOBZ, UPLO, N, A, LDA, B, LDB, W, WORK,'),('     $                  LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDA, LDB, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSYGV computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.'),('*  Here A and B are assumed to be symmetric and B is also'),('*  positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          matrix Z of eigenvectors.  The eigenvectors are normalized'),('*          as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then on exit the upper triangle (if UPLO=\'U\')'),('*          or the lower triangle (if UPLO=\'L\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)'),('*          On entry, the symmetric positive definite matrix B.'),('*          If UPLO = \'U\', the leading N-by-N upper triangular part of B'),('*          contains the upper triangular part of the matrix B.'),('*          If UPLO = \'L\', the leading N-by-N lower triangular part of B'),('*          contains the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,3*N-1).'),('*          For optimal efficiency, LWORK >= (NB+2)*N,'),('*          where NB is the blocksize for DSYTRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  DPOTRF or DSYEV returned an error code:'),('*             <= N:  if INFO = i, DSYEV failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `dsygv_Table160` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsygvd_Table184`
--

DROP TABLE IF EXISTS `dsygvd_Table184`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsygvd_Table184` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsygvd_Table184`
--

LOCK TABLES `dsygvd_Table184` WRITE;
/*!40000 ALTER TABLE `dsygvd_Table184` DISABLE KEYS */;
INSERT INTO `dsygvd_Table184` VALUES ('      SUBROUTINE DSYGVD( ITYPE, JOBZ, UPLO, N, A, LDA, B, LDB, W, WORK,'),('     $                   LWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDA, LDB, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSYGVD computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be symmetric and B is also positive definite.'),('*  If eigenvectors are desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          matrix Z of eigenvectors.  The eigenvectors are normalized'),('*          as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then on exit the upper triangle (if UPLO=\'U\')'),('*          or the lower triangle (if UPLO=\'L\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)'),('*          On entry, the symmetric matrix B.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of B contains the'),('*          upper triangular part of the matrix B.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of B contains'),('*          the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK >= 2*N+1.'),('*          If JOBZ = \'V\' and N > 1, LWORK >= 1 + 6*N + 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If N <= 1,                LIWORK >= 1.'),('*          If JOBZ  = \'N\' and N > 1, LIWORK >= 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  DPOTRF or DSYEVD returned an error code:'),('*             <= N:  if INFO = i and JOBZ = \'N\', then the algorithm'),('*                    failed to converge; i off-diagonal elements of an'),('*                    intermediate tridiagonal form did not converge to'),('*                    zero;'),('*                    if INFO = i and JOBZ = \'V\', then the algorithm'),('*                    failed to compute an eigenvalue while working on'),('*                    the submatrix lying in rows and columns INFO/(N+1)'),('*                    through mod(INFO,N+1);'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*'),('*  Modified so that no backsubstitution is performed if DSYEVD fails to'),('*  converge (NEIG in old code could be greater than N causing out of'),('*  bounds reference to A - reported by Ralf Meyer).  Also corrected the'),('*  description of INFO and the test on ITYPE. Sven, 16 Feb 05.');
/*!40000 ALTER TABLE `dsygvd_Table184` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsygvx_Table172`
--

DROP TABLE IF EXISTS `dsygvx_Table172`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsygvx_Table172` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsygvx_Table172`
--

LOCK TABLES `dsygvx_Table172` WRITE;
/*!40000 ALTER TABLE `dsygvx_Table172` DISABLE KEYS */;
INSERT INTO `dsygvx_Table172` VALUES ('      SUBROUTINE DSYGVX( ITYPE, JOBZ, RANGE, UPLO, N, A, LDA, B, LDB,'),('     $                   VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK,'),('     $                   LWORK, IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, ITYPE, IU, LDA, LDB, LDZ, LWORK, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), W( * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSYGVX computes selected eigenvalues, and optionally, eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A'),('*  and B are assumed to be symmetric and B is also positive definite.'),('*  Eigenvalues and eigenvectors can be selected by specifying either a'),('*  range of values or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A and B are stored;'),('*          = \'L\':  Lower triangle of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix pencil (A,B).  N >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit, the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB, N)'),('*          On entry, the symmetric matrix B.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of B contains the'),('*          upper triangular part of the matrix B.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of B contains'),('*          the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          On normal exit, the first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) DOUBLE PRECISION array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,8*N).'),('*          For optimal efficiency, LWORK >= (NB+3)*N,'),('*          where NB is the blocksize for DSYTRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  DPOTRF or DSYEVX returned an error code:'),('*             <= N:  if INFO = i, DSYEVX failed to converge;'),('*                    i eigenvectors failed to converge.  Their indices'),('*                    are stored in array IFAIL.'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `dsygvx_Table172` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsysv_Table34`
--

DROP TABLE IF EXISTS `dsysv_Table34`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsysv_Table34` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsysv_Table34`
--

LOCK TABLES `dsysv_Table34` WRITE;
/*!40000 ALTER TABLE `dsysv_Table34` DISABLE KEYS */;
INSERT INTO `dsysv_Table34` VALUES ('      SUBROUTINE DSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,'),('     $                  LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     May 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSYSV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**T,  if UPLO = \'U\', or'),('*     A = L * D * L**T,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, and D is symmetric and block diagonal with'),('*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then'),('*  used to solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) DOUBLE PRECISION array, dimension (LDA,N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.'),('*'),('*          On exit, if INFO = 0, the block diagonal matrix D and the'),('*          multipliers used to obtain the factor U or L from the'),('*          factorization A = U*D*U**T or A = L*D*L**T as computed by'),('*          DSYTRF.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by DSYTRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= 1, and for best performance'),('*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for'),('*          DSYTRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization'),('*               has been completed, but the block diagonal matrix D is'),('*               exactly singular, so the solution could not be computed.'),('*');
/*!40000 ALTER TABLE `dsysv_Table34` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dsysvx_Table74`
--

DROP TABLE IF EXISTS `dsysvx_Table74`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `dsysvx_Table74` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dsysvx_Table74`
--

LOCK TABLES `dsysvx_Table74` WRITE;
/*!40000 ALTER TABLE `dsysvx_Table74` DISABLE KEYS */;
INSERT INTO `dsysvx_Table74` VALUES ('      SUBROUTINE DSYSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,'),('     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,'),('     $                   IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * ), IWORK( * )'),('      DOUBLE PRECISION   A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   BERR( * ), FERR( * ), WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  DSYSVX uses the diagonal pivoting factorization to compute the'),('*  solution to a real system of linear equations A * X = B,'),('*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.'),('*     The form of the factorization is'),('*        A = U * D * U**T,  if UPLO = \'U\', or'),('*        A = L * D * L**T,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices, and D is symmetric and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AF and IPIV contain the factored form of'),('*                  A.  AF and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input) DOUBLE PRECISION array, dimension (LDA,N)'),('*          The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N'),('*          upper triangular part of A contains the upper triangular part'),('*          of the matrix A, and the strictly lower triangular part of A'),('*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower'),('*          triangular part of A contains the lower triangular part of'),('*          the matrix A, and the strictly upper triangular part of A is'),('*          not referenced.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) DOUBLE PRECISION array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by DSYTRF.'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T.'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by DSYTRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by DSYTRF.'),('*'),('*  B       (input) DOUBLE PRECISION array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) DOUBLE PRECISION array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= max(1,3*N), and for best'),('*          performance, when FACT = \'N\', LWORK >= max(1,3*N,N*NB), where'),('*          NB is the optimal blocksize for DSYTRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `dsysvx_Table74` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `nonSym_Eigen`
--

DROP TABLE IF EXISTS `nonSym_Eigen`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `nonSym_Eigen` (
  `id_non` smallint(5) unsigned NOT NULL auto_increment,
  `thePrecision` enum('s','d','c','z') default NULL,
  `routineName` varchar(6) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `structureType` enum('f','b','p','t','g') default NULL,
  `url` varchar(20) default NULL,
  `problem` smallint(5) unsigned NOT NULL,
  `description` varchar(255) default NULL,
  PRIMARY KEY  (`id_non`),
  FULLTEXT KEY `routineName` (`routineName`,`matrixType`,`url`,`description`)
) ENGINE=MyISAM AUTO_INCREMENT=33 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `nonSym_Eigen`
--

LOCK TABLES `nonSym_Eigen` WRITE;
/*!40000 ALTER TABLE `nonSym_Eigen` DISABLE KEYS */;
INSERT INTO `nonSym_Eigen` VALUES (1,'s','geev','general','f','single/sgeev.f',5,'nonsymmetric eigenvalues, left, right eigenvectors, simple driver,'),(2,'d','geev','general','f','double/dgeev.f',5,'nonsymmetric eigenvalues, left, right eigenvectors, simple driver,'),(3,'c','geev','general','f','complex/cgeev.f',5,'nonsymmetric eigenvalues, left, right eigenvectors, simple driver,'),(4,'z','geev','general','f','complex16/zgeev.f',5,'nonsymmetric eigenvalues, left, right eigenvectors, simple driver,'),(5,'s','geevx','general','f','single/sgeevx.f',5,'nonsymmetric eigenvalues, left, right eigenvectors, expert driver, balance matrix, condition numbers'),(6,'d','geevx','general','f','double/dgeevx.f',5,'nonsymmetric eigenvalues, left, right eigenvectors, expert driver, balance matrix, condition numbers'),(7,'c','geevx','general','f','complex/cgeevx.f',5,'nonsymmetric eigenvalues, left, right eigenvectors, expert driver, balance matrix, condition numbers'),(8,'z','geevx','general','f','complex16/zgeevx.f',5,'nonsymmetric eigenvalues, left, right eigenvectors, expert driver, balance matrix, condition numbers'),(9,'s','gees','general','f','single/sgees.f',7,'nonsymmetric eigenvalues, simple driver,'),(10,'d','gees','general','f','double/dgees.f',7,'nonsymmetric eigenvalues, simple driver,'),(11,'c','gees','general','f','complex/cgees.f',7,'nonsymmetric eigenvalues, simple driver,'),(12,'z','gees','general','f','complex16/zgees.f',7,'nonsymmetric eigenvalues, simple driver,'),(13,'s','geesx','general','f','single/sgeesx.f',7,'nonsymmetric eigenvalues, expert driver, condition numbers'),(14,'d','geesx','general','f','double/dgeesx.f',7,'nonsymmetric eigenvalues, expert driver, condition numbers'),(15,'c','geesx','general','f','complex/cgeesx.f',7,'nonsymmetric eigenvalues, expert driver, condition numbers'),(16,'z','geesx','general','f','complex16/zgeesx.f',7,'nonsymmetric eigenvalues, expert driver, condition numbers'),(17,'s','ggev','general','f','single/sggev.f',6,'nonsymmetric generalized eigenvalues, left, right eigenvectors, simple driver,'),(18,'d','ggev','general','f','double/dggev.f',6,'nonsymmetric generalized eigenvalues, left, right eigenvectors, simple driver,'),(19,'c','ggev','general','f','complex/cggev.f',6,'nonsymmetric generalized eigenvalues, left, right eigenvectors, simple driver,'),(20,'z','ggev','general','f','complex16/zggev.f',6,'nonsymmetric generalized eigenvalues, left, right eigenvectors, simple driver,'),(21,'s','ggevx','general','f','single/sggevx.f',6,'nonsymmetric generalized eigenvalues, left, right eigenvectors, expert driver, balance matrix, condition numbers'),(22,'d','ggevx','general','f','double/dggevx.f',6,'nonsymmetric generalized eigenvalues, left, right eigenvectors, expert driver, balance matrix, condition numbers'),(23,'c','ggevx','general','f','complex/cggevx.f',6,'nonsymmetric generalized eigenvalues, left, right eigenvectors, expert driver, balance matrix, condition numbers'),(24,'z','ggevx','general','f','complex16/zggevx.f',6,'nonsymmetric generalized eigenvalues, left, right eigenvectors, expert driver, balance matrix, condition numbers'),(25,'s','gges','general','f','single/sgges.f',8,'nonsymmetric generalized eigenvalues, simple driver,'),(26,'d','gges','general','f','double/dgges.f',8,'nonsymmetric generalized eigenvalues, simple driver,'),(27,'c','gges','general','f','complex/cgges.f',8,'nonsymmetric generalized eigenvalues, simple driver,'),(28,'z','gges','general','f','complex16/zgges.f',8,'nonsymmetric generalized eigenvalues, simple driver,'),(29,'s','ggesx','general','f','single/sggesx.f',8,'nonsymmetric generalized eigenvalues, expert driver, condition numbers'),(30,'d','ggesx','general','f','double/dggesx.f',8,'nonsymmetric generalized eigenvalues, expert driver, condition numbers'),(31,'c','ggesx','general','f','complex/cggesx.f',8,'nonsymmetric generalized eigenvalues, expert driver, condition numbers'),(32,'z','ggesx','general','f','complex16/zggesx.f',8,'nonsymmetric generalized eigenvalues, expert driver, condition numbers');
/*!40000 ALTER TABLE `nonSym_Eigen` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `routineList`
--

DROP TABLE IF EXISTS `routineList`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `routineList` (
  `id` smallint(5) unsigned NOT NULL,
  `thePrecision` enum('s','d','c','z') default NULL,
  `routineName` varchar(6) NOT NULL,
  `url` varchar(20) default NULL,
  `fileName` varchar(20) default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `routineList`
--

LOCK TABLES `routineList` WRITE;
/*!40000 ALTER TABLE `routineList` DISABLE KEYS */;
INSERT INTO `routineList` VALUES (1,'s','gesv','single/sgesv.f','sgesv_1.txt'),(2,'d','gesv','double/dgesv.f','dgesv_2.txt'),(3,'c','gesv','complex/cgesv.f','cgesv_3.txt'),(4,'z','gesv','complex16/zgesv.f','zgesv_4.txt'),(5,'s','gbsv','single/sgbsv.f','sgbsv_5.txt'),(6,'d','gbsv','double/dgbsv.f','dgbsv_6.txt'),(7,'c','gbsv','complex/cgbsv.f','cgbsv_7.txt'),(8,'z','gbsv','complex16/zgbsv.f','zgbsv_8.txt'),(9,'s','gtsv','single/sgtsv.f','sgtsv_9.txt'),(10,'d','gtsv','double/dgtsv.f','dgtsv_10.txt'),(11,'c','gtsv','complex/cgtsv.f','cgtsv_11.txt'),(12,'z','gtsv','complex16/zgtsv.f','zgtsv_12.txt'),(13,'c','hesv','complex/chesv.f','chesv_13.txt'),(14,'z','hesv','complex16/zhesv.f','zhesv_14.txt'),(15,'c','hpsv','complex/chpsv.f','chpsv_15.txt'),(16,'z','hpsv','complex16/zhpsv.f','zhpsv_16.txt'),(17,'s','posv','single/sposv.f','sposv_17.txt'),(18,'d','posv','double/dposv.f','dposv_18.txt'),(19,'c','posv','complex/cposv.f','cposv_19.txt'),(20,'z','posv','complex16/zposv.f','zposv_20.txt'),(21,'s','pbsv','single/spbsv.f','spbsv_21.txt'),(22,'d','pbsv','double/dpbsv.f','dpbsv_22.txt'),(23,'c','pbsv','complex/cpbsv.f','cpbsv_23.txt'),(24,'z','pbsv','complex16/zpbsv.f','zpbsv_24.txt'),(25,'s','ppsv','single/sppsv.f','sppsv_25.txt'),(26,'d','ppsv','double/dppsv.f','dppsv_26.txt'),(27,'c','ppsv','complex/cppsv.f','cppsv_27.txt'),(28,'z','ppsv','complex16/zppsv.f','zppsv_28.txt'),(29,'s','ptsv','single/sptsv.f','sptsv_29.txt'),(30,'d','ptsv','double/dptsv.f','dptsv_30.txt'),(31,'c','ptsv','complex/cptsv.f','cptsv_31.txt'),(32,'z','ptsv','complex16/zptsv.f','zptsv_32.txt'),(33,'s','sysv','single/ssysv.f','ssysv_33.txt'),(34,'d','sysv','double/dsysv.f','dsysv_34.txt'),(35,'c','sysv','complex/csysv.f','csysv_35.txt'),(36,'z','sysv','complex16/zsysv.f','zsysv_36.txt'),(37,'s','spsv','single/sspsv.f','sspsv_37.txt'),(38,'d','spsv','double/dspsv.f','dspsv_38.txt'),(39,'c','spsv','complex/cspsv.f','cspsv_39.txt'),(40,'z','spsv','complex16/zspsv.f','zspsv_40.txt'),(41,'s','gesvx','single/sgesvx.f','sgesvx_41.txt'),(42,'d','gesvx','double/dgesvx.f','dgesvx_42.txt'),(43,'c','gesvx','complex/cgesvx.f','cgesvx_43.txt'),(44,'z','gesvx','complex16/zgesvx.f','zgesvx_44.txt'),(45,'s','gbsvx','single/sgbsvx.f','sgbsvx_45.txt'),(46,'d','gbsvx','double/dgbsvx.f','dgbsvx_46.txt'),(47,'c','gbsvx','complex/cgbsvx.f','cgbsvx_47.txt'),(48,'z','gbsvx','complex16/zgbsvx.f','zgbsvx_48.txt'),(49,'s','gtsvx','single/sgtsvx.f','sgtsvx_49.txt'),(50,'d','gtsvx','double/dgtsvx.f','dgtsvx_50.txt'),(51,'c','gtsvx','complex/cgtsvx.f','cgtsvx_51.txt'),(52,'z','gtsvx','complex16/zgtsvx.f','zgtsvx_52.txt'),(53,'c','hesvx','complex/chesvx.f','chesvx_53.txt'),(54,'z','hesvx','complex16/zhesvx.f','zhesvx_54.txt'),(55,'c','hpsvx','complex/chpsvx.f','chpsvx_55.txt'),(56,'z','hpsvx','complex16/zhpsvx.f','zhpsvx_56.txt'),(57,'s','posvx','single/sposvx.f','sposvx_57.txt'),(58,'d','posvx','double/dposvx.f','dposvx_58.txt'),(59,'c','posvx','complex/cposvx.f','cposvx_59.txt'),(60,'z','posvx','complex16/zposvx.f','zposvx_60.txt'),(61,'s','pbsvx','single/spbsvx.f','spbsvx_61.txt'),(62,'d','pbsvx','double/dpbsvx.f','dpbsvx_62.txt'),(63,'c','pbsvx','complex/cpbsvx.f','cpbsvx_63.txt'),(64,'z','pbsvx','complex16/zpbsvx.f','zpbsvx_64.txt'),(65,'s','ppsvx','single/sppsvx.f','sppsvx_65.txt'),(66,'d','ppsvx','double/dppsvx.f','dppsvx_66.txt'),(67,'c','ppsvx','complex/cppsvx.f','cppsvx_67.txt'),(68,'z','ppsvx','complex16/zppsvx.f','zppsvx_68.txt'),(69,'s','ptsvx','single/sptsvx.f','sptsvx_69.txt'),(70,'d','ptsvx','double/dptsvx.f','dptsvx_70.txt'),(71,'c','ptsvx','complex/cptsvx.f','cptsvx_71.txt'),(72,'z','ptsvx','complex16/zptsvx.f','zptsvx_72.txt'),(73,'s','sysvx','single/ssysvx.f','ssysvx_73.txt'),(74,'d','sysvx','double/dsysvx.f','dsysvx_74.txt'),(75,'c','sysvx','complex/csysvx.f','csysvx_75.txt'),(76,'z','sysvx','complex16/zsysvx.f','zsysvx_76.txt'),(77,'s','spsvx','single/sspsvx.f','sspsvx_77.txt'),(78,'d','spsvx','double/dspsvx.f','dspsvx_78.txt'),(79,'c','spsvx','complex/cspsvx.f','cspsvx_79.txt'),(80,'z','spsvx','complex16/zspsvx.f','zspsvx_80.txt'),(81,'s','gels','single/sgels.f','sgels_81.txt'),(82,'d','gels','double/dgels.f','dgels_82.txt'),(83,'c','gels','complex/cgels.f','cgels_83.txt'),(84,'z','gels','complex16/zgels.f','zgels_84.txt'),(85,'s','gelsy','single/sgelsy.f','sgelsy_85.txt'),(86,'d','gelsy','double/dgelsy.f','dgelsy_86.txt'),(87,'c','gelsy','complex/cgelsy.f','cgelsy_87.txt'),(88,'z','gelsy','complex16/zgelsy.f','zgelsy_88.txt'),(89,'s','gelsd','single/sgelsd.f','sgelsd_89.txt'),(90,'d','gelsd','double/dgelsd.f','dgelsd_90.txt'),(91,'c','gelsd','complex/cgelsd.f','cgelsd_91.txt'),(92,'z','gelsd','complex16/zgelsd.f','zgelsd_92.txt'),(93,'s','gelss','single/sgelss.f','sgelss_93.txt'),(94,'d','gelss','double/dgelss.f','dgelss_94.txt'),(95,'c','gelss','complex/cgelss.f','cgelss_95.txt'),(96,'z','gelss','complex16/zgelss.f','zgelss_96.txt'),(97,'s','gglse','single/sgglse.f','sgglse_97.txt'),(98,'d','gglse','double/dgglse.f','dgglse_98.txt'),(99,'c','gglse','complex/cgglse.f','cgglse_99.txt'),(100,'z','gglse','complex16/zgglse.f','zgglse_100.txt'),(101,'s','ggglm','single/sggglm.f','sggglm_101.txt'),(102,'d','ggglm','double/dggglm.f','dggglm_102.txt'),(103,'c','ggglm','complex/cggglm.f','cggglm_103.txt'),(104,'z','ggglm','complex16/zggglm.f','zggglm_104.txt'),(105,'c','heev','complex/cheev.f','cheev_105.txt'),(106,'z','heev','complex16/zheev.f','zheev_106.txt'),(107,'c','hbev','complex/chbev.f','chbev_107.txt'),(108,'z','hbev','complex16/zhbev.f','zhbev_108.txt'),(109,'c','hpev','complex/chpev.f','chpev_109.txt'),(110,'z','hpev','complex16/zhpev.f','zhpev_110.txt'),(111,'s','syev','single/ssyev.f','ssyev_111.txt'),(112,'d','syev','double/dsyev.f','dsyev_112.txt'),(113,'s','sbev','single/ssbev.f','ssbev_113.txt'),(114,'d','sbev','double/dsbev.f','dsbev_114.txt'),(115,'s','spev','single/sspev.f','sspev_115.txt'),(116,'d','spev','double/dspev.f','dspev_116.txt'),(117,'s','stev','single/sstev.f','sstev_117.txt'),(118,'d','stev','double/dstev.f','dstev_118.txt'),(119,'c','heevx','complex/cheevx.f','cheevx_119.txt'),(120,'z','heevx','complex16/zheevx.f','zheevx_120.txt'),(121,'c','hbevx','complex/chbevx.f','chbevx_121.txt'),(122,'z','hbevx','complex16/zhbevx.f','zhbevx_122.txt'),(123,'c','hpevx','complex/chpevx.f','chpevx_123.txt'),(124,'z','hpevx','complex16/zhpevx.f','zhpevx_124.txt'),(125,'s','syevx','single/ssyevx.f','ssyevx_125.txt'),(126,'d','syevx','double/dsyevx.f','dsyevx_126.txt'),(127,'s','sbevx','single/ssbevx.f','ssbevx_127.txt'),(128,'d','sbevx','double/dsbevx.f','dsbevx_128.txt'),(129,'s','spevx','single/sspevx.f','sspevx_129.txt'),(130,'d','spevx','double/dspevx.f','dspevx_130.txt'),(131,'s','stevx','single/sstevx.f','sstevx_131.txt'),(132,'d','stevx','double/dstevx.f','dstevx_132.txt'),(133,'c','heevd','complex/cheevd.f','cheevd_133.txt'),(134,'z','heevd','complex16/zheevd.f','zheevd_134.txt'),(135,'c','hbevd','complex/chbevd.f','chbevd_135.txt'),(136,'z','hbevd','complex16/zhbevd.f','zhbevd_136.txt'),(137,'c','hpevd','complex/chpevd.f','chpevd_137.txt'),(138,'z','hpevd','complex16/zhpevd.f','zhpevd_138.txt'),(139,'s','syevd','single/ssyevd.f','ssyevd_139.txt'),(140,'d','syevd','double/dsyevd.f','dsyevd_140.txt'),(141,'s','sbevd','single/ssbevd.f','ssbevd_141.txt'),(142,'d','sbevd','double/dsbevd.f','dsbevd_142.txt'),(143,'s','spevd','single/sspevd.f','sspevd_143.txt'),(144,'d','spevd','double/dspevd.f','dspevd_144.txt'),(145,'s','stevd','single/sstevd.f','sstevd_145.txt'),(146,'d','stevd','double/dstevd.f','dstevd_146.txt'),(147,'c','heevr','complex/cheevr.f','cheevr_147.txt'),(148,'z','heevr','complex16/zheevr.f','zheevr_148.txt'),(149,'s','syevr','single/ssyevr.f','ssyevr_149.txt'),(150,'d','syevr','double/dsyevr.f','dsyevr_150.txt'),(151,'s','stevr','single/sstevr.f','sstevr_151.txt'),(152,'d','stevr','double/dstevr.f','dstevr_152.txt'),(153,'c','hegv','complex/chegv.f','chegv_153.txt'),(154,'z','hegv','complex16/zhegv.f','zhegv_154.txt'),(155,'c','hbgv','complex/chbgv.f','chbgv_155.txt'),(156,'z','hbgv','complex16/zhbgv.f','zhbgv_156.txt'),(157,'c','hpgv','complex/chpgv.f','chpgv_157.txt'),(158,'z','hpgv','complex16/zhpgv.f','zhpgv_158.txt'),(159,'s','sygv','single/ssygv.f','ssygv_159.txt'),(160,'d','sygv','double/dsygv.f','dsygv_160.txt'),(161,'s','sbgv','single/ssbgv.f','ssbgv_161.txt'),(162,'d','sbgv','double/dsbgv.f','dsbgv_162.txt'),(163,'s','spgv','single/sspgv.f','sspgv_163.txt'),(164,'d','spgv','double/dspgv.f','dspgv_164.txt'),(165,'c','hegvx','complex/chegvx.f','chegvx_165.txt'),(166,'z','hegvx','complex16/zhegvx.f','zhegvx_166.txt'),(167,'c','hbgvx','complex/chbgvx.f','chbgvx_167.txt'),(168,'z','hbgvx','complex16/zhbgvx.f','zhbgvx_168.txt'),(169,'c','hpgvx','complex/chpgvx.f','chpgvx_169.txt'),(170,'z','hpgvx','complex16/zhpgvx.f','zhpgvx_170.txt'),(171,'s','sygvx','single/ssygvx.f','ssygvx_171.txt'),(172,'d','sygvx','double/dsygvx.f','dsygvx_172.txt'),(173,'s','sbgvx','single/ssbgvx.f','ssbgvx_173.txt'),(174,'d','sbgvx','double/dsbgvx.f','dsbgvx_174.txt'),(175,'s','spgvx','single/sspgvx.f','sspgvx_175.txt'),(176,'d','spgvx','double/dspgvx.f','dspgvx_176.txt'),(177,'c','hegvd','complex/chegvd.f','chegvd_177.txt'),(178,'z','hegvd','complex16/zhegvd.f','zhegvd_178.txt'),(179,'c','hbgvd','complex/chbgvd.f','chbgvd_179.txt'),(180,'z','hbgvd','complex16/zhbgvd.f','zhbgvd_180.txt'),(181,'c','hpgvd','complex/chpgvd.f','chpgvd_181.txt'),(182,'z','hpgvd','complex16/zhpgvd.f','zhpgvd_182.txt'),(183,'s','sygvd','single/ssygvd.f','ssygvd_183.txt'),(184,'d','sygvd','double/dsygvd.f','dsygvd_184.txt'),(185,'s','sbgvd','single/ssbgvd.f','ssbgvd_185.txt'),(186,'d','sbgvd','double/dsbgvd.f','dsbgvd_186.txt'),(187,'s','spgvd','single/sspgvd.f','sspgvd_187.txt'),(188,'d','spgvd','double/dspgvd.f','dspgvd_188.txt'),(189,'s','geev','single/sgeev.f','sgeev_189.txt'),(190,'d','geev','double/dgeev.f','dgeev_190.txt'),(191,'c','geev','complex/cgeev.f','cgeev_191.txt'),(192,'z','geev','complex16/zgeev.f','zgeev_192.txt'),(193,'s','geevx','single/sgeevx.f','sgeevx_193.txt'),(194,'d','geevx','double/dgeevx.f','dgeevx_194.txt'),(195,'c','geevx','complex/cgeevx.f','cgeevx_195.txt'),(196,'z','geevx','complex16/zgeevx.f','zgeevx_196.txt'),(197,'s','gees','single/sgees.f','sgees_197.txt'),(198,'d','gees','double/dgees.f','dgees_198.txt'),(199,'c','gees','complex/cgees.f','cgees_199.txt'),(200,'z','gees','complex16/zgees.f','zgees_200.txt'),(201,'s','geesx','single/sgeesx.f','sgeesx_201.txt'),(202,'d','geesx','double/dgeesx.f','dgeesx_202.txt'),(203,'c','geesx','complex/cgeesx.f','cgeesx_203.txt'),(204,'z','geesx','complex16/zgeesx.f','zgeesx_204.txt'),(205,'s','ggev','single/sggev.f','sggev_205.txt'),(206,'d','ggev','double/dggev.f','dggev_206.txt'),(207,'c','ggev','complex/cggev.f','cggev_207.txt'),(208,'z','ggev','complex16/zggev.f','zggev_208.txt'),(209,'s','ggevx','single/sggevx.f','sggevx_209.txt'),(210,'d','ggevx','double/dggevx.f','dggevx_210.txt'),(211,'s','gges','single/sgges.f','sgges_211.txt'),(212,'d','gges','double/dgges.f','dgges_212.txt'),(213,'c','gges','complex/cgges.f','cgges_213.txt'),(214,'z','gges','complex16/zgges.f','zgges_214.txt'),(215,'s','ggesx','single/sggesx.f','sggesx_215.txt'),(216,'d','ggesx','double/dggesx.f','dggesx_216.txt'),(217,'c','ggesx','complex/cggesx.f','cggesx_217.txt'),(218,'z','ggesx','complex16/zggesx.f','zggesx_218.txt'),(219,'s','gesvd','single/sgesvd.f','sgesvd_219.txt'),(220,'d','gesvd','double/dgesvd.f','dgesvd_220.txt'),(221,'c','gesvd','complex/cgesvd.f','cgesvd_221.txt'),(222,'z','gesvd','complex16/zgesvd.f','zgesvd_222.txt'),(223,'s','gesdd','single/sgesdd.f','sgesdd_223.txt'),(224,'d','gesdd','double/dgesdd.f','dgesdd_224.txt'),(225,'c','gesdd','complex/cgesdd.f','cgesdd_225.txt'),(226,'z','gesdd','complex16/zgesdd.f','zgesdd_226.txt'),(227,'s','ggsvd','single/sggsvd.f','sggsvd_227.txt'),(228,'d','ggsvd','double/dggsvd.f','dggsvd_228.txt'),(229,'c','ggsvd','complex/cggsvd.f','cggsvd_229.txt'),(230,'z','ggsvd','complex16/zggsvd.f','zggsvd_230.txt'),(231,'c','ggevx','complex/cggevx.f','cggevx_231.txt'),(232,'z','ggevx','complex16/zggevx.f','zggevx_232.txt');
/*!40000 ALTER TABLE `routineList` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `search_test`
--

DROP TABLE IF EXISTS `search_test`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `search_test` (
  `id` int(11) NOT NULL auto_increment,
  `name` text NOT NULL,
  `description` text NOT NULL,
  `price` int(11) NOT NULL,
  `img` text NOT NULL,
  PRIMARY KEY  (`id`),
  FULLTEXT KEY `name` (`name`,`description`)
) ENGINE=MyISAM AUTO_INCREMENT=6 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `search_test`
--

LOCK TABLES `search_test` WRITE;
/*!40000 ALTER TABLE `search_test` DISABLE KEYS */;
INSERT INTO `search_test` VALUES (1,'Nike running shoe','Fantastic nike running shoe. Comes in both blue and white',100,'nike.png'),(2,'Reebok basket shoe','Great basket shoe from Reebok. Unisex model. Comes in both red and white',90,'reebok.png'),(3,'Nike basket shoe','Basket shoe from Nike. Comes in both white and red',80,'nike2.png'),(4,'Reebok running shoe','Running shoe from Reebok. Comes in both white and red',75,'reebok2.png'),(5,'New Nike basket shoe','New Basket shoe from Nike. Comes in both blue and red',80,'nike3.png');
/*!40000 ALTER TABLE `search_test` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgbsv_Table5`
--

DROP TABLE IF EXISTS `sgbsv_Table5`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgbsv_Table5` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgbsv_Table5`
--

LOCK TABLES `sgbsv_Table5` WRITE;
/*!40000 ALTER TABLE `sgbsv_Table5` DISABLE KEYS */;
INSERT INTO `sgbsv_Table5` VALUES ('      SUBROUTINE SGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               AB( LDAB, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGBSV computes the solution to a real system of linear equations'),('*  A * X = B, where A is a band matrix of order N with KL subdiagonals'),('*  and KU superdiagonals, and X and B are N-by-NRHS matrices.'),('*'),('*  The LU decomposition with partial pivoting and row interchanges is'),('*  used to factor A as A = L * U, where L is a product of permutation'),('*  and unit lower triangular matrices with KL subdiagonals, and U is'),('*  upper triangular with KL+KU superdiagonals.  The factored form of A'),('*  is then used to solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KL      (input) INTEGER'),('*          The number of subdiagonals within the band of A.  KL >= 0.'),('*'),('*  KU      (input) INTEGER'),('*          The number of superdiagonals within the band of A.  KU >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AB      (input/output) REAL array, dimension (LDAB,N)'),('*          On entry, the matrix A in band storage, in rows KL+1 to'),('*          2*KL+KU+1; rows 1 to KL of the array need not be set.'),('*          The j-th column of A is stored in the j-th column of the'),('*          array AB as follows:'),('*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)'),('*          On exit, details of the factorization: U is stored as an'),('*          upper triangular band matrix with KL+KU superdiagonals in'),('*          rows 1 to KL+KU+1, and the multipliers used during the'),('*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.'),('*          See below for further details.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          The pivot indices that define the permutation matrix P;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization'),('*                has been completed, but the factor U is exactly'),('*                singular, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  M = N = 6, KL = 2, KU = 1:'),('*'),('*  On entry:                       On exit:'),('*'),('*      *    *    *    +    +    +       *    *    *   u14  u25  u36'),('*      *    *    +    +    +    +       *    *   u13  u24  u35  u46'),('*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56'),('*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66'),('*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *'),('*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *'),('*'),('*  Array elements marked * are not used by the routine; elements marked'),('*  + need not be set on entry, but are required by the routine to store'),('*  elements of U because of fill-in resulting from the row interchanges.'),('*');
/*!40000 ALTER TABLE `sgbsv_Table5` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgbsvx_Table45`
--

DROP TABLE IF EXISTS `sgbsvx_Table45`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgbsvx_Table45` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgbsvx_Table45`
--

LOCK TABLES `sgbsvx_Table45` WRITE;
/*!40000 ALTER TABLE `sgbsvx_Table45` DISABLE KEYS */;
INSERT INTO `sgbsvx_Table45` VALUES ('      SUBROUTINE SGBSVX( FACT, TRANS, N, KL, KU, NRHS, AB, LDAB, AFB,'),('     $                   LDAFB, IPIV, EQUED, R, C, B, LDB, X, LDX,'),('     $                   RCOND, FERR, BERR, WORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, TRANS'),('      INTEGER            INFO, KL, KU, LDAB, LDAFB, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * ), IWORK( * )'),('      REAL               AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),'),('     $                   BERR( * ), C( * ), FERR( * ), R( * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGBSVX uses the LU factorization to compute the solution to a real'),('*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,'),('*  where A is a band matrix of order N with KL subdiagonals and KU'),('*  superdiagonals, and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed by this subroutine:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B'),('*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B'),('*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')'),('*     or diag(C)*B (if TRANS = \'T\' or \'C\').'),('*'),('*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the'),('*     matrix A (after equilibration if FACT = \'E\') as'),('*        A = L * U,'),('*     where L is a product of permutation and unit lower triangular'),('*     matrices with KL subdiagonals, and U is upper triangular with'),('*     KL+KU superdiagonals.'),('*'),('*  3. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so'),('*     that it solves the original system before equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFB and IPIV contain the factored form of'),('*                  A.  If EQUED is not \'N\', the matrix A has been'),('*                  equilibrated with scaling factors given by R and C.'),('*                  AB, AFB, and IPIV are not modified.'),('*          = \'N\':  The matrix A will be copied to AFB and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFB and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations.'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Transpose)'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KL      (input) INTEGER'),('*          The number of subdiagonals within the band of A.  KL >= 0.'),('*'),('*  KU      (input) INTEGER'),('*          The number of superdiagonals within the band of A.  KU >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AB      (input/output) REAL array, dimension (LDAB,N)'),('*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.'),('*          The j-th column of A is stored in the j-th column of the'),('*          array AB as follows:'),('*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)'),('*'),('*          If FACT = \'F\' and EQUED is not \'N\', then A must have been'),('*          equilibrated by the scaling factors in R and/or C.  AB is not'),('*          modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and'),('*          EQUED = \'N\' on exit.'),('*'),('*          On exit, if EQUED .ne. \'N\', A is scaled as follows:'),('*          EQUED = \'R\':  A := diag(R) * A'),('*          EQUED = \'C\':  A := A * diag(C)'),('*          EQUED = \'B\':  A := diag(R) * A * diag(C).'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KL+KU+1.'),('*'),('*  AFB     (input or output) REAL array, dimension (LDAFB,N)'),('*          If FACT = \'F\', then AFB is an input argument and on entry'),('*          contains details of the LU factorization of the band matrix'),('*          A, as computed by SGBTRF.  U is stored as an upper triangular'),('*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,'),('*          and the multipliers used during the factorization are stored'),('*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is'),('*          the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFB is an output argument and on exit'),('*          returns details of the LU factorization of A.'),('*'),('*          If FACT = \'E\', then AFB is an output argument and on exit'),('*          returns details of the LU factorization of the equilibrated'),('*          matrix A (see the description of AB for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAFB   (input) INTEGER'),('*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the factorization A = L*U'),('*          as computed by SGBTRF; row i of the matrix was interchanged'),('*          with row IPIV(i).'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = L*U'),('*          of the equilibrated matrix A.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'R\':  Row equilibration, i.e., A has been premultiplied by'),('*                  diag(R).'),('*          = \'C\':  Column equilibration, i.e., A has been postmultiplied'),('*                  by diag(C).'),('*          = \'B\':  Both row and column equilibration, i.e., A has been'),('*                  replaced by diag(R) * A * diag(C).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  R       (input or output) REAL array, dimension (N)'),('*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is'),('*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R'),('*          is not accessed.  R is an input argument if FACT = \'F\';'),('*          otherwise, R is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'R\' or \'B\', each element of R must be positive.'),('*'),('*  C       (input or output) REAL array, dimension (N)'),('*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is'),('*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C'),('*          is not accessed.  C is an input argument if FACT = \'F\';'),('*          otherwise, C is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'C\' or \'B\', each element of C must be positive.'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the right hand side matrix B.'),('*          On exit,'),('*          if EQUED = \'N\', B is not modified;'),('*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by'),('*          diag(R)*B;'),('*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is'),('*          overwritten by diag(C)*B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) REAL array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X'),('*          to the original system of equations.  Note that A and B are'),('*          modified on exit if EQUED .ne. \'N\', and the solution to the'),('*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and'),('*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\''),('*          and EQUED = \'R\' or \'B\'.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (3*N)'),('*          On exit, WORK(1) contains the reciprocal pivot growth'),('*          factor norm(A)/norm(U). The \"max absolute element\" norm is'),('*          used. If WORK(1) is much less than 1, then the stability'),('*          of the LU factorization of the (equilibrated) matrix A'),('*          could be poor. This also means that the solution X, condition'),('*          estimator RCOND, and forward error bound FERR could be'),('*          unreliable. If factorization fails with 0<INFO<=N, then'),('*          WORK(1) contains the reciprocal pivot growth factor for the'),('*          leading INFO columns of A.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization'),('*                       has been completed, but the factor U is exactly'),('*                       singular, so the solution and error bounds'),('*                       could not be computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*'),('*                       value of RCOND would suggest.');
/*!40000 ALTER TABLE `sgbsvx_Table45` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgees_Table197`
--

DROP TABLE IF EXISTS `sgees_Table197`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgees_Table197` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgees_Table197`
--

LOCK TABLES `sgees_Table197` WRITE;
/*!40000 ALTER TABLE `sgees_Table197` DISABLE KEYS */;
INSERT INTO `sgees_Table197` VALUES ('      SUBROUTINE SGEES( JOBVS, SORT, SELECT, N, A, LDA, SDIM, WR, WI,'),('     $                  VS, LDVS, WORK, LWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVS, SORT'),('      INTEGER            INFO, LDA, LDVS, LWORK, N, SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      REAL               A( LDA, * ), VS( LDVS, * ), WI( * ), WORK( * ),'),('     $                   WR( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELECT'),('      EXTERNAL           SELECT'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGEES computes for an N-by-N real nonsymmetric matrix A, the'),('*  eigenvalues, the real Schur form T, and, optionally, the matrix of'),('*  Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).'),('*'),('*  Optionally, it also orders the eigenvalues on the diagonal of the'),('*  real Schur form so that selected eigenvalues are at the top left.'),('*  The leading columns of Z then form an orthonormal basis for the'),('*  invariant subspace corresponding to the selected eigenvalues.'),('*'),('*  A matrix is in real Schur form if it is upper quasi-triangular with'),('*  1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in the'),('*  form'),('*          [  a  b  ]'),('*          [  c  a  ]'),('*'),('*  where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVS   (input) CHARACTER*1'),('*          = \'N\': Schur vectors are not computed;'),('*          = \'V\': Schur vectors are computed.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the Schur form.'),('*          = \'N\': Eigenvalues are not ordered;'),('*          = \'S\': Eigenvalues are ordered (see SELECT).'),('*'),('*  SELECT  (external procedure) LOGICAL FUNCTION of two REAL arguments'),('*          SELECT must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'S\', SELECT is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          If SORT = \'N\', SELECT is not referenced.'),('*          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if'),('*          SELECT(WR(j),WI(j)) is true; i.e., if either one of a complex'),('*          conjugate pair of eigenvalues is selected, then both complex'),('*          eigenvalues are selected.'),('*          Note that a selected complex eigenvalue may no longer'),('*          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since'),('*          ordering may change the value of complex eigenvalues'),('*          (especially if the eigenvalue is ill-conditioned); in this'),('*          case INFO is set to N+2 (see INFO below).'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten by its real Schur form T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*                         for which SELECT is true. (Complex conjugate'),('*                         pairs for which SELECT is true for either'),('*                         eigenvalue count as 2.)'),('*'),('*  WR      (output) REAL array, dimension (N)'),('*  WI      (output) REAL array, dimension (N)'),('*          WR and WI contain the real and imaginary parts,'),('*          respectively, of the computed eigenvalues in the same order'),('*          that they appear on the diagonal of the output Schur form T.'),('*          Complex conjugate pairs of eigenvalues will appear'),('*          consecutively with the eigenvalue having the positive'),('*          imaginary part first.'),('*'),('*  VS      (output) REAL array, dimension (LDVS,N)'),('*          If JOBVS = \'V\', VS contains the orthogonal matrix Z of Schur'),('*          vectors.'),('*          If JOBVS = \'N\', VS is not referenced.'),('*'),('*  LDVS    (input) INTEGER'),('*          The leading dimension of the array VS.  LDVS >= 1; if'),('*          JOBVS = \'V\', LDVS >= N.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) contains the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,3*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value.'),('*          > 0: if INFO = i, and i is'),('*             <= N: the QR algorithm failed to compute all the'),('*                   eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI'),('*                   contain those eigenvalues which have converged; if'),('*                   JOBVS = \'V\', VS contains the matrix which reduces A'),('*                   to its partially converged Schur form.'),('*             = N+1: the eigenvalues could not be reordered because some'),('*                   eigenvalues were too close to separate (the problem'),('*                   is very ill-conditioned);'),('*             = N+2: after reordering, roundoff changed values of some'),('*                   complex eigenvalues so that leading eigenvalues in'),('*                   the Schur form no longer satisfy SELECT=.TRUE.  This'),('*                   could also be caused by underflow due to scaling.'),('*');
/*!40000 ALTER TABLE `sgees_Table197` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgeesx_Table201`
--

DROP TABLE IF EXISTS `sgeesx_Table201`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgeesx_Table201` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgeesx_Table201`
--

LOCK TABLES `sgeesx_Table201` WRITE;
/*!40000 ALTER TABLE `sgeesx_Table201` DISABLE KEYS */;
INSERT INTO `sgeesx_Table201` VALUES ('      SUBROUTINE SGEESX( JOBVS, SORT, SELECT, SENSE, N, A, LDA, SDIM,'),('     $                   WR, WI, VS, LDVS, RCONDE, RCONDV, WORK, LWORK,'),('     $                   IWORK, LIWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVS, SENSE, SORT'),('      INTEGER            INFO, LDA, LDVS, LIWORK, LWORK, N, SDIM'),('      REAL               RCONDE, RCONDV'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      INTEGER            IWORK( * )'),('      REAL               A( LDA, * ), VS( LDVS, * ), WI( * ), WORK( * ),'),('     $                   WR( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELECT'),('      EXTERNAL           SELECT'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGEESX computes for an N-by-N real nonsymmetric matrix A, the'),('*  eigenvalues, the real Schur form T, and, optionally, the matrix of'),('*  Schur vectors Z.  This gives the Schur factorization A = Z*T*(Z**T).'),('*'),('*  Optionally, it also orders the eigenvalues on the diagonal of the'),('*  real Schur form so that selected eigenvalues are at the top left;'),('*  computes a reciprocal condition number for the average of the'),('*  selected eigenvalues (RCONDE); and computes a reciprocal condition'),('*  number for the right invariant subspace corresponding to the'),('*  selected eigenvalues (RCONDV).  The leading columns of Z form an'),('*  orthonormal basis for this invariant subspace.'),('*'),('*  For further explanation of the reciprocal condition numbers RCONDE'),('*  and RCONDV, see Section 4.10 of the LAPACK Users\' Guide (where'),('*  these quantities are called s and sep respectively).'),('*'),('*  A real matrix is in real Schur form if it is upper quasi-triangular'),('*  with 1-by-1 and 2-by-2 blocks. 2-by-2 blocks will be standardized in'),('*  the form'),('*            [  a  b  ]'),('*            [  c  a  ]'),('*'),('*  where b*c < 0. The eigenvalues of such a block are a +- sqrt(bc).'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVS   (input) CHARACTER*1'),('*          = \'N\': Schur vectors are not computed;'),('*          = \'V\': Schur vectors are computed.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the Schur form.'),('*          = \'N\': Eigenvalues are not ordered;'),('*          = \'S\': Eigenvalues are ordered (see SELECT).'),('*'),('*  SELECT  (external procedure) LOGICAL FUNCTION of two REAL arguments'),('*          SELECT must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'S\', SELECT is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          If SORT = \'N\', SELECT is not referenced.'),('*          An eigenvalue WR(j)+sqrt(-1)*WI(j) is selected if'),('*          SELECT(WR(j),WI(j)) is true; i.e., if either one of a'),('*          complex conjugate pair of eigenvalues is selected, then both'),('*          are.  Note that a selected complex eigenvalue may no longer'),('*          satisfy SELECT(WR(j),WI(j)) = .TRUE. after ordering, since'),('*          ordering may change the value of complex eigenvalues'),('*          (especially if the eigenvalue is ill-conditioned); in this'),('*          case INFO may be set to N+3 (see INFO below).'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': None are computed;'),('*          = \'E\': Computed for average of selected eigenvalues only;'),('*          = \'V\': Computed for selected right invariant subspace only;'),('*          = \'B\': Computed for both.'),('*          If SENSE = \'E\', \'V\' or \'B\', SORT must equal \'S\'.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A is overwritten by its real Schur form T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*                         for which SELECT is true. (Complex conjugate'),('*                         pairs for which SELECT is true for either'),('*                         eigenvalue count as 2.)'),('*'),('*  WR      (output) REAL array, dimension (N)'),('*  WI      (output) REAL array, dimension (N)'),('*          WR and WI contain the real and imaginary parts, respectively,'),('*          of the computed eigenvalues, in the same order that they'),('*          appear on the diagonal of the output Schur form T.  Complex'),('*          conjugate pairs of eigenvalues appear consecutively with the'),('*          eigenvalue having the positive imaginary part first.'),('*'),('*  VS      (output) REAL array, dimension (LDVS,N)'),('*          If JOBVS = \'V\', VS contains the orthogonal matrix Z of Schur'),('*          vectors.'),('*          If JOBVS = \'N\', VS is not referenced.'),('*'),('*  LDVS    (input) INTEGER'),('*          The leading dimension of the array VS.  LDVS >= 1, and if'),('*          JOBVS = \'V\', LDVS >= N.'),('*'),('*  RCONDE  (output) REAL'),('*          If SENSE = \'E\' or \'B\', RCONDE contains the reciprocal'),('*          condition number for the average of the selected eigenvalues.'),('*          Not referenced if SENSE = \'N\' or \'V\'.'),('*'),('*  RCONDV  (output) REAL'),('*          If SENSE = \'V\' or \'B\', RCONDV contains the reciprocal'),('*          condition number for the selected right invariant subspace.'),('*          Not referenced if SENSE = \'N\' or \'E\'.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,3*N).'),('*          Also, if SENSE = \'E\' or \'V\' or \'B\','),('*          LWORK >= N+2*SDIM*(N-SDIM), where SDIM is the number of'),('*          selected eigenvalues computed by this routine.  Note that'),('*          N+2*SDIM*(N-SDIM) <= N+N*N/2. Note also that an error is only'),('*          returned if LWORK < max(1,3*N), but if SENSE = \'E\' or \'V\' or'),('*          \'B\' this may not be large enough.'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates upper bounds on the optimal sizes of the'),('*          arrays WORK and IWORK, returns these values as the first'),('*          entries of the WORK and IWORK arrays, and no error messages'),('*          related to LWORK or LIWORK are issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          LIWORK >= 1; if SENSE = \'V\' or \'B\', LIWORK >= SDIM*(N-SDIM).'),('*          Note that SDIM*(N-SDIM) <= N*N/4. Note also that an error is'),('*          only returned if LIWORK < 1, but if SENSE = \'V\' or \'B\' this'),('*          may not be large enough.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates upper bounds on the optimal sizes of'),('*          the arrays WORK and IWORK, returns these values as the first'),('*          entries of the WORK and IWORK arrays, and no error messages'),('*          related to LWORK or LIWORK are issued by XERBLA.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value.'),('*          > 0: if INFO = i, and i is'),('*             <= N: the QR algorithm failed to compute all the'),('*                   eigenvalues; elements 1:ILO-1 and i+1:N of WR and WI'),('*                   contain those eigenvalues which have converged; if'),('*                   JOBVS = \'V\', VS contains the transformation which'),('*                   reduces A to its partially converged Schur form.'),('*             = N+1: the eigenvalues could not be reordered because some'),('*                   eigenvalues were too close to separate (the problem'),('*                   is very ill-conditioned);'),('*             = N+2: after reordering, roundoff changed values of some'),('*                   complex eigenvalues so that leading eigenvalues in'),('*                   the Schur form no longer satisfy SELECT=.TRUE.  This'),('*                   could also be caused by underflow due to scaling.'),('*');
/*!40000 ALTER TABLE `sgeesx_Table201` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgeev_Table189`
--

DROP TABLE IF EXISTS `sgeev_Table189`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgeev_Table189` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgeev_Table189`
--

LOCK TABLES `sgeev_Table189` WRITE;
/*!40000 ALTER TABLE `sgeev_Table189` DISABLE KEYS */;
INSERT INTO `sgeev_Table189` VALUES ('      SUBROUTINE SGEEV( JOBVL, JOBVR, N, A, LDA, WR, WI, VL, LDVL, VR,'),('     $                  LDVR, WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVL, JOBVR'),('      INTEGER            INFO, LDA, LDVL, LDVR, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   WI( * ), WORK( * ), WR( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGEEV computes for an N-by-N real nonsymmetric matrix A, the'),('*  eigenvalues and, optionally, the left and/or right eigenvectors.'),('*'),('*  The right eigenvector v(j) of A satisfies'),('*                   A * v(j) = lambda(j) * v(j)'),('*  where lambda(j) is its eigenvalue.'),('*  The left eigenvector u(j) of A satisfies'),('*                u(j)**H * A = lambda(j) * u(j)**H'),('*  where u(j)**H denotes the conjugate transpose of u(j).'),('*'),('*  The computed eigenvectors are normalized to have Euclidean norm'),('*  equal to 1 and largest component real.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\': left eigenvectors of A are not computed;'),('*          = \'V\': left eigenvectors of A are computed.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\': right eigenvectors of A are not computed;'),('*          = \'V\': right eigenvectors of A are computed.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  WR      (output) REAL array, dimension (N)'),('*  WI      (output) REAL array, dimension (N)'),('*          WR and WI contain the real and imaginary parts,'),('*          respectively, of the computed eigenvalues.  Complex'),('*          conjugate pairs of eigenvalues appear consecutively'),('*          with the eigenvalue having the positive imaginary part'),('*          first.'),('*'),('*  VL      (output) REAL array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order'),('*          as their eigenvalues.'),('*          If JOBVL = \'N\', VL is not referenced.'),('*          If the j-th eigenvalue is real, then u(j) = VL(:,j),'),('*          the j-th column of VL.'),('*          If the j-th and (j+1)-st eigenvalues form a complex'),('*          conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and'),('*          u(j+1) = VL(:,j) - i*VL(:,j+1).'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the array VL.  LDVL >= 1; if'),('*          JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) REAL array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order'),('*          as their eigenvalues.'),('*          If JOBVR = \'N\', VR is not referenced.'),('*          If the j-th eigenvalue is real, then v(j) = VR(:,j),'),('*          the j-th column of VR.'),('*          If the j-th and (j+1)-st eigenvalues form a complex'),('*          conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and'),('*          v(j+1) = VR(:,j) - i*VR(:,j+1).'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the array VR.  LDVR >= 1; if'),('*          JOBVR = \'V\', LDVR >= N.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,3*N), and'),('*          if JOBVL = \'V\' or JOBVR = \'V\', LWORK >= 4*N.  For good'),('*          performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the QR algorithm failed to compute all the'),('*                eigenvalues, and no eigenvectors have been computed;'),('*                elements i+1:N of WR and WI contain eigenvalues which'),('*                have converged.'),('*');
/*!40000 ALTER TABLE `sgeev_Table189` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgeevx_Table193`
--

DROP TABLE IF EXISTS `sgeevx_Table193`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgeevx_Table193` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgeevx_Table193`
--

LOCK TABLES `sgeevx_Table193` WRITE;
/*!40000 ALTER TABLE `sgeevx_Table193` DISABLE KEYS */;
INSERT INTO `sgeevx_Table193` VALUES ('      SUBROUTINE SGEEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, WR, WI,'),('     $                   VL, LDVL, VR, LDVR, ILO, IHI, SCALE, ABNRM,'),('     $                   RCONDE, RCONDV, WORK, LWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          BALANC, JOBVL, JOBVR, SENSE'),('      INTEGER            IHI, ILO, INFO, LDA, LDVL, LDVR, LWORK, N'),('      REAL               ABNRM'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               A( LDA, * ), RCONDE( * ), RCONDV( * ),'),('     $                   SCALE( * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   WI( * ), WORK( * ), WR( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGEEVX computes for an N-by-N real nonsymmetric matrix A, the'),('*  eigenvalues and, optionally, the left and/or right eigenvectors.'),('*'),('*  Optionally also, it computes a balancing transformation to improve'),('*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,'),('*  SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues'),('*  (RCONDE), and reciprocal condition numbers for the right'),('*  eigenvectors (RCONDV).'),('*'),('*  The right eigenvector v(j) of A satisfies'),('*                   A * v(j) = lambda(j) * v(j)'),('*  where lambda(j) is its eigenvalue.'),('*  The left eigenvector u(j) of A satisfies'),('*                u(j)**H * A = lambda(j) * u(j)**H'),('*  where u(j)**H denotes the conjugate transpose of u(j).'),('*'),('*  The computed eigenvectors are normalized to have Euclidean norm'),('*  equal to 1 and largest component real.'),('*'),('*  Balancing a matrix means permuting the rows and columns to make it'),('*  more nearly upper triangular, and applying a diagonal similarity'),('*  transformation D * A * D**(-1), where D is a diagonal matrix, to'),('*  make its rows and columns closer in norm and the condition numbers'),('*  of its eigenvalues and eigenvectors smaller.  The computed'),('*  reciprocal condition numbers correspond to the balanced matrix.'),('*  Permuting rows and columns will not change the condition numbers'),('*  (in exact arithmetic) but diagonal scaling will.  For further'),('*  explanation of balancing, see section 4.10.2 of the LAPACK'),('*  Users\' Guide.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  BALANC  (input) CHARACTER*1'),('*          Indicates how the input matrix should be diagonally scaled'),('*          and/or permuted to improve the conditioning of its'),('*          eigenvalues.'),('*          = \'N\': Do not diagonally scale or permute;'),('*          = \'P\': Perform permutations to make the matrix more nearly'),('*                 upper triangular. Do not diagonally scale;'),('*          = \'S\': Diagonally scale the matrix, i.e. replace A by'),('*                 D*A*D**(-1), where D is a diagonal matrix chosen'),('*                 to make the rows and columns of A more equal in'),('*                 norm. Do not permute;'),('*          = \'B\': Both diagonally scale and permute A.'),('*'),('*          Computed reciprocal condition numbers will be for the matrix'),('*          after balancing and/or permuting. Permuting does not change'),('*          condition numbers (in exact arithmetic), but balancing does.'),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\': left eigenvectors of A are not computed;'),('*          = \'V\': left eigenvectors of A are computed.'),('*          If SENSE = \'E\' or \'B\', JOBVL must = \'V\'.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\': right eigenvectors of A are not computed;'),('*          = \'V\': right eigenvectors of A are computed.'),('*          If SENSE = \'E\' or \'B\', JOBVR must = \'V\'.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': None are computed;'),('*          = \'E\': Computed for eigenvalues only;'),('*          = \'V\': Computed for right eigenvectors only;'),('*          = \'B\': Computed for eigenvalues and right eigenvectors.'),('*'),('*          If SENSE = \'E\' or \'B\', both left and right eigenvectors'),('*          must also be computed (JOBVL = \'V\' and JOBVR = \'V\').'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten.  If JOBVL = \'V\' or'),('*          JOBVR = \'V\', A contains the real Schur form of the balanced'),('*          version of the input matrix A.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  WR      (output) REAL array, dimension (N)'),('*  WI      (output) REAL array, dimension (N)'),('*          WR and WI contain the real and imaginary parts,'),('*          respectively, of the computed eigenvalues.  Complex'),('*          conjugate pairs of eigenvalues will appear consecutively'),('*          with the eigenvalue having the positive imaginary part'),('*          first.'),('*'),('*  VL      (output) REAL array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order'),('*          as their eigenvalues.'),('*          If JOBVL = \'N\', VL is not referenced.'),('*          If the j-th eigenvalue is real, then u(j) = VL(:,j),'),('*          the j-th column of VL.'),('*          If the j-th and (j+1)-st eigenvalues form a complex'),('*          conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and'),('*          u(j+1) = VL(:,j) - i*VL(:,j+1).'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the array VL.  LDVL >= 1; if'),('*          JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) REAL array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order'),('*          as their eigenvalues.'),('*          If JOBVR = \'N\', VR is not referenced.'),('*          If the j-th eigenvalue is real, then v(j) = VR(:,j),'),('*          the j-th column of VR.'),('*          If the j-th and (j+1)-st eigenvalues form a complex'),('*          conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and'),('*          v(j+1) = VR(:,j) - i*VR(:,j+1).'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the array VR.  LDVR >= 1, and if'),('*          JOBVR = \'V\', LDVR >= N.'),('*'),('*  ILO     (output) INTEGER'),('*  IHI     (output) INTEGER'),('*          ILO and IHI are integer values determined when A was'),('*          balanced.  The balanced A(i,j) = 0 if I > J and '),('*          J = 1,...,ILO-1 or I = IHI+1,...,N.'),('*'),('*  SCALE   (output) REAL array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          when balancing A.  If P(j) is the index of the row and column'),('*          interchanged with row and column j, and D(j) is the scaling'),('*          factor applied to row and column j, then'),('*          SCALE(J) = P(J),    for J = 1,...,ILO-1'),('*                   = D(J),    for J = ILO,...,IHI'),('*                   = P(J)     for J = IHI+1,...,N.'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  ABNRM   (output) REAL'),('*          The one-norm of the balanced matrix (the maximum'),('*          of the sum of absolute values of elements of any column).'),('*'),('*  RCONDE  (output) REAL array, dimension (N)'),('*          RCONDE(j) is the reciprocal condition number of the j-th'),('*          eigenvalue.'),('*'),('*  RCONDV  (output) REAL array, dimension (N)'),('*          RCONDV(j) is the reciprocal condition number of the j-th'),('*          right eigenvector.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.   If SENSE = \'N\' or \'E\','),('*          LWORK >= max(1,2*N), and if JOBVL = \'V\' or JOBVR = \'V\','),('*          LWORK >= 3*N.  If SENSE = \'V\' or \'B\', LWORK >= N*(N+6).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (2*N-2)'),('*          If SENSE = \'N\' or \'E\', not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the QR algorithm failed to compute all the'),('*                eigenvalues, and no eigenvectors or condition numbers'),('*                have been computed; elements 1:ILO-1 and i+1:N of WR'),('*                and WI contain eigenvalues which have converged.'),('*');
/*!40000 ALTER TABLE `sgeevx_Table193` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgels_Table81`
--

DROP TABLE IF EXISTS `sgels_Table81`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgels_Table81` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgels_Table81`
--

LOCK TABLES `sgels_Table81` WRITE;
/*!40000 ALTER TABLE `sgels_Table81` DISABLE KEYS */;
INSERT INTO `sgels_Table81` VALUES ('      SUBROUTINE SGELS( TRANS, M, N, NRHS, A, LDA, B, LDB, WORK, LWORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          TRANS'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGELS solves overdetermined or underdetermined real linear systems'),('*  involving an M-by-N matrix A, or its transpose, using a QR or LQ'),('*  factorization of A.  It is assumed that A has full rank.'),('*'),('*  The following options are provided: '),('*'),('*  1. If TRANS = \'N\' and m >= n:  find the least squares solution of'),('*     an overdetermined system, i.e., solve the least squares problem'),('*                  minimize || B - A*X ||.'),('*'),('*  2. If TRANS = \'N\' and m < n:  find the minimum norm solution of'),('*     an underdetermined system A * X = B.'),('*'),('*  3. If TRANS = \'T\' and m >= n:  find the minimum norm solution of'),('*     an undetermined system A**T * X = B.'),('*'),('*  4. If TRANS = \'T\' and m < n:  find the least squares solution of'),('*     an overdetermined system, i.e., solve the least squares problem'),('*                  minimize || B - A**T * X ||.'),('*'),('*  Several right hand side vectors b and solution vectors x can be '),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution '),('*  matrix X.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  TRANS   (input) CHARACTER*1'),('*          = \'N\': the linear system involves A;'),('*          = \'T\': the linear system involves A**T. '),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of'),('*          columns of the matrices B and X. NRHS >=0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit,'),('*            if M >= N, A is overwritten by details of its QR'),('*                       factorization as returned by SGEQRF;'),('*            if M <  N, A is overwritten by details of its LQ'),('*                       factorization as returned by SGELQF.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the matrix B of right hand side vectors, stored'),('*          columnwise; B is M-by-NRHS if TRANS = \'N\', or N-by-NRHS'),('*          if TRANS = \'T\'.  '),('*          On exit, if INFO = 0, B is overwritten by the solution'),('*          vectors, stored columnwise:'),('*          if TRANS = \'N\' and m >= n, rows 1 to n of B contain the least'),('*          squares solution vectors; the residual sum of squares for the'),('*          solution in each column is given by the sum of squares of'),('*          elements N+1 to M in that column;'),('*          if TRANS = \'N\' and m < n, rows 1 to N of B contain the'),('*          minimum norm solution vectors;'),('*          if TRANS = \'T\' and m >= n, rows 1 to M of B contain the'),('*          minimum norm solution vectors;'),('*          if TRANS = \'T\' and m < n, rows 1 to M of B contain the'),('*          least squares solution vectors; the residual sum of squares'),('*          for the solution in each column is given by the sum of'),('*          squares of elements M+1 to N in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= MAX(1,M,N).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          LWORK >= max( 1, MN + max( MN, NRHS ) ).'),('*          For optimal performance,'),('*          LWORK >= max( 1, MN + max( MN, NRHS )*NB ).'),('*          where MN = min(M,N) and NB is the optimum block size.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO =  i, the i-th diagonal element of the'),('*                triangular factor of A is zero, so that A does not have'),('*                full rank; the least squares solution could not be'),('*                computed.'),('*');
/*!40000 ALTER TABLE `sgels_Table81` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgelsd_Table89`
--

DROP TABLE IF EXISTS `sgelsd_Table89`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgelsd_Table89` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgelsd_Table89`
--

LOCK TABLES `sgelsd_Table89` WRITE;
/*!40000 ALTER TABLE `sgelsd_Table89` DISABLE KEYS */;
INSERT INTO `sgelsd_Table89` VALUES ('      SUBROUTINE SGELSD( M, N, NRHS, A, LDA, B, LDB, S, RCOND,'),('     $                   RANK, WORK, LWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               A( LDA, * ), B( LDB, * ), S( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGELSD computes the minimum-norm solution to a real linear least'),('*  squares problem:'),('*      minimize 2-norm(| b - A*x |)'),('*  using the singular value decomposition (SVD) of A. A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  The problem is solved in three steps:'),('*  (1) Reduce the coefficient matrix A to bidiagonal form with'),('*      Householder transformations, reducing the original problem'),('*      into a \"bidiagonal least squares problem\" (BLS)'),('*  (2) Solve the BLS using a divide and conquer approach.'),('*  (3) Apply back all the Householder tranformations to solve'),('*      the original least squares problem.'),('*'),('*  The effective rank of A is determined by treating as zero those'),('*  singular values which are less than RCOND times the largest singular'),('*  value.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of A. M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of A. N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X. NRHS >= 0.'),('*'),('*  A       (input) REAL array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A has been destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, B is overwritten by the N-by-NRHS solution'),('*          matrix X.  If m >= n and RANK = n, the residual'),('*          sum-of-squares for the solution in the i-th column is given'),('*          by the sum of squares of elements n+1:m in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,max(M,N)).'),('*'),('*  S       (output) REAL array, dimension (min(M,N))'),('*          The singular values of A in decreasing order.'),('*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).'),('*'),('*  RCOND   (input) REAL'),('*          RCOND is used to determine the effective rank of A.'),('*          Singular values S(i) <= RCOND*S(1) are treated as zero.'),('*          If RCOND < 0, machine precision is used instead.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the number of singular values'),('*          which are greater than RCOND*S(1).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK must be at least 1.'),('*          The exact minimum amount of workspace needed depends on M,'),('*          N and NRHS. As long as LWORK is at least'),('*              12*N + 2*N*SMLSIZ + 8*N*NLVL + N*NRHS + (SMLSIZ+1)**2,'),('*          if M is greater than or equal to N or'),('*              12*M + 2*M*SMLSIZ + 8*M*NLVL + M*NRHS + (SMLSIZ+1)**2,'),('*          if M is less than N, the code will execute correctly.'),('*          SMLSIZ is returned by ILAENV and is equal to the maximum'),('*          size of the subproblems at the bottom of the computation'),('*          tree (usually about 25), and'),('*             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the array WORK and the'),('*          minimum size of the array IWORK, and returns these values as'),('*          the first entries of the WORK and IWORK arrays, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))'),('*          LIWORK >= max(1, 3*MINMN*NLVL + 11*MINMN),'),('*          where MINMN = MIN( M,N ).'),('*          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  the algorithm for computing the SVD failed to converge;'),('*                if INFO = i, i off-diagonal elements of an intermediate'),('*                bidiagonal form did not converge to zero.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Ming Gu and Ren-Cang Li, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*     Osni Marques, LBNL/NERSC, USA'),('*');
/*!40000 ALTER TABLE `sgelsd_Table89` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgelss_Table93`
--

DROP TABLE IF EXISTS `sgelss_Table93`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgelss_Table93` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgelss_Table93`
--

LOCK TABLES `sgelss_Table93` WRITE;
/*!40000 ALTER TABLE `sgelss_Table93` DISABLE KEYS */;
INSERT INTO `sgelss_Table93` VALUES ('      SUBROUTINE SGELSS( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,'),('     $                   WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               A( LDA, * ), B( LDB, * ), S( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGELSS computes the minimum norm solution to a real linear least'),('*  squares problem:'),('*'),('*  Minimize 2-norm(| b - A*x |).'),('*'),('*  using the singular value decomposition (SVD) of A. A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix'),('*  X.'),('*'),('*  The effective rank of A is determined by treating as zero those'),('*  singular values which are less than RCOND times the largest singular'),('*  value.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A. M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A. N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, the first min(m,n) rows of A are overwritten with'),('*          its right singular vectors, stored rowwise.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, B is overwritten by the N-by-NRHS solution'),('*          matrix X.  If m >= n and RANK = n, the residual'),('*          sum-of-squares for the solution in the i-th column is given'),('*          by the sum of squares of elements n+1:m in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,max(M,N)).'),('*'),('*  S       (output) REAL array, dimension (min(M,N))'),('*          The singular values of A in decreasing order.'),('*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).'),('*'),('*  RCOND   (input) REAL'),('*          RCOND is used to determine the effective rank of A.'),('*          Singular values S(i) <= RCOND*S(1) are treated as zero.'),('*          If RCOND < 0, machine precision is used instead.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the number of singular values'),('*          which are greater than RCOND*S(1).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= 1, and also:'),('*          LWORK >= 3*min(M,N) + max( 2*min(M,N), max(M,N), NRHS )'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  the algorithm for computing the SVD failed to converge;'),('*                if INFO = i, i off-diagonal elements of an intermediate'),('*                bidiagonal form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `sgelss_Table93` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgelsy_Table85`
--

DROP TABLE IF EXISTS `sgelsy_Table85`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgelsy_Table85` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgelsy_Table85`
--

LOCK TABLES `sgelsy_Table85` WRITE;
/*!40000 ALTER TABLE `sgelsy_Table85` DISABLE KEYS */;
INSERT INTO `sgelsy_Table85` VALUES ('      SUBROUTINE SGELSY( M, N, NRHS, A, LDA, B, LDB, JPVT, RCOND, RANK,'),('     $                   WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            JPVT( * )'),('      REAL               A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGELSY computes the minimum-norm solution to a real linear least'),('*  squares problem:'),('*      minimize || A * X - B ||'),('*  using a complete orthogonal factorization of A.  A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  The routine first computes a QR factorization with column pivoting:'),('*      A * P = Q * [ R11 R12 ]'),('*                  [  0  R22 ]'),('*  with R11 defined as the largest leading submatrix whose estimated'),('*  condition number is less than 1/RCOND.  The order of R11, RANK,'),('*  is the effective rank of A.'),('*'),('*  Then, R22 is considered to be negligible, and R12 is annihilated'),('*  by orthogonal transformations from the right, arriving at the'),('*  complete orthogonal factorization:'),('*     A * P = Q * [ T11 0 ] * Z'),('*                 [  0  0 ]'),('*  The minimum-norm solution is then'),('*     X = P * Z\' [ inv(T11)*Q1\'*B ]'),('*                [        0       ]'),('*  where Q1 consists of the first RANK columns of Q.'),('*'),('*  This routine is basically identical to the original xGELSX except'),('*  three differences:'),('*    o The call to the subroutine xGEQPF has been substituted by the'),('*      the call to the subroutine xGEQP3. This subroutine is a Blas-3'),('*      version of the QR factorization with column pivoting.'),('*    o Matrix B (the right hand side) is updated with Blas-3.'),('*    o The permutation of matrix B (the right hand side) is faster and'),('*      more simple.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of'),('*          columns of matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A has been overwritten by details of its'),('*          complete orthogonal factorization.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,M,N).'),('*'),('*  JPVT    (input/output) INTEGER array, dimension (N)'),('*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted'),('*          to the front of AP, otherwise column i is a free column.'),('*          On exit, if JPVT(i) = k, then the i-th column of AP'),('*          was the k-th column of A.'),('*'),('*  RCOND   (input) REAL'),('*          RCOND is used to determine the effective rank of A, which'),('*          is defined as the order of the largest leading triangular'),('*          submatrix R11 in the QR factorization with pivoting of A,'),('*          whose estimated condition number < 1/RCOND.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the order of the submatrix'),('*          R11.  This is the same as the order of the submatrix T11'),('*          in the complete orthogonal factorization of A.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          The unblocked strategy requires that:'),('*             LWORK >= MAX( MN+3*N+1, 2*MN+NRHS ),'),('*          where MN = min( M, N ).'),('*          The block algorithm requires that:'),('*             LWORK >= MAX( MN+2*N+NB*(N+1), 2*MN+NB*NRHS ),'),('*          where NB is an upper bound on the blocksize returned'),('*          by ILAENV for the routines SGEQP3, STZRZF, STZRQF, SORMQR,'),('*          and SORMRZ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: If INFO = -i, the i-th argument had an illegal value.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA'),('*    E. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain'),('*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain'),('*');
/*!40000 ALTER TABLE `sgelsy_Table85` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgesdd_Table223`
--

DROP TABLE IF EXISTS `sgesdd_Table223`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgesdd_Table223` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgesdd_Table223`
--

LOCK TABLES `sgesdd_Table223` WRITE;
/*!40000 ALTER TABLE `sgesdd_Table223` DISABLE KEYS */;
INSERT INTO `sgesdd_Table223` VALUES ('      SUBROUTINE SGESDD( JOBZ, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK,'),('     $                   LWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.1)                                  --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     March 2009'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ'),('      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               A( LDA, * ), S( * ), U( LDU, * ),'),('     $                   VT( LDVT, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGESDD computes the singular value decomposition (SVD) of a real'),('*  M-by-N matrix A, optionally computing the left and right singular'),('*  vectors.  If singular vectors are desired, it uses a'),('*  divide-and-conquer algorithm.'),('*'),('*  The SVD is written'),('*'),('*       A = U * SIGMA * transpose(V)'),('*'),('*  where SIGMA is an M-by-N matrix which is zero except for its'),('*  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and'),('*  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA'),('*  are the singular values of A; they are real and non-negative, and'),('*  are returned in descending order.  The first min(m,n) columns of'),('*  U and V are the left and right singular vectors of A.'),('*'),('*  Note that the routine returns VT = V**T, not V.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix U:'),('*          = \'A\':  all M columns of U and all N rows of V**T are'),('*                  returned in the arrays U and VT;'),('*          = \'S\':  the first min(M,N) columns of U and the first'),('*                  min(M,N) rows of V**T are returned in the arrays U'),('*                  and VT;'),('*          = \'O\':  If M >= N, the first N columns of U are overwritten'),('*                  on the array A and all rows of V**T are returned in'),('*                  the array VT;'),('*                  otherwise, all columns of U are returned in the'),('*                  array U and the first M rows of V**T are overwritten'),('*                  in the array A;'),('*          = \'N\':  no columns of U or rows of V**T are computed.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the input matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the input matrix A.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit,'),('*          if JOBZ = \'O\',  A is overwritten with the first N columns'),('*                          of U (the left singular vectors, stored'),('*                          columnwise) if M >= N;'),('*                          A is overwritten with the first M rows'),('*                          of V**T (the right singular vectors, stored'),('*                          rowwise) otherwise.'),('*          if JOBZ .ne. \'O\', the contents of A are destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  S       (output) REAL array, dimension (min(M,N))'),('*          The singular values of A, sorted so that S(i) >= S(i+1).'),('*'),('*  U       (output) REAL array, dimension (LDU,UCOL)'),('*          UCOL = M if JOBZ = \'A\' or JOBZ = \'O\' and M < N;'),('*          UCOL = min(M,N) if JOBZ = \'S\'.'),('*          If JOBZ = \'A\' or JOBZ = \'O\' and M < N, U contains the M-by-M'),('*          orthogonal matrix U;'),('*          if JOBZ = \'S\', U contains the first min(M,N) columns of U'),('*          (the left singular vectors, stored columnwise);'),('*          if JOBZ = \'O\' and M >= N, or JOBZ = \'N\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U.  LDU >= 1; if'),('*          JOBZ = \'S\' or \'A\' or JOBZ = \'O\' and M < N, LDU >= M.'),('*'),('*  VT      (output) REAL array, dimension (LDVT,N)'),('*          If JOBZ = \'A\' or JOBZ = \'O\' and M >= N, VT contains the'),('*          N-by-N orthogonal matrix V**T;'),('*          if JOBZ = \'S\', VT contains the first min(M,N) rows of'),('*          V**T (the right singular vectors, stored rowwise);'),('*          if JOBZ = \'O\' and M < N, or JOBZ = \'N\', VT is not referenced.'),('*'),('*  LDVT    (input) INTEGER'),('*          The leading dimension of the array VT.  LDVT >= 1; if'),('*          JOBZ = \'A\' or JOBZ = \'O\' and M >= N, LDVT >= N;'),('*          if JOBZ = \'S\', LDVT >= min(M,N).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= 1.'),('*          If JOBZ = \'N\','),('*            LWORK >= 3*min(M,N) + max(max(M,N),6*min(M,N)).'),('*          If JOBZ = \'O\','),('*            LWORK >= 3*min(M,N) + '),('*                     max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).'),('*          If JOBZ = \'S\' or \'A\''),('*            LWORK >= 3*min(M,N) +'),('*                     max(max(M,N),4*min(M,N)*min(M,N)+4*min(M,N)).'),('*          For good performance, LWORK should generally be larger.'),('*          If LWORK = -1 but other input arguments are legal, WORK(1)'),('*          returns the optimal LWORK.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  SBDSDC did not converge, updating process failed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Ming Gu and Huan Ren, Computer Science Division, University of'),('*     California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `sgesdd_Table223` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgesv_Table1`
--

DROP TABLE IF EXISTS `sgesv_Table1`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgesv_Table1` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgesv_Table1`
--

LOCK TABLES `sgesv_Table1` WRITE;
/*!40000 ALTER TABLE `sgesv_Table1` DISABLE KEYS */;
INSERT INTO `sgesv_Table1` VALUES ('      SUBROUTINE SGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               A( LDA, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGESV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.'),('*'),('*  The LU decomposition with partial pivoting and row interchanges is'),('*  used to factor A as'),('*     A = P * L * U,'),('*  where P is a permutation matrix, L is unit lower triangular, and U is'),('*  upper triangular.  The factored form of A is then used to solve the'),('*  system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the N-by-N coefficient matrix A.'),('*          On exit, the factors L and U from the factorization'),('*          A = P*L*U; the unit diagonal elements of L are not stored.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          The pivot indices that define the permutation matrix P;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS matrix of right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization'),('*                has been completed, but the factor U is exactly'),('*                singular, so the solution could not be computed.'),('*');
/*!40000 ALTER TABLE `sgesv_Table1` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgesvd_Table219`
--

DROP TABLE IF EXISTS `sgesvd_Table219`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgesvd_Table219` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgesvd_Table219`
--

LOCK TABLES `sgesvd_Table219` WRITE;
/*!40000 ALTER TABLE `sgesvd_Table219` DISABLE KEYS */;
INSERT INTO `sgesvd_Table219` VALUES ('      SUBROUTINE SGESVD( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,'),('     $                   WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBU, JOBVT'),('      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               A( LDA, * ), S( * ), U( LDU, * ),'),('     $                   VT( LDVT, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGESVD computes the singular value decomposition (SVD) of a real'),('*  M-by-N matrix A, optionally computing the left and/or right singular'),('*  vectors. The SVD is written'),('*'),('*       A = U * SIGMA * transpose(V)'),('*'),('*  where SIGMA is an M-by-N matrix which is zero except for its'),('*  min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and'),('*  V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA'),('*  are the singular values of A; they are real and non-negative, and'),('*  are returned in descending order.  The first min(m,n) columns of'),('*  U and V are the left and right singular vectors of A.'),('*'),('*  Note that the routine returns V**T, not V.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBU    (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix U:'),('*          = \'A\':  all M columns of U are returned in array U:'),('*          = \'S\':  the first min(m,n) columns of U (the left singular'),('*                  vectors) are returned in the array U;'),('*          = \'O\':  the first min(m,n) columns of U (the left singular'),('*                  vectors) are overwritten on the array A;'),('*          = \'N\':  no columns of U (no left singular vectors) are'),('*                  computed.'),('*'),('*  JOBVT   (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix'),('*          V**T:'),('*          = \'A\':  all N rows of V**T are returned in the array VT;'),('*          = \'S\':  the first min(m,n) rows of V**T (the right singular'),('*                  vectors) are returned in the array VT;'),('*          = \'O\':  the first min(m,n) rows of V**T (the right singular'),('*                  vectors) are overwritten on the array A;'),('*          = \'N\':  no rows of V**T (no right singular vectors) are'),('*                  computed.'),('*'),('*          JOBVT and JOBU cannot both be \'O\'.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the input matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the input matrix A.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit,'),('*          if JOBU = \'O\',  A is overwritten with the first min(m,n)'),('*                          columns of U (the left singular vectors,'),('*                          stored columnwise);'),('*          if JOBVT = \'O\', A is overwritten with the first min(m,n)'),('*                          rows of V**T (the right singular vectors,'),('*                          stored rowwise);'),('*          if JOBU .ne. \'O\' and JOBVT .ne. \'O\', the contents of A'),('*                          are destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  S       (output) REAL array, dimension (min(M,N))'),('*          The singular values of A, sorted so that S(i) >= S(i+1).'),('*'),('*  U       (output) REAL array, dimension (LDU,UCOL)'),('*          (LDU,M) if JOBU = \'A\' or (LDU,min(M,N)) if JOBU = \'S\'.'),('*          If JOBU = \'A\', U contains the M-by-M orthogonal matrix U;'),('*          if JOBU = \'S\', U contains the first min(m,n) columns of U'),('*          (the left singular vectors, stored columnwise);'),('*          if JOBU = \'N\' or \'O\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U.  LDU >= 1; if'),('*          JOBU = \'S\' or \'A\', LDU >= M.'),('*'),('*  VT      (output) REAL array, dimension (LDVT,N)'),('*          If JOBVT = \'A\', VT contains the N-by-N orthogonal matrix'),('*          V**T;'),('*          if JOBVT = \'S\', VT contains the first min(m,n) rows of'),('*          V**T (the right singular vectors, stored rowwise);'),('*          if JOBVT = \'N\' or \'O\', VT is not referenced.'),('*'),('*  LDVT    (input) INTEGER'),('*          The leading dimension of the array VT.  LDVT >= 1; if'),('*          JOBVT = \'A\', LDVT >= N; if JOBVT = \'S\', LDVT >= min(M,N).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK;'),('*          if INFO > 0, WORK(2:MIN(M,N)) contains the unconverged'),('*          superdiagonal elements of an upper bidiagonal matrix B'),('*          whose diagonal is in S (not necessarily sorted). B'),('*          satisfies A = U * B * VT, so it has the same singular values'),('*          as A, and singular vectors related by U and VT.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          LWORK >= MAX(1,3*MIN(M,N)+MAX(M,N),5*MIN(M,N)).'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if SBDSQR did not converge, INFO specifies how many'),('*                superdiagonals of an intermediate bidiagonal form B'),('*                did not converge to zero. See the description of WORK'),('*                above for details.'),('*');
/*!40000 ALTER TABLE `sgesvd_Table219` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgesvx_Table41`
--

DROP TABLE IF EXISTS `sgesvx_Table41`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgesvx_Table41` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgesvx_Table41`
--

LOCK TABLES `sgesvx_Table41` WRITE;
/*!40000 ALTER TABLE `sgesvx_Table41` DISABLE KEYS */;
INSERT INTO `sgesvx_Table41` VALUES ('      SUBROUTINE SGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV,'),('     $                   EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, TRANS'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * ), IWORK( * )'),('      REAL               A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   BERR( * ), C( * ), FERR( * ), R( * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGESVX uses the LU factorization to compute the solution to a real'),('*  system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B'),('*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B'),('*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')'),('*     or diag(C)*B (if TRANS = \'T\' or \'C\').'),('*'),('*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the'),('*     matrix A (after equilibration if FACT = \'E\') as'),('*        A = P * L * U,'),('*     where P is a permutation matrix, L is a unit lower triangular'),('*     matrix, and U is upper triangular.'),('*'),('*  3. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so'),('*     that it solves the original system before equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AF and IPIV contain the factored form of A.'),('*                  If EQUED is not \'N\', the matrix A has been'),('*                  equilibrated with scaling factors given by R and C.'),('*                  A, AF, and IPIV are not modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AF and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations:'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Transpose)'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is'),('*          not \'N\', then A must have been equilibrated by the scaling'),('*          factors in R and/or C.  A is not modified if FACT = \'F\' or'),('*          \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if EQUED .ne. \'N\', A is scaled as follows:'),('*          EQUED = \'R\':  A := diag(R) * A'),('*          EQUED = \'C\':  A := A * diag(C)'),('*          EQUED = \'B\':  A := diag(R) * A * diag(C).'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) REAL array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the factors L and U from the factorization'),('*          A = P*L*U as computed by SGETRF.  If EQUED .ne. \'N\', then'),('*          AF is the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the factors L and U from the factorization A = P*L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then AF is an output argument and on exit'),('*          returns the factors L and U from the factorization A = P*L*U'),('*          of the equilibrated matrix A (see the description of A for'),('*          the form of the equilibrated matrix).'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          as computed by SGETRF; row i of the matrix was interchanged'),('*          with row IPIV(i).'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          of the equilibrated matrix A.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'R\':  Row equilibration, i.e., A has been premultiplied by'),('*                  diag(R).'),('*          = \'C\':  Column equilibration, i.e., A has been postmultiplied'),('*                  by diag(C).'),('*          = \'B\':  Both row and column equilibration, i.e., A has been'),('*                  replaced by diag(R) * A * diag(C).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  R       (input or output) REAL array, dimension (N)'),('*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is'),('*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R'),('*          is not accessed.  R is an input argument if FACT = \'F\';'),('*          otherwise, R is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'R\' or \'B\', each element of R must be positive.'),('*'),('*  C       (input or output) REAL array, dimension (N)'),('*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is'),('*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C'),('*          is not accessed.  C is an input argument if FACT = \'F\';'),('*          otherwise, C is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'C\' or \'B\', each element of C must be positive.'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit,'),('*          if EQUED = \'N\', B is not modified;'),('*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by'),('*          diag(R)*B;'),('*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is'),('*          overwritten by diag(C)*B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) REAL array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X'),('*          to the original system of equations.  Note that A and B are'),('*          modified on exit if EQUED .ne. \'N\', and the solution to the'),('*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and'),('*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\''),('*          and EQUED = \'R\' or \'B\'.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (4*N)'),('*          On exit, WORK(1) contains the reciprocal pivot growth'),('*          factor norm(A)/norm(U). The \"max absolute element\" norm is'),('*          used. If WORK(1) is much less than 1, then the stability'),('*          of the LU factorization of the (equilibrated) matrix A'),('*          could be poor. This also means that the solution X, condition'),('*          estimator RCOND, and forward error bound FERR could be'),('*          unreliable. If factorization fails with 0<INFO<=N, then'),('*          WORK(1) contains the reciprocal pivot growth factor for the'),('*          leading INFO columns of A.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization has'),('*                       been completed, but the factor U is exactly'),('*                       singular, so the solution and error bounds'),('*                       could not be computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `sgesvx_Table41` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgges_Table211`
--

DROP TABLE IF EXISTS `sgges_Table211`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgges_Table211` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgges_Table211`
--

LOCK TABLES `sgges_Table211` WRITE;
/*!40000 ALTER TABLE `sgges_Table211` DISABLE KEYS */;
INSERT INTO `sgges_Table211` VALUES ('      SUBROUTINE SGGES( JOBVSL, JOBVSR, SORT, SELCTG, N, A, LDA, B, LDB,'),('     $                  SDIM, ALPHAR, ALPHAI, BETA, VSL, LDVSL, VSR,'),('     $                  LDVSR, WORK, LWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVSL, JOBVSR, SORT'),('      INTEGER            INFO, LDA, LDB, LDVSL, LDVSR, LWORK, N, SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      REAL               A( LDA, * ), ALPHAI( * ), ALPHAR( * ),'),('     $                   B( LDB, * ), BETA( * ), VSL( LDVSL, * ),'),('     $                   VSR( LDVSR, * ), WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELCTG'),('      EXTERNAL           SELCTG'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGGES computes for a pair of N-by-N real nonsymmetric matrices (A,B),'),('*  the generalized eigenvalues, the generalized real Schur form (S,T),'),('*  optionally, the left and/or right matrices of Schur vectors (VSL and'),('*  VSR). This gives the generalized Schur factorization'),('*'),('*           (A,B) = ( (VSL)*S*(VSR)**T, (VSL)*T*(VSR)**T )'),('*'),('*  Optionally, it also orders the eigenvalues so that a selected cluster'),('*  of eigenvalues appears in the leading diagonal blocks of the upper'),('*  quasi-triangular matrix S and the upper triangular matrix T.The'),('*  leading columns of VSL and VSR then form an orthonormal basis for the'),('*  corresponding left and right eigenspaces (deflating subspaces).'),('*'),('*  (If only the generalized eigenvalues are needed, use the driver'),('*  SGGEV instead, which is faster.)'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w'),('*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is'),('*  usually represented as the pair (alpha,beta), as there is a'),('*  reasonable interpretation for beta=0 or both being zero.'),('*'),('*  A pair of matrices (S,T) is in generalized real Schur form if T is'),('*  upper triangular with non-negative diagonal and S is block upper'),('*  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond'),('*  to real generalized eigenvalues, while 2-by-2 blocks of S will be'),('*  \"standardized\" by making the corresponding elements of T have the'),('*  form:'),('*          [  a  0  ]'),('*          [  0  b  ]'),('*'),('*  and the pair of corresponding 2-by-2 blocks in S and T will have a'),('*  complex conjugate pair of generalized eigenvalues.'),('*'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVSL  (input) CHARACTER*1'),('*          = \'N\':  do not compute the left Schur vectors;'),('*          = \'V\':  compute the left Schur vectors.'),('*'),('*  JOBVSR  (input) CHARACTER*1'),('*          = \'N\':  do not compute the right Schur vectors;'),('*          = \'V\':  compute the right Schur vectors.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the generalized Schur form.'),('*          = \'N\':  Eigenvalues are not ordered;'),('*          = \'S\':  Eigenvalues are ordered (see SELCTG);'),('*'),('*  SELCTG  (external procedure) LOGICAL FUNCTION of three REAL arguments'),('*          SELCTG must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'N\', SELCTG is not referenced.'),('*          If SORT = \'S\', SELCTG is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if'),('*          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either'),('*          one of a complex conjugate pair of eigenvalues is selected,'),('*          then both complex eigenvalues are selected.'),('*'),('*          Note that in the ill-conditioned case, a selected complex'),('*          eigenvalue may no longer satisfy SELCTG(ALPHAR(j),ALPHAI(j),'),('*          BETA(j)) = .TRUE. after ordering. INFO is to be set to N+2'),('*          in this case.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VSL, and VSR.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the first of the pair of matrices.'),('*          On exit, A has been overwritten by its generalized Schur'),('*          form S.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) REAL array, dimension (LDB, N)'),('*          On entry, the second of the pair of matrices.'),('*          On exit, B has been overwritten by its generalized Schur'),('*          form T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*          for which SELCTG is true.  (Complex conjugate pairs for which'),('*          SELCTG is true for either eigenvalue count as 2.)'),('*'),('*  ALPHAR  (output) REAL array, dimension (N)'),('*  ALPHAI  (output) REAL array, dimension (N)'),('*  BETA    (output) REAL array, dimension (N)'),('*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will'),('*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i,'),('*          and  BETA(j),j=1,...,N are the diagonals of the complex Schur'),('*          form (S,T) that would result if the 2-by-2 diagonal blocks of'),('*          the real Schur form of (A,B) were further reduced to'),('*          triangular form using 2-by-2 complex unitary transformations.'),('*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if'),('*          positive, then the j-th and (j+1)-st eigenvalues are a'),('*          complex conjugate pair, with ALPHAI(j+1) negative.'),('*'),('*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)'),('*          may easily over- or underflow, and BETA(j) may even be zero.'),('*          Thus, the user should avoid naively computing the ratio.'),('*          However, ALPHAR and ALPHAI will be always less than and'),('*          usually comparable with norm(A) in magnitude, and BETA always'),('*          less than and usually comparable with norm(B).'),('*'),('*  VSL     (output) REAL array, dimension (LDVSL,N)'),('*          If JOBVSL = \'V\', VSL will contain the left Schur vectors.'),('*          Not referenced if JOBVSL = \'N\'.'),('*'),('*  LDVSL   (input) INTEGER'),('*          The leading dimension of the matrix VSL. LDVSL >=1, and'),('*          if JOBVSL = \'V\', LDVSL >= N.'),('*'),('*  VSR     (output) REAL array, dimension (LDVSR,N)'),('*          If JOBVSR = \'V\', VSR will contain the right Schur vectors.'),('*          Not referenced if JOBVSR = \'N\'.'),('*'),('*  LDVSR   (input) INTEGER'),('*          The leading dimension of the matrix VSR. LDVSR >= 1, and'),('*          if JOBVSR = \'V\', LDVSR >= N.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N = 0, LWORK >= 1, else LWORK >= max(8*N,6*N+16).'),('*          For good performance , LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  (A,B) are not in Schur'),('*                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should'),('*                be correct for j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in SHGEQZ.'),('*                =N+2: after reordering, roundoff changed values of'),('*                      some complex eigenvalues so that leading'),('*                      eigenvalues in the Generalized Schur form no'),('*                      longer satisfy SELCTG=.TRUE.  This could also'),('*                      be caused due to scaling.'),('*                =N+3: reordering failed in STGSEN.'),('*');
/*!40000 ALTER TABLE `sgges_Table211` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sggesx_Table215`
--

DROP TABLE IF EXISTS `sggesx_Table215`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sggesx_Table215` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sggesx_Table215`
--

LOCK TABLES `sggesx_Table215` WRITE;
/*!40000 ALTER TABLE `sggesx_Table215` DISABLE KEYS */;
INSERT INTO `sggesx_Table215` VALUES ('      SUBROUTINE SGGESX( JOBVSL, JOBVSR, SORT, SELCTG, SENSE, N, A, LDA,'),('     $                   B, LDB, SDIM, ALPHAR, ALPHAI, BETA, VSL, LDVSL,'),('     $                   VSR, LDVSR, RCONDE, RCONDV, WORK, LWORK, IWORK,'),('     $                   LIWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.1)                                  --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*  -- April 2009                                                      --'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVSL, JOBVSR, SENSE, SORT'),('      INTEGER            INFO, LDA, LDB, LDVSL, LDVSR, LIWORK, LWORK, N,'),('     $                   SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      INTEGER            IWORK( * )'),('      REAL               A( LDA, * ), ALPHAI( * ), ALPHAR( * ),'),('     $                   B( LDB, * ), BETA( * ), RCONDE( 2 ),'),('     $                   RCONDV( 2 ), VSL( LDVSL, * ), VSR( LDVSR, * ),'),('     $                   WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELCTG'),('      EXTERNAL           SELCTG'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGGESX computes for a pair of N-by-N real nonsymmetric matrices'),('*  (A,B), the generalized eigenvalues, the real Schur form (S,T), and,'),('*  optionally, the left and/or right matrices of Schur vectors (VSL and'),('*  VSR).  This gives the generalized Schur factorization'),('*'),('*       (A,B) = ( (VSL) S (VSR)**T, (VSL) T (VSR)**T )'),('*'),('*  Optionally, it also orders the eigenvalues so that a selected cluster'),('*  of eigenvalues appears in the leading diagonal blocks of the upper'),('*  quasi-triangular matrix S and the upper triangular matrix T; computes'),('*  a reciprocal condition number for the average of the selected'),('*  eigenvalues (RCONDE); and computes a reciprocal condition number for'),('*  the right and left deflating subspaces corresponding to the selected'),('*  eigenvalues (RCONDV). The leading columns of VSL and VSR then form'),('*  an orthonormal basis for the corresponding left and right eigenspaces'),('*  (deflating subspaces).'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w'),('*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is'),('*  usually represented as the pair (alpha,beta), as there is a'),('*  reasonable interpretation for beta=0 or for both being zero.'),('*'),('*  A pair of matrices (S,T) is in generalized real Schur form if T is'),('*  upper triangular with non-negative diagonal and S is block upper'),('*  triangular with 1-by-1 and 2-by-2 blocks.  1-by-1 blocks correspond'),('*  to real generalized eigenvalues, while 2-by-2 blocks of S will be'),('*  \"standardized\" by making the corresponding elements of T have the'),('*  form:'),('*          [  a  0  ]'),('*          [  0  b  ]'),('*'),('*  and the pair of corresponding 2-by-2 blocks in S and T will have a'),('*  complex conjugate pair of generalized eigenvalues.'),('*'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVSL  (input) CHARACTER*1'),('*          = \'N\':  do not compute the left Schur vectors;'),('*          = \'V\':  compute the left Schur vectors.'),('*'),('*  JOBVSR  (input) CHARACTER*1'),('*          = \'N\':  do not compute the right Schur vectors;'),('*          = \'V\':  compute the right Schur vectors.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the generalized Schur form.'),('*          = \'N\':  Eigenvalues are not ordered;'),('*          = \'S\':  Eigenvalues are ordered (see SELCTG).'),('*'),('*  SELCTG  (external procedure) LOGICAL FUNCTION of three REAL arguments'),('*          SELCTG must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'N\', SELCTG is not referenced.'),('*          If SORT = \'S\', SELCTG is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          An eigenvalue (ALPHAR(j)+ALPHAI(j))/BETA(j) is selected if'),('*          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) is true; i.e. if either'),('*          one of a complex conjugate pair of eigenvalues is selected,'),('*          then both complex eigenvalues are selected.'),('*          Note that a selected complex eigenvalue may no longer satisfy'),('*          SELCTG(ALPHAR(j),ALPHAI(j),BETA(j)) = .TRUE. after ordering,'),('*          since ordering may change the value of complex eigenvalues'),('*          (especially if the eigenvalue is ill-conditioned), in this'),('*          case INFO is set to N+3.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\' : None are computed;'),('*          = \'E\' : Computed for average of selected eigenvalues only;'),('*          = \'V\' : Computed for selected deflating subspaces only;'),('*          = \'B\' : Computed for both.'),('*          If SENSE = \'E\', \'V\', or \'B\', SORT must equal \'S\'.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VSL, and VSR.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the first of the pair of matrices.'),('*          On exit, A has been overwritten by its generalized Schur'),('*          form S.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) REAL array, dimension (LDB, N)'),('*          On entry, the second of the pair of matrices.'),('*          On exit, B has been overwritten by its generalized Schur'),('*          form T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*          for which SELCTG is true.  (Complex conjugate pairs for which'),('*          SELCTG is true for either eigenvalue count as 2.)'),('*'),('*  ALPHAR  (output) REAL array, dimension (N)'),('*  ALPHAI  (output) REAL array, dimension (N)'),('*  BETA    (output) REAL array, dimension (N)'),('*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will'),('*          be the generalized eigenvalues.  ALPHAR(j) + ALPHAI(j)*i'),('*          and BETA(j),j=1,...,N  are the diagonals of the complex Schur'),('*          form (S,T) that would result if the 2-by-2 diagonal blocks of'),('*          the real Schur form of (A,B) were further reduced to'),('*          triangular form using 2-by-2 complex unitary transformations.'),('*          If ALPHAI(j) is zero, then the j-th eigenvalue is real; if'),('*          positive, then the j-th and (j+1)-st eigenvalues are a'),('*          complex conjugate pair, with ALPHAI(j+1) negative.'),('*'),('*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)'),('*          may easily over- or underflow, and BETA(j) may even be zero.'),('*          Thus, the user should avoid naively computing the ratio.'),('*          However, ALPHAR and ALPHAI will be always less than and'),('*          usually comparable with norm(A) in magnitude, and BETA always'),('*          less than and usually comparable with norm(B).'),('*'),('*  VSL     (output) REAL array, dimension (LDVSL,N)'),('*          If JOBVSL = \'V\', VSL will contain the left Schur vectors.'),('*          Not referenced if JOBVSL = \'N\'.'),('*'),('*  LDVSL   (input) INTEGER'),('*          The leading dimension of the matrix VSL. LDVSL >=1, and'),('*          if JOBVSL = \'V\', LDVSL >= N.'),('*'),('*  VSR     (output) REAL array, dimension (LDVSR,N)'),('*          If JOBVSR = \'V\', VSR will contain the right Schur vectors.'),('*          Not referenced if JOBVSR = \'N\'.'),('*'),('*  LDVSR   (input) INTEGER'),('*          The leading dimension of the matrix VSR. LDVSR >= 1, and'),('*          if JOBVSR = \'V\', LDVSR >= N.'),('*'),('*  RCONDE  (output) REAL array, dimension ( 2 )'),('*          If SENSE = \'E\' or \'B\', RCONDE(1) and RCONDE(2) contain the'),('*          reciprocal condition numbers for the average of the selected'),('*          eigenvalues.'),('*          Not referenced if SENSE = \'N\' or \'V\'.'),('*'),('*  RCONDV  (output) REAL array, dimension ( 2 )'),('*          If SENSE = \'V\' or \'B\', RCONDV(1) and RCONDV(2) contain the'),('*          reciprocal condition numbers for the selected deflating'),('*          subspaces.'),('*          Not referenced if SENSE = \'N\' or \'E\'.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N = 0, LWORK >= 1, else if SENSE = \'E\', \'V\', or \'B\','),('*          LWORK >= max( 8*N, 6*N+16, 2*SDIM*(N-SDIM) ), else'),('*          LWORK >= max( 8*N, 6*N+16 ).'),('*          Note that 2*SDIM*(N-SDIM) <= N*N/2.'),('*          Note also that an error is only returned if'),('*          LWORK < max( 8*N, 6*N+16), but if SENSE = \'E\' or \'V\' or \'B\''),('*          this may not be large enough.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the bound on the optimal size of the WORK'),('*          array and the minimum size of the IWORK array, returns these'),('*          values as the first entries of the WORK and IWORK arrays, and'),('*          no error message related to LWORK or LIWORK is issued by'),('*          XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If SENSE = \'N\' or N = 0, LIWORK >= 1, otherwise'),('*          LIWORK >= N+6.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the bound on the optimal size of the'),('*          WORK array and the minimum size of the IWORK array, returns'),('*          these values as the first entries of the WORK and IWORK'),('*          arrays, and no error message related to LWORK or LIWORK is'),('*          issued by XERBLA.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  (A,B) are not in Schur'),('*                form, but ALPHAR(j), ALPHAI(j), and BETA(j) should'),('*                be correct for j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in SHGEQZ'),('*                =N+2: after reordering, roundoff changed values of'),('*                      some complex eigenvalues so that leading'),('*                      eigenvalues in the Generalized Schur form no'),('*                      longer satisfy SELCTG=.TRUE.  This could also'),('*                      be caused due to scaling.'),('*                =N+3: reordering failed in STGSEN.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  An approximate (asymptotic) bound on the average absolute error of'),('*  the selected eigenvalues is'),('*'),('*       EPS * norm((A, B)) / RCONDE( 1 ).'),('*'),('*  An approximate (asymptotic) bound on the maximum angular error in'),('*  the computed deflating subspaces is'),('*'),('*       EPS * norm((A, B)) / RCONDV( 2 ).'),('*'),('*  See LAPACK User\'s Guide, section 4.11 for more information.'),('*');
/*!40000 ALTER TABLE `sggesx_Table215` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sggev_Table205`
--

DROP TABLE IF EXISTS `sggev_Table205`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sggev_Table205` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sggev_Table205`
--

LOCK TABLES `sggev_Table205` WRITE;
/*!40000 ALTER TABLE `sggev_Table205` DISABLE KEYS */;
INSERT INTO `sggev_Table205` VALUES ('      SUBROUTINE SGGEV( JOBVL, JOBVR, N, A, LDA, B, LDB, ALPHAR, ALPHAI,'),('     $                  BETA, VL, LDVL, VR, LDVR, WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVL, JOBVR'),('      INTEGER            INFO, LDA, LDB, LDVL, LDVR, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               A( LDA, * ), ALPHAI( * ), ALPHAR( * ),'),('     $                   B( LDB, * ), BETA( * ), VL( LDVL, * ),'),('     $                   VR( LDVR, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGGEV computes for a pair of N-by-N real nonsymmetric matrices (A,B)'),('*  the generalized eigenvalues, and optionally, the left and/or right'),('*  generalized eigenvectors.'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar'),('*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is'),('*  singular. It is usually represented as the pair (alpha,beta), as'),('*  there is a reasonable interpretation for beta=0, and even for both'),('*  being zero.'),('*'),('*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*'),('*                   A * v(j) = lambda(j) * B * v(j).'),('*'),('*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*'),('*                   u(j)**H * A  = lambda(j) * u(j)**H * B .'),('*'),('*  where u(j)**H is the conjugate-transpose of u(j).'),('*'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\':  do not compute the left generalized eigenvectors;'),('*          = \'V\':  compute the left generalized eigenvectors.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\':  do not compute the right generalized eigenvectors;'),('*          = \'V\':  compute the right generalized eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VL, and VR.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the matrix A in the pair (A,B).'),('*          On exit, A has been overwritten.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) REAL array, dimension (LDB, N)'),('*          On entry, the matrix B in the pair (A,B).'),('*          On exit, B has been overwritten.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  ALPHAR  (output) REAL array, dimension (N)'),('*  ALPHAI  (output) REAL array, dimension (N)'),('*  BETA    (output) REAL array, dimension (N)'),('*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will'),('*          be the generalized eigenvalues.  If ALPHAI(j) is zero, then'),('*          the j-th eigenvalue is real; if positive, then the j-th and'),('*          (j+1)-st eigenvalues are a complex conjugate pair, with'),('*          ALPHAI(j+1) negative.'),('*'),('*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)'),('*          may easily over- or underflow, and BETA(j) may even be zero.'),('*          Thus, the user should avoid naively computing the ratio'),('*          alpha/beta.  However, ALPHAR and ALPHAI will be always less'),('*          than and usually comparable with norm(A) in magnitude, and'),('*          BETA always less than and usually comparable with norm(B).'),('*'),('*  VL      (output) REAL array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order as'),('*          their eigenvalues. If the j-th eigenvalue is real, then'),('*          u(j) = VL(:,j), the j-th column of VL. If the j-th and'),('*          (j+1)-th eigenvalues form a complex conjugate pair, then'),('*          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).'),('*          Each eigenvector is scaled so the largest component has'),('*          abs(real part)+abs(imag. part)=1.'),('*          Not referenced if JOBVL = \'N\'.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the matrix VL. LDVL >= 1, and'),('*          if JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) REAL array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order as'),('*          their eigenvalues. If the j-th eigenvalue is real, then'),('*          v(j) = VR(:,j), the j-th column of VR. If the j-th and'),('*          (j+1)-th eigenvalues form a complex conjugate pair, then'),('*          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).'),('*          Each eigenvector is scaled so the largest component has'),('*          abs(real part)+abs(imag. part)=1.'),('*          Not referenced if JOBVR = \'N\'.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the matrix VR. LDVR >= 1, and'),('*          if JOBVR = \'V\', LDVR >= N.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,8*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  No eigenvectors have been'),('*                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)'),('*                should be correct for j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in SHGEQZ.'),('*                =N+2: error return from STGEVC.'),('*');
/*!40000 ALTER TABLE `sggev_Table205` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sggevx_Table209`
--

DROP TABLE IF EXISTS `sggevx_Table209`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sggevx_Table209` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sggevx_Table209`
--

LOCK TABLES `sggevx_Table209` WRITE;
/*!40000 ALTER TABLE `sggevx_Table209` DISABLE KEYS */;
INSERT INTO `sggevx_Table209` VALUES ('      SUBROUTINE SGGEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, B, LDB,'),('     $                   ALPHAR, ALPHAI, BETA, VL, LDVL, VR, LDVR, ILO,'),('     $                   IHI, LSCALE, RSCALE, ABNRM, BBNRM, RCONDE,'),('     $                   RCONDV, WORK, LWORK, IWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          BALANC, JOBVL, JOBVR, SENSE'),('      INTEGER            IHI, ILO, INFO, LDA, LDB, LDVL, LDVR, LWORK, N'),('      REAL               ABNRM, BBNRM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      INTEGER            IWORK( * )'),('      REAL               A( LDA, * ), ALPHAI( * ), ALPHAR( * ),'),('     $                   B( LDB, * ), BETA( * ), LSCALE( * ),'),('     $                   RCONDE( * ), RCONDV( * ), RSCALE( * ),'),('     $                   VL( LDVL, * ), VR( LDVR, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)'),('*  the generalized eigenvalues, and optionally, the left and/or right'),('*  generalized eigenvectors.'),('*'),('*  Optionally also, it computes a balancing transformation to improve'),('*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,'),('*  LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for'),('*  the eigenvalues (RCONDE), and reciprocal condition numbers for the'),('*  right eigenvectors (RCONDV).'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar'),('*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is'),('*  singular. It is usually represented as the pair (alpha,beta), as'),('*  there is a reasonable interpretation for beta=0, and even for both'),('*  being zero.'),('*'),('*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*'),('*                   A * v(j) = lambda(j) * B * v(j) .'),('*'),('*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*'),('*                   u(j)**H * A  = lambda(j) * u(j)**H * B.'),('*'),('*  where u(j)**H is the conjugate-transpose of u(j).'),('*'),('*'),('*  Arguments'),('*  ========='),('*'),('*  BALANC  (input) CHARACTER*1'),('*          Specifies the balance option to be performed.'),('*          = \'N\':  do not diagonally scale or permute;'),('*          = \'P\':  permute only;'),('*          = \'S\':  scale only;'),('*          = \'B\':  both permute and scale.'),('*          Computed reciprocal condition numbers will be for the'),('*          matrices after permuting and/or balancing. Permuting does'),('*          not change condition numbers (in exact arithmetic), but'),('*          balancing does.'),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\':  do not compute the left generalized eigenvectors;'),('*          = \'V\':  compute the left generalized eigenvectors.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\':  do not compute the right generalized eigenvectors;'),('*          = \'V\':  compute the right generalized eigenvectors.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': none are computed;'),('*          = \'E\': computed for eigenvalues only;'),('*          = \'V\': computed for eigenvectors only;'),('*          = \'B\': computed for eigenvalues and eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VL, and VR.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the matrix A in the pair (A,B).'),('*          On exit, A has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\''),('*          or both, then A contains the first part of the real Schur'),('*          form of the \"balanced\" versions of the input A and B.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) REAL array, dimension (LDB, N)'),('*          On entry, the matrix B in the pair (A,B).'),('*          On exit, B has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\''),('*          or both, then B contains the second part of the real Schur'),('*          form of the \"balanced\" versions of the input A and B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  ALPHAR  (output) REAL array, dimension (N)'),('*  ALPHAI  (output) REAL array, dimension (N)'),('*  BETA    (output) REAL array, dimension (N)'),('*          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will'),('*          be the generalized eigenvalues.  If ALPHAI(j) is zero, then'),('*          the j-th eigenvalue is real; if positive, then the j-th and'),('*          (j+1)-st eigenvalues are a complex conjugate pair, with'),('*          ALPHAI(j+1) negative.'),('*'),('*          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)'),('*          may easily over- or underflow, and BETA(j) may even be zero.'),('*          Thus, the user should avoid naively computing the ratio'),('*          ALPHA/BETA. However, ALPHAR and ALPHAI will be always less'),('*          than and usually comparable with norm(A) in magnitude, and'),('*          BETA always less than and usually comparable with norm(B).'),('*'),('*  VL      (output) REAL array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order as'),('*          their eigenvalues. If the j-th eigenvalue is real, then'),('*          u(j) = VL(:,j), the j-th column of VL. If the j-th and'),('*          (j+1)-th eigenvalues form a complex conjugate pair, then'),('*          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).'),('*          Each eigenvector will be scaled so the largest component have'),('*          abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVL = \'N\'.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the matrix VL. LDVL >= 1, and'),('*          if JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) REAL array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order as'),('*          their eigenvalues. If the j-th eigenvalue is real, then'),('*          v(j) = VR(:,j), the j-th column of VR. If the j-th and'),('*          (j+1)-th eigenvalues form a complex conjugate pair, then'),('*          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).'),('*          Each eigenvector will be scaled so the largest component have'),('*          abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVR = \'N\'.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the matrix VR. LDVR >= 1, and'),('*          if JOBVR = \'V\', LDVR >= N.'),('*'),('*  ILO     (output) INTEGER'),('*  IHI     (output) INTEGER'),('*          ILO and IHI are integer values such that on exit'),('*          A(i,j) = 0 and B(i,j) = 0 if i > j and'),('*          j = 1,...,ILO-1 or i = IHI+1,...,N.'),('*          If BALANC = \'N\' or \'S\', ILO = 1 and IHI = N.'),('*'),('*  LSCALE  (output) REAL array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          to the left side of A and B.  If PL(j) is the index of the'),('*          row interchanged with row j, and DL(j) is the scaling'),('*          factor applied to row j, then'),('*            LSCALE(j) = PL(j)  for j = 1,...,ILO-1'),('*                      = DL(j)  for j = ILO,...,IHI'),('*                      = PL(j)  for j = IHI+1,...,N.'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  RSCALE  (output) REAL array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          to the right side of A and B.  If PR(j) is the index of the'),('*          column interchanged with column j, and DR(j) is the scaling'),('*          factor applied to column j, then'),('*            RSCALE(j) = PR(j)  for j = 1,...,ILO-1'),('*                      = DR(j)  for j = ILO,...,IHI'),('*                      = PR(j)  for j = IHI+1,...,N'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  ABNRM   (output) REAL'),('*          The one-norm of the balanced matrix A.'),('*'),('*  BBNRM   (output) REAL'),('*          The one-norm of the balanced matrix B.'),('*'),('*  RCONDE  (output) REAL array, dimension (N)'),('*          If SENSE = \'E\' or \'B\', the reciprocal condition numbers of'),('*          the eigenvalues, stored in consecutive elements of the array.'),('*          For a complex conjugate pair of eigenvalues two consecutive'),('*          elements of RCONDE are set to the same value. Thus RCONDE(j),'),('*          RCONDV(j), and the j-th columns of VL and VR all correspond'),('*          to the j-th eigenpair.'),('*          If SENSE = \'N\' or \'V\', RCONDE is not referenced.'),('*'),('*  RCONDV  (output) REAL array, dimension (N)'),('*          If SENSE = \'V\' or \'B\', the estimated reciprocal condition'),('*          numbers of the eigenvectors, stored in consecutive elements'),('*          of the array. For a complex eigenvector two consecutive'),('*          elements of RCONDV are set to the same value. If the'),('*          eigenvalues cannot be reordered to compute RCONDV(j),'),('*          RCONDV(j) is set to 0; this can only occur when the true'),('*          value would be very small anyway.'),('*          If SENSE = \'N\' or \'E\', RCONDV is not referenced.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,2*N).'),('*          If BALANC = \'S\' or \'B\', or JOBVL = \'V\', or JOBVR = \'V\','),('*          LWORK >= max(1,6*N).'),('*          If SENSE = \'E\', LWORK >= max(1,10*N).'),('*          If SENSE = \'V\' or \'B\', LWORK >= 2*N*N+8*N+16.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N+6)'),('*          If SENSE = \'E\', IWORK is not referenced.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          If SENSE = \'N\', BWORK is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  No eigenvectors have been'),('*                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)'),('*                should be correct for j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in SHGEQZ.'),('*                =N+2: error return from STGEVC.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Balancing a matrix pair (A,B) includes, first, permuting rows and'),('*  columns to isolate eigenvalues, second, applying diagonal similarity'),('*  transformation to the rows and columns to make the rows and columns'),('*  as close in norm as possible. The computed reciprocal condition'),('*  numbers correspond to the balanced matrix. Permuting rows and columns'),('*  will not change the condition numbers (in exact arithmetic) but'),('*  diagonal scaling will.  For further explanation of balancing, see'),('*  section 4.11.1.2 of LAPACK Users\' Guide.'),('*'),('*  An approximate error bound on the chordal distance between the i-th'),('*  computed generalized eigenvalue w and the corresponding exact'),('*  eigenvalue lambda is'),('*'),('*       chord(w, lambda) <= EPS * norm(ABNRM, BBNRM) / RCONDE(I)'),('*'),('*  An approximate error bound for the angle between the i-th computed'),('*  eigenvector VL(i) or VR(i) is given by'),('*'),('*       EPS * norm(ABNRM, BBNRM) / DIF(i).'),('*'),('*  For further explanation of the reciprocal condition numbers RCONDE'),('*  and RCONDV, see section 4.11 of LAPACK User\'s Guide.'),('*');
/*!40000 ALTER TABLE `sggevx_Table209` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sggglm_Table101`
--

DROP TABLE IF EXISTS `sggglm_Table101`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sggglm_Table101` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sggglm_Table101`
--

LOCK TABLES `sggglm_Table101` WRITE;
/*!40000 ALTER TABLE `sggglm_Table101` DISABLE KEYS */;
INSERT INTO `sggglm_Table101` VALUES ('      SUBROUTINE SGGGLM( N, M, P, A, LDA, B, LDB, D, X, Y, WORK, LWORK,'),('     $                   INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               A( LDA, * ), B( LDB, * ), D( * ), WORK( * ),'),('     $                   X( * ), Y( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGGGLM solves a general Gauss-Markov linear model (GLM) problem:'),('*'),('*          minimize || y ||_2   subject to   d = A*x + B*y'),('*              x'),('*'),('*  where A is an N-by-M matrix, B is an N-by-P matrix, and d is a'),('*  given N-vector. It is assumed that M <= N <= M+P, and'),('*'),('*             rank(A) = M    and    rank( A B ) = N.'),('*'),('*  Under these assumptions, the constrained equation is always'),('*  consistent, and there is a unique solution x and a minimal 2-norm'),('*  solution y, which is obtained using a generalized QR factorization'),('*  of the matrices (A, B) given by'),('*'),('*     A = Q*(R),   B = Q*T*Z.'),('*           (0)'),('*'),('*  In particular, if matrix B is square nonsingular, then the problem'),('*  GLM is equivalent to the following weighted linear least squares'),('*  problem'),('*'),('*               minimize || inv(B)*(d-A*x) ||_2'),('*                   x'),('*'),('*  where inv(B) denotes the inverse of B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of rows of the matrices A and B.  N >= 0.'),('*'),('*  M       (input) INTEGER'),('*          The number of columns of the matrix A.  0 <= M <= N.'),('*'),('*  P       (input) INTEGER'),('*          The number of columns of the matrix B.  P >= N-M.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,M)'),('*          On entry, the N-by-M matrix A.'),('*          On exit, the upper triangular part of the array A contains'),('*          the M-by-M upper triangular matrix R.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,N).'),('*'),('*  B       (input/output) REAL array, dimension (LDB,P)'),('*          On entry, the N-by-P matrix B.'),('*          On exit, if N <= P, the upper triangle of the subarray'),('*          B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;'),('*          if N > P, the elements on and above the (N-P)th subdiagonal'),('*          contain the N-by-P upper trapezoidal matrix T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,N).'),('*'),('*  D       (input/output) REAL array, dimension (N)'),('*          On entry, D is the left hand side of the GLM equation.'),('*          On exit, D is destroyed.'),('*'),('*  X       (output) REAL array, dimension (M)'),('*  Y       (output) REAL array, dimension (P)'),('*          On exit, X and Y are the solutions of the GLM problem.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,N+M+P).'),('*          For optimum performance, LWORK >= M+min(N,P)+max(N,P)*NB,'),('*          where NB is an upper bound for the optimal blocksizes for'),('*          SGEQRF, SGERQF, SORMQR and SORMRQ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1:  the upper triangular factor R associated with A in the'),('*                generalized QR factorization of the pair (A, B) is'),('*                singular, so that rank(A) < M; the least squares'),('*                solution could not be computed.'),('*          = 2:  the bottom (N-M) by (N-M) part of the upper trapezoidal'),('*                factor T associated with B in the generalized QR'),('*                factorization of the pair (A, B) is singular, so that'),('*                rank( A B ) < N; the least squares solution could not'),('*                be computed.'),('*');
/*!40000 ALTER TABLE `sggglm_Table101` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgglse_Table97`
--

DROP TABLE IF EXISTS `sgglse_Table97`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgglse_Table97` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgglse_Table97`
--

LOCK TABLES `sgglse_Table97` WRITE;
/*!40000 ALTER TABLE `sgglse_Table97` DISABLE KEYS */;
INSERT INTO `sgglse_Table97` VALUES ('      SUBROUTINE SGGLSE( M, N, P, A, LDA, B, LDB, C, D, X, WORK, LWORK,'),('     $                   INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               A( LDA, * ), B( LDB, * ), C( * ), D( * ),'),('     $                   WORK( * ), X( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGGLSE solves the linear equality-constrained least squares (LSE)'),('*  problem:'),('*'),('*          minimize || c - A*x ||_2   subject to   B*x = d'),('*'),('*  where A is an M-by-N matrix, B is a P-by-N matrix, c is a given'),('*  M-vector, and d is a given P-vector. It is assumed that'),('*  P <= N <= M+P, and'),('*'),('*           rank(B) = P and  rank( (A) ) = N.'),('*                                ( (B) )'),('*'),('*  These conditions ensure that the LSE problem has a unique solution,'),('*  which is obtained using a generalized RQ factorization of the'),('*  matrices (B, A) given by'),('*'),('*     B = (0 R)*Q,   A = Z*T*Q.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrices A and B. N >= 0.'),('*'),('*  P       (input) INTEGER'),('*          The number of rows of the matrix B. 0 <= P <= N <= M+P.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, the elements on and above the diagonal of the array'),('*          contain the min(M,N)-by-N upper trapezoidal matrix T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) REAL array, dimension (LDB,N)'),('*          On entry, the P-by-N matrix B.'),('*          On exit, the upper triangle of the subarray B(1:P,N-P+1:N)'),('*          contains the P-by-P upper triangular matrix R.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,P).'),('*'),('*  C       (input/output) REAL array, dimension (M)'),('*          On entry, C contains the right hand side vector for the'),('*          least squares part of the LSE problem.'),('*          On exit, the residual sum of squares for the solution'),('*          is given by the sum of squares of elements N-P+1 to M of'),('*          vector C.'),('*'),('*  D       (input/output) REAL array, dimension (P)'),('*          On entry, D contains the right hand side vector for the'),('*          constrained equation.'),('*          On exit, D is destroyed.'),('*'),('*  X       (output) REAL array, dimension (N)'),('*          On exit, X is the solution of the LSE problem.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,M+N+P).'),('*          For optimum performance LWORK >= P+min(M,N)+max(M,N)*NB,'),('*          where NB is an upper bound for the optimal blocksizes for'),('*          SGEQRF, SGERQF, SORMQR and SORMRQ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1:  the upper triangular factor R associated with B in the'),('*                generalized RQ factorization of the pair (B, A) is'),('*                singular, so that rank(B) < P; the least squares'),('*                solution could not be computed.'),('*          = 2:  the (N-P) by (N-P) part of the upper trapezoidal factor'),('*                T associated with A in the generalized RQ factorization'),('*                of the pair (B, A) is singular, so that'),('*                rank( (A) ) < N; the least squares solution could not'),('*                    ( (B) )'),('*                be computed.'),('*');
/*!40000 ALTER TABLE `sgglse_Table97` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sggsvd_Table227`
--

DROP TABLE IF EXISTS `sggsvd_Table227`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sggsvd_Table227` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sggsvd_Table227`
--

LOCK TABLES `sggsvd_Table227` WRITE;
/*!40000 ALTER TABLE `sggsvd_Table227` DISABLE KEYS */;
INSERT INTO `sggsvd_Table227` VALUES ('      SUBROUTINE SGGSVD( JOBU, JOBV, JOBQ, M, N, P, K, L, A, LDA, B,'),('     $                   LDB, ALPHA, BETA, U, LDU, V, LDV, Q, LDQ, WORK,'),('     $                   IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBQ, JOBU, JOBV'),('      INTEGER            INFO, K, L, LDA, LDB, LDQ, LDU, LDV, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               A( LDA, * ), ALPHA( * ), B( LDB, * ),'),('     $                   BETA( * ), Q( LDQ, * ), U( LDU, * ),'),('     $                   V( LDV, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGGSVD computes the generalized singular value decomposition (GSVD)'),('*  of an M-by-N real matrix A and P-by-N real matrix B:'),('*'),('*      U\'*A*Q = D1*( 0 R ),    V\'*B*Q = D2*( 0 R )'),('*'),('*  where U, V and Q are orthogonal matrices, and Z\' is the transpose'),('*  of Z.  Let K+L = the effective numerical rank of the matrix (A\',B\')\','),('*  then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and'),('*  D2 are M-by-(K+L) and P-by-(K+L) \"diagonal\" matrices and of the'),('*  following structures, respectively:'),('*'),('*  If M-K-L >= 0,'),('*'),('*                      K  L'),('*         D1 =     K ( I  0 )'),('*                  L ( 0  C )'),('*              M-K-L ( 0  0 )'),('*'),('*                    K  L'),('*         D2 =   L ( 0  S )'),('*              P-L ( 0  0 )'),('*'),('*                  N-K-L  K    L'),('*    ( 0 R ) = K (  0   R11  R12 )'),('*              L (  0    0   R22 )'),('*'),('*  where'),('*'),('*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),'),('*    S = diag( BETA(K+1),  ... , BETA(K+L) ),'),('*    C**2 + S**2 = I.'),('*'),('*    R is stored in A(1:K+L,N-K-L+1:N) on exit.'),('*'),('*  If M-K-L < 0,'),('*'),('*                    K M-K K+L-M'),('*         D1 =   K ( I  0    0   )'),('*              M-K ( 0  C    0   )'),('*'),('*                      K M-K K+L-M'),('*         D2 =   M-K ( 0  S    0  )'),('*              K+L-M ( 0  0    I  )'),('*                P-L ( 0  0    0  )'),('*'),('*                     N-K-L  K   M-K  K+L-M'),('*    ( 0 R ) =     K ( 0    R11  R12  R13  )'),('*                M-K ( 0     0   R22  R23  )'),('*              K+L-M ( 0     0    0   R33  )'),('*'),('*  where'),('*'),('*    C = diag( ALPHA(K+1), ... , ALPHA(M) ),'),('*    S = diag( BETA(K+1),  ... , BETA(M) ),'),('*    C**2 + S**2 = I.'),('*'),('*    (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored'),('*    ( 0  R22 R23 )'),('*    in B(M-K+1:L,N+M-K-L+1:N) on exit.'),('*'),('*  The routine computes C, S, R, and optionally the orthogonal'),('*  transformation matrices U, V and Q.'),('*'),('*  In particular, if B is an N-by-N nonsingular matrix, then the GSVD of'),('*  A and B implicitly gives the SVD of A*inv(B):'),('*                       A*inv(B) = U*(D1*inv(D2))*V\'.'),('*  If ( A\',B\')\' has orthonormal columns, then the GSVD of A and B is'),('*  also equal to the CS decomposition of A and B. Furthermore, the GSVD'),('*  can be used to derive the solution of the eigenvalue problem:'),('*                       A\'*A x = lambda* B\'*B x.'),('*  In some literature, the GSVD of A and B is presented in the form'),('*                   U\'*A*X = ( 0 D1 ),   V\'*B*X = ( 0 D2 )'),('*  where U and V are orthogonal and X is nonsingular, D1 and D2 are'),('*  ``diagonal\'\'.  The former GSVD form can be converted to the latter'),('*  form by taking the nonsingular matrix X as'),('*'),('*                       X = Q*( I   0    )'),('*                             ( 0 inv(R) ).'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBU    (input) CHARACTER*1'),('*          = \'U\':  Orthogonal matrix U is computed;'),('*          = \'N\':  U is not computed.'),('*'),('*  JOBV    (input) CHARACTER*1'),('*          = \'V\':  Orthogonal matrix V is computed;'),('*          = \'N\':  V is not computed.'),('*'),('*  JOBQ    (input) CHARACTER*1'),('*          = \'Q\':  Orthogonal matrix Q is computed;'),('*          = \'N\':  Q is not computed.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrices A and B.  N >= 0.'),('*'),('*  P       (input) INTEGER'),('*          The number of rows of the matrix B.  P >= 0.'),('*'),('*  K       (output) INTEGER'),('*  L       (output) INTEGER'),('*          On exit, K and L specify the dimension of the subblocks'),('*          described in the Purpose section.'),('*          K + L = effective numerical rank of (A\',B\')\'.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A contains the triangular matrix R, or part of R.'),('*          See Purpose for details.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) REAL array, dimension (LDB,N)'),('*          On entry, the P-by-N matrix B.'),('*          On exit, B contains the triangular matrix R if M-K-L < 0.'),('*          See Purpose for details.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,P).'),('*'),('*  ALPHA   (output) REAL array, dimension (N)'),('*  BETA    (output) REAL array, dimension (N)'),('*          On exit, ALPHA and BETA contain the generalized singular'),('*          value pairs of A and B;'),('*            ALPHA(1:K) = 1,'),('*            BETA(1:K)  = 0,'),('*          and if M-K-L >= 0,'),('*            ALPHA(K+1:K+L) = C,'),('*            BETA(K+1:K+L)  = S,'),('*          or if M-K-L < 0,'),('*            ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0'),('*            BETA(K+1:M) =S, BETA(M+1:K+L) =1'),('*          and'),('*            ALPHA(K+L+1:N) = 0'),('*            BETA(K+L+1:N)  = 0'),('*'),('*  U       (output) REAL array, dimension (LDU,M)'),('*          If JOBU = \'U\', U contains the M-by-M orthogonal matrix U.'),('*          If JOBU = \'N\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U. LDU >= max(1,M) if'),('*          JOBU = \'U\'; LDU >= 1 otherwise.'),('*'),('*  V       (output) REAL array, dimension (LDV,P)'),('*          If JOBV = \'V\', V contains the P-by-P orthogonal matrix V.'),('*          If JOBV = \'N\', V is not referenced.'),('*'),('*  LDV     (input) INTEGER'),('*          The leading dimension of the array V. LDV >= max(1,P) if'),('*          JOBV = \'V\'; LDV >= 1 otherwise.'),('*'),('*  Q       (output) REAL array, dimension (LDQ,N)'),('*          If JOBQ = \'Q\', Q contains the N-by-N orthogonal matrix Q.'),('*          If JOBQ = \'N\', Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q. LDQ >= max(1,N) if'),('*          JOBQ = \'Q\'; LDQ >= 1 otherwise.'),('*'),('*  WORK    (workspace) REAL array,'),('*                      dimension (max(3*N,M,P)+N)'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (N)'),('*          On exit, IWORK stores the sorting information. More'),('*          precisely, the following loop will sort ALPHA'),('*             for I = K+1, min(M,K+L)'),('*                 swap ALPHA(I) and ALPHA(IWORK(I))'),('*             endfor'),('*          such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = 1, the Jacobi-type procedure failed to'),('*                converge.  For further details, see subroutine STGSJA.'),('*'),('*  Internal Parameters'),('*  ==================='),('*'),('*  TOLA    REAL'),('*  TOLB    REAL'),('*          TOLA and TOLB are the thresholds to determine the effective'),('*          rank of (A\',B\')\'. Generally, they are set to'),('*                   TOLA = MAX(M,N)*norm(A)*MACHEPS,'),('*                   TOLB = MAX(P,N)*norm(B)*MACHEPS.'),('*          The size of TOLA and TOLB may affect the size of backward'),('*          errors of the decomposition.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  2-96 Based on modifications by'),('*     Ming Gu and Huan Ren, Computer Science Division, University of'),('*     California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `sggsvd_Table227` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgtsv_Table9`
--

DROP TABLE IF EXISTS `sgtsv_Table9`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgtsv_Table9` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgtsv_Table9`
--

LOCK TABLES `sgtsv_Table9` WRITE;
/*!40000 ALTER TABLE `sgtsv_Table9` DISABLE KEYS */;
INSERT INTO `sgtsv_Table9` VALUES ('      SUBROUTINE SGTSV( N, NRHS, DL, D, DU, B, LDB, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               B( LDB, * ), D( * ), DL( * ), DU( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGTSV  solves the equation'),('*'),('*     A*X = B,'),('*'),('*  where A is an n by n tridiagonal matrix, by Gaussian elimination with'),('*  partial pivoting.'),('*'),('*  Note that the equation  A\'*X = B  may be solved by interchanging the'),('*  order of the arguments DU and DL.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  DL      (input/output) REAL array, dimension (N-1)'),('*          On entry, DL must contain the (n-1) sub-diagonal elements of'),('*          A.'),('*'),('*          On exit, DL is overwritten by the (n-2) elements of the'),('*          second super-diagonal of the upper triangular matrix U from'),('*          the LU factorization of A, in DL(1), ..., DL(n-2).'),('*'),('*  D       (input/output) REAL array, dimension (N)'),('*          On entry, D must contain the diagonal elements of A.'),('*'),('*          On exit, D is overwritten by the n diagonal elements of U.'),('*'),('*  DU      (input/output) REAL array, dimension (N-1)'),('*          On entry, DU must contain the (n-1) super-diagonal elements'),('*          of A.'),('*'),('*          On exit, DU is overwritten by the (n-1) elements of the first'),('*          super-diagonal of U.'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N by NRHS matrix of right hand side matrix B.'),('*          On exit, if INFO = 0, the N by NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, U(i,i) is exactly zero, and the solution'),('*               has not been computed.  The factorization has not been'),('*               completed unless i = N.'),('*');
/*!40000 ALTER TABLE `sgtsv_Table9` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sgtsvx_Table49`
--

DROP TABLE IF EXISTS `sgtsvx_Table49`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sgtsvx_Table49` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sgtsvx_Table49`
--

LOCK TABLES `sgtsvx_Table49` WRITE;
/*!40000 ALTER TABLE `sgtsvx_Table49` DISABLE KEYS */;
INSERT INTO `sgtsvx_Table49` VALUES ('      SUBROUTINE SGTSVX( FACT, TRANS, N, NRHS, DL, D, DU, DLF, DF, DUF,'),('     $                   DU2, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, IWORK, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, TRANS'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * ), IWORK( * )'),('      REAL               B( LDB, * ), BERR( * ), D( * ), DF( * ),'),('     $                   DL( * ), DLF( * ), DU( * ), DU2( * ), DUF( * ),'),('     $                   FERR( * ), WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SGTSVX uses the LU factorization to compute the solution to a real'),('*  system of linear equations A * X = B or A**T * X = B,'),('*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the LU decomposition is used to factor the matrix A'),('*     as A = L * U, where L is a product of permutation and unit lower'),('*     bidiagonal matrices and U is upper triangular with nonzeros in'),('*     only the main diagonal and first two superdiagonals.'),('*'),('*  2. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored'),('*                  form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV'),('*                  will not be modified.'),('*          = \'N\':  The matrix will be copied to DLF, DF, and DUF'),('*                  and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations:'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  DL      (input) REAL array, dimension (N-1)'),('*          The (n-1) subdiagonal elements of A.'),('*'),('*  D       (input) REAL array, dimension (N)'),('*          The n diagonal elements of A.'),('*'),('*  DU      (input) REAL array, dimension (N-1)'),('*          The (n-1) superdiagonal elements of A.'),('*'),('*  DLF     (input or output) REAL array, dimension (N-1)'),('*          If FACT = \'F\', then DLF is an input argument and on entry'),('*          contains the (n-1) multipliers that define the matrix L from'),('*          the LU factorization of A as computed by SGTTRF.'),('*'),('*          If FACT = \'N\', then DLF is an output argument and on exit'),('*          contains the (n-1) multipliers that define the matrix L from'),('*          the LU factorization of A.'),('*'),('*  DF      (input or output) REAL array, dimension (N)'),('*          If FACT = \'F\', then DF is an input argument and on entry'),('*          contains the n diagonal elements of the upper triangular'),('*          matrix U from the LU factorization of A.'),('*'),('*          If FACT = \'N\', then DF is an output argument and on exit'),('*          contains the n diagonal elements of the upper triangular'),('*          matrix U from the LU factorization of A.'),('*'),('*  DUF     (input or output) REAL array, dimension (N-1)'),('*          If FACT = \'F\', then DUF is an input argument and on entry'),('*          contains the (n-1) elements of the first superdiagonal of U.'),('*'),('*          If FACT = \'N\', then DUF is an output argument and on exit'),('*          contains the (n-1) elements of the first superdiagonal of U.'),('*'),('*  DU2     (input or output) REAL array, dimension (N-2)'),('*          If FACT = \'F\', then DU2 is an input argument and on entry'),('*          contains the (n-2) elements of the second superdiagonal of'),('*          U.'),('*'),('*          If FACT = \'N\', then DU2 is an output argument and on exit'),('*          contains the (n-2) elements of the second superdiagonal of'),('*          U.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the LU factorization of A as'),('*          computed by SGTTRF.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the LU factorization of A;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates'),('*          a row interchange was not required.'),('*'),('*  B       (input) REAL array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) REAL array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) REAL array, dimension (3*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization'),('*                       has not been completed unless i = N, but the'),('*                       factor U is exactly singular, so the solution'),('*                       and error bounds could not be computed.'),('*                       RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `sgtsvx_Table49` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `spbsv_Table21`
--

DROP TABLE IF EXISTS `spbsv_Table21`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `spbsv_Table21` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `spbsv_Table21`
--

LOCK TABLES `spbsv_Table21` WRITE;
/*!40000 ALTER TABLE `spbsv_Table21` DISABLE KEYS */;
INSERT INTO `spbsv_Table21` VALUES ('      SUBROUTINE SPBSV( UPLO, N, KD, NRHS, AB, LDAB, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, KD, LDAB, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               AB( LDAB, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SPBSV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite band matrix and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**T * U,  if UPLO = \'U\', or'),('*     A = L * L**T,  if UPLO = \'L\','),('*  where U is an upper triangular band matrix, and L is a lower'),('*  triangular band matrix, with the same number of superdiagonals or'),('*  subdiagonals as A.  The factored form of A is then used to solve the'),('*  system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AB      (input/output) REAL array, dimension (LDAB,N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).'),('*          See below for further details.'),('*'),('*          On exit, if INFO = 0, the triangular factor U or L from the'),('*          Cholesky factorization A = U**T*U or A = L*L**T of the band'),('*          matrix A, in the same storage format as A.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD+1.'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  N = 6, KD = 2, and UPLO = \'U\':'),('*'),('*  On entry:                       On exit:'),('*'),('*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46'),('*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56'),('*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66'),('*'),('*  Similarly, if UPLO = \'L\' the format of A is as follows:'),('*'),('*  On entry:                       On exit:'),('*'),('*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66'),('*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *'),('*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *'),('*'),('*  Array elements marked * are not used by the routine.'),('*');
/*!40000 ALTER TABLE `spbsv_Table21` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `spbsvx_Table61`
--

DROP TABLE IF EXISTS `spbsvx_Table61`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `spbsvx_Table61` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `spbsvx_Table61`
--

LOCK TABLES `spbsvx_Table61` WRITE;
/*!40000 ALTER TABLE `spbsvx_Table61` DISABLE KEYS */;
INSERT INTO `spbsvx_Table61` VALUES ('      SUBROUTINE SPBSVX( FACT, UPLO, N, KD, NRHS, AB, LDAB, AFB, LDAFB,'),('     $                   EQUED, S, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, KD, LDAB, LDAFB, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),'),('     $                   BERR( * ), FERR( * ), S( * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to'),('*  compute the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite band matrix and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U**T * U,  if UPLO = \'U\', or'),('*        A = L * L**T,  if UPLO = \'L\','),('*     where U is an upper triangular band matrix, and L is a lower'),('*     triangular band matrix.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFB contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  AB and AFB will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AFB and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFB and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right-hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AB      (input/output) REAL array, dimension (LDAB,N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first KD+1 rows of the array, except'),('*          if FACT = \'F\' and EQUED = \'Y\', then A must contain the'),('*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A'),('*          is stored in the j-th column of the array AB as follows:'),('*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).'),('*          See below for further details.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array A.  LDAB >= KD+1.'),('*'),('*  AFB     (input or output) REAL array, dimension (LDAFB,N)'),('*          If FACT = \'F\', then AFB is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T of the band matrix'),('*          A, in the same storage format as A (see AB).  If EQUED = \'Y\','),('*          then AFB is the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFB is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T.'),('*'),('*          If FACT = \'E\', then AFB is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T of the equilibrated'),('*          matrix A (see the description of A for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAFB   (input) INTEGER'),('*          The leading dimension of the array AFB.  LDAFB >= KD+1.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) REAL array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) REAL array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) REAL array, dimension (3*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  N = 6, KD = 2, and UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11  a12  a13'),('*          a22  a23  a24'),('*               a33  a34  a35'),('*                    a44  a45  a46'),('*                         a55  a56'),('*     (aij=conjg(aji))         a66'),('*'),('*  Band storage of the upper triangle of A:'),('*'),('*      *    *   a13  a24  a35  a46'),('*      *   a12  a23  a34  a45  a56'),('*     a11  a22  a33  a44  a55  a66'),('*'),('*  Similarly, if UPLO = \'L\' the format of A is as follows:'),('*'),('*     a11  a22  a33  a44  a55  a66'),('*     a21  a32  a43  a54  a65   *'),('*     a31  a42  a53  a64   *    *'),('*'),('*  Array elements marked * are not used by the routine.'),('*');
/*!40000 ALTER TABLE `spbsvx_Table61` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sposv_Table17`
--

DROP TABLE IF EXISTS `sposv_Table17`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sposv_Table17` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sposv_Table17`
--

LOCK TABLES `sposv_Table17` WRITE;
/*!40000 ALTER TABLE `sposv_Table17` DISABLE KEYS */;
INSERT INTO `sposv_Table17` VALUES ('      SUBROUTINE SPOSV( UPLO, N, NRHS, A, LDA, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDA, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               A( LDA, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SPOSV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite matrix and X and B'),('*  are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**T* U,  if UPLO = \'U\', or'),('*     A = L * L**T,  if UPLO = \'L\','),('*  where U is an upper triangular matrix and L is a lower triangular'),('*  matrix.  The factored form of A is then used to solve the system of'),('*  equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.'),('*'),('*          On exit, if INFO = 0, the factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*');
/*!40000 ALTER TABLE `sposv_Table17` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sposvx_Table57`
--

DROP TABLE IF EXISTS `sposvx_Table57`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sposvx_Table57` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sposvx_Table57`
--

LOCK TABLES `sposvx_Table57` WRITE;
/*!40000 ALTER TABLE `sposvx_Table57` DISABLE KEYS */;
INSERT INTO `sposvx_Table57` VALUES ('      SUBROUTINE SPOSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, EQUED,'),('     $                   S, B, LDB, X, LDX, RCOND, FERR, BERR, WORK,'),('     $                   IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   BERR( * ), FERR( * ), S( * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to'),('*  compute the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite matrix and X and B'),('*  are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U**T* U,  if UPLO = \'U\', or'),('*        A = L * L**T,  if UPLO = \'L\','),('*     where U is an upper triangular matrix and L is a lower triangular'),('*     matrix.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AF contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  A and AF will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AF and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the symmetric matrix A, except if FACT = \'F\' and'),('*          EQUED = \'Y\', then A must contain the equilibrated matrix'),('*          diag(S)*A*diag(S).  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.  A is not modified if'),('*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) REAL array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T, in the same storage'),('*          format as A.  If EQUED .ne. \'N\', then AF is the factored form'),('*          of the equilibrated matrix diag(S)*A*diag(S).'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T of the original'),('*          matrix A.'),('*'),('*          If FACT = \'E\', then AF is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T of the equilibrated'),('*          matrix A (see the description of A for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) REAL array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) REAL array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) REAL array, dimension (3*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `sposvx_Table57` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sppsv_Table25`
--

DROP TABLE IF EXISTS `sppsv_Table25`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sppsv_Table25` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sppsv_Table25`
--

LOCK TABLES `sppsv_Table25` WRITE;
/*!40000 ALTER TABLE `sppsv_Table25` DISABLE KEYS */;
INSERT INTO `sppsv_Table25` VALUES ('      SUBROUTINE SPPSV( UPLO, N, NRHS, AP, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               AP( * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SPPSV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite matrix stored in'),('*  packed format and X and B are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**T* U,  if UPLO = \'U\', or'),('*     A = L * L**T,  if UPLO = \'L\','),('*  where U is an upper triangular matrix and L is a lower triangular'),('*  matrix.  The factored form of A is then used to solve the system of'),('*  equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.  '),('*'),('*          On exit, if INFO = 0, the factor U or L from the Cholesky'),('*          factorization A = U**T*U or A = L*L**T, in the same storage'),('*          format as A.'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `sppsv_Table25` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sppsvx_Table65`
--

DROP TABLE IF EXISTS `sppsvx_Table65`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sppsvx_Table65` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sppsvx_Table65`
--

LOCK TABLES `sppsvx_Table65` WRITE;
/*!40000 ALTER TABLE `sppsvx_Table65` DISABLE KEYS */;
INSERT INTO `sppsvx_Table65` VALUES ('      SUBROUTINE SPPSVX( FACT, UPLO, N, NRHS, AP, AFP, EQUED, S, B, LDB,'),('     $                   X, LDX, RCOND, FERR, BERR, WORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               AFP( * ), AP( * ), B( LDB, * ), BERR( * ),'),('     $                   FERR( * ), S( * ), WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to'),('*  compute the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric positive definite matrix stored in'),('*  packed format and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U**T* U,  if UPLO = \'U\', or'),('*        A = L * L**T,  if UPLO = \'L\','),('*     where U is an upper triangular matrix and L is a lower triangular'),('*     matrix.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFP contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  AP and AFP will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AFP and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFP and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array, except if FACT = \'F\''),('*          and EQUED = \'Y\', then A must contain the equilibrated matrix'),('*          diag(S)*A*diag(S).  The j-th column of A is stored in the'),('*          array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.  A is not modified if'),('*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  AFP     (input or output) REAL array, dimension'),('*                            (N*(N+1)/2)'),('*          If FACT = \'F\', then AFP is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U\'*U or A = L*L\', in the same storage'),('*          format as A.  If EQUED .ne. \'N\', then AFP is the factored'),('*          form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFP is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U\'*U or A = L*L\' of the original matrix A.'),('*'),('*          If FACT = \'E\', then AFP is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U\'*U or A = L*L\' of the equilibrated'),('*          matrix A (see the description of AP for the form of the'),('*          equilibrated matrix).'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) REAL array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) REAL array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) REAL array, dimension (3*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `sppsvx_Table65` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sptsv_Table29`
--

DROP TABLE IF EXISTS `sptsv_Table29`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sptsv_Table29` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sptsv_Table29`
--

LOCK TABLES `sptsv_Table29` WRITE;
/*!40000 ALTER TABLE `sptsv_Table29` DISABLE KEYS */;
INSERT INTO `sptsv_Table29` VALUES ('      SUBROUTINE SPTSV( N, NRHS, D, E, B, LDB, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               B( LDB, * ), D( * ), E( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SPTSV computes the solution to a real system of linear equations'),('*  A*X = B, where A is an N-by-N symmetric positive definite tridiagonal'),('*  matrix, and X and B are N-by-NRHS matrices.'),('*'),('*  A is factored as A = L*D*L**T, and the factored form of A is then'),('*  used to solve the system of equations.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  D       (input/output) REAL array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.  On exit, the n diagonal elements of the diagonal matrix'),('*          D from the factorization A = L*D*L**T.'),('*'),('*  E       (input/output) REAL array, dimension (N-1)'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A.  On exit, the (n-1) subdiagonal elements of the'),('*          unit bidiagonal factor L from the L*D*L**T factorization of'),('*          A.  (E can also be regarded as the superdiagonal of the unit'),('*          bidiagonal factor U from the U**T*D*U factorization of A.)'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i is not'),('*                positive definite, and the solution has not been'),('*                computed.  The factorization has not been completed'),('*                unless i = N.'),('*');
/*!40000 ALTER TABLE `sptsv_Table29` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sptsvx_Table69`
--

DROP TABLE IF EXISTS `sptsvx_Table69`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sptsvx_Table69` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sptsvx_Table69`
--

LOCK TABLES `sptsvx_Table69` WRITE;
/*!40000 ALTER TABLE `sptsvx_Table69` DISABLE KEYS */;
INSERT INTO `sptsvx_Table69` VALUES ('      SUBROUTINE SPTSVX( FACT, N, NRHS, D, E, DF, EF, B, LDB, X, LDX,'),('     $                   RCOND, FERR, BERR, WORK, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               B( LDB, * ), BERR( * ), D( * ), DF( * ),'),('     $                   E( * ), EF( * ), FERR( * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SPTSVX uses the factorization A = L*D*L**T to compute the solution'),('*  to a real system of linear equations A*X = B, where A is an N-by-N'),('*  symmetric positive definite tridiagonal matrix and X and B are'),('*  N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the matrix A is factored as A = L*D*L**T, where L'),('*     is a unit lower bidiagonal matrix and D is diagonal.  The'),('*     factorization can also be regarded as having the form'),('*     A = U**T*D*U.'),('*'),('*  2. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, DF and EF contain the factored form of A.'),('*                  D, E, DF, and EF will not be modified.'),('*          = \'N\':  The matrix A will be copied to DF and EF and'),('*                  factored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  D       (input) REAL array, dimension (N)'),('*          The n diagonal elements of the tridiagonal matrix A.'),('*'),('*  E       (input) REAL array, dimension (N-1)'),('*          The (n-1) subdiagonal elements of the tridiagonal matrix A.'),('*'),('*  DF      (input or output) REAL array, dimension (N)'),('*          If FACT = \'F\', then DF is an input argument and on entry'),('*          contains the n diagonal elements of the diagonal matrix D'),('*          from the L*D*L**T factorization of A.'),('*          If FACT = \'N\', then DF is an output argument and on exit'),('*          contains the n diagonal elements of the diagonal matrix D'),('*          from the L*D*L**T factorization of A.'),('*'),('*  EF      (input or output) REAL array, dimension (N-1)'),('*          If FACT = \'F\', then EF is an input argument and on entry'),('*          contains the (n-1) subdiagonal elements of the unit'),('*          bidiagonal factor L from the L*D*L**T factorization of A.'),('*          If FACT = \'N\', then EF is an output argument and on exit'),('*          contains the (n-1) subdiagonal elements of the unit'),('*          bidiagonal factor L from the L*D*L**T factorization of A.'),('*'),('*  B       (input) REAL array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) REAL array, dimension (LDX,NRHS)'),('*          If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The reciprocal condition number of the matrix A.  If RCOND'),('*          is less than the machine precision (in particular, if'),('*          RCOND = 0), the matrix is singular to working precision.'),('*          This condition is indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in any'),('*          element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) REAL array, dimension (2*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `sptsvx_Table69` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssbev_Table113`
--

DROP TABLE IF EXISTS `ssbev_Table113`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssbev_Table113` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssbev_Table113`
--

LOCK TABLES `ssbev_Table113` WRITE;
/*!40000 ALTER TABLE `ssbev_Table113` DISABLE KEYS */;
INSERT INTO `ssbev_Table113` VALUES ('      SUBROUTINE SSBEV( JOBZ, UPLO, N, KD, AB, LDAB, W, Z, LDZ, WORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KD, LDAB, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               AB( LDAB, * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSBEV computes all the eigenvalues and, optionally, eigenvectors of'),('*  a real symmetric band matrix A.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) REAL array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the first'),('*          superdiagonal and the diagonal of the tridiagonal matrix T'),('*          are returned in rows KD and KD+1 of AB, and if UPLO = \'L\','),('*          the diagonal and first subdiagonal of T are returned in the'),('*          first two rows of AB.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) REAL array, dimension (max(1,3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `ssbev_Table113` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssbevd_Table141`
--

DROP TABLE IF EXISTS `ssbevd_Table141`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssbevd_Table141` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssbevd_Table141`
--

LOCK TABLES `ssbevd_Table141` WRITE;
/*!40000 ALTER TABLE `ssbevd_Table141` DISABLE KEYS */;
INSERT INTO `ssbevd_Table141` VALUES ('      SUBROUTINE SSBEVD( JOBZ, UPLO, N, KD, AB, LDAB, W, Z, LDZ, WORK,'),('     $                   LWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KD, LDAB, LDZ, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               AB( LDAB, * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSBEVD computes all the eigenvalues and, optionally, eigenvectors of'),('*  a real symmetric band matrix A. If eigenvectors are desired, it uses'),('*  a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) REAL array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the first'),('*          superdiagonal and the diagonal of the tridiagonal matrix T'),('*          are returned in rows KD and KD+1 of AB, and if UPLO = \'L\','),('*          the diagonal and first subdiagonal of T are returned in the'),('*          first two rows of AB.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) REAL array,'),('*                                         dimension (LWORK)'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          IF N <= 1,                LWORK must be at least 1.'),('*          If JOBZ  = \'N\' and N > 2, LWORK must be at least 2*N.'),('*          If JOBZ  = \'V\' and N > 2, LWORK must be at least'),('*                         ( 1 + 5*N + 2*N**2 ).'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array LIWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 2, LIWORK must be at least 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `ssbevd_Table141` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssbevx_Table127`
--

DROP TABLE IF EXISTS `ssbevx_Table127`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssbevx_Table127` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssbevx_Table127`
--

LOCK TABLES `ssbevx_Table127` WRITE;
/*!40000 ALTER TABLE `ssbevx_Table127` DISABLE KEYS */;
INSERT INTO `ssbevx_Table127` VALUES ('      SUBROUTINE SSBEVX( JOBZ, RANGE, UPLO, N, KD, AB, LDAB, Q, LDQ, VL,'),('     $                   VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK, IWORK,'),('     $                   IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, KD, LDAB, LDQ, LDZ, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               AB( LDAB, * ), Q( LDQ, * ), W( * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSBEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric band matrix A.  Eigenvalues and eigenvectors can'),('*  be selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) REAL array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the first'),('*          superdiagonal and the diagonal of the tridiagonal matrix T'),('*          are returned in rows KD and KD+1 of AB, and if UPLO = \'L\','),('*          the diagonal and first subdiagonal of T are returned in the'),('*          first two rows of AB.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  Q       (output) REAL array, dimension (LDQ, N)'),('*          If JOBZ = \'V\', the N-by-N orthogonal matrix used in the'),('*                         reduction to tridiagonal form.'),('*          If JOBZ = \'N\', the array Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q.  If JOBZ = \'V\', then'),('*          LDQ >= max(1,N).'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AB to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) REAL array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `ssbevx_Table127` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssbgv_Table161`
--

DROP TABLE IF EXISTS `ssbgv_Table161`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssbgv_Table161` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssbgv_Table161`
--

LOCK TABLES `ssbgv_Table161` WRITE;
/*!40000 ALTER TABLE `ssbgv_Table161` DISABLE KEYS */;
INSERT INTO `ssbgv_Table161` VALUES ('      SUBROUTINE SSBGV( JOBZ, UPLO, N, KA, KB, AB, LDAB, BB, LDBB, W, Z,'),('     $                  LDZ, WORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KA, KB, LDAB, LDBB, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               AB( LDAB, * ), BB( LDBB, * ), W( * ),'),('     $                   WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSBGV computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a real generalized symmetric-definite banded eigenproblem, of'),('*  the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric'),('*  and banded, and B is also positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KB >= 0.'),('*'),('*  AB      (input/output) REAL array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) REAL array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**T*S, as returned by SPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i). The eigenvectors are'),('*          normalized so that Z**T*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= N.'),('*'),('*  WORK    (workspace) REAL array, dimension (3*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is:'),('*             <= N:  the algorithm failed to converge:'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then SPBSTF'),('*                    returned INFO = i: B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `ssbgv_Table161` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssbgvd_Table185`
--

DROP TABLE IF EXISTS `ssbgvd_Table185`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssbgvd_Table185` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssbgvd_Table185`
--

LOCK TABLES `ssbgvd_Table185` WRITE;
/*!40000 ALTER TABLE `ssbgvd_Table185` DISABLE KEYS */;
INSERT INTO `ssbgvd_Table185` VALUES ('      SUBROUTINE SSBGVD( JOBZ, UPLO, N, KA, KB, AB, LDAB, BB, LDBB, W,'),('     $                   Z, LDZ, WORK, LWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KA, KB, LDAB, LDBB, LDZ, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               AB( LDAB, * ), BB( LDBB, * ), W( * ),'),('     $                   WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSBGVD computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a real generalized symmetric-definite banded eigenproblem, of the'),('*  form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and'),('*  banded, and B is also positive definite.  If eigenvectors are'),('*  desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KB >= 0.'),('*'),('*  AB      (input/output) REAL array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) REAL array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**T*S, as returned by SPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i).  The eigenvectors are'),('*          normalized so Z**T*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK >= 3*N.'),('*          If JOBZ = \'V\' and N > 1, LWORK >= 1 + 5*N + 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if LIWORK > 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK >= 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is:'),('*             <= N:  the algorithm failed to converge:'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then SPBSTF'),('*                    returned INFO = i: B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `ssbgvd_Table185` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssbgvx_Table173`
--

DROP TABLE IF EXISTS `ssbgvx_Table173`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssbgvx_Table173` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssbgvx_Table173`
--

LOCK TABLES `ssbgvx_Table173` WRITE;
/*!40000 ALTER TABLE `ssbgvx_Table173` DISABLE KEYS */;
INSERT INTO `ssbgvx_Table173` VALUES ('      SUBROUTINE SSBGVX( JOBZ, RANGE, UPLO, N, KA, KB, AB, LDAB, BB,'),('     $                   LDBB, Q, LDQ, VL, VU, IL, IU, ABSTOL, M, W, Z,'),('     $                   LDZ, WORK, IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, KA, KB, LDAB, LDBB, LDQ, LDZ, M,'),('     $                   N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               AB( LDAB, * ), BB( LDBB, * ), Q( LDQ, * ),'),('     $                   W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSBGVX computes selected eigenvalues, and optionally, eigenvectors'),('*  of a real generalized symmetric-definite banded eigenproblem, of'),('*  the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric'),('*  and banded, and B is also positive definite.  Eigenvalues and'),('*  eigenvectors can be selected by specifying either all eigenvalues,'),('*  a range of values or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KB >= 0.'),('*'),('*  AB      (input/output) REAL array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) REAL array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the symmetric band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(ka+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**T*S, as returned by SPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  Q       (output) REAL array, dimension (LDQ, N)'),('*          If JOBZ = \'V\', the n-by-n matrix used in the reduction of'),('*          A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,'),('*          and consequently C to tridiagonal form.'),('*          If JOBZ = \'N\', the array Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q.  If JOBZ = \'N\','),('*          LDQ >= 1. If JOBZ = \'V\', LDQ >= max(1,N).'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i).  The eigenvectors are'),('*          normalized so Z**T*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (7N)'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (5N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (M)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvalues that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0 : successful exit'),('*          < 0 : if INFO = -i, the i-th argument had an illegal value'),('*          <= N: if INFO = i, then i eigenvectors failed to converge.'),('*                  Their indices are stored in IFAIL.'),('*          > N : SPBSTF returned an error code; i.e.,'),('*                if INFO = N + i, for 1 <= i <= N, then the leading'),('*                minor of order i of B is not positive definite.'),('*                The factorization of B could not be completed and'),('*                no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `ssbgvx_Table173` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sspev_Table115`
--

DROP TABLE IF EXISTS `sspev_Table115`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sspev_Table115` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sspev_Table115`
--

LOCK TABLES `sspev_Table115` WRITE;
/*!40000 ALTER TABLE `sspev_Table115` DISABLE KEYS */;
INSERT INTO `sspev_Table115` VALUES ('      SUBROUTINE SSPEV( JOBZ, UPLO, N, AP, W, Z, LDZ, WORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               AP( * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSPEV computes all the eigenvalues and, optionally, eigenvectors of a'),('*  real symmetric matrix A in packed storage.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) REAL array, dimension (3*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `sspev_Table115` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sspevd_Table143`
--

DROP TABLE IF EXISTS `sspevd_Table143`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sspevd_Table143` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sspevd_Table143`
--

LOCK TABLES `sspevd_Table143` WRITE;
/*!40000 ALTER TABLE `sspevd_Table143` DISABLE KEYS */;
INSERT INTO `sspevd_Table143` VALUES ('      SUBROUTINE SSPEVD( JOBZ, UPLO, N, AP, W, Z, LDZ, WORK, LWORK,'),('     $                   IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDZ, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               AP( * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSPEVD computes all the eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric matrix A in packed storage. If eigenvectors are'),('*  desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the required LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK must be at least 2*N.'),('*          If JOBZ = \'V\' and N > 1, LWORK must be at least'),('*                                                 1 + 6*N + N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the required sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the required LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK must be at least 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `sspevd_Table143` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sspevx_Table129`
--

DROP TABLE IF EXISTS `sspevx_Table129`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sspevx_Table129` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sspevx_Table129`
--

LOCK TABLES `sspevx_Table129` WRITE;
/*!40000 ALTER TABLE `sspevx_Table129` DISABLE KEYS */;
INSERT INTO `sspevx_Table129` VALUES ('      SUBROUTINE SSPEVX( JOBZ, RANGE, UPLO, N, AP, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, WORK, IWORK, IFAIL,'),('     $                   INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDZ, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               AP( * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSPEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric matrix A in packed storage.  Eigenvalues/vectors'),('*  can be selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AP to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the selected eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) REAL array, dimension (8*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `sspevx_Table129` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sspgv_Table163`
--

DROP TABLE IF EXISTS `sspgv_Table163`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sspgv_Table163` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sspgv_Table163`
--

LOCK TABLES `sspgv_Table163` WRITE;
/*!40000 ALTER TABLE `sspgv_Table163` DISABLE KEYS */;
INSERT INTO `sspgv_Table163` VALUES ('      SUBROUTINE SSPGV( ITYPE, JOBZ, UPLO, N, AP, BP, W, Z, LDZ, WORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               AP( * ), BP( * ), W( * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSPGV computes all the eigenvalues and, optionally, the eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.'),('*  Here A and B are assumed to be symmetric, stored in packed format,'),('*  and B is also positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  AP      (input/output) REAL array, dimension'),('*                            (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T, in the same storage'),('*          format as B.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors.  The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) REAL array, dimension (3*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  SPPTRF or SSPEV returned an error code:'),('*             <= N:  if INFO = i, SSPEV failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero.'),('*             > N:   if INFO = n + i, for 1 <= i <= n, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `sspgv_Table163` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sspgvd_Table187`
--

DROP TABLE IF EXISTS `sspgvd_Table187`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sspgvd_Table187` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sspgvd_Table187`
--

LOCK TABLES `sspgvd_Table187` WRITE;
/*!40000 ALTER TABLE `sspgvd_Table187` DISABLE KEYS */;
INSERT INTO `sspgvd_Table187` VALUES ('      SUBROUTINE SSPGVD( ITYPE, JOBZ, UPLO, N, AP, BP, W, Z, LDZ, WORK,'),('     $                   LWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDZ, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               AP( * ), BP( * ), W( * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSPGVD computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be symmetric, stored in packed format, and B is also'),('*  positive definite.'),('*  If eigenvectors are desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  AP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T, in the same storage'),('*          format as B.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors.  The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the required LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK >= 2*N.'),('*          If JOBZ = \'V\' and N > 1, LWORK >= 1 + 6*N + 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the required sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the required LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK >= 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  SPPTRF or SSPEVD returned an error code:'),('*             <= N:  if INFO = i, SSPEVD failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `sspgvd_Table187` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sspgvx_Table175`
--

DROP TABLE IF EXISTS `sspgvx_Table175`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sspgvx_Table175` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sspgvx_Table175`
--

LOCK TABLES `sspgvx_Table175` WRITE;
/*!40000 ALTER TABLE `sspgvx_Table175` DISABLE KEYS */;
INSERT INTO `sspgvx_Table175` VALUES ('      SUBROUTINE SSPGVX( ITYPE, JOBZ, RANGE, UPLO, N, AP, BP, VL, VU,'),('     $                   IL, IU, ABSTOL, M, W, Z, LDZ, WORK, IWORK,'),('     $                   IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, ITYPE, IU, LDZ, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               AP( * ), BP( * ), W( * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSPGVX computes selected eigenvalues, and optionally, eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A'),('*  and B are assumed to be symmetric, stored in packed storage, and B'),('*  is also positive definite.  Eigenvalues and eigenvectors can be'),('*  selected by specifying either a range of values or a range of indices'),('*  for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A and B are stored;'),('*          = \'L\':  Lower triangle of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix pencil (A,B).  N >= 0.'),('*'),('*  AP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T, in the same storage'),('*          format as B.'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          On normal exit, the first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) REAL array, dimension (8*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  SPPTRF or SSPEVX returned an error code:'),('*             <= N:  if INFO = i, SSPEVX failed to converge;'),('*                    i eigenvectors failed to converge.  Their indices'),('*                    are stored in array IFAIL.'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `sspgvx_Table175` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sspsv_Table37`
--

DROP TABLE IF EXISTS `sspsv_Table37`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sspsv_Table37` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sspsv_Table37`
--

LOCK TABLES `sspsv_Table37` WRITE;
/*!40000 ALTER TABLE `sspsv_Table37` DISABLE KEYS */;
INSERT INTO `sspsv_Table37` VALUES ('      SUBROUTINE SSPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               AP( * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSPSV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric matrix stored in packed format and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**T,  if UPLO = \'U\', or'),('*     A = L * D * L**T,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, D is symmetric and block diagonal with 1-by-1'),('*  and 2-by-2 diagonal blocks.  The factored form of A is then used to'),('*  solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AP      (input/output) REAL array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*          On exit, the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by SSPTRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization'),('*                has been completed, but the block diagonal matrix D is'),('*                exactly singular, so the solution could not be'),('*                computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = aji)'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `sspsv_Table37` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sspsvx_Table77`
--

DROP TABLE IF EXISTS `sspsvx_Table77`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sspsvx_Table77` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sspsvx_Table77`
--

LOCK TABLES `sspsvx_Table77` WRITE;
/*!40000 ALTER TABLE `sspsvx_Table77` DISABLE KEYS */;
INSERT INTO `sspsvx_Table77` VALUES ('      SUBROUTINE SSPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,'),('     $                   LDX, RCOND, FERR, BERR, WORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * ), IWORK( * )'),('      REAL               AFP( * ), AP( * ), B( LDB, * ), BERR( * ),'),('     $                   FERR( * ), WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSPSVX uses the diagonal pivoting factorization A = U*D*U**T or'),('*  A = L*D*L**T to compute the solution to a real system of linear'),('*  equations A * X = B, where A is an N-by-N symmetric matrix stored'),('*  in packed format and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as'),('*        A = U * D * U**T,  if UPLO = \'U\', or'),('*        A = L * D * L**T,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices and D is symmetric and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AFP and IPIV contain the factored form of'),('*                  A.  AP, AFP and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AFP and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AP      (input) REAL array, dimension (N*(N+1)/2)'),('*          The upper or lower triangle of the symmetric matrix A, packed'),('*          columnwise in a linear array.  The j-th column of A is stored'),('*          in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*  AFP     (input or output) REAL array, dimension'),('*                            (N*(N+1)/2)'),('*          If FACT = \'F\', then AFP is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*          If FACT = \'N\', then AFP is an output argument and on exit'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by SSPTRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by SSPTRF.'),('*'),('*  B       (input) REAL array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) REAL array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) REAL array, dimension (3*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = aji)'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `sspsvx_Table77` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sstev_Table117`
--

DROP TABLE IF EXISTS `sstev_Table117`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sstev_Table117` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sstev_Table117`
--

LOCK TABLES `sstev_Table117` WRITE;
/*!40000 ALTER TABLE `sstev_Table117` DISABLE KEYS */;
INSERT INTO `sstev_Table117` VALUES ('      SUBROUTINE SSTEV( JOBZ, N, D, E, Z, LDZ, WORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ'),('      INTEGER            INFO, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               D( * ), E( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSTEV computes all eigenvalues and, optionally, eigenvectors of a'),('*  real symmetric tridiagonal matrix A.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix.  N >= 0.'),('*'),('*  D       (input/output) REAL array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.'),('*          On exit, if INFO = 0, the eigenvalues in ascending order.'),('*'),('*  E       (input/output) REAL array, dimension (N-1)'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A, stored in elements 1 to N-1 of E.'),('*          On exit, the contents of E are destroyed.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with D(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) REAL array, dimension (max(1,2*N-2))'),('*          If JOBZ = \'N\', WORK is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of E did not converge to zero.'),('*');
/*!40000 ALTER TABLE `sstev_Table117` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sstevd_Table145`
--

DROP TABLE IF EXISTS `sstevd_Table145`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sstevd_Table145` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sstevd_Table145`
--

LOCK TABLES `sstevd_Table145` WRITE;
/*!40000 ALTER TABLE `sstevd_Table145` DISABLE KEYS */;
INSERT INTO `sstevd_Table145` VALUES ('      SUBROUTINE SSTEVD( JOBZ, N, D, E, Z, LDZ, WORK, LWORK, IWORK,'),('     $                   LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ'),('      INTEGER            INFO, LDZ, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               D( * ), E( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSTEVD computes all eigenvalues and, optionally, eigenvectors of a'),('*  real symmetric tridiagonal matrix. If eigenvectors are desired, it'),('*  uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix.  N >= 0.'),('*'),('*  D       (input/output) REAL array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.'),('*          On exit, if INFO = 0, the eigenvalues in ascending order.'),('*'),('*  E       (input/output) REAL array, dimension (N-1)'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A, stored in elements 1 to N-1 of E.'),('*          On exit, the contents of E are destroyed.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with D(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) REAL array,'),('*                                         dimension (LWORK)'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If JOBZ  = \'N\' or N <= 1 then LWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1 then LWORK must be at least'),('*                         ( 1 + 4*N + N**2 ).'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1 then LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1 then LIWORK must be at least 3+5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of E did not converge to zero.'),('*');
/*!40000 ALTER TABLE `sstevd_Table145` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sstevr_Table151`
--

DROP TABLE IF EXISTS `sstevr_Table151`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sstevr_Table151` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sstevr_Table151`
--

LOCK TABLES `sstevr_Table151` WRITE;
/*!40000 ALTER TABLE `sstevr_Table151` DISABLE KEYS */;
INSERT INTO `sstevr_Table151` VALUES ('      SUBROUTINE SSTEVR( JOBZ, RANGE, N, D, E, VL, VU, IL, IU, ABSTOL,'),('     $                   M, W, Z, LDZ, ISUPPZ, WORK, LWORK, IWORK,'),('     $                   LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE'),('      INTEGER            IL, INFO, IU, LDZ, LIWORK, LWORK, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            ISUPPZ( * ), IWORK( * )'),('      REAL               D( * ), E( * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSTEVR computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric tridiagonal matrix T.  Eigenvalues and'),('*  eigenvectors can be selected by specifying either a range of values'),('*  or a range of indices for the desired eigenvalues.'),('*'),('*  Whenever possible, SSTEVR calls SSTEMR to compute the'),('*  eigenspectrum using Relatively Robust Representations.  SSTEMR'),('*  computes eigenvalues by the dqds algorithm, while orthogonal'),('*  eigenvectors are computed from various \"good\" L D L^T representations'),('*  (also known as Relatively Robust Representations). Gram-Schmidt'),('*  orthogonalization is avoided as far as possible. More specifically,'),('*  the various steps of the algorithm are as follows. For the i-th'),('*  unreduced block of T,'),('*     (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T'),('*          is a relatively robust representation,'),('*     (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high'),('*         relative accuracy by the dqds algorithm,'),('*     (c) If there is a cluster of close eigenvalues, \"choose\" sigma_i'),('*         close to the cluster, and go to step (a),'),('*     (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,'),('*         compute the corresponding eigenvector by forming a'),('*         rank-revealing twisted factorization.'),('*  The desired accuracy of the output can be specified by the input'),('*  parameter ABSTOL.'),('*'),('*  For more details, see \"A new O(n^2) algorithm for the symmetric'),('*  tridiagonal eigenvalue/eigenvector problem\", by Inderjit Dhillon,'),('*  Computer Science Division Technical Report No. UCB//CSD-97-971,'),('*  UC Berkeley, May 1997.'),('*'),('*'),('*  Note 1 : SSTEVR calls SSTEMR when the full spectrum is requested'),('*  on machines which conform to the ieee-754 floating point standard.'),('*  SSTEVR calls SSTEBZ and SSTEIN on non-ieee machines and'),('*  when partial spectrum requests are made.'),('*'),('*  Normal execution of SSTEMR may create NaNs and infinities and'),('*  hence may abort due to a floating point exception in environments'),('*  which do not handle NaNs and infinities in the ieee standard default'),('*  manner.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('********** For RANGE = \'V\' or \'I\' and IU - IL < N - 1, SSTEBZ and'),('********** SSTEIN are called'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix.  N >= 0.'),('*'),('*  D       (input/output) REAL array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.'),('*          On exit, D may be multiplied by a constant factor chosen'),('*          to avoid over/underflow in computing the eigenvalues.'),('*'),('*  E       (input/output) REAL array, dimension (max(1,N-1))'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A in elements 1 to N-1 of E.'),('*          On exit, E may be multiplied by a constant factor chosen'),('*          to avoid over/underflow in computing the eigenvalues.'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*          If high relative accuracy is important, set ABSTOL to'),('*          SLAMCH( \'Safe minimum\' ).  Doing so will guarantee that'),('*          eigenvalues are computed to high relative accuracy when'),('*          possible in future releases.  The current code does not'),('*          make any guarantees about high relative accuracy, but'),('*          future releases will. See J. Barlow and J. Demmel,'),('*          \"Computing Accurate Eigensystems of Scaled Diagonally'),('*          Dominant Matrices\", LAPACK Working Note #7, for a discussion'),('*          of which matrices define their eigenvalues to high relative'),('*          accuracy.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, max(1,M) )'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  ISUPPZ  (output) INTEGER array, dimension ( 2*max(1,M) )'),('*          The support of the eigenvectors in Z, i.e., the indices'),('*          indicating the nonzero elements in Z. The i-th eigenvector'),('*          is nonzero only in elements ISUPPZ( 2*i-1 ) through'),('*          ISUPPZ( 2*i ).'),('********** Implemented only for RANGE = \'A\' or \'I\' and IU - IL = N - 1'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal (and'),('*          minimal) LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= 20*N.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal (and'),('*          minimal) LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.  LIWORK >= 10*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  Internal error'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Inderjit Dhillon, IBM Almaden, USA'),('*     Osni Marques, LBNL/NERSC, USA'),('*     Ken Stanley, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*     Jason Riedy, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `sstevr_Table151` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sstevx_Table131`
--

DROP TABLE IF EXISTS `sstevx_Table131`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `sstevx_Table131` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sstevx_Table131`
--

LOCK TABLES `sstevx_Table131` WRITE;
/*!40000 ALTER TABLE `sstevx_Table131` DISABLE KEYS */;
INSERT INTO `sstevx_Table131` VALUES ('      SUBROUTINE SSTEVX( JOBZ, RANGE, N, D, E, VL, VU, IL, IU, ABSTOL,'),('     $                   M, W, Z, LDZ, WORK, IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE'),('      INTEGER            IL, INFO, IU, LDZ, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               D( * ), E( * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSTEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric tridiagonal matrix A.  Eigenvalues and'),('*  eigenvectors can be selected by specifying either a range of values'),('*  or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix.  N >= 0.'),('*'),('*  D       (input/output) REAL array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.'),('*          On exit, D may be multiplied by a constant factor chosen'),('*          to avoid over/underflow in computing the eigenvalues.'),('*'),('*  E       (input/output) REAL array, dimension (max(1,N-1))'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A in elements 1 to N-1 of E.'),('*          On exit, E may be multiplied by a constant factor chosen'),('*          to avoid over/underflow in computing the eigenvalues.'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less'),('*          than or equal to zero, then  EPS*|T|  will be used in'),('*          its place, where |T| is the 1-norm of the tridiagonal'),('*          matrix.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, max(1,M) )'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge (INFO > 0), then that'),('*          column of Z contains the latest approximation to the'),('*          eigenvector, and the index of the eigenvector is returned'),('*          in IFAIL.  If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) REAL array, dimension (5*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `sstevx_Table131` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssyev_Table111`
--

DROP TABLE IF EXISTS `ssyev_Table111`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssyev_Table111` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssyev_Table111`
--

LOCK TABLES `ssyev_Table111` WRITE;
/*!40000 ALTER TABLE `ssyev_Table111` DISABLE KEYS */;
INSERT INTO `ssyev_Table111` VALUES ('      SUBROUTINE SSYEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDA, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               A( LDA, * ), W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSYEV computes all eigenvalues and, optionally, eigenvectors of a'),('*  real symmetric matrix A.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          orthonormal eigenvectors of the matrix A.'),('*          If JOBZ = \'N\', then on exit the lower triangle (if UPLO=\'L\')'),('*          or the upper triangle (if UPLO=\'U\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,3*N-1).'),('*          For optimal efficiency, LWORK >= (NB+2)*N,'),('*          where NB is the blocksize for SSYTRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `ssyev_Table111` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssyevd_Table139`
--

DROP TABLE IF EXISTS `ssyevd_Table139`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssyevd_Table139` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssyevd_Table139`
--

LOCK TABLES `ssyevd_Table139` WRITE;
/*!40000 ALTER TABLE `ssyevd_Table139` DISABLE KEYS */;
INSERT INTO `ssyevd_Table139` VALUES ('      SUBROUTINE SSYEVD( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, IWORK,'),('     $                   LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDA, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               A( LDA, * ), W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSYEVD computes all eigenvalues and, optionally, eigenvectors of a'),('*  real symmetric matrix A. If eigenvectors are desired, it uses a'),('*  divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Because of large use of BLAS of level 3, SSYEVD needs N**2 more'),('*  workspace than SSYEVX.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          orthonormal eigenvectors of the matrix A.'),('*          If JOBZ = \'N\', then on exit the lower triangle (if UPLO=\'L\')'),('*          or the upper triangle (if UPLO=\'U\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) REAL array,'),('*                                         dimension (LWORK)'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK must be at least 2*N+1.'),('*          If JOBZ = \'V\' and N > 1, LWORK must be at least '),('*                                                1 + 6*N + 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If N <= 1,                LIWORK must be at least 1.'),('*          If JOBZ  = \'N\' and N > 1, LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK must be at least 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i and JOBZ = \'N\', then the algorithm failed'),('*                to converge; i off-diagonal elements of an intermediate'),('*                tridiagonal form did not converge to zero;'),('*                if INFO = i and JOBZ = \'V\', then the algorithm failed'),('*                to compute an eigenvalue while working on the submatrix'),('*                lying in rows and columns INFO/(N+1) through'),('*                mod(INFO,N+1).'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Jeff Rutter, Computer Science Division, University of California'),('*     at Berkeley, USA'),('*  Modified by Francoise Tisseur, University of Tennessee.'),('*'),('*  Modified description of INFO. Sven, 16 Feb 05.');
/*!40000 ALTER TABLE `ssyevd_Table139` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssyevr_Table149`
--

DROP TABLE IF EXISTS `ssyevr_Table149`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssyevr_Table149` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssyevr_Table149`
--

LOCK TABLES `ssyevr_Table149` WRITE;
/*!40000 ALTER TABLE `ssyevr_Table149` DISABLE KEYS */;
INSERT INTO `ssyevr_Table149` VALUES ('      SUBROUTINE SSYEVR( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, ISUPPZ, WORK, LWORK,'),('     $                   IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDA, LDZ, LIWORK, LWORK, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            ISUPPZ( * ), IWORK( * )'),('      REAL               A( LDA, * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSYEVR computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric matrix A.  Eigenvalues and eigenvectors can be'),('*  selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  SSYEVR first reduces the matrix A to tridiagonal form T with a call'),('*  to SSYTRD.  Then, whenever possible, SSYEVR calls SSTEMR to compute'),('*  the eigenspectrum using Relatively Robust Representations.  SSTEMR'),('*  computes eigenvalues by the dqds algorithm, while orthogonal'),('*  eigenvectors are computed from various \"good\" L D L^T representations'),('*  (also known as Relatively Robust Representations). Gram-Schmidt'),('*  orthogonalization is avoided as far as possible. More specifically,'),('*  the various steps of the algorithm are as follows.'),('*'),('*  For each unreduced block (submatrix) of T,'),('*     (a) Compute T - sigma I  = L D L^T, so that L and D'),('*         define all the wanted eigenvalues to high relative accuracy.'),('*         This means that small relative changes in the entries of D and L'),('*         cause only small relative changes in the eigenvalues and'),('*         eigenvectors. The standard (unfactored) representation of the'),('*         tridiagonal matrix T does not have this property in general.'),('*     (b) Compute the eigenvalues to suitable accuracy.'),('*         If the eigenvectors are desired, the algorithm attains full'),('*         accuracy of the computed eigenvalues only right before'),('*         the corresponding vectors have to be computed, see steps c) and d).'),('*     (c) For each cluster of close eigenvalues, select a new'),('*         shift close to the cluster, find a new factorization, and refine'),('*         the shifted eigenvalues to suitable accuracy.'),('*     (d) For each eigenvalue with a large enough relative separation compute'),('*         the corresponding eigenvector by forming a rank revealing twisted'),('*         factorization. Go back to (c) for any clusters that remain.'),('*'),('*  The desired accuracy of the output can be specified by the input'),('*  parameter ABSTOL.'),('*'),('*  For more details, see SSTEMR\'s documentation and:'),('*  - Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations'),('*    to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"'),('*    Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.'),('*  - Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and'),('*    Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,'),('*    2004.  Also LAPACK Working Note 154.'),('*  - Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric'),('*    tridiagonal eigenvalue/eigenvector problem\",'),('*    Computer Science Division Technical Report No. UCB/CSD-97-971,'),('*    UC Berkeley, May 1997.'),('*'),('*'),('*  Note 1 : SSYEVR calls SSTEMR when the full spectrum is requested'),('*  on machines which conform to the ieee-754 floating point standard.'),('*  SSYEVR calls SSTEBZ and SSTEIN on non-ieee machines and'),('*  when partial spectrum requests are made.'),('*'),('*  Normal execution of SSTEMR may create NaNs and infinities and'),('*  hence may abort due to a floating point exception in environments'),('*  which do not handle NaNs and infinities in the ieee standard default'),('*  manner.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('********** For RANGE = \'V\' or \'I\' and IU - IL < N - 1, SSTEBZ and'),('********** SSTEIN are called'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*          If high relative accuracy is important, set ABSTOL to'),('*          SLAMCH( \'Safe minimum\' ).  Doing so will guarantee that'),('*          eigenvalues are computed to high relative accuracy when'),('*          possible in future releases.  The current code does not'),('*          make any guarantees about high relative accuracy, but'),('*          future releases will. See J. Barlow and J. Demmel,'),('*          \"Computing Accurate Eigensystems of Scaled Diagonally'),('*          Dominant Matrices\", LAPACK Working Note #7, for a discussion'),('*          of which matrices define their eigenvalues to high relative'),('*          accuracy.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*          Supplying N columns is always safe.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  ISUPPZ  (output) INTEGER array, dimension ( 2*max(1,M) )'),('*          The support of the eigenvectors in Z, i.e., the indices'),('*          indicating the nonzero elements in Z. The i-th eigenvector'),('*          is nonzero only in elements ISUPPZ( 2*i-1 ) through'),('*          ISUPPZ( 2*i ).'),('********** Implemented only for RANGE = \'A\' or \'I\' and IU - IL = N - 1'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,26*N).'),('*          For optimal efficiency, LWORK >= (NB+6)*N,'),('*          where NB is the max of the blocksize for SSYTRD and SORMTR'),('*          returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.  LIWORK >= max(1,10*N).'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  Internal error'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Inderjit Dhillon, IBM Almaden, USA'),('*     Osni Marques, LBNL/NERSC, USA'),('*     Ken Stanley, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*     Jason Riedy, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `ssyevr_Table149` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssyevx_Table125`
--

DROP TABLE IF EXISTS `ssyevx_Table125`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssyevx_Table125` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssyevx_Table125`
--

LOCK TABLES `ssyevx_Table125` WRITE;
/*!40000 ALTER TABLE `ssyevx_Table125` DISABLE KEYS */;
INSERT INTO `ssyevx_Table125` VALUES ('      SUBROUTINE SSYEVX( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, WORK, LWORK, IWORK,'),('     $                   IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDA, LDZ, LWORK, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               A( LDA, * ), W( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSYEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a real symmetric matrix A.  Eigenvalues and eigenvectors can be'),('*  selected by specifying either a range of values or a range of indices'),('*  for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*SLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          On normal exit, the first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= 1, when N <= 1;'),('*          otherwise 8*N.'),('*          For optimal efficiency, LWORK >= (NB+3)*N,'),('*          where NB is the max of the blocksize for SSYTRD and SORMTR'),('*          returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `ssyevx_Table125` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssygv_Table159`
--

DROP TABLE IF EXISTS `ssygv_Table159`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssygv_Table159` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssygv_Table159`
--

LOCK TABLES `ssygv_Table159` WRITE;
/*!40000 ALTER TABLE `ssygv_Table159` DISABLE KEYS */;
INSERT INTO `ssygv_Table159` VALUES ('      SUBROUTINE SSYGV( ITYPE, JOBZ, UPLO, N, A, LDA, B, LDB, W, WORK,'),('     $                  LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDA, LDB, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      REAL               A( LDA, * ), B( LDB, * ), W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSYGV computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.'),('*  Here A and B are assumed to be symmetric and B is also'),('*  positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          matrix Z of eigenvectors.  The eigenvectors are normalized'),('*          as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then on exit the upper triangle (if UPLO=\'U\')'),('*          or the lower triangle (if UPLO=\'L\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) REAL array, dimension (LDB, N)'),('*          On entry, the symmetric positive definite matrix B.'),('*          If UPLO = \'U\', the leading N-by-N upper triangular part of B'),('*          contains the upper triangular part of the matrix B.'),('*          If UPLO = \'L\', the leading N-by-N lower triangular part of B'),('*          contains the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,3*N-1).'),('*          For optimal efficiency, LWORK >= (NB+2)*N,'),('*          where NB is the blocksize for SSYTRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  SPOTRF or SSYEV returned an error code:'),('*             <= N:  if INFO = i, SSYEV failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `ssygv_Table159` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssygvd_Table183`
--

DROP TABLE IF EXISTS `ssygvd_Table183`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssygvd_Table183` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssygvd_Table183`
--

LOCK TABLES `ssygvd_Table183` WRITE;
/*!40000 ALTER TABLE `ssygvd_Table183` DISABLE KEYS */;
INSERT INTO `ssygvd_Table183` VALUES ('      SUBROUTINE SSYGVD( ITYPE, JOBZ, UPLO, N, A, LDA, B, LDB, W, WORK,'),('     $                   LWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDA, LDB, LIWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      REAL               A( LDA, * ), B( LDB, * ), W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSYGVD computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be symmetric and B is also positive definite.'),('*  If eigenvectors are desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          matrix Z of eigenvectors.  The eigenvectors are normalized'),('*          as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then on exit the upper triangle (if UPLO=\'U\')'),('*          or the lower triangle (if UPLO=\'L\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) REAL array, dimension (LDB, N)'),('*          On entry, the symmetric matrix B.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of B contains the'),('*          upper triangular part of the matrix B.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of B contains'),('*          the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK >= 2*N+1.'),('*          If JOBZ = \'V\' and N > 1, LWORK >= 1 + 6*N + 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK and IWORK'),('*          arrays, returns these values as the first entries of the WORK'),('*          and IWORK arrays, and no error message related to LWORK or'),('*          LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If N <= 1,                LIWORK >= 1.'),('*          If JOBZ  = \'N\' and N > 1, LIWORK >= 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK and IWORK arrays, and no error message related to'),('*          LWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  SPOTRF or SSYEVD returned an error code:'),('*             <= N:  if INFO = i and JOBZ = \'N\', then the algorithm'),('*                    failed to converge; i off-diagonal elements of an'),('*                    intermediate tridiagonal form did not converge to'),('*                    zero;'),('*                    if INFO = i and JOBZ = \'V\', then the algorithm'),('*                    failed to compute an eigenvalue while working on'),('*                    the submatrix lying in rows and columns INFO/(N+1)'),('*                    through mod(INFO,N+1);'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*'),('*  Modified so that no backsubstitution is performed if SSYEVD fails to'),('*  converge (NEIG in old code could be greater than N causing out of'),('*  bounds reference to A - reported by Ralf Meyer).  Also corrected the'),('*  description of INFO and the test on ITYPE. Sven, 16 Feb 05.');
/*!40000 ALTER TABLE `ssygvd_Table183` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssygvx_Table171`
--

DROP TABLE IF EXISTS `ssygvx_Table171`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssygvx_Table171` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssygvx_Table171`
--

LOCK TABLES `ssygvx_Table171` WRITE;
/*!40000 ALTER TABLE `ssygvx_Table171` DISABLE KEYS */;
INSERT INTO `ssygvx_Table171` VALUES ('      SUBROUTINE SSYGVX( ITYPE, JOBZ, RANGE, UPLO, N, A, LDA, B, LDB,'),('     $                   VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK,'),('     $                   LWORK, IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, ITYPE, IU, LDA, LDB, LDZ, LWORK, M, N'),('      REAL               ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      REAL               A( LDA, * ), B( LDB, * ), W( * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSYGVX computes selected eigenvalues, and optionally, eigenvectors'),('*  of a real generalized symmetric-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A'),('*  and B are assumed to be symmetric and B is also positive definite.'),('*  Eigenvalues and eigenvectors can be selected by specifying either a'),('*  range of values or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A and B are stored;'),('*          = \'L\':  Lower triangle of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix pencil (A,B).  N >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit, the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) REAL array, dimension (LDA, N)'),('*          On entry, the symmetric matrix B.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of B contains the'),('*          upper triangular part of the matrix B.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of B contains'),('*          the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**T*U or B = L*L**T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  VL      (input) REAL'),('*  VU      (input) REAL'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) REAL'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*SLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) REAL array, dimension (N)'),('*          On normal exit, the first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) REAL array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,8*N).'),('*          For optimal efficiency, LWORK >= (NB+3)*N,'),('*          where NB is the blocksize for SSYTRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  SPOTRF or SSYEVX returned an error code:'),('*             <= N:  if INFO = i, SSYEVX failed to converge;'),('*                    i eigenvectors failed to converge.  Their indices'),('*                    are stored in array IFAIL.'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `ssygvx_Table171` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssysv_Table33`
--

DROP TABLE IF EXISTS `ssysv_Table33`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssysv_Table33` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssysv_Table33`
--

LOCK TABLES `ssysv_Table33` WRITE;
/*!40000 ALTER TABLE `ssysv_Table33` DISABLE KEYS */;
INSERT INTO `ssysv_Table33` VALUES ('      SUBROUTINE SSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,'),('     $                  LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     May 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      REAL               A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSYSV computes the solution to a real system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**T,  if UPLO = \'U\', or'),('*     A = L * D * L**T,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, and D is symmetric and block diagonal with '),('*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then'),('*  used to solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) REAL array, dimension (LDA,N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.'),('*'),('*          On exit, if INFO = 0, the block diagonal matrix D and the'),('*          multipliers used to obtain the factor U or L from the'),('*          factorization A = U*D*U**T or A = L*D*L**T as computed by'),('*          SSYTRF.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by SSYTRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) REAL array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= 1, and for best performance'),('*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for'),('*          SSYTRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization'),('*               has been completed, but the block diagonal matrix D is'),('*               exactly singular, so the solution could not be computed.'),('*');
/*!40000 ALTER TABLE `ssysv_Table33` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `ssysvx_Table73`
--

DROP TABLE IF EXISTS `ssysvx_Table73`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `ssysvx_Table73` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `ssysvx_Table73`
--

LOCK TABLES `ssysvx_Table73` WRITE;
/*!40000 ALTER TABLE `ssysvx_Table73` DISABLE KEYS */;
INSERT INTO `ssysvx_Table73` VALUES ('      SUBROUTINE SSYSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,'),('     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,'),('     $                   IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS'),('      REAL               RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * ), IWORK( * )'),('      REAL               A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   BERR( * ), FERR( * ), WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  SSYSVX uses the diagonal pivoting factorization to compute the'),('*  solution to a real system of linear equations A * X = B,'),('*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.'),('*     The form of the factorization is'),('*        A = U * D * U**T,  if UPLO = \'U\', or'),('*        A = L * D * L**T,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices, and D is symmetric and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AF and IPIV contain the factored form of'),('*                  A.  AF and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input) REAL array, dimension (LDA,N)'),('*          The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N'),('*          upper triangular part of A contains the upper triangular part'),('*          of the matrix A, and the strictly lower triangular part of A'),('*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower'),('*          triangular part of A contains the lower triangular part of'),('*          the matrix A, and the strictly upper triangular part of A is'),('*          not referenced.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) REAL array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by SSYTRF.'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T.'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by SSYTRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by SSYTRF.'),('*'),('*  B       (input) REAL array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) REAL array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) REAL'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) REAL array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) REAL array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace/output) REAL array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= max(1,3*N), and for best'),('*          performance, when FACT = \'N\', LWORK >= max(1,3*N,N*NB), where'),('*          NB is the optimal blocksize for SSYTRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `ssysvx_Table73` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `users`
--

DROP TABLE IF EXISTS `users`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `users` (
  `login` varchar(8) default NULL,
  `uid` smallint(6) default NULL
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `users`
--

LOCK TABLES `users` WRITE;
/*!40000 ALTER TABLE `users` DISABLE KEYS */;
INSERT INTO `users` VALUES ('jane',7100),('bob',7200);
/*!40000 ALTER TABLE `users` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgbsv_Table8`
--

DROP TABLE IF EXISTS `zgbsv_Table8`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgbsv_Table8` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgbsv_Table8`
--

LOCK TABLES `zgbsv_Table8` WRITE;
/*!40000 ALTER TABLE `zgbsv_Table8` DISABLE KEYS */;
INSERT INTO `zgbsv_Table8` VALUES ('      SUBROUTINE ZGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX*16         AB( LDAB, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGBSV computes the solution to a complex system of linear equations'),('*  A * X = B, where A is a band matrix of order N with KL subdiagonals'),('*  and KU superdiagonals, and X and B are N-by-NRHS matrices.'),('*'),('*  The LU decomposition with partial pivoting and row interchanges is'),('*  used to factor A as A = L * U, where L is a product of permutation'),('*  and unit lower triangular matrices with KL subdiagonals, and U is'),('*  upper triangular with KL+KU superdiagonals.  The factored form of A'),('*  is then used to solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KL      (input) INTEGER'),('*          The number of subdiagonals within the band of A.  KL >= 0.'),('*'),('*  KU      (input) INTEGER'),('*          The number of superdiagonals within the band of A.  KU >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)'),('*          On entry, the matrix A in band storage, in rows KL+1 to'),('*          2*KL+KU+1; rows 1 to KL of the array need not be set.'),('*          The j-th column of A is stored in the j-th column of the'),('*          array AB as follows:'),('*          AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)'),('*          On exit, details of the factorization: U is stored as an'),('*          upper triangular band matrix with KL+KU superdiagonals in'),('*          rows 1 to KL+KU+1, and the multipliers used during the'),('*          factorization are stored in rows KL+KU+2 to 2*KL+KU+1.'),('*          See below for further details.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          The pivot indices that define the permutation matrix P;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization'),('*                has been completed, but the factor U is exactly'),('*                singular, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  M = N = 6, KL = 2, KU = 1:'),('*'),('*  On entry:                       On exit:'),('*'),('*      *    *    *    +    +    +       *    *    *   u14  u25  u36'),('*      *    *    +    +    +    +       *    *   u13  u24  u35  u46'),('*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56'),('*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66'),('*     a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *'),('*     a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *'),('*'),('*  Array elements marked * are not used by the routine; elements marked'),('*  + need not be set on entry, but are required by the routine to store'),('*  elements of U because of fill-in resulting from the row interchanges.'),('*');
/*!40000 ALTER TABLE `zgbsv_Table8` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgbsvx_Table48`
--

DROP TABLE IF EXISTS `zgbsvx_Table48`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgbsvx_Table48` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgbsvx_Table48`
--

LOCK TABLES `zgbsvx_Table48` WRITE;
/*!40000 ALTER TABLE `zgbsvx_Table48` DISABLE KEYS */;
INSERT INTO `zgbsvx_Table48` VALUES ('      SUBROUTINE ZGBSVX( FACT, TRANS, N, KL, KU, NRHS, AB, LDAB, AFB,'),('     $                   LDAFB, IPIV, EQUED, R, C, B, LDB, X, LDX,'),('     $                   RCOND, FERR, BERR, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, TRANS'),('      INTEGER            INFO, KL, KU, LDAB, LDAFB, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   BERR( * ), C( * ), FERR( * ), R( * ),'),('     $                   RWORK( * )'),('      COMPLEX*16         AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGBSVX uses the LU factorization to compute the solution to a complex'),('*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,'),('*  where A is a band matrix of order N with KL subdiagonals and KU'),('*  superdiagonals, and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed by this subroutine:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B'),('*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B'),('*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')'),('*     or diag(C)*B (if TRANS = \'T\' or \'C\').'),('*'),('*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the'),('*     matrix A (after equilibration if FACT = \'E\') as'),('*        A = L * U,'),('*     where L is a product of permutation and unit lower triangular'),('*     matrices with KL subdiagonals, and U is upper triangular with'),('*     KL+KU superdiagonals.'),('*'),('*  3. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so'),('*     that it solves the original system before equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFB and IPIV contain the factored form of'),('*                  A.  If EQUED is not \'N\', the matrix A has been'),('*                  equilibrated with scaling factors given by R and C.'),('*                  AB, AFB, and IPIV are not modified.'),('*          = \'N\':  The matrix A will be copied to AFB and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFB and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations.'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Conjugate transpose)'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KL      (input) INTEGER'),('*          The number of subdiagonals within the band of A.  KL >= 0.'),('*'),('*  KU      (input) INTEGER'),('*          The number of superdiagonals within the band of A.  KU >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)'),('*          On entry, the matrix A in band storage, in rows 1 to KL+KU+1.'),('*          The j-th column of A is stored in the j-th column of the'),('*          array AB as follows:'),('*          AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)'),('*'),('*          If FACT = \'F\' and EQUED is not \'N\', then A must have been'),('*          equilibrated by the scaling factors in R and/or C.  AB is not'),('*          modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and'),('*          EQUED = \'N\' on exit.'),('*'),('*          On exit, if EQUED .ne. \'N\', A is scaled as follows:'),('*          EQUED = \'R\':  A := diag(R) * A'),('*          EQUED = \'C\':  A := A * diag(C)'),('*          EQUED = \'B\':  A := diag(R) * A * diag(C).'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KL+KU+1.'),('*'),('*  AFB     (input or output) COMPLEX*16 array, dimension (LDAFB,N)'),('*          If FACT = \'F\', then AFB is an input argument and on entry'),('*          contains details of the LU factorization of the band matrix'),('*          A, as computed by ZGBTRF.  U is stored as an upper triangular'),('*          band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,'),('*          and the multipliers used during the factorization are stored'),('*          in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is'),('*          the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFB is an output argument and on exit'),('*          returns details of the LU factorization of A.'),('*'),('*          If FACT = \'E\', then AFB is an output argument and on exit'),('*          returns details of the LU factorization of the equilibrated'),('*          matrix A (see the description of AB for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAFB   (input) INTEGER'),('*          The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the factorization A = L*U'),('*          as computed by ZGBTRF; row i of the matrix was interchanged'),('*          with row IPIV(i).'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = L*U'),('*          of the equilibrated matrix A.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'R\':  Row equilibration, i.e., A has been premultiplied by'),('*                  diag(R).'),('*          = \'C\':  Column equilibration, i.e., A has been postmultiplied'),('*                  by diag(C).'),('*          = \'B\':  Both row and column equilibration, i.e., A has been'),('*                  replaced by diag(R) * A * diag(C).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  R       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is'),('*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R'),('*          is not accessed.  R is an input argument if FACT = \'F\';'),('*          otherwise, R is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'R\' or \'B\', each element of R must be positive.'),('*'),('*  C       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is'),('*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C'),('*          is not accessed.  C is an input argument if FACT = \'F\';'),('*          otherwise, C is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'C\' or \'B\', each element of C must be positive.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the right hand side matrix B.'),('*          On exit,'),('*          if EQUED = \'N\', B is not modified;'),('*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by'),('*          diag(R)*B;'),('*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is'),('*          overwritten by diag(C)*B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X'),('*          to the original system of equations.  Note that A and B are'),('*          modified on exit if EQUED .ne. \'N\', and the solution to the'),('*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and'),('*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\''),('*          and EQUED = \'R\' or \'B\'.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)'),('*'),('*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (N)'),('*          On exit, RWORK(1) contains the reciprocal pivot growth'),('*          factor norm(A)/norm(U). The \"max absolute element\" norm is'),('*          used. If RWORK(1) is much less than 1, then the stability'),('*          of the LU factorization of the (equilibrated) matrix A'),('*          could be poor. This also means that the solution X, condition'),('*          estimator RCOND, and forward error bound FERR could be'),('*          unreliable. If factorization fails with 0<INFO<=N, then'),('*          RWORK(1) contains the reciprocal pivot growth factor for the'),('*          leading INFO columns of A.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization'),('*                       has been completed, but the factor U is exactly'),('*                       singular, so the solution and error bounds'),('*                       could not be computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `zgbsvx_Table48` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgees_Table200`
--

DROP TABLE IF EXISTS `zgees_Table200`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgees_Table200` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgees_Table200`
--

LOCK TABLES `zgees_Table200` WRITE;
/*!40000 ALTER TABLE `zgees_Table200` DISABLE KEYS */;
INSERT INTO `zgees_Table200` VALUES ('      SUBROUTINE ZGEES( JOBVS, SORT, SELECT, N, A, LDA, SDIM, W, VS,'),('     $                  LDVS, WORK, LWORK, RWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVS, SORT'),('      INTEGER            INFO, LDA, LDVS, LWORK, N, SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      DOUBLE PRECISION   RWORK( * )'),('      COMPLEX*16         A( LDA, * ), VS( LDVS, * ), W( * ), WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELECT'),('      EXTERNAL           SELECT'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGEES computes for an N-by-N complex nonsymmetric matrix A, the'),('*  eigenvalues, the Schur form T, and, optionally, the matrix of Schur'),('*  vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).'),('*'),('*  Optionally, it also orders the eigenvalues on the diagonal of the'),('*  Schur form so that selected eigenvalues are at the top left.'),('*  The leading columns of Z then form an orthonormal basis for the'),('*  invariant subspace corresponding to the selected eigenvalues.'),('*'),('*  A complex matrix is in Schur form if it is upper triangular.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVS   (input) CHARACTER*1'),('*          = \'N\': Schur vectors are not computed;'),('*          = \'V\': Schur vectors are computed.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the Schur form.'),('*          = \'N\': Eigenvalues are not ordered:'),('*          = \'S\': Eigenvalues are ordered (see SELECT).'),('*'),('*  SELECT  (external procedure) LOGICAL FUNCTION of one COMPLEX*16 argument'),('*          SELECT must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'S\', SELECT is used to select eigenvalues to order'),('*          to the top left of the Schur form.'),('*          IF SORT = \'N\', SELECT is not referenced.'),('*          The eigenvalue W(j) is selected if SELECT(W(j)) is true.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten by its Schur form T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues for which'),('*                         SELECT is true.'),('*'),('*  W       (output) COMPLEX*16 array, dimension (N)'),('*          W contains the computed eigenvalues, in the same order that'),('*          they appear on the diagonal of the output Schur form T.'),('*'),('*  VS      (output) COMPLEX*16 array, dimension (LDVS,N)'),('*          If JOBVS = \'V\', VS contains the unitary matrix Z of Schur'),('*          vectors.'),('*          If JOBVS = \'N\', VS is not referenced.'),('*'),('*  LDVS    (input) INTEGER'),('*          The leading dimension of the array VS.  LDVS >= 1; if'),('*          JOBVS = \'V\', LDVS >= N.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,2*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value.'),('*          > 0: if INFO = i, and i is'),('*               <= N:  the QR algorithm failed to compute all the'),('*                      eigenvalues; elements 1:ILO-1 and i+1:N of W'),('*                      contain those eigenvalues which have converged;'),('*                      if JOBVS = \'V\', VS contains the matrix which'),('*                      reduces A to its partially converged Schur form.'),('*               = N+1: the eigenvalues could not be reordered because'),('*                      some eigenvalues were too close to separate (the'),('*                      problem is very ill-conditioned);'),('*               = N+2: after reordering, roundoff changed values of'),('*                      some complex eigenvalues so that leading'),('*                      eigenvalues in the Schur form no longer satisfy'),('*                      SELECT = .TRUE..  This could also be caused by'),('*                      underflow due to scaling.'),('*');
/*!40000 ALTER TABLE `zgees_Table200` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgeesx_Table204`
--

DROP TABLE IF EXISTS `zgeesx_Table204`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgeesx_Table204` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgeesx_Table204`
--

LOCK TABLES `zgeesx_Table204` WRITE;
/*!40000 ALTER TABLE `zgeesx_Table204` DISABLE KEYS */;
INSERT INTO `zgeesx_Table204` VALUES ('      SUBROUTINE ZGEESX( JOBVS, SORT, SELECT, SENSE, N, A, LDA, SDIM, W,'),('     $                   VS, LDVS, RCONDE, RCONDV, WORK, LWORK, RWORK,'),('     $                   BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVS, SENSE, SORT'),('      INTEGER            INFO, LDA, LDVS, LWORK, N, SDIM'),('      DOUBLE PRECISION   RCONDE, RCONDV'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      DOUBLE PRECISION   RWORK( * )'),('      COMPLEX*16         A( LDA, * ), VS( LDVS, * ), W( * ), WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELECT'),('      EXTERNAL           SELECT'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGEESX computes for an N-by-N complex nonsymmetric matrix A, the'),('*  eigenvalues, the Schur form T, and, optionally, the matrix of Schur'),('*  vectors Z.  This gives the Schur factorization A = Z*T*(Z**H).'),('*'),('*  Optionally, it also orders the eigenvalues on the diagonal of the'),('*  Schur form so that selected eigenvalues are at the top left;'),('*  computes a reciprocal condition number for the average of the'),('*  selected eigenvalues (RCONDE); and computes a reciprocal condition'),('*  number for the right invariant subspace corresponding to the'),('*  selected eigenvalues (RCONDV).  The leading columns of Z form an'),('*  orthonormal basis for this invariant subspace.'),('*'),('*  For further explanation of the reciprocal condition numbers RCONDE'),('*  and RCONDV, see Section 4.10 of the LAPACK Users\' Guide (where'),('*  these quantities are called s and sep respectively).'),('*'),('*  A complex matrix is in Schur form if it is upper triangular.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVS   (input) CHARACTER*1'),('*          = \'N\': Schur vectors are not computed;'),('*          = \'V\': Schur vectors are computed.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the Schur form.'),('*          = \'N\': Eigenvalues are not ordered;'),('*          = \'S\': Eigenvalues are ordered (see SELECT).'),('*'),('*  SELECT  (external procedure) LOGICAL FUNCTION of one COMPLEX*16 argument'),('*          SELECT must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'S\', SELECT is used to select eigenvalues to order'),('*          to the top left of the Schur form.'),('*          If SORT = \'N\', SELECT is not referenced.'),('*          An eigenvalue W(j) is selected if SELECT(W(j)) is true.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': None are computed;'),('*          = \'E\': Computed for average of selected eigenvalues only;'),('*          = \'V\': Computed for selected right invariant subspace only;'),('*          = \'B\': Computed for both.'),('*          If SENSE = \'E\', \'V\' or \'B\', SORT must equal \'S\'.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A is overwritten by its Schur form T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues for which'),('*                         SELECT is true.'),('*'),('*  W       (output) COMPLEX*16 array, dimension (N)'),('*          W contains the computed eigenvalues, in the same order'),('*          that they appear on the diagonal of the output Schur form T.'),('*'),('*  VS      (output) COMPLEX*16 array, dimension (LDVS,N)'),('*          If JOBVS = \'V\', VS contains the unitary matrix Z of Schur'),('*          vectors.'),('*          If JOBVS = \'N\', VS is not referenced.'),('*'),('*  LDVS    (input) INTEGER'),('*          The leading dimension of the array VS.  LDVS >= 1, and if'),('*          JOBVS = \'V\', LDVS >= N.'),('*'),('*  RCONDE  (output) DOUBLE PRECISION'),('*          If SENSE = \'E\' or \'B\', RCONDE contains the reciprocal'),('*          condition number for the average of the selected eigenvalues.'),('*          Not referenced if SENSE = \'N\' or \'V\'.'),('*'),('*  RCONDV  (output) DOUBLE PRECISION'),('*          If SENSE = \'V\' or \'B\', RCONDV contains the reciprocal'),('*          condition number for the selected right invariant subspace.'),('*          Not referenced if SENSE = \'N\' or \'E\'.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,2*N).'),('*          Also, if SENSE = \'E\' or \'V\' or \'B\', LWORK >= 2*SDIM*(N-SDIM),'),('*          where SDIM is the number of selected eigenvalues computed by'),('*          this routine.  Note that 2*SDIM*(N-SDIM) <= N*N/2. Note also'),('*          that an error is only returned if LWORK < max(1,2*N), but if'),('*          SENSE = \'E\' or \'V\' or \'B\' this may not be large enough.'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates upper bound on the optimal size of the'),('*          array WORK, returns this value as the first entry of the WORK'),('*          array, and no error message related to LWORK is issued by'),('*          XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value.'),('*          > 0: if INFO = i, and i is'),('*             <= N: the QR algorithm failed to compute all the'),('*                   eigenvalues; elements 1:ILO-1 and i+1:N of W'),('*                   contain those eigenvalues which have converged; if'),('*                   JOBVS = \'V\', VS contains the transformation which'),('*                   reduces A to its partially converged Schur form.'),('*             = N+1: the eigenvalues could not be reordered because some'),('*                   eigenvalues were too close to separate (the problem'),('*                   is very ill-conditioned);'),('*             = N+2: after reordering, roundoff changed values of some'),('*                   complex eigenvalues so that leading eigenvalues in'),('*                   the Schur form no longer satisfy SELECT=.TRUE.  This'),('*                   could also be caused by underflow due to scaling.'),('*');
/*!40000 ALTER TABLE `zgeesx_Table204` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgeev_Table192`
--

DROP TABLE IF EXISTS `zgeev_Table192`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgeev_Table192` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgeev_Table192`
--

LOCK TABLES `zgeev_Table192` WRITE;
/*!40000 ALTER TABLE `zgeev_Table192` DISABLE KEYS */;
INSERT INTO `zgeev_Table192` VALUES ('      SUBROUTINE ZGEEV( JOBVL, JOBVR, N, A, LDA, W, VL, LDVL, VR, LDVR,'),('     $                  WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVL, JOBVR'),('      INTEGER            INFO, LDA, LDVL, LDVR, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RWORK( * )'),('      COMPLEX*16         A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGEEV computes for an N-by-N complex nonsymmetric matrix A, the'),('*  eigenvalues and, optionally, the left and/or right eigenvectors.'),('*'),('*  The right eigenvector v(j) of A satisfies'),('*                   A * v(j) = lambda(j) * v(j)'),('*  where lambda(j) is its eigenvalue.'),('*  The left eigenvector u(j) of A satisfies'),('*                u(j)**H * A = lambda(j) * u(j)**H'),('*  where u(j)**H denotes the conjugate transpose of u(j).'),('*'),('*  The computed eigenvectors are normalized to have Euclidean norm'),('*  equal to 1 and largest component real.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\': left eigenvectors of A are not computed;'),('*          = \'V\': left eigenvectors of are computed.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\': right eigenvectors of A are not computed;'),('*          = \'V\': right eigenvectors of A are computed.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) COMPLEX*16 array, dimension (N)'),('*          W contains the computed eigenvalues.'),('*'),('*  VL      (output) COMPLEX*16 array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order'),('*          as their eigenvalues.'),('*          If JOBVL = \'N\', VL is not referenced.'),('*          u(j) = VL(:,j), the j-th column of VL.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the array VL.  LDVL >= 1; if'),('*          JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) COMPLEX*16 array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order'),('*          as their eigenvalues.'),('*          If JOBVR = \'N\', VR is not referenced.'),('*          v(j) = VR(:,j), the j-th column of VR.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the array VR.  LDVR >= 1; if'),('*          JOBVR = \'V\', LDVR >= N.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,2*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the QR algorithm failed to compute all the'),('*                eigenvalues, and no eigenvectors have been computed;'),('*                elements and i+1:N of W contain eigenvalues which have'),('*                converged.'),('*');
/*!40000 ALTER TABLE `zgeev_Table192` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgeevx_Table196`
--

DROP TABLE IF EXISTS `zgeevx_Table196`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgeevx_Table196` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgeevx_Table196`
--

LOCK TABLES `zgeevx_Table196` WRITE;
/*!40000 ALTER TABLE `zgeevx_Table196` DISABLE KEYS */;
INSERT INTO `zgeevx_Table196` VALUES ('      SUBROUTINE ZGEEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, W, VL,'),('     $                   LDVL, VR, LDVR, ILO, IHI, SCALE, ABNRM, RCONDE,'),('     $                   RCONDV, WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          BALANC, JOBVL, JOBVR, SENSE'),('      INTEGER            IHI, ILO, INFO, LDA, LDVL, LDVR, LWORK, N'),('      DOUBLE PRECISION   ABNRM'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RCONDE( * ), RCONDV( * ), RWORK( * ),'),('     $                   SCALE( * )'),('      COMPLEX*16         A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   W( * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGEEVX computes for an N-by-N complex nonsymmetric matrix A, the'),('*  eigenvalues and, optionally, the left and/or right eigenvectors.'),('*'),('*  Optionally also, it computes a balancing transformation to improve'),('*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,'),('*  SCALE, and ABNRM), reciprocal condition numbers for the eigenvalues'),('*  (RCONDE), and reciprocal condition numbers for the right'),('*  eigenvectors (RCONDV).'),('*'),('*  The right eigenvector v(j) of A satisfies'),('*                   A * v(j) = lambda(j) * v(j)'),('*  where lambda(j) is its eigenvalue.'),('*  The left eigenvector u(j) of A satisfies'),('*                u(j)**H * A = lambda(j) * u(j)**H'),('*  where u(j)**H denotes the conjugate transpose of u(j).'),('*'),('*  The computed eigenvectors are normalized to have Euclidean norm'),('*  equal to 1 and largest component real.'),('*'),('*  Balancing a matrix means permuting the rows and columns to make it'),('*  more nearly upper triangular, and applying a diagonal similarity'),('*  transformation D * A * D**(-1), where D is a diagonal matrix, to'),('*  make its rows and columns closer in norm and the condition numbers'),('*  of its eigenvalues and eigenvectors smaller.  The computed'),('*  reciprocal condition numbers correspond to the balanced matrix.'),('*  Permuting rows and columns will not change the condition numbers'),('*  (in exact arithmetic) but diagonal scaling will.  For further'),('*  explanation of balancing, see section 4.10.2 of the LAPACK'),('*  Users\' Guide.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  BALANC  (input) CHARACTER*1'),('*          Indicates how the input matrix should be diagonally scaled'),('*          and/or permuted to improve the conditioning of its'),('*          eigenvalues.'),('*          = \'N\': Do not diagonally scale or permute;'),('*          = \'P\': Perform permutations to make the matrix more nearly'),('*                 upper triangular. Do not diagonally scale;'),('*          = \'S\': Diagonally scale the matrix, ie. replace A by'),('*                 D*A*D**(-1), where D is a diagonal matrix chosen'),('*                 to make the rows and columns of A more equal in'),('*                 norm. Do not permute;'),('*          = \'B\': Both diagonally scale and permute A.'),('*'),('*          Computed reciprocal condition numbers will be for the matrix'),('*          after balancing and/or permuting. Permuting does not change'),('*          condition numbers (in exact arithmetic), but balancing does.'),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\': left eigenvectors of A are not computed;'),('*          = \'V\': left eigenvectors of A are computed.'),('*          If SENSE = \'E\' or \'B\', JOBVL must = \'V\'.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\': right eigenvectors of A are not computed;'),('*          = \'V\': right eigenvectors of A are computed.'),('*          If SENSE = \'E\' or \'B\', JOBVR must = \'V\'.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': None are computed;'),('*          = \'E\': Computed for eigenvalues only;'),('*          = \'V\': Computed for right eigenvectors only;'),('*          = \'B\': Computed for eigenvalues and right eigenvectors.'),('*'),('*          If SENSE = \'E\' or \'B\', both left and right eigenvectors'),('*          must also be computed (JOBVL = \'V\' and JOBVR = \'V\').'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A. N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.'),('*          On exit, A has been overwritten.  If JOBVL = \'V\' or'),('*          JOBVR = \'V\', A contains the Schur form of the balanced'),('*          version of the matrix A.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) COMPLEX*16 array, dimension (N)'),('*          W contains the computed eigenvalues.'),('*'),('*  VL      (output) COMPLEX*16 array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left eigenvectors u(j) are stored one'),('*          after another in the columns of VL, in the same order'),('*          as their eigenvalues.'),('*          If JOBVL = \'N\', VL is not referenced.'),('*          u(j) = VL(:,j), the j-th column of VL.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the array VL.  LDVL >= 1; if'),('*          JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) COMPLEX*16 array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right eigenvectors v(j) are stored one'),('*          after another in the columns of VR, in the same order'),('*          as their eigenvalues.'),('*          If JOBVR = \'N\', VR is not referenced.'),('*          v(j) = VR(:,j), the j-th column of VR.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the array VR.  LDVR >= 1; if'),('*          JOBVR = \'V\', LDVR >= N.'),('*'),('*  ILO     (output) INTEGER'),('*  IHI     (output) INTEGER'),('*          ILO and IHI are integer values determined when A was'),('*          balanced.  The balanced A(i,j) = 0 if I > J and'),('*          J = 1,...,ILO-1 or I = IHI+1,...,N.'),('*'),('*  SCALE   (output) DOUBLE PRECISION array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          when balancing A.  If P(j) is the index of the row and column'),('*          interchanged with row and column j, and D(j) is the scaling'),('*          factor applied to row and column j, then'),('*          SCALE(J) = P(J),    for J = 1,...,ILO-1'),('*                   = D(J),    for J = ILO,...,IHI'),('*                   = P(J)     for J = IHI+1,...,N.'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  ABNRM   (output) DOUBLE PRECISION'),('*          The one-norm of the balanced matrix (the maximum'),('*          of the sum of absolute values of elements of any column).'),('*'),('*  RCONDE  (output) DOUBLE PRECISION array, dimension (N)'),('*          RCONDE(j) is the reciprocal condition number of the j-th'),('*          eigenvalue.'),('*'),('*  RCONDV  (output) DOUBLE PRECISION array, dimension (N)'),('*          RCONDV(j) is the reciprocal condition number of the j-th'),('*          right eigenvector.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  If SENSE = \'N\' or \'E\','),('*          LWORK >= max(1,2*N), and if SENSE = \'V\' or \'B\','),('*          LWORK >= N*N+2*N.'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the QR algorithm failed to compute all the'),('*                eigenvalues, and no eigenvectors or condition numbers'),('*                have been computed; elements 1:ILO-1 and i+1:N of W'),('*                contain eigenvalues which have converged.'),('*');
/*!40000 ALTER TABLE `zgeevx_Table196` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgels_Table84`
--

DROP TABLE IF EXISTS `zgels_Table84`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgels_Table84` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgels_Table84`
--

LOCK TABLES `zgels_Table84` WRITE;
/*!40000 ALTER TABLE `zgels_Table84` DISABLE KEYS */;
INSERT INTO `zgels_Table84` VALUES ('      SUBROUTINE ZGELS( TRANS, M, N, NRHS, A, LDA, B, LDB, WORK, LWORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          TRANS'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGELS solves overdetermined or underdetermined complex linear systems'),('*  involving an M-by-N matrix A, or its conjugate-transpose, using a QR'),('*  or LQ factorization of A.  It is assumed that A has full rank.'),('*'),('*  The following options are provided:'),('*'),('*  1. If TRANS = \'N\' and m >= n:  find the least squares solution of'),('*     an overdetermined system, i.e., solve the least squares problem'),('*                  minimize || B - A*X ||.'),('*'),('*  2. If TRANS = \'N\' and m < n:  find the minimum norm solution of'),('*     an underdetermined system A * X = B.'),('*'),('*  3. If TRANS = \'C\' and m >= n:  find the minimum norm solution of'),('*     an undetermined system A**H * X = B.'),('*'),('*  4. If TRANS = \'C\' and m < n:  find the least squares solution of'),('*     an overdetermined system, i.e., solve the least squares problem'),('*                  minimize || B - A**H * X ||.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  TRANS   (input) CHARACTER*1'),('*          = \'N\': the linear system involves A;'),('*          = \'C\': the linear system involves A**H.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of'),('*          columns of the matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*            if M >= N, A is overwritten by details of its QR'),('*                       factorization as returned by ZGEQRF;'),('*            if M <  N, A is overwritten by details of its LQ'),('*                       factorization as returned by ZGELQF.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the matrix B of right hand side vectors, stored'),('*          columnwise; B is M-by-NRHS if TRANS = \'N\', or N-by-NRHS'),('*          if TRANS = \'C\'.'),('*          On exit, if INFO = 0, B is overwritten by the solution'),('*          vectors, stored columnwise:'),('*          if TRANS = \'N\' and m >= n, rows 1 to n of B contain the least'),('*          squares solution vectors; the residual sum of squares for the'),('*          solution in each column is given by the sum of squares of the'),('*          modulus of elements N+1 to M in that column;'),('*          if TRANS = \'N\' and m < n, rows 1 to N of B contain the'),('*          minimum norm solution vectors;'),('*          if TRANS = \'C\' and m >= n, rows 1 to M of B contain the'),('*          minimum norm solution vectors;'),('*          if TRANS = \'C\' and m < n, rows 1 to M of B contain the'),('*          least squares solution vectors; the residual sum of squares'),('*          for the solution in each column is given by the sum of'),('*          squares of the modulus of elements M+1 to N in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= MAX(1,M,N).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          LWORK >= max( 1, MN + max( MN, NRHS ) ).'),('*          For optimal performance,'),('*          LWORK >= max( 1, MN + max( MN, NRHS )*NB ).'),('*          where MN = min(M,N) and NB is the optimum block size.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO =  i, the i-th diagonal element of the'),('*                triangular factor of A is zero, so that A does not have'),('*                full rank; the least squares solution could not be'),('*                computed.'),('*');
/*!40000 ALTER TABLE `zgels_Table84` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgelsd_Table92`
--

DROP TABLE IF EXISTS `zgelsd_Table92`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgelsd_Table92` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgelsd_Table92`
--

LOCK TABLES `zgelsd_Table92` WRITE;
/*!40000 ALTER TABLE `zgelsd_Table92` DISABLE KEYS */;
INSERT INTO `zgelsd_Table92` VALUES ('      SUBROUTINE ZGELSD( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,'),('     $                   WORK, LWORK, RWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), S( * )'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGELSD computes the minimum-norm solution to a real linear least'),('*  squares problem:'),('*      minimize 2-norm(| b - A*x |)'),('*  using the singular value decomposition (SVD) of A. A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  The problem is solved in three steps:'),('*  (1) Reduce the coefficient matrix A to bidiagonal form with'),('*      Householder tranformations, reducing the original problem'),('*      into a \"bidiagonal least squares problem\" (BLS)'),('*  (2) Solve the BLS using a divide and conquer approach.'),('*  (3) Apply back all the Householder tranformations to solve'),('*      the original least squares problem.'),('*'),('*  The effective rank of A is determined by treating as zero those'),('*  singular values which are less than RCOND times the largest singular'),('*  value.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A. M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A. N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X. NRHS >= 0.'),('*'),('*  A       (input) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A has been destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, B is overwritten by the N-by-NRHS solution matrix X.'),('*          If m >= n and RANK = n, the residual sum-of-squares for'),('*          the solution in the i-th column is given by the sum of'),('*          squares of the modulus of elements n+1:m in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,M,N).'),('*'),('*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))'),('*          The singular values of A in decreasing order.'),('*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).'),('*'),('*  RCOND   (input) DOUBLE PRECISION'),('*          RCOND is used to determine the effective rank of A.'),('*          Singular values S(i) <= RCOND*S(1) are treated as zero.'),('*          If RCOND < 0, machine precision is used instead.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the number of singular values'),('*          which are greater than RCOND*S(1).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK must be at least 1.'),('*          The exact minimum amount of workspace needed depends on M,'),('*          N and NRHS. As long as LWORK is at least'),('*              2*N + N*NRHS'),('*          if M is greater than or equal to N or'),('*              2*M + M*NRHS'),('*          if M is less than N, the code will execute correctly.'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the array WORK and the'),('*          minimum sizes of the arrays RWORK and IWORK, and returns'),('*          these values as the first entries of the WORK, RWORK and'),('*          IWORK arrays, and no error message related to LWORK is issued'),('*          by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (MAX(1,LRWORK))'),('*          LRWORK >='),('*             10*N + 2*N*SMLSIZ + 8*N*NLVL + 3*SMLSIZ*NRHS +'),('*             MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS )'),('*          if M is greater than or equal to N or'),('*             10*M + 2*M*SMLSIZ + 8*M*NLVL + 3*SMLSIZ*NRHS +'),('*             MAX( (SMLSIZ+1)**2, N*(1+NRHS) + 2*NRHS )'),('*          if M is less than N, the code will execute correctly.'),('*          SMLSIZ is returned by ILAENV and is equal to the maximum'),('*          size of the subproblems at the bottom of the computation'),('*          tree (usually about 25), and'),('*             NLVL = MAX( 0, INT( LOG_2( MIN( M,N )/(SMLSIZ+1) ) ) + 1 )'),('*          On exit, if INFO = 0, RWORK(1) returns the minimum LRWORK.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (MAX(1,LIWORK))'),('*          LIWORK >= max(1, 3*MINMN*NLVL + 11*MINMN),'),('*          where MINMN = MIN( M,N ).'),('*          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  the algorithm for computing the SVD failed to converge;'),('*                if INFO = i, i off-diagonal elements of an intermediate'),('*                bidiagonal form did not converge to zero.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Ming Gu and Ren-Cang Li, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*     Osni Marques, LBNL/NERSC, USA'),('*');
/*!40000 ALTER TABLE `zgelsd_Table92` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgelss_Table96`
--

DROP TABLE IF EXISTS `zgelss_Table96`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgelss_Table96` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgelss_Table96`
--

LOCK TABLES `zgelss_Table96` WRITE;
/*!40000 ALTER TABLE `zgelss_Table96` DISABLE KEYS */;
INSERT INTO `zgelss_Table96` VALUES ('      SUBROUTINE ZGELSS( M, N, NRHS, A, LDA, B, LDB, S, RCOND, RANK,'),('     $                   WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RWORK( * ), S( * )'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGELSS computes the minimum norm solution to a complex linear'),('*  least squares problem:'),('*'),('*  Minimize 2-norm(| b - A*x |).'),('*'),('*  using the singular value decomposition (SVD) of A. A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution matrix'),('*  X.'),('*'),('*  The effective rank of A is determined by treating as zero those'),('*  singular values which are less than RCOND times the largest singular'),('*  value.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A. M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A. N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, the first min(m,n) rows of A are overwritten with'),('*          its right singular vectors, stored rowwise.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, B is overwritten by the N-by-NRHS solution matrix X.'),('*          If m >= n and RANK = n, the residual sum-of-squares for'),('*          the solution in the i-th column is given by the sum of'),('*          squares of the modulus of elements n+1:m in that column.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,M,N).'),('*'),('*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))'),('*          The singular values of A in decreasing order.'),('*          The condition number of A in the 2-norm = S(1)/S(min(m,n)).'),('*'),('*  RCOND   (input) DOUBLE PRECISION'),('*          RCOND is used to determine the effective rank of A.'),('*          Singular values S(i) <= RCOND*S(1) are treated as zero.'),('*          If RCOND < 0, machine precision is used instead.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the number of singular values'),('*          which are greater than RCOND*S(1).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= 1, and also:'),('*          LWORK >=  2*min(M,N) + max(M,N,NRHS)'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (5*min(M,N))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  the algorithm for computing the SVD failed to converge;'),('*                if INFO = i, i off-diagonal elements of an intermediate'),('*                bidiagonal form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `zgelss_Table96` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgelsy_Table88`
--

DROP TABLE IF EXISTS `zgelsy_Table88`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgelsy_Table88` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgelsy_Table88`
--

LOCK TABLES `zgelsy_Table88` WRITE;
/*!40000 ALTER TABLE `zgelsy_Table88` DISABLE KEYS */;
INSERT INTO `zgelsy_Table88` VALUES ('      SUBROUTINE ZGELSY( M, N, NRHS, A, LDA, B, LDB, JPVT, RCOND, RANK,'),('     $                   WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            JPVT( * )'),('      DOUBLE PRECISION   RWORK( * )'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGELSY computes the minimum-norm solution to a complex linear least'),('*  squares problem:'),('*      minimize || A * X - B ||'),('*  using a complete orthogonal factorization of A.  A is an M-by-N'),('*  matrix which may be rank-deficient.'),('*'),('*  Several right hand side vectors b and solution vectors x can be'),('*  handled in a single call; they are stored as the columns of the'),('*  M-by-NRHS right hand side matrix B and the N-by-NRHS solution'),('*  matrix X.'),('*'),('*  The routine first computes a QR factorization with column pivoting:'),('*      A * P = Q * [ R11 R12 ]'),('*                  [  0  R22 ]'),('*  with R11 defined as the largest leading submatrix whose estimated'),('*  condition number is less than 1/RCOND.  The order of R11, RANK,'),('*  is the effective rank of A.'),('*'),('*  Then, R22 is considered to be negligible, and R12 is annihilated'),('*  by unitary transformations from the right, arriving at the'),('*  complete orthogonal factorization:'),('*     A * P = Q * [ T11 0 ] * Z'),('*                 [  0  0 ]'),('*  The minimum-norm solution is then'),('*     X = P * Z\' [ inv(T11)*Q1\'*B ]'),('*                [        0       ]'),('*  where Q1 consists of the first RANK columns of Q.'),('*'),('*  This routine is basically identical to the original xGELSX except'),('*  three differences:'),('*    o The permutation of matrix B (the right hand side) is faster and'),('*      more simple.'),('*    o The call to the subroutine xGEQPF has been substituted by the'),('*      the call to the subroutine xGEQP3. This subroutine is a Blas-3'),('*      version of the QR factorization with column pivoting.'),('*    o Matrix B (the right hand side) is updated with Blas-3.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of'),('*          columns of matrices B and X. NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A has been overwritten by details of its'),('*          complete orthogonal factorization.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the M-by-NRHS right hand side matrix B.'),('*          On exit, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,M,N).'),('*'),('*  JPVT    (input/output) INTEGER array, dimension (N)'),('*          On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted'),('*          to the front of AP, otherwise column i is a free column.'),('*          On exit, if JPVT(i) = k, then the i-th column of A*P'),('*          was the k-th column of A.'),('*'),('*  RCOND   (input) DOUBLE PRECISION'),('*          RCOND is used to determine the effective rank of A, which'),('*          is defined as the order of the largest leading triangular'),('*          submatrix R11 in the QR factorization with pivoting of A,'),('*          whose estimated condition number < 1/RCOND.'),('*'),('*  RANK    (output) INTEGER'),('*          The effective rank of A, i.e., the order of the submatrix'),('*          R11.  This is the same as the order of the submatrix T11'),('*          in the complete orthogonal factorization of A.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          The unblocked strategy requires that:'),('*            LWORK >= MN + MAX( 2*MN, N+1, MN+NRHS )'),('*          where MN = min(M,N).'),('*          The block algorithm requires that:'),('*            LWORK >= MN + MAX( 2*MN, NB*(N+1), MN+MN*NB, MN+NB*NRHS )'),('*          where NB is an upper bound on the blocksize returned'),('*          by ILAENV for the routines ZGEQP3, ZTZRZF, CTZRQF, ZUNMQR,'),('*          and ZUNMRZ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*    A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA'),('*    E. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain'),('*    G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain'),('*');
/*!40000 ALTER TABLE `zgelsy_Table88` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgesdd_Table226`
--

DROP TABLE IF EXISTS `zgesdd_Table226`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgesdd_Table226` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgesdd_Table226`
--

LOCK TABLES `zgesdd_Table226` WRITE;
/*!40000 ALTER TABLE `zgesdd_Table226` DISABLE KEYS */;
INSERT INTO `zgesdd_Table226` VALUES ('      SUBROUTINE ZGESDD( JOBZ, M, N, A, LDA, S, U, LDU, VT, LDVT, WORK,'),('     $                   LWORK, RWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*     8-15-00:  Improve consistency of WS calculations (eca)'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ'),('      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), S( * )'),('      COMPLEX*16         A( LDA, * ), U( LDU, * ), VT( LDVT, * ),'),('     $                   WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGESDD computes the singular value decomposition (SVD) of a complex'),('*  M-by-N matrix A, optionally computing the left and/or right singular'),('*  vectors, by using divide-and-conquer method. The SVD is written'),('*'),('*       A = U * SIGMA * conjugate-transpose(V)'),('*'),('*  where SIGMA is an M-by-N matrix which is zero except for its'),('*  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and'),('*  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA'),('*  are the singular values of A; they are real and non-negative, and'),('*  are returned in descending order.  The first min(m,n) columns of'),('*  U and V are the left and right singular vectors of A.'),('*'),('*  Note that the routine returns VT = V**H, not V.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix U:'),('*          = \'A\':  all M columns of U and all N rows of V**H are'),('*                  returned in the arrays U and VT;'),('*          = \'S\':  the first min(M,N) columns of U and the first'),('*                  min(M,N) rows of V**H are returned in the arrays U'),('*                  and VT;'),('*          = \'O\':  If M >= N, the first N columns of U are overwritten'),('*                  in the array A and all rows of V**H are returned in'),('*                  the array VT;'),('*                  otherwise, all columns of U are returned in the'),('*                  array U and the first M rows of V**H are overwritten'),('*                  in the array A;'),('*          = \'N\':  no columns of U or rows of V**H are computed.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the input matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the input matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit,'),('*          if JOBZ = \'O\',  A is overwritten with the first N columns'),('*                          of U (the left singular vectors, stored'),('*                          columnwise) if M >= N;'),('*                          A is overwritten with the first M rows'),('*                          of V**H (the right singular vectors, stored'),('*                          rowwise) otherwise.'),('*          if JOBZ .ne. \'O\', the contents of A are destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))'),('*          The singular values of A, sorted so that S(i) >= S(i+1).'),('*'),('*  U       (output) COMPLEX*16 array, dimension (LDU,UCOL)'),('*          UCOL = M if JOBZ = \'A\' or JOBZ = \'O\' and M < N;'),('*          UCOL = min(M,N) if JOBZ = \'S\'.'),('*          If JOBZ = \'A\' or JOBZ = \'O\' and M < N, U contains the M-by-M'),('*          unitary matrix U;'),('*          if JOBZ = \'S\', U contains the first min(M,N) columns of U'),('*          (the left singular vectors, stored columnwise);'),('*          if JOBZ = \'O\' and M >= N, or JOBZ = \'N\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U.  LDU >= 1; if'),('*          JOBZ = \'S\' or \'A\' or JOBZ = \'O\' and M < N, LDU >= M.'),('*'),('*  VT      (output) COMPLEX*16 array, dimension (LDVT,N)'),('*          If JOBZ = \'A\' or JOBZ = \'O\' and M >= N, VT contains the'),('*          N-by-N unitary matrix V**H;'),('*          if JOBZ = \'S\', VT contains the first min(M,N) rows of'),('*          V**H (the right singular vectors, stored rowwise);'),('*          if JOBZ = \'O\' and M < N, or JOBZ = \'N\', VT is not referenced.'),('*'),('*  LDVT    (input) INTEGER'),('*          The leading dimension of the array VT.  LDVT >= 1; if'),('*          JOBZ = \'A\' or JOBZ = \'O\' and M >= N, LDVT >= N;'),('*          if JOBZ = \'S\', LDVT >= min(M,N).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= 1.'),('*          if JOBZ = \'N\', LWORK >= 2*min(M,N)+max(M,N).'),('*          if JOBZ = \'O\','),('*                LWORK >= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).'),('*          if JOBZ = \'S\' or \'A\','),('*                LWORK >= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, a workspace query is assumed.  The optimal'),('*          size for the WORK array is calculated and stored in WORK(1),'),('*          and no other work except argument checking is performed.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (MAX(1,LRWORK))'),('*          If JOBZ = \'N\', LRWORK >= 5*min(M,N).'),('*          Otherwise,'),('*          LRWORK >= min(M,N)*max(5*min(M,N)+7,2*max(M,N)+2*min(M,N)+1)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (8*min(M,N))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  The updating process of DBDSDC did not converge.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Ming Gu and Huan Ren, Computer Science Division, University of'),('*     California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `zgesdd_Table226` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgesv_Table4`
--

DROP TABLE IF EXISTS `zgesv_Table4`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgesv_Table4` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgesv_Table4`
--

LOCK TABLES `zgesv_Table4` WRITE;
/*!40000 ALTER TABLE `zgesv_Table4` DISABLE KEYS */;
INSERT INTO `zgesv_Table4` VALUES ('      SUBROUTINE ZGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX*16         A( LDA, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGESV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.'),('*'),('*  The LU decomposition with partial pivoting and row interchanges is'),('*  used to factor A as'),('*     A = P * L * U,'),('*  where P is a permutation matrix, L is unit lower triangular, and U is'),('*  upper triangular.  The factored form of A is then used to solve the'),('*  system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the N-by-N coefficient matrix A.'),('*          On exit, the factors L and U from the factorization'),('*          A = P*L*U; the unit diagonal elements of L are not stored.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          The pivot indices that define the permutation matrix P;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS matrix of right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization'),('*                has been completed, but the factor U is exactly'),('*                singular, so the solution could not be computed.'),('*');
/*!40000 ALTER TABLE `zgesv_Table4` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgesvd_Table222`
--

DROP TABLE IF EXISTS `zgesvd_Table222`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgesvd_Table222` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgesvd_Table222`
--

LOCK TABLES `zgesvd_Table222` WRITE;
/*!40000 ALTER TABLE `zgesvd_Table222` DISABLE KEYS */;
INSERT INTO `zgesvd_Table222` VALUES ('      SUBROUTINE ZGESVD( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, LDVT,'),('     $                   WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBU, JOBVT'),('      INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RWORK( * ), S( * )'),('      COMPLEX*16         A( LDA, * ), U( LDU, * ), VT( LDVT, * ),'),('     $                   WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGESVD computes the singular value decomposition (SVD) of a complex'),('*  M-by-N matrix A, optionally computing the left and/or right singular'),('*  vectors. The SVD is written'),('*'),('*       A = U * SIGMA * conjugate-transpose(V)'),('*'),('*  where SIGMA is an M-by-N matrix which is zero except for its'),('*  min(m,n) diagonal elements, U is an M-by-M unitary matrix, and'),('*  V is an N-by-N unitary matrix.  The diagonal elements of SIGMA'),('*  are the singular values of A; they are real and non-negative, and'),('*  are returned in descending order.  The first min(m,n) columns of'),('*  U and V are the left and right singular vectors of A.'),('*'),('*  Note that the routine returns V**H, not V.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBU    (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix U:'),('*          = \'A\':  all M columns of U are returned in array U:'),('*          = \'S\':  the first min(m,n) columns of U (the left singular'),('*                  vectors) are returned in the array U;'),('*          = \'O\':  the first min(m,n) columns of U (the left singular'),('*                  vectors) are overwritten on the array A;'),('*          = \'N\':  no columns of U (no left singular vectors) are'),('*                  computed.'),('*'),('*  JOBVT   (input) CHARACTER*1'),('*          Specifies options for computing all or part of the matrix'),('*          V**H:'),('*          = \'A\':  all N rows of V**H are returned in the array VT;'),('*          = \'S\':  the first min(m,n) rows of V**H (the right singular'),('*                  vectors) are returned in the array VT;'),('*          = \'O\':  the first min(m,n) rows of V**H (the right singular'),('*                  vectors) are overwritten on the array A;'),('*          = \'N\':  no rows of V**H (no right singular vectors) are'),('*                  computed.'),('*'),('*          JOBVT and JOBU cannot both be \'O\'.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the input matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the input matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit,'),('*          if JOBU = \'O\',  A is overwritten with the first min(m,n)'),('*                          columns of U (the left singular vectors,'),('*                          stored columnwise);'),('*          if JOBVT = \'O\', A is overwritten with the first min(m,n)'),('*                          rows of V**H (the right singular vectors,'),('*                          stored rowwise);'),('*          if JOBU .ne. \'O\' and JOBVT .ne. \'O\', the contents of A'),('*                          are destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,M).'),('*'),('*  S       (output) DOUBLE PRECISION array, dimension (min(M,N))'),('*          The singular values of A, sorted so that S(i) >= S(i+1).'),('*'),('*  U       (output) COMPLEX*16 array, dimension (LDU,UCOL)'),('*          (LDU,M) if JOBU = \'A\' or (LDU,min(M,N)) if JOBU = \'S\'.'),('*          If JOBU = \'A\', U contains the M-by-M unitary matrix U;'),('*          if JOBU = \'S\', U contains the first min(m,n) columns of U'),('*          (the left singular vectors, stored columnwise);'),('*          if JOBU = \'N\' or \'O\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U.  LDU >= 1; if'),('*          JOBU = \'S\' or \'A\', LDU >= M.'),('*'),('*  VT      (output) COMPLEX*16 array, dimension (LDVT,N)'),('*          If JOBVT = \'A\', VT contains the N-by-N unitary matrix'),('*          V**H;'),('*          if JOBVT = \'S\', VT contains the first min(m,n) rows of'),('*          V**H (the right singular vectors, stored rowwise);'),('*          if JOBVT = \'N\' or \'O\', VT is not referenced.'),('*'),('*  LDVT    (input) INTEGER'),('*          The leading dimension of the array VT.  LDVT >= 1; if'),('*          JOBVT = \'A\', LDVT >= N; if JOBVT = \'S\', LDVT >= min(M,N).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          LWORK >=  MAX(1,2*MIN(M,N)+MAX(M,N)).'),('*          For good performance, LWORK should generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (5*min(M,N))'),('*          On exit, if INFO > 0, RWORK(1:MIN(M,N)-1) contains the'),('*          unconverged superdiagonal elements of an upper bidiagonal'),('*          matrix B whose diagonal is in S (not necessarily sorted).'),('*          B satisfies A = U * B * VT, so it has the same singular'),('*          values as A, and singular vectors related by U and VT.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if ZBDSQR did not converge, INFO specifies how many'),('*                superdiagonals of an intermediate bidiagonal form B'),('*                did not converge to zero. See the description of RWORK'),('*                above for details.'),('*');
/*!40000 ALTER TABLE `zgesvd_Table222` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgesvx_Table44`
--

DROP TABLE IF EXISTS `zgesvx_Table44`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgesvx_Table44` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgesvx_Table44`
--

LOCK TABLES `zgesvx_Table44` WRITE;
/*!40000 ALTER TABLE `zgesvx_Table44` DISABLE KEYS */;
INSERT INTO `zgesvx_Table44` VALUES ('      SUBROUTINE ZGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV,'),('     $                   EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, TRANS'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   BERR( * ), C( * ), FERR( * ), R( * ),'),('     $                   RWORK( * )'),('      COMPLEX*16         A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGESVX uses the LU factorization to compute the solution to a complex'),('*  system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N matrix and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B'),('*        TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B'),('*        TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')'),('*     or diag(C)*B (if TRANS = \'T\' or \'C\').'),('*'),('*  2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the'),('*     matrix A (after equilibration if FACT = \'E\') as'),('*        A = P * L * U,'),('*     where P is a permutation matrix, L is a unit lower triangular'),('*     matrix, and U is upper triangular.'),('*'),('*  3. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so'),('*     that it solves the original system before equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AF and IPIV contain the factored form of A.'),('*                  If EQUED is not \'N\', the matrix A has been'),('*                  equilibrated with scaling factors given by R and C.'),('*                  A, AF, and IPIV are not modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AF and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations:'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Conjugate transpose)'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is'),('*          not \'N\', then A must have been equilibrated by the scaling'),('*          factors in R and/or C.  A is not modified if FACT = \'F\' or'),('*          \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if EQUED .ne. \'N\', A is scaled as follows:'),('*          EQUED = \'R\':  A := diag(R) * A'),('*          EQUED = \'C\':  A := A * diag(C)'),('*          EQUED = \'B\':  A := diag(R) * A * diag(C).'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the factors L and U from the factorization'),('*          A = P*L*U as computed by ZGETRF.  If EQUED .ne. \'N\', then'),('*          AF is the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the factors L and U from the factorization A = P*L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then AF is an output argument and on exit'),('*          returns the factors L and U from the factorization A = P*L*U'),('*          of the equilibrated matrix A (see the description of A for'),('*          the form of the equilibrated matrix).'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          as computed by ZGETRF; row i of the matrix was interchanged'),('*          with row IPIV(i).'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          of the original matrix A.'),('*'),('*          If FACT = \'E\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the factorization A = P*L*U'),('*          of the equilibrated matrix A.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'R\':  Row equilibration, i.e., A has been premultiplied by'),('*                  diag(R).'),('*          = \'C\':  Column equilibration, i.e., A has been postmultiplied'),('*                  by diag(C).'),('*          = \'B\':  Both row and column equilibration, i.e., A has been'),('*                  replaced by diag(R) * A * diag(C).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  R       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The row scale factors for A.  If EQUED = \'R\' or \'B\', A is'),('*          multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R'),('*          is not accessed.  R is an input argument if FACT = \'F\';'),('*          otherwise, R is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'R\' or \'B\', each element of R must be positive.'),('*'),('*  C       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The column scale factors for A.  If EQUED = \'C\' or \'B\', A is'),('*          multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C'),('*          is not accessed.  C is an input argument if FACT = \'F\';'),('*          otherwise, C is an output argument.  If FACT = \'F\' and'),('*          EQUED = \'C\' or \'B\', each element of C must be positive.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit,'),('*          if EQUED = \'N\', B is not modified;'),('*          if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by'),('*          diag(R)*B;'),('*          if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is'),('*          overwritten by diag(C)*B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X'),('*          to the original system of equations.  Note that A and B are'),('*          modified on exit if EQUED .ne. \'N\', and the solution to the'),('*          equilibrated system is inv(diag(C))*X if TRANS = \'N\' and'),('*          EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\''),('*          and EQUED = \'R\' or \'B\'.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)'),('*'),('*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (2*N)'),('*          On exit, RWORK(1) contains the reciprocal pivot growth'),('*          factor norm(A)/norm(U). The \"max absolute element\" norm is'),('*          used. If RWORK(1) is much less than 1, then the stability'),('*          of the LU factorization of the (equilibrated) matrix A'),('*          could be poor. This also means that the solution X, condition'),('*          estimator RCOND, and forward error bound FERR could be'),('*          unreliable. If factorization fails with 0<INFO<=N, then'),('*          RWORK(1) contains the reciprocal pivot growth factor for the'),('*          leading INFO columns of A.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization has'),('*                       been completed, but the factor U is exactly'),('*                       singular, so the solution and error bounds'),('*                       could not be computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `zgesvx_Table44` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgges_Table214`
--

DROP TABLE IF EXISTS `zgges_Table214`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgges_Table214` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgges_Table214`
--

LOCK TABLES `zgges_Table214` WRITE;
/*!40000 ALTER TABLE `zgges_Table214` DISABLE KEYS */;
INSERT INTO `zgges_Table214` VALUES ('      SUBROUTINE ZGGES( JOBVSL, JOBVSR, SORT, SELCTG, N, A, LDA, B, LDB,'),('     $                  SDIM, ALPHA, BETA, VSL, LDVSL, VSR, LDVSR, WORK,'),('     $                  LWORK, RWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVSL, JOBVSR, SORT'),('      INTEGER            INFO, LDA, LDB, LDVSL, LDVSR, LWORK, N, SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      DOUBLE PRECISION   RWORK( * )'),('      COMPLEX*16         A( LDA, * ), ALPHA( * ), B( LDB, * ),'),('     $                   BETA( * ), VSL( LDVSL, * ), VSR( LDVSR, * ),'),('     $                   WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELCTG'),('      EXTERNAL           SELCTG'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGGES computes for a pair of N-by-N complex nonsymmetric matrices'),('*  (A,B), the generalized eigenvalues, the generalized complex Schur'),('*  form (S, T), and optionally left and/or right Schur vectors (VSL'),('*  and VSR). This gives the generalized Schur factorization'),('*'),('*          (A,B) = ( (VSL)*S*(VSR)**H, (VSL)*T*(VSR)**H )'),('*'),('*  where (VSR)**H is the conjugate-transpose of VSR.'),('*'),('*  Optionally, it also orders the eigenvalues so that a selected cluster'),('*  of eigenvalues appears in the leading diagonal blocks of the upper'),('*  triangular matrix S and the upper triangular matrix T. The leading'),('*  columns of VSL and VSR then form an unitary basis for the'),('*  corresponding left and right eigenspaces (deflating subspaces).'),('*'),('*  (If only the generalized eigenvalues are needed, use the driver'),('*  ZGGEV instead, which is faster.)'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w'),('*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is'),('*  usually represented as the pair (alpha,beta), as there is a'),('*  reasonable interpretation for beta=0, and even for both being zero.'),('*'),('*  A pair of matrices (S,T) is in generalized complex Schur form if S'),('*  and T are upper triangular and, in addition, the diagonal elements'),('*  of T are non-negative real numbers.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVSL  (input) CHARACTER*1'),('*          = \'N\':  do not compute the left Schur vectors;'),('*          = \'V\':  compute the left Schur vectors.'),('*'),('*  JOBVSR  (input) CHARACTER*1'),('*          = \'N\':  do not compute the right Schur vectors;'),('*          = \'V\':  compute the right Schur vectors.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the generalized Schur form.'),('*          = \'N\':  Eigenvalues are not ordered;'),('*          = \'S\':  Eigenvalues are ordered (see SELCTG).'),('*'),('*  SELCTG  (external procedure) LOGICAL FUNCTION of two COMPLEX*16 arguments'),('*          SELCTG must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'N\', SELCTG is not referenced.'),('*          If SORT = \'S\', SELCTG is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          An eigenvalue ALPHA(j)/BETA(j) is selected if'),('*          SELCTG(ALPHA(j),BETA(j)) is true.'),('*'),('*          Note that a selected complex eigenvalue may no longer satisfy'),('*          SELCTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since'),('*          ordering may change the value of complex eigenvalues'),('*          (especially if the eigenvalue is ill-conditioned), in this'),('*          case INFO is set to N+2 (See INFO below).'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VSL, and VSR.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the first of the pair of matrices.'),('*          On exit, A has been overwritten by its generalized Schur'),('*          form S.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)'),('*          On entry, the second of the pair of matrices.'),('*          On exit, B has been overwritten by its generalized Schur'),('*          form T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*          for which SELCTG is true.'),('*'),('*  ALPHA   (output) COMPLEX*16 array, dimension (N)'),('*  BETA    (output) COMPLEX*16 array, dimension (N)'),('*          On exit,  ALPHA(j)/BETA(j), j=1,...,N, will be the'),('*          generalized eigenvalues.  ALPHA(j), j=1,...,N  and  BETA(j),'),('*          j=1,...,N  are the diagonals of the complex Schur form (A,B)'),('*          output by ZGGES. The  BETA(j) will be non-negative real.'),('*'),('*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or'),('*          underflow, and BETA(j) may even be zero.  Thus, the user'),('*          should avoid naively computing the ratio alpha/beta.'),('*          However, ALPHA will be always less than and usually'),('*          comparable with norm(A) in magnitude, and BETA always less'),('*          than and usually comparable with norm(B).'),('*'),('*  VSL     (output) COMPLEX*16 array, dimension (LDVSL,N)'),('*          If JOBVSL = \'V\', VSL will contain the left Schur vectors.'),('*          Not referenced if JOBVSL = \'N\'.'),('*'),('*  LDVSL   (input) INTEGER'),('*          The leading dimension of the matrix VSL. LDVSL >= 1, and'),('*          if JOBVSL = \'V\', LDVSL >= N.'),('*'),('*  VSR     (output) COMPLEX*16 array, dimension (LDVSR,N)'),('*          If JOBVSR = \'V\', VSR will contain the right Schur vectors.'),('*          Not referenced if JOBVSR = \'N\'.'),('*'),('*  LDVSR   (input) INTEGER'),('*          The leading dimension of the matrix VSR. LDVSR >= 1, and'),('*          if JOBVSR = \'V\', LDVSR >= N.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,2*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (8*N)'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          =1,...,N:'),('*                The QZ iteration failed.  (A,B) are not in Schur'),('*                form, but ALPHA(j) and BETA(j) should be correct for'),('*                j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in ZHGEQZ'),('*                =N+2: after reordering, roundoff changed values of'),('*                      some complex eigenvalues so that leading'),('*                      eigenvalues in the Generalized Schur form no'),('*                      longer satisfy SELCTG=.TRUE.  This could also'),('*                      be caused due to scaling.'),('*                =N+3: reordering falied in ZTGSEN.'),('*');
/*!40000 ALTER TABLE `zgges_Table214` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zggesx_Table218`
--

DROP TABLE IF EXISTS `zggesx_Table218`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zggesx_Table218` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zggesx_Table218`
--

LOCK TABLES `zggesx_Table218` WRITE;
/*!40000 ALTER TABLE `zggesx_Table218` DISABLE KEYS */;
INSERT INTO `zggesx_Table218` VALUES ('      SUBROUTINE ZGGESX( JOBVSL, JOBVSR, SORT, SELCTG, SENSE, N, A, LDA,'),('     $                   B, LDB, SDIM, ALPHA, BETA, VSL, LDVSL, VSR,'),('     $                   LDVSR, RCONDE, RCONDV, WORK, LWORK, RWORK,'),('     $                   IWORK, LIWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVSL, JOBVSR, SENSE, SORT'),('      INTEGER            INFO, LDA, LDB, LDVSL, LDVSR, LIWORK, LWORK, N,'),('     $                   SDIM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   RCONDE( 2 ), RCONDV( 2 ), RWORK( * )'),('      COMPLEX*16         A( LDA, * ), ALPHA( * ), B( LDB, * ),'),('     $                   BETA( * ), VSL( LDVSL, * ), VSR( LDVSR, * ),'),('     $                   WORK( * )'),('*     ..'),('*     .. Function Arguments ..'),('      LOGICAL            SELCTG'),('      EXTERNAL           SELCTG'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGGESX computes for a pair of N-by-N complex nonsymmetric matrices'),('*  (A,B), the generalized eigenvalues, the complex Schur form (S,T),'),('*  and, optionally, the left and/or right matrices of Schur vectors (VSL'),('*  and VSR).  This gives the generalized Schur factorization'),('*'),('*       (A,B) = ( (VSL) S (VSR)**H, (VSL) T (VSR)**H )'),('*'),('*  where (VSR)**H is the conjugate-transpose of VSR.'),('*'),('*  Optionally, it also orders the eigenvalues so that a selected cluster'),('*  of eigenvalues appears in the leading diagonal blocks of the upper'),('*  triangular matrix S and the upper triangular matrix T; computes'),('*  a reciprocal condition number for the average of the selected'),('*  eigenvalues (RCONDE); and computes a reciprocal condition number for'),('*  the right and left deflating subspaces corresponding to the selected'),('*  eigenvalues (RCONDV). The leading columns of VSL and VSR then form'),('*  an orthonormal basis for the corresponding left and right eigenspaces'),('*  (deflating subspaces).'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar w'),('*  or a ratio alpha/beta = w, such that  A - w*B is singular.  It is'),('*  usually represented as the pair (alpha,beta), as there is a'),('*  reasonable interpretation for beta=0 or for both being zero.'),('*'),('*  A pair of matrices (S,T) is in generalized complex Schur form if T is'),('*  upper triangular with non-negative diagonal and S is upper'),('*  triangular.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVSL  (input) CHARACTER*1'),('*          = \'N\':  do not compute the left Schur vectors;'),('*          = \'V\':  compute the left Schur vectors.'),('*'),('*  JOBVSR  (input) CHARACTER*1'),('*          = \'N\':  do not compute the right Schur vectors;'),('*          = \'V\':  compute the right Schur vectors.'),('*'),('*  SORT    (input) CHARACTER*1'),('*          Specifies whether or not to order the eigenvalues on the'),('*          diagonal of the generalized Schur form.'),('*          = \'N\':  Eigenvalues are not ordered;'),('*          = \'S\':  Eigenvalues are ordered (see SELCTG).'),('*'),('*  SELCTG  (external procedure) LOGICAL FUNCTION of two COMPLEX*16 arguments'),('*          SELCTG must be declared EXTERNAL in the calling subroutine.'),('*          If SORT = \'N\', SELCTG is not referenced.'),('*          If SORT = \'S\', SELCTG is used to select eigenvalues to sort'),('*          to the top left of the Schur form.'),('*          Note that a selected complex eigenvalue may no longer satisfy'),('*          SELCTG(ALPHA(j),BETA(j)) = .TRUE. after ordering, since'),('*          ordering may change the value of complex eigenvalues'),('*          (especially if the eigenvalue is ill-conditioned), in this'),('*          case INFO is set to N+3 see INFO below).'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\' : None are computed;'),('*          = \'E\' : Computed for average of selected eigenvalues only;'),('*          = \'V\' : Computed for selected deflating subspaces only;'),('*          = \'B\' : Computed for both.'),('*          If SENSE = \'E\', \'V\', or \'B\', SORT must equal \'S\'.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VSL, and VSR.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the first of the pair of matrices.'),('*          On exit, A has been overwritten by its generalized Schur'),('*          form S.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)'),('*          On entry, the second of the pair of matrices.'),('*          On exit, B has been overwritten by its generalized Schur'),('*          form T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  SDIM    (output) INTEGER'),('*          If SORT = \'N\', SDIM = 0.'),('*          If SORT = \'S\', SDIM = number of eigenvalues (after sorting)'),('*          for which SELCTG is true.'),('*'),('*  ALPHA   (output) COMPLEX*16 array, dimension (N)'),('*  BETA    (output) COMPLEX*16 array, dimension (N)'),('*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the'),('*          generalized eigenvalues.  ALPHA(j) and BETA(j),j=1,...,N  are'),('*          the diagonals of the complex Schur form (S,T).  BETA(j) will'),('*          be non-negative real.'),('*'),('*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or'),('*          underflow, and BETA(j) may even be zero.  Thus, the user'),('*          should avoid naively computing the ratio alpha/beta.'),('*          However, ALPHA will be always less than and usually'),('*          comparable with norm(A) in magnitude, and BETA always less'),('*          than and usually comparable with norm(B).'),('*'),('*  VSL     (output) COMPLEX*16 array, dimension (LDVSL,N)'),('*          If JOBVSL = \'V\', VSL will contain the left Schur vectors.'),('*          Not referenced if JOBVSL = \'N\'.'),('*'),('*  LDVSL   (input) INTEGER'),('*          The leading dimension of the matrix VSL. LDVSL >=1, and'),('*          if JOBVSL = \'V\', LDVSL >= N.'),('*'),('*  VSR     (output) COMPLEX*16 array, dimension (LDVSR,N)'),('*          If JOBVSR = \'V\', VSR will contain the right Schur vectors.'),('*          Not referenced if JOBVSR = \'N\'.'),('*'),('*  LDVSR   (input) INTEGER'),('*          The leading dimension of the matrix VSR. LDVSR >= 1, and'),('*          if JOBVSR = \'V\', LDVSR >= N.'),('*'),('*  RCONDE  (output) DOUBLE PRECISION array, dimension ( 2 )'),('*          If SENSE = \'E\' or \'B\', RCONDE(1) and RCONDE(2) contain the'),('*          reciprocal condition numbers for the average of the selected'),('*          eigenvalues.'),('*          Not referenced if SENSE = \'N\' or \'V\'.'),('*'),('*  RCONDV  (output) DOUBLE PRECISION array, dimension ( 2 )'),('*          If SENSE = \'V\' or \'B\', RCONDV(1) and RCONDV(2) contain the'),('*          reciprocal condition number for the selected deflating'),('*          subspaces.'),('*          Not referenced if SENSE = \'N\' or \'E\'.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N = 0, LWORK >= 1, else if SENSE = \'E\', \'V\', or \'B\','),('*          LWORK >= MAX(1,2*N,2*SDIM*(N-SDIM)), else'),('*          LWORK >= MAX(1,2*N).  Note that 2*SDIM*(N-SDIM) <= N*N/2.'),('*          Note also that an error is only returned if'),('*          LWORK < MAX(1,2*N), but if SENSE = \'E\' or \'V\' or \'B\' this may'),('*          not be large enough.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the bound on the optimal size of the WORK'),('*          array and the minimum size of the IWORK array, returns these'),('*          values as the first entries of the WORK and IWORK arrays, and'),('*          no error message related to LWORK or LIWORK is issued by'),('*          XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension ( 8*N )'),('*          Real workspace.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the minimum LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If SENSE = \'N\' or N = 0, LIWORK >= 1, otherwise'),('*          LIWORK >= N+2.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the bound on the optimal size of the'),('*          WORK array and the minimum size of the IWORK array, returns'),('*          these values as the first entries of the WORK and IWORK'),('*          arrays, and no error message related to LWORK or LIWORK is'),('*          issued by XERBLA.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          Not referenced if SORT = \'N\'.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  (A,B) are not in Schur'),('*                form, but ALPHA(j) and BETA(j) should be correct for'),('*                j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in ZHGEQZ'),('*                =N+2: after reordering, roundoff changed values of'),('*                      some complex eigenvalues so that leading'),('*                      eigenvalues in the Generalized Schur form no'),('*                      longer satisfy SELCTG=.TRUE.  This could also'),('*                      be caused due to scaling.'),('*                =N+3: reordering failed in ZTGSEN.'),('*');
/*!40000 ALTER TABLE `zggesx_Table218` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zggev_Table208`
--

DROP TABLE IF EXISTS `zggev_Table208`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zggev_Table208` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zggev_Table208`
--

LOCK TABLES `zggev_Table208` WRITE;
/*!40000 ALTER TABLE `zggev_Table208` DISABLE KEYS */;
INSERT INTO `zggev_Table208` VALUES ('      SUBROUTINE ZGGEV( JOBVL, JOBVR, N, A, LDA, B, LDB, ALPHA, BETA,'),('     $                  VL, LDVL, VR, LDVR, WORK, LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBVL, JOBVR'),('      INTEGER            INFO, LDA, LDB, LDVL, LDVR, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RWORK( * )'),('      COMPLEX*16         A( LDA, * ), ALPHA( * ), B( LDB, * ),'),('     $                   BETA( * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGGEV computes for a pair of N-by-N complex nonsymmetric matrices'),('*  (A,B), the generalized eigenvalues, and optionally, the left and/or'),('*  right generalized eigenvectors.'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar'),('*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is'),('*  singular. It is usually represented as the pair (alpha,beta), as'),('*  there is a reasonable interpretation for beta=0, and even for both'),('*  being zero.'),('*'),('*  The right generalized eigenvector v(j) corresponding to the'),('*  generalized eigenvalue lambda(j) of (A,B) satisfies'),('*'),('*               A * v(j) = lambda(j) * B * v(j).'),('*'),('*  The left generalized eigenvector u(j) corresponding to the'),('*  generalized eigenvalues lambda(j) of (A,B) satisfies'),('*'),('*               u(j)**H * A = lambda(j) * u(j)**H * B'),('*'),('*  where u(j)**H is the conjugate-transpose of u(j).'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\':  do not compute the left generalized eigenvectors;'),('*          = \'V\':  compute the left generalized eigenvectors.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\':  do not compute the right generalized eigenvectors;'),('*          = \'V\':  compute the right generalized eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VL, and VR.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the matrix A in the pair (A,B).'),('*          On exit, A has been overwritten.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)'),('*          On entry, the matrix B in the pair (A,B).'),('*          On exit, B has been overwritten.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  ALPHA   (output) COMPLEX*16 array, dimension (N)'),('*  BETA    (output) COMPLEX*16 array, dimension (N)'),('*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the'),('*          generalized eigenvalues.'),('*'),('*          Note: the quotients ALPHA(j)/BETA(j) may easily over- or'),('*          underflow, and BETA(j) may even be zero.  Thus, the user'),('*          should avoid naively computing the ratio alpha/beta.'),('*          However, ALPHA will be always less than and usually'),('*          comparable with norm(A) in magnitude, and BETA always less'),('*          than and usually comparable with norm(B).'),('*'),('*  VL      (output) COMPLEX*16 array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left generalized eigenvectors u(j) are'),('*          stored one after another in the columns of VL, in the same'),('*          order as their eigenvalues.'),('*          Each eigenvector is scaled so the largest component has'),('*          abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVL = \'N\'.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the matrix VL. LDVL >= 1, and'),('*          if JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) COMPLEX*16 array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right generalized eigenvectors v(j) are'),('*          stored one after another in the columns of VR, in the same'),('*          order as their eigenvalues.'),('*          Each eigenvector is scaled so the largest component has'),('*          abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVR = \'N\'.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the matrix VR. LDVR >= 1, and'),('*          if JOBVR = \'V\', LDVR >= N.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.  LWORK >= max(1,2*N).'),('*          For good performance, LWORK must generally be larger.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (8*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          =1,...,N:'),('*                The QZ iteration failed.  No eigenvectors have been'),('*                calculated, but ALPHA(j) and BETA(j) should be'),('*                correct for j=INFO+1,...,N.'),('*          > N:  =N+1: other then QZ iteration failed in DHGEQZ,'),('*                =N+2: error return from DTGEVC.'),('*');
/*!40000 ALTER TABLE `zggev_Table208` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zggevx_Table232`
--

DROP TABLE IF EXISTS `zggevx_Table232`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zggevx_Table232` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zggevx_Table232`
--

LOCK TABLES `zggevx_Table232` WRITE;
/*!40000 ALTER TABLE `zggevx_Table232` DISABLE KEYS */;
INSERT INTO `zggevx_Table232` VALUES ('      SUBROUTINE ZGGEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, B, LDB,'),('     $                   ALPHA, BETA, VL, LDVL, VR, LDVR, ILO, IHI,'),('     $                   LSCALE, RSCALE, ABNRM, BBNRM, RCONDE, RCONDV,'),('     $                   WORK, LWORK, RWORK, IWORK, BWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          BALANC, JOBVL, JOBVR, SENSE'),('      INTEGER            IHI, ILO, INFO, LDA, LDB, LDVL, LDVR, LWORK, N'),('      DOUBLE PRECISION   ABNRM, BBNRM'),('*     ..'),('*     .. Array Arguments ..'),('      LOGICAL            BWORK( * )'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   LSCALE( * ), RCONDE( * ), RCONDV( * ),'),('     $                   RSCALE( * ), RWORK( * )'),('      COMPLEX*16         A( LDA, * ), ALPHA( * ), B( LDB, * ),'),('     $                   BETA( * ), VL( LDVL, * ), VR( LDVR, * ),'),('     $                   WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGGEVX computes for a pair of N-by-N complex nonsymmetric matrices'),('*  (A,B) the generalized eigenvalues, and optionally, the left and/or'),('*  right generalized eigenvectors.'),('*'),('*  Optionally, it also computes a balancing transformation to improve'),('*  the conditioning of the eigenvalues and eigenvectors (ILO, IHI,'),('*  LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for'),('*  the eigenvalues (RCONDE), and reciprocal condition numbers for the'),('*  right eigenvectors (RCONDV).'),('*'),('*  A generalized eigenvalue for a pair of matrices (A,B) is a scalar'),('*  lambda or a ratio alpha/beta = lambda, such that A - lambda*B is'),('*  singular. It is usually represented as the pair (alpha,beta), as'),('*  there is a reasonable interpretation for beta=0, and even for both'),('*  being zero.'),('*'),('*  The right eigenvector v(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*                   A * v(j) = lambda(j) * B * v(j) .'),('*  The left eigenvector u(j) corresponding to the eigenvalue lambda(j)'),('*  of (A,B) satisfies'),('*                   u(j)**H * A  = lambda(j) * u(j)**H * B.'),('*  where u(j)**H is the conjugate-transpose of u(j).'),('*'),('*'),('*  Arguments'),('*  ========='),('*'),('*  BALANC  (input) CHARACTER*1'),('*          Specifies the balance option to be performed:'),('*          = \'N\':  do not diagonally scale or permute;'),('*          = \'P\':  permute only;'),('*          = \'S\':  scale only;'),('*          = \'B\':  both permute and scale.'),('*          Computed reciprocal condition numbers will be for the'),('*          matrices after permuting and/or balancing. Permuting does'),('*          not change condition numbers (in exact arithmetic), but'),('*          balancing does.'),('*'),('*  JOBVL   (input) CHARACTER*1'),('*          = \'N\':  do not compute the left generalized eigenvectors;'),('*          = \'V\':  compute the left generalized eigenvectors.'),('*'),('*  JOBVR   (input) CHARACTER*1'),('*          = \'N\':  do not compute the right generalized eigenvectors;'),('*          = \'V\':  compute the right generalized eigenvectors.'),('*'),('*  SENSE   (input) CHARACTER*1'),('*          Determines which reciprocal condition numbers are computed.'),('*          = \'N\': none are computed;'),('*          = \'E\': computed for eigenvalues only;'),('*          = \'V\': computed for eigenvectors only;'),('*          = \'B\': computed for eigenvalues and eigenvectors.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A, B, VL, and VR.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the matrix A in the pair (A,B).'),('*          On exit, A has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\''),('*          or both, then A contains the first part of the complex Schur'),('*          form of the \"balanced\" versions of the input A and B.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)'),('*          On entry, the matrix B in the pair (A,B).'),('*          On exit, B has been overwritten. If JOBVL=\'V\' or JOBVR=\'V\''),('*          or both, then B contains the second part of the complex'),('*          Schur form of the \"balanced\" versions of the input A and B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of B.  LDB >= max(1,N).'),('*'),('*  ALPHA   (output) COMPLEX*16 array, dimension (N)'),('*  BETA    (output) COMPLEX*16 array, dimension (N)'),('*          On exit, ALPHA(j)/BETA(j), j=1,...,N, will be the generalized'),('*          eigenvalues.'),('*'),('*          Note: the quotient ALPHA(j)/BETA(j) ) may easily over- or'),('*          underflow, and BETA(j) may even be zero.  Thus, the user'),('*          should avoid naively computing the ratio ALPHA/BETA.'),('*          However, ALPHA will be always less than and usually'),('*          comparable with norm(A) in magnitude, and BETA always less'),('*          than and usually comparable with norm(B).'),('*'),('*  VL      (output) COMPLEX*16 array, dimension (LDVL,N)'),('*          If JOBVL = \'V\', the left generalized eigenvectors u(j) are'),('*          stored one after another in the columns of VL, in the same'),('*          order as their eigenvalues.'),('*          Each eigenvector will be scaled so the largest component'),('*          will have abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVL = \'N\'.'),('*'),('*  LDVL    (input) INTEGER'),('*          The leading dimension of the matrix VL. LDVL >= 1, and'),('*          if JOBVL = \'V\', LDVL >= N.'),('*'),('*  VR      (output) COMPLEX*16 array, dimension (LDVR,N)'),('*          If JOBVR = \'V\', the right generalized eigenvectors v(j) are'),('*          stored one after another in the columns of VR, in the same'),('*          order as their eigenvalues.'),('*          Each eigenvector will be scaled so the largest component'),('*          will have abs(real part) + abs(imag. part) = 1.'),('*          Not referenced if JOBVR = \'N\'.'),('*'),('*  LDVR    (input) INTEGER'),('*          The leading dimension of the matrix VR. LDVR >= 1, and'),('*          if JOBVR = \'V\', LDVR >= N.'),('*'),('*  ILO     (output) INTEGER'),('*  IHI     (output) INTEGER'),('*          ILO and IHI are integer values such that on exit'),('*          A(i,j) = 0 and B(i,j) = 0 if i > j and'),('*          j = 1,...,ILO-1 or i = IHI+1,...,N.'),('*          If BALANC = \'N\' or \'S\', ILO = 1 and IHI = N.'),('*'),('*  LSCALE  (output) DOUBLE PRECISION array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          to the left side of A and B.  If PL(j) is the index of the'),('*          row interchanged with row j, and DL(j) is the scaling'),('*          factor applied to row j, then'),('*            LSCALE(j) = PL(j)  for j = 1,...,ILO-1'),('*                      = DL(j)  for j = ILO,...,IHI'),('*                      = PL(j)  for j = IHI+1,...,N.'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  RSCALE  (output) DOUBLE PRECISION array, dimension (N)'),('*          Details of the permutations and scaling factors applied'),('*          to the right side of A and B.  If PR(j) is the index of the'),('*          column interchanged with column j, and DR(j) is the scaling'),('*          factor applied to column j, then'),('*            RSCALE(j) = PR(j)  for j = 1,...,ILO-1'),('*                      = DR(j)  for j = ILO,...,IHI'),('*                      = PR(j)  for j = IHI+1,...,N'),('*          The order in which the interchanges are made is N to IHI+1,'),('*          then 1 to ILO-1.'),('*'),('*  ABNRM   (output) DOUBLE PRECISION'),('*          The one-norm of the balanced matrix A.'),('*'),('*  BBNRM   (output) DOUBLE PRECISION'),('*          The one-norm of the balanced matrix B.'),('*'),('*  RCONDE  (output) DOUBLE PRECISION array, dimension (N)'),('*          If SENSE = \'E\' or \'B\', the reciprocal condition numbers of'),('*          the eigenvalues, stored in consecutive elements of the array.'),('*          If SENSE = \'N\' or \'V\', RCONDE is not referenced.'),('*'),('*  RCONDV  (output) DOUBLE PRECISION array, dimension (N)'),('*          If JOB = \'V\' or \'B\', the estimated reciprocal condition'),('*          numbers of the eigenvectors, stored in consecutive elements'),('*          of the array. If the eigenvalues cannot be reordered to'),('*          compute RCONDV(j), RCONDV(j) is set to 0; this can only occur'),('*          when the true value would be very small anyway.'),('*          If SENSE = \'N\' or \'E\', RCONDV is not referenced.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,2*N).'),('*          If SENSE = \'E\', LWORK >= max(1,4*N).'),('*          If SENSE = \'V\' or \'B\', LWORK >= max(1,2*N*N+2*N).'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) REAL array, dimension (lrwork)'),('*          lrwork must be at least max(1,6*N) if BALANC = \'S\' or \'B\','),('*          and at least max(1,2*N) otherwise.'),('*          Real workspace.'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (N+2)'),('*          If SENSE = \'E\', IWORK is not referenced.'),('*'),('*  BWORK   (workspace) LOGICAL array, dimension (N)'),('*          If SENSE = \'N\', BWORK is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1,...,N:'),('*                The QZ iteration failed.  No eigenvectors have been'),('*                calculated, but ALPHA(j) and BETA(j) should be correct'),('*                for j=INFO+1,...,N.'),('*          > N:  =N+1: other than QZ iteration failed in ZHGEQZ.'),('*                =N+2: error return from ZTGEVC.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Balancing a matrix pair (A,B) includes, first, permuting rows and'),('*  columns to isolate eigenvalues, second, applying diagonal similarity'),('*  transformation to the rows and columns to make the rows and columns'),('*  as close in norm as possible. The computed reciprocal condition'),('*  numbers correspond to the balanced matrix. Permuting rows and columns'),('*  will not change the condition numbers (in exact arithmetic) but'),('*  diagonal scaling will.  For further explanation of balancing, see'),('*  section 4.11.1.2 of LAPACK Users\' Guide.'),('*'),('*  An approximate error bound on the chordal distance between the i-th'),('*  computed generalized eigenvalue w and the corresponding exact'),('*  eigenvalue lambda is'),('*'),('*       chord(w, lambda) <= EPS * norm(ABNRM, BBNRM) / RCONDE(I)'),('*'),('*  An approximate error bound for the angle between the i-th computed'),('*  eigenvector VL(i) or VR(i) is given by'),('*'),('*       EPS * norm(ABNRM, BBNRM) / DIF(i).'),('*'),('*  For further explanation of the reciprocal condition numbers RCONDE'),('*  and RCONDV, see section 4.11 of LAPACK User\'s Guide.'),('*'),('');
/*!40000 ALTER TABLE `zggevx_Table232` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zggglm_Table104`
--

DROP TABLE IF EXISTS `zggglm_Table104`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zggglm_Table104` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zggglm_Table104`
--

LOCK TABLES `zggglm_Table104` WRITE;
/*!40000 ALTER TABLE `zggglm_Table104` DISABLE KEYS */;
INSERT INTO `zggglm_Table104` VALUES ('      SUBROUTINE ZGGGLM( N, M, P, A, LDA, B, LDB, D, X, Y, WORK, LWORK,'),('     $                   INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), D( * ), WORK( * ),'),('     $                   X( * ), Y( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGGGLM solves a general Gauss-Markov linear model (GLM) problem:'),('*'),('*          minimize || y ||_2   subject to   d = A*x + B*y'),('*              x'),('*'),('*  where A is an N-by-M matrix, B is an N-by-P matrix, and d is a'),('*  given N-vector. It is assumed that M <= N <= M+P, and'),('*'),('*             rank(A) = M    and    rank( A B ) = N.'),('*'),('*  Under these assumptions, the constrained equation is always'),('*  consistent, and there is a unique solution x and a minimal 2-norm'),('*  solution y, which is obtained using a generalized QR factorization'),('*  of the matrices (A, B) given by'),('*'),('*     A = Q*(R),   B = Q*T*Z.'),('*           (0)'),('*'),('*  In particular, if matrix B is square nonsingular, then the problem'),('*  GLM is equivalent to the following weighted linear least squares'),('*  problem'),('*'),('*               minimize || inv(B)*(d-A*x) ||_2'),('*                   x'),('*'),('*  where inv(B) denotes the inverse of B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The number of rows of the matrices A and B.  N >= 0.'),('*'),('*  M       (input) INTEGER'),('*          The number of columns of the matrix A.  0 <= M <= N.'),('*'),('*  P       (input) INTEGER'),('*          The number of columns of the matrix B.  P >= N-M.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,M)'),('*          On entry, the N-by-M matrix A.'),('*          On exit, the upper triangular part of the array A contains'),('*          the M-by-M upper triangular matrix R.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,P)'),('*          On entry, the N-by-P matrix B.'),('*          On exit, if N <= P, the upper triangle of the subarray'),('*          B(1:N,P-N+1:P) contains the N-by-N upper triangular matrix T;'),('*          if N > P, the elements on and above the (N-P)th subdiagonal'),('*          contain the N-by-P upper trapezoidal matrix T.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,N).'),('*'),('*  D       (input/output) COMPLEX*16 array, dimension (N)'),('*          On entry, D is the left hand side of the GLM equation.'),('*          On exit, D is destroyed.'),('*'),('*  X       (output) COMPLEX*16 array, dimension (M)'),('*  Y       (output) COMPLEX*16 array, dimension (P)'),('*          On exit, X and Y are the solutions of the GLM problem.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,N+M+P).'),('*          For optimum performance, LWORK >= M+min(N,P)+max(N,P)*NB,'),('*          where NB is an upper bound for the optimal blocksizes for'),('*          ZGEQRF, ZGERQF, ZUNMQR and ZUNMRQ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1:  the upper triangular factor R associated with A in the'),('*                generalized QR factorization of the pair (A, B) is'),('*                singular, so that rank(A) < M; the least squares'),('*                solution could not be computed.'),('*          = 2:  the bottom (N-M) by (N-M) part of the upper trapezoidal'),('*                factor T associated with B in the generalized QR'),('*                factorization of the pair (A, B) is singular, so that'),('*                rank( A B ) < N; the least squares solution could not'),('*                be computed.'),('*');
/*!40000 ALTER TABLE `zggglm_Table104` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgglse_Table100`
--

DROP TABLE IF EXISTS `zgglse_Table100`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgglse_Table100` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgglse_Table100`
--

LOCK TABLES `zgglse_Table100` WRITE;
/*!40000 ALTER TABLE `zgglse_Table100` DISABLE KEYS */;
INSERT INTO `zgglse_Table100` VALUES ('      SUBROUTINE ZGGLSE( M, N, P, A, LDA, B, LDB, C, D, X, WORK, LWORK,'),('     $                   INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     February 2007'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDA, LDB, LWORK, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), C( * ), D( * ),'),('     $                   WORK( * ), X( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGGLSE solves the linear equality-constrained least squares (LSE)'),('*  problem:'),('*'),('*          minimize || c - A*x ||_2   subject to   B*x = d'),('*'),('*  where A is an M-by-N matrix, B is a P-by-N matrix, c is a given'),('*  M-vector, and d is a given P-vector. It is assumed that'),('*  P <= N <= M+P, and'),('*'),('*           rank(B) = P and  rank( ( A ) ) = N.'),('*                                ( ( B ) )'),('*'),('*  These conditions ensure that the LSE problem has a unique solution,'),('*  which is obtained using a generalized RQ factorization of the'),('*  matrices (B, A) given by'),('*'),('*     B = (0 R)*Q,   A = Z*T*Q.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrices A and B. N >= 0.'),('*'),('*  P       (input) INTEGER'),('*          The number of rows of the matrix B. 0 <= P <= N <= M+P.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, the elements on and above the diagonal of the array'),('*          contain the min(M,N)-by-N upper trapezoidal matrix T.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)'),('*          On entry, the P-by-N matrix B.'),('*          On exit, the upper triangle of the subarray B(1:P,N-P+1:N)'),('*          contains the P-by-P upper triangular matrix R.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,P).'),('*'),('*  C       (input/output) COMPLEX*16 array, dimension (M)'),('*          On entry, C contains the right hand side vector for the'),('*          least squares part of the LSE problem.'),('*          On exit, the residual sum of squares for the solution'),('*          is given by the sum of squares of elements N-P+1 to M of'),('*          vector C.'),('*'),('*  D       (input/output) COMPLEX*16 array, dimension (P)'),('*          On entry, D contains the right hand side vector for the'),('*          constrained equation.'),('*          On exit, D is destroyed.'),('*'),('*  X       (output) COMPLEX*16 array, dimension (N)'),('*          On exit, X is the solution of the LSE problem.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK. LWORK >= max(1,M+N+P).'),('*          For optimum performance LWORK >= P+min(M,N)+max(M,N)*NB,'),('*          where NB is an upper bound for the optimal blocksizes for'),('*          ZGEQRF, CGERQF, ZUNMQR and CUNMRQ.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          = 1:  the upper triangular factor R associated with B in the'),('*                generalized RQ factorization of the pair (B, A) is'),('*                singular, so that rank(B) < P; the least squares'),('*                solution could not be computed.'),('*          = 2:  the (N-P) by (N-P) part of the upper trapezoidal factor'),('*                T associated with A in the generalized RQ factorization'),('*                of the pair (B, A) is singular, so that'),('*                rank( (A) ) < N; the least squares solution could not'),('*                    ( (B) )'),('*                be computed.'),('*');
/*!40000 ALTER TABLE `zgglse_Table100` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zggsvd_Table230`
--

DROP TABLE IF EXISTS `zggsvd_Table230`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zggsvd_Table230` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zggsvd_Table230`
--

LOCK TABLES `zggsvd_Table230` WRITE;
/*!40000 ALTER TABLE `zggsvd_Table230` DISABLE KEYS */;
INSERT INTO `zggsvd_Table230` VALUES ('      SUBROUTINE ZGGSVD( JOBU, JOBV, JOBQ, M, N, P, K, L, A, LDA, B,'),('     $                   LDB, ALPHA, BETA, U, LDU, V, LDV, Q, LDQ, WORK,'),('     $                   RWORK, IWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBQ, JOBU, JOBV'),('      INTEGER            INFO, K, L, LDA, LDB, LDQ, LDU, LDV, M, N, P'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   ALPHA( * ), BETA( * ), RWORK( * )'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), Q( LDQ, * ),'),('     $                   U( LDU, * ), V( LDV, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGGSVD computes the generalized singular value decomposition (GSVD)'),('*  of an M-by-N complex matrix A and P-by-N complex matrix B:'),('*'),('*        U\'*A*Q = D1*( 0 R ),    V\'*B*Q = D2*( 0 R )'),('*'),('*  where U, V and Q are unitary matrices, and Z\' means the conjugate'),('*  transpose of Z.  Let K+L = the effective numerical rank of the'),('*  matrix (A\',B\')\', then R is a (K+L)-by-(K+L) nonsingular upper'),('*  triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) \"diagonal\"'),('*  matrices and of the following structures, respectively:'),('*'),('*  If M-K-L >= 0,'),('*'),('*                      K  L'),('*         D1 =     K ( I  0 )'),('*                  L ( 0  C )'),('*              M-K-L ( 0  0 )'),('*'),('*                    K  L'),('*         D2 =   L ( 0  S )'),('*              P-L ( 0  0 )'),('*'),('*                  N-K-L  K    L'),('*    ( 0 R ) = K (  0   R11  R12 )'),('*              L (  0    0   R22 )'),('*  where'),('*'),('*    C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),'),('*    S = diag( BETA(K+1),  ... , BETA(K+L) ),'),('*    C**2 + S**2 = I.'),('*'),('*    R is stored in A(1:K+L,N-K-L+1:N) on exit.'),('*'),('*  If M-K-L < 0,'),('*'),('*                    K M-K K+L-M'),('*         D1 =   K ( I  0    0   )'),('*              M-K ( 0  C    0   )'),('*'),('*                      K M-K K+L-M'),('*         D2 =   M-K ( 0  S    0  )'),('*              K+L-M ( 0  0    I  )'),('*                P-L ( 0  0    0  )'),('*'),('*                     N-K-L  K   M-K  K+L-M'),('*    ( 0 R ) =     K ( 0    R11  R12  R13  )'),('*                M-K ( 0     0   R22  R23  )'),('*              K+L-M ( 0     0    0   R33  )'),('*'),('*  where'),('*'),('*    C = diag( ALPHA(K+1), ... , ALPHA(M) ),'),('*    S = diag( BETA(K+1),  ... , BETA(M) ),'),('*    C**2 + S**2 = I.'),('*'),('*    (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored'),('*    ( 0  R22 R23 )'),('*    in B(M-K+1:L,N+M-K-L+1:N) on exit.'),('*'),('*  The routine computes C, S, R, and optionally the unitary'),('*  transformation matrices U, V and Q.'),('*'),('*  In particular, if B is an N-by-N nonsingular matrix, then the GSVD of'),('*  A and B implicitly gives the SVD of A*inv(B):'),('*                       A*inv(B) = U*(D1*inv(D2))*V\'.'),('*  If ( A\',B\')\' has orthnormal columns, then the GSVD of A and B is also'),('*  equal to the CS decomposition of A and B. Furthermore, the GSVD can'),('*  be used to derive the solution of the eigenvalue problem:'),('*                       A\'*A x = lambda* B\'*B x.'),('*  In some literature, the GSVD of A and B is presented in the form'),('*                   U\'*A*X = ( 0 D1 ),   V\'*B*X = ( 0 D2 )'),('*  where U and V are orthogonal and X is nonsingular, and D1 and D2 are'),('*  ``diagonal\'\'.  The former GSVD form can be converted to the latter'),('*  form by taking the nonsingular matrix X as'),('*'),('*                        X = Q*(  I   0    )'),('*                              (  0 inv(R) )'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBU    (input) CHARACTER*1'),('*          = \'U\':  Unitary matrix U is computed;'),('*          = \'N\':  U is not computed.'),('*'),('*  JOBV    (input) CHARACTER*1'),('*          = \'V\':  Unitary matrix V is computed;'),('*          = \'N\':  V is not computed.'),('*'),('*  JOBQ    (input) CHARACTER*1'),('*          = \'Q\':  Unitary matrix Q is computed;'),('*          = \'N\':  Q is not computed.'),('*'),('*  M       (input) INTEGER'),('*          The number of rows of the matrix A.  M >= 0.'),('*'),('*  N       (input) INTEGER'),('*          The number of columns of the matrices A and B.  N >= 0.'),('*'),('*  P       (input) INTEGER'),('*          The number of rows of the matrix B.  P >= 0.'),('*'),('*  K       (output) INTEGER'),('*  L       (output) INTEGER'),('*          On exit, K and L specify the dimension of the subblocks'),('*          described in Purpose.'),('*          K + L = effective numerical rank of (A\',B\')\'.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the M-by-N matrix A.'),('*          On exit, A contains the triangular matrix R, or part of R.'),('*          See Purpose for details.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A. LDA >= max(1,M).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)'),('*          On entry, the P-by-N matrix B.'),('*          On exit, B contains part of the triangular matrix R if'),('*          M-K-L < 0.  See Purpose for details.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B. LDB >= max(1,P).'),('*'),('*  ALPHA   (output) DOUBLE PRECISION array, dimension (N)'),('*  BETA    (output) DOUBLE PRECISION array, dimension (N)'),('*          On exit, ALPHA and BETA contain the generalized singular'),('*          value pairs of A and B;'),('*            ALPHA(1:K) = 1,'),('*            BETA(1:K)  = 0,'),('*          and if M-K-L >= 0,'),('*            ALPHA(K+1:K+L) = C,'),('*            BETA(K+1:K+L)  = S,'),('*          or if M-K-L < 0,'),('*            ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0'),('*            BETA(K+1:M) = S, BETA(M+1:K+L) = 1'),('*          and'),('*            ALPHA(K+L+1:N) = 0'),('*            BETA(K+L+1:N)  = 0'),('*'),('*  U       (output) COMPLEX*16 array, dimension (LDU,M)'),('*          If JOBU = \'U\', U contains the M-by-M unitary matrix U.'),('*          If JOBU = \'N\', U is not referenced.'),('*'),('*  LDU     (input) INTEGER'),('*          The leading dimension of the array U. LDU >= max(1,M) if'),('*          JOBU = \'U\'; LDU >= 1 otherwise.'),('*'),('*  V       (output) COMPLEX*16 array, dimension (LDV,P)'),('*          If JOBV = \'V\', V contains the P-by-P unitary matrix V.'),('*          If JOBV = \'N\', V is not referenced.'),('*'),('*  LDV     (input) INTEGER'),('*          The leading dimension of the array V. LDV >= max(1,P) if'),('*          JOBV = \'V\'; LDV >= 1 otherwise.'),('*'),('*  Q       (output) COMPLEX*16 array, dimension (LDQ,N)'),('*          If JOBQ = \'Q\', Q contains the N-by-N unitary matrix Q.'),('*          If JOBQ = \'N\', Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q. LDQ >= max(1,N) if'),('*          JOBQ = \'Q\'; LDQ >= 1 otherwise.'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (max(3*N,M,P)+N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (2*N)'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (N)'),('*          On exit, IWORK stores the sorting information. More'),('*          precisely, the following loop will sort ALPHA'),('*             for I = K+1, min(M,K+L)'),('*                 swap ALPHA(I) and ALPHA(IWORK(I))'),('*             endfor'),('*          such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = 1, the Jacobi-type procedure failed to'),('*                converge.  For further details, see subroutine ZTGSJA.'),('*'),('*  Internal Parameters'),('*  ==================='),('*'),('*  TOLA    DOUBLE PRECISION'),('*  TOLB    DOUBLE PRECISION'),('*          TOLA and TOLB are the thresholds to determine the effective'),('*          rank of (A\',B\')\'. Generally, they are set to'),('*                   TOLA = MAX(M,N)*norm(A)*MAZHEPS,'),('*                   TOLB = MAX(P,N)*norm(B)*MAZHEPS.'),('*          The size of TOLA and TOLB may affect the size of backward'),('*          errors of the decomposition.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  2-96 Based on modifications by'),('*     Ming Gu and Huan Ren, Computer Science Division, University of'),('*     California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `zggsvd_Table230` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgtsv_Table12`
--

DROP TABLE IF EXISTS `zgtsv_Table12`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgtsv_Table12` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgtsv_Table12`
--

LOCK TABLES `zgtsv_Table12` WRITE;
/*!40000 ALTER TABLE `zgtsv_Table12` DISABLE KEYS */;
INSERT INTO `zgtsv_Table12` VALUES ('      SUBROUTINE ZGTSV( N, NRHS, DL, D, DU, B, LDB, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX*16         B( LDB, * ), D( * ), DL( * ), DU( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGTSV  solves the equation'),('*'),('*     A*X = B,'),('*'),('*  where A is an N-by-N tridiagonal matrix, by Gaussian elimination with'),('*  partial pivoting.'),('*'),('*  Note that the equation  A\'*X = B  may be solved by interchanging the'),('*  order of the arguments DU and DL.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  DL      (input/output) COMPLEX*16 array, dimension (N-1)'),('*          On entry, DL must contain the (n-1) subdiagonal elements of'),('*          A.'),('*          On exit, DL is overwritten by the (n-2) elements of the'),('*          second superdiagonal of the upper triangular matrix U from'),('*          the LU factorization of A, in DL(1), ..., DL(n-2).'),('*'),('*  D       (input/output) COMPLEX*16 array, dimension (N)'),('*          On entry, D must contain the diagonal elements of A.'),('*          On exit, D is overwritten by the n diagonal elements of U.'),('*'),('*  DU      (input/output) COMPLEX*16 array, dimension (N-1)'),('*          On entry, DU must contain the (n-1) superdiagonal elements'),('*          of A.'),('*          On exit, DU is overwritten by the (n-1) elements of the first'),('*          superdiagonal of U.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, U(i,i) is exactly zero, and the solution'),('*                has not been computed.  The factorization has not been'),('*                completed unless i = N.'),('*');
/*!40000 ALTER TABLE `zgtsv_Table12` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zgtsvx_Table52`
--

DROP TABLE IF EXISTS `zgtsvx_Table52`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zgtsvx_Table52` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zgtsvx_Table52`
--

LOCK TABLES `zgtsvx_Table52` WRITE;
/*!40000 ALTER TABLE `zgtsvx_Table52` DISABLE KEYS */;
INSERT INTO `zgtsvx_Table52` VALUES ('      SUBROUTINE ZGTSVX( FACT, TRANS, N, NRHS, DL, D, DU, DLF, DF, DUF,'),('     $                   DU2, IPIV, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, RWORK, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, TRANS'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * )'),('      COMPLEX*16         B( LDB, * ), D( * ), DF( * ), DL( * ),'),('     $                   DLF( * ), DU( * ), DU2( * ), DUF( * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZGTSVX uses the LU factorization to compute the solution to a complex'),('*  system of linear equations A * X = B, A**T * X = B, or A**H * X = B,'),('*  where A is a tridiagonal matrix of order N and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the LU decomposition is used to factor the matrix A'),('*     as A = L * U, where L is a product of permutation and unit lower'),('*     bidiagonal matrices and U is upper triangular with nonzeros in'),('*     only the main diagonal and first two superdiagonals.'),('*'),('*  2. If some U(i,i)=0, so that U is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored form'),('*                  of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV will not'),('*                  be modified.'),('*          = \'N\':  The matrix will be copied to DLF, DF, and DUF'),('*                  and factored.'),('*'),('*  TRANS   (input) CHARACTER*1'),('*          Specifies the form of the system of equations:'),('*          = \'N\':  A * X = B     (No transpose)'),('*          = \'T\':  A**T * X = B  (Transpose)'),('*          = \'C\':  A**H * X = B  (Conjugate transpose)'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  DL      (input) COMPLEX*16 array, dimension (N-1)'),('*          The (n-1) subdiagonal elements of A.'),('*'),('*  D       (input) COMPLEX*16 array, dimension (N)'),('*          The n diagonal elements of A.'),('*'),('*  DU      (input) COMPLEX*16 array, dimension (N-1)'),('*          The (n-1) superdiagonal elements of A.'),('*'),('*  DLF     (input or output) COMPLEX*16 array, dimension (N-1)'),('*          If FACT = \'F\', then DLF is an input argument and on entry'),('*          contains the (n-1) multipliers that define the matrix L from'),('*          the LU factorization of A as computed by ZGTTRF.'),('*'),('*          If FACT = \'N\', then DLF is an output argument and on exit'),('*          contains the (n-1) multipliers that define the matrix L from'),('*          the LU factorization of A.'),('*'),('*  DF      (input or output) COMPLEX*16 array, dimension (N)'),('*          If FACT = \'F\', then DF is an input argument and on entry'),('*          contains the n diagonal elements of the upper triangular'),('*          matrix U from the LU factorization of A.'),('*'),('*          If FACT = \'N\', then DF is an output argument and on exit'),('*          contains the n diagonal elements of the upper triangular'),('*          matrix U from the LU factorization of A.'),('*'),('*  DUF     (input or output) COMPLEX*16 array, dimension (N-1)'),('*          If FACT = \'F\', then DUF is an input argument and on entry'),('*          contains the (n-1) elements of the first superdiagonal of U.'),('*'),('*          If FACT = \'N\', then DUF is an output argument and on exit'),('*          contains the (n-1) elements of the first superdiagonal of U.'),('*'),('*  DU2     (input or output) COMPLEX*16 array, dimension (N-2)'),('*          If FACT = \'F\', then DU2 is an input argument and on entry'),('*          contains the (n-2) elements of the second superdiagonal of'),('*          U.'),('*'),('*          If FACT = \'N\', then DU2 is an output argument and on exit'),('*          contains the (n-2) elements of the second superdiagonal of'),('*          U.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains the pivot indices from the LU factorization of A as'),('*          computed by ZGTTRF.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains the pivot indices from the LU factorization of A;'),('*          row i of the matrix was interchanged with row IPIV(i).'),('*          IPIV(i) will always be either i or i+1; IPIV(i) = i indicates'),('*          a row interchange was not required.'),('*'),('*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  U(i,i) is exactly zero.  The factorization'),('*                       has not been completed unless i = N, but the'),('*                       factor U is exactly singular, so the solution'),('*                       and error bounds could not be computed.'),('*                       RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `zgtsvx_Table52` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhbev_Table108`
--

DROP TABLE IF EXISTS `zhbev_Table108`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhbev_Table108` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhbev_Table108`
--

LOCK TABLES `zhbev_Table108` WRITE;
/*!40000 ALTER TABLE `zhbev_Table108` DISABLE KEYS */;
INSERT INTO `zhbev_Table108` VALUES ('      SUBROUTINE ZHBEV( JOBZ, UPLO, N, KD, AB, LDAB, W, Z, LDZ, WORK,'),('     $                  RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KD, LDAB, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AB( LDAB, * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHBEV computes all the eigenvalues and, optionally, eigenvectors of'),('*  a complex Hermitian band matrix A.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the first'),('*          superdiagonal and the diagonal of the tridiagonal matrix T'),('*          are returned in rows KD and KD+1 of AB, and if UPLO = \'L\','),('*          the diagonal and first subdiagonal of T are returned in the'),('*          first two rows of AB.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(1,3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `zhbev_Table108` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhbevd_Table136`
--

DROP TABLE IF EXISTS `zhbevd_Table136`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhbevd_Table136` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhbevd_Table136`
--

LOCK TABLES `zhbevd_Table136` WRITE;
/*!40000 ALTER TABLE `zhbevd_Table136` DISABLE KEYS */;
INSERT INTO `zhbevd_Table136` VALUES ('      SUBROUTINE ZHBEVD( JOBZ, UPLO, N, KD, AB, LDAB, W, Z, LDZ, WORK,'),('     $                   LWORK, RWORK, LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KD, LDAB, LDZ, LIWORK, LRWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AB( LDAB, * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHBEVD computes all the eigenvalues and, optionally, eigenvectors of'),('*  a complex Hermitian band matrix A.  If eigenvectors are desired, it'),('*  uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the first'),('*          superdiagonal and the diagonal of the tridiagonal matrix T'),('*          are returned in rows KD and KD+1 of AB, and if UPLO = \'L\','),('*          the diagonal and first subdiagonal of T are returned in the'),('*          first two rows of AB.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK must be at least N.'),('*          If JOBZ = \'V\' and N > 1, LWORK must be at least 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) DOUBLE PRECISION array,'),('*                                         dimension (LRWORK)'),('*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of array RWORK.'),('*          If N <= 1,               LRWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LRWORK must be at least N.'),('*          If JOBZ = \'V\' and N > 1, LRWORK must be at least'),('*                        1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of array IWORK.'),('*          If JOBZ = \'N\' or N <= 1, LIWORK must be at least 1.'),('*          If JOBZ = \'V\' and N > 1, LIWORK must be at least 3 + 5*N .'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `zhbevd_Table136` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhbevx_Table122`
--

DROP TABLE IF EXISTS `zhbevx_Table122`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhbevx_Table122` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhbevx_Table122`
--

LOCK TABLES `zhbevx_Table122` WRITE;
/*!40000 ALTER TABLE `zhbevx_Table122` DISABLE KEYS */;
INSERT INTO `zhbevx_Table122` VALUES ('      SUBROUTINE ZHBEVX( JOBZ, RANGE, UPLO, N, KD, AB, LDAB, Q, LDQ, VL,'),('     $                   VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK, RWORK,'),('     $                   IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, KD, LDAB, LDQ, LDZ, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AB( LDAB, * ), Q( LDQ, * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHBEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a complex Hermitian band matrix A.  Eigenvalues and eigenvectors'),('*  can be selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).'),('*'),('*          On exit, AB is overwritten by values generated during the'),('*          reduction to tridiagonal form.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD + 1.'),('*'),('*  Q       (output) COMPLEX*16 array, dimension (LDQ, N)'),('*          If JOBZ = \'V\', the N-by-N unitary matrix used in the'),('*                          reduction to tridiagonal form.'),('*          If JOBZ = \'N\', the array Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q.  If JOBZ = \'V\', then'),('*          LDQ >= max(1,N).'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AB to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `zhbevx_Table122` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhbgv_Table156`
--

DROP TABLE IF EXISTS `zhbgv_Table156`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhbgv_Table156` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhbgv_Table156`
--

LOCK TABLES `zhbgv_Table156` WRITE;
/*!40000 ALTER TABLE `zhbgv_Table156` DISABLE KEYS */;
INSERT INTO `zhbgv_Table156` VALUES ('      SUBROUTINE ZHBGV( JOBZ, UPLO, N, KA, KB, AB, LDAB, BB, LDBB, W, Z,'),('     $                  LDZ, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KA, KB, LDAB, LDBB, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AB( LDAB, * ), BB( LDBB, * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHBGV computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite banded eigenproblem, of'),('*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian'),('*  and banded, and B is also positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KB >= 0.'),('*'),('*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) COMPLEX*16 array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**H*S, as returned by ZPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i). The eigenvectors are'),('*          normalized so that Z**H*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= N.'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (3*N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is:'),('*             <= N:  the algorithm failed to converge:'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then ZPBSTF'),('*                    returned INFO = i: B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `zhbgv_Table156` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhbgvd_Table180`
--

DROP TABLE IF EXISTS `zhbgvd_Table180`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhbgvd_Table180` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhbgvd_Table180`
--

LOCK TABLES `zhbgvd_Table180` WRITE;
/*!40000 ALTER TABLE `zhbgvd_Table180` DISABLE KEYS */;
INSERT INTO `zhbgvd_Table180` VALUES ('      SUBROUTINE ZHBGVD( JOBZ, UPLO, N, KA, KB, AB, LDAB, BB, LDBB, W,'),('     $                   Z, LDZ, WORK, LWORK, RWORK, LRWORK, IWORK,'),('     $                   LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, KA, KB, LDAB, LDBB, LDZ, LIWORK, LRWORK,'),('     $                   LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AB( LDAB, * ), BB( LDBB, * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHBGVD computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite banded eigenproblem, of'),('*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian'),('*  and banded, and B is also positive definite.  If eigenvectors are'),('*  desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KB >= 0.'),('*'),('*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) COMPLEX*16 array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**H*S, as returned by ZPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i). The eigenvectors are'),('*          normalized so that Z**H*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= N.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO=0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of the array WORK.'),('*          If N <= 1,               LWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK >= N.'),('*          If JOBZ = \'V\' and N > 1, LWORK >= 2*N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LRWORK))'),('*          On exit, if INFO=0, RWORK(1) returns the optimal LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of array RWORK.'),('*          If N <= 1,               LRWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LRWORK >= N.'),('*          If JOBZ = \'V\' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO=0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of array IWORK.'),('*          If JOBZ = \'N\' or N <= 1, LIWORK >= 1.'),('*          If JOBZ = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is:'),('*             <= N:  the algorithm failed to converge:'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then ZPBSTF'),('*                    returned INFO = i: B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `zhbgvd_Table180` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhbgvx_Table168`
--

DROP TABLE IF EXISTS `zhbgvx_Table168`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhbgvx_Table168` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhbgvx_Table168`
--

LOCK TABLES `zhbgvx_Table168` WRITE;
/*!40000 ALTER TABLE `zhbgvx_Table168` DISABLE KEYS */;
INSERT INTO `zhbgvx_Table168` VALUES ('      SUBROUTINE ZHBGVX( JOBZ, RANGE, UPLO, N, KA, KB, AB, LDAB, BB,'),('     $                   LDBB, Q, LDQ, VL, VU, IL, IU, ABSTOL, M, W, Z,'),('     $                   LDZ, WORK, RWORK, IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, KA, KB, LDAB, LDBB, LDQ, LDZ, M,'),('     $                   N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AB( LDAB, * ), BB( LDBB, * ), Q( LDQ, * ),'),('     $                   WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHBGVX computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite banded eigenproblem, of'),('*  the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian'),('*  and banded, and B is also positive definite.  Eigenvalues and'),('*  eigenvectors can be selected by specifying either all eigenvalues,'),('*  a range of values or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  KA      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KA >= 0.'),('*'),('*  KB      (input) INTEGER'),('*          The number of superdiagonals of the matrix B if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'. KB >= 0.'),('*'),('*  AB      (input/output) COMPLEX*16 array, dimension (LDAB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first ka+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(ka+1+i-j,j) = A(i,j) for max(1,j-ka)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+ka).'),('*'),('*          On exit, the contents of AB are destroyed.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KA+1.'),('*'),('*  BB      (input/output) COMPLEX*16 array, dimension (LDBB, N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix B, stored in the first kb+1 rows of the array.  The'),('*          j-th column of B is stored in the j-th column of the array BB'),('*          as follows:'),('*          if UPLO = \'U\', BB(kb+1+i-j,j) = B(i,j) for max(1,j-kb)<=i<=j;'),('*          if UPLO = \'L\', BB(1+i-j,j)    = B(i,j) for j<=i<=min(n,j+kb).'),('*'),('*          On exit, the factor S from the split Cholesky factorization'),('*          B = S**H*S, as returned by ZPBSTF.'),('*'),('*  LDBB    (input) INTEGER'),('*          The leading dimension of the array BB.  LDBB >= KB+1.'),('*'),('*  Q       (output) COMPLEX*16 array, dimension (LDQ, N)'),('*          If JOBZ = \'V\', the n-by-n matrix used in the reduction of'),('*          A*x = (lambda)*B*x to standard form, i.e. C*x = (lambda)*x,'),('*          and consequently C to tridiagonal form.'),('*          If JOBZ = \'N\', the array Q is not referenced.'),('*'),('*  LDQ     (input) INTEGER'),('*          The leading dimension of the array Q.  If JOBZ = \'N\','),('*          LDQ >= 1. If JOBZ = \'V\', LDQ >= max(1,N).'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AP to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors, with the i-th column of Z holding the'),('*          eigenvector associated with W(i). The eigenvectors are'),('*          normalized so that Z**H*B*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= N.'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is:'),('*             <= N:  then i eigenvectors failed to converge.  Their'),('*                    indices are stored in array IFAIL.'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then ZPBSTF'),('*                    returned INFO = i: B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `zhbgvx_Table168` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zheev_Table106`
--

DROP TABLE IF EXISTS `zheev_Table106`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zheev_Table106` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zheev_Table106`
--

LOCK TABLES `zheev_Table106` WRITE;
/*!40000 ALTER TABLE `zheev_Table106` DISABLE KEYS */;
INSERT INTO `zheev_Table106` VALUES ('      SUBROUTINE ZHEEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDA, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         A( LDA, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHEEV computes all eigenvalues and, optionally, eigenvectors of a'),('*  complex Hermitian matrix A.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          orthonormal eigenvectors of the matrix A.'),('*          If JOBZ = \'N\', then on exit the lower triangle (if UPLO=\'L\')'),('*          or the upper triangle (if UPLO=\'U\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,2*N-1).'),('*          For optimal efficiency, LWORK >= (NB+1)*N,'),('*          where NB is the blocksize for ZHETRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(1, 3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `zheev_Table106` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zheevd_Table134`
--

DROP TABLE IF EXISTS `zheevd_Table134`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zheevd_Table134` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zheevd_Table134`
--

LOCK TABLES `zheevd_Table134` WRITE;
/*!40000 ALTER TABLE `zheevd_Table134` DISABLE KEYS */;
INSERT INTO `zheevd_Table134` VALUES ('      SUBROUTINE ZHEEVD( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK,'),('     $                   LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDA, LIWORK, LRWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         A( LDA, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHEEVD computes all eigenvalues and, optionally, eigenvectors of a'),('*  complex Hermitian matrix A.  If eigenvectors are desired, it uses a'),('*  divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          orthonormal eigenvectors of the matrix A.'),('*          If JOBZ = \'N\', then on exit the lower triangle (if UPLO=\'L\')'),('*          or the upper triangle (if UPLO=\'U\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.'),('*          If N <= 1,                LWORK must be at least 1.'),('*          If JOBZ  = \'N\' and N > 1, LWORK must be at least N + 1.'),('*          If JOBZ  = \'V\' and N > 1, LWORK must be at least 2*N + N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) DOUBLE PRECISION array,'),('*                                         dimension (LRWORK)'),('*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of the array RWORK.'),('*          If N <= 1,                LRWORK must be at least 1.'),('*          If JOBZ  = \'N\' and N > 1, LRWORK must be at least N.'),('*          If JOBZ  = \'V\' and N > 1, LRWORK must be at least'),('*                         1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If N <= 1,                LIWORK must be at least 1.'),('*          If JOBZ  = \'N\' and N > 1, LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK must be at least 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i and JOBZ = \'N\', then the algorithm failed'),('*                to converge; i off-diagonal elements of an intermediate'),('*                tridiagonal form did not converge to zero;'),('*                if INFO = i and JOBZ = \'V\', then the algorithm failed'),('*                to compute an eigenvalue while working on the submatrix'),('*                lying in rows and columns INFO/(N+1) through'),('*                mod(INFO,N+1).'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Jeff Rutter, Computer Science Division, University of California'),('*     at Berkeley, USA'),('*'),('*  Modified description of INFO. Sven, 16 Feb 05.');
/*!40000 ALTER TABLE `zheevd_Table134` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zheevr_Table148`
--

DROP TABLE IF EXISTS `zheevr_Table148`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zheevr_Table148` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zheevr_Table148`
--

LOCK TABLES `zheevr_Table148` WRITE;
/*!40000 ALTER TABLE `zheevr_Table148` DISABLE KEYS */;
INSERT INTO `zheevr_Table148` VALUES ('      SUBROUTINE ZHEEVR( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, ISUPPZ, WORK, LWORK,'),('     $                   RWORK, LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDA, LDZ, LIWORK, LRWORK, LWORK,'),('     $                   M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            ISUPPZ( * ), IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         A( LDA, * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHEEVR computes selected eigenvalues and, optionally, eigenvectors'),('*  of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can'),('*  be selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  ZHEEVR first reduces the matrix A to tridiagonal form T with a call'),('*  to ZHETRD.  Then, whenever possible, ZHEEVR calls ZSTEMR to compute'),('*  eigenspectrum using Relatively Robust Representations.  ZSTEMR'),('*  computes eigenvalues by the dqds algorithm, while orthogonal'),('*  eigenvectors are computed from various \"good\" L D L^T representations'),('*  (also known as Relatively Robust Representations). Gram-Schmidt'),('*  orthogonalization is avoided as far as possible. More specifically,'),('*  the various steps of the algorithm are as follows.'),('*'),('*  For each unreduced block (submatrix) of T,'),('*     (a) Compute T - sigma I  = L D L^T, so that L and D'),('*         define all the wanted eigenvalues to high relative accuracy.'),('*         This means that small relative changes in the entries of D and L'),('*         cause only small relative changes in the eigenvalues and'),('*         eigenvectors. The standard (unfactored) representation of the'),('*         tridiagonal matrix T does not have this property in general.'),('*     (b) Compute the eigenvalues to suitable accuracy.'),('*         If the eigenvectors are desired, the algorithm attains full'),('*         accuracy of the computed eigenvalues only right before'),('*         the corresponding vectors have to be computed, see steps c) and d).'),('*     (c) For each cluster of close eigenvalues, select a new'),('*         shift close to the cluster, find a new factorization, and refine'),('*         the shifted eigenvalues to suitable accuracy.'),('*     (d) For each eigenvalue with a large enough relative separation compute'),('*         the corresponding eigenvector by forming a rank revealing twisted'),('*         factorization. Go back to (c) for any clusters that remain.'),('*'),('*  The desired accuracy of the output can be specified by the input'),('*  parameter ABSTOL.'),('*'),('*  For more details, see DSTEMR\'s documentation and:'),('*  - Inderjit S. Dhillon and Beresford N. Parlett: \"Multiple representations'),('*    to compute orthogonal eigenvectors of symmetric tridiagonal matrices,\"'),('*    Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.'),('*  - Inderjit Dhillon and Beresford Parlett: \"Orthogonal Eigenvectors and'),('*    Relative Gaps,\" SIAM Journal on Matrix Analysis and Applications, Vol. 25,'),('*    2004.  Also LAPACK Working Note 154.'),('*  - Inderjit Dhillon: \"A new O(n^2) algorithm for the symmetric'),('*    tridiagonal eigenvalue/eigenvector problem\",'),('*    Computer Science Division Technical Report No. UCB/CSD-97-971,'),('*    UC Berkeley, May 1997.'),('*'),('*'),('*  Note 1 : ZHEEVR calls ZSTEMR when the full spectrum is requested'),('*  on machines which conform to the ieee-754 floating point standard.'),('*  ZHEEVR calls DSTEBZ and ZSTEIN on non-ieee machines and'),('*  when partial spectrum requests are made.'),('*'),('*  Normal execution of ZSTEMR may create NaNs and infinities and'),('*  hence may abort due to a floating point exception in environments'),('*  which do not handle NaNs and infinities in the ieee standard default'),('*  manner.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('********** For RANGE = \'V\' or \'I\' and IU - IL < N - 1, DSTEBZ and'),('********** ZSTEIN are called'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*          If high relative accuracy is important, set ABSTOL to'),('*          DLAMCH( \'Safe minimum\' ).  Doing so will guarantee that'),('*          eigenvalues are computed to high relative accuracy when'),('*          possible in future releases.  The current code does not'),('*          make any guarantees about high relative accuracy, but'),('*          furutre releases will. See J. Barlow and J. Demmel,'),('*          \"Computing Accurate Eigensystems of Scaled Diagonally'),('*          Dominant Matrices\", LAPACK Working Note #7, for a discussion'),('*          of which matrices define their eigenvalues to high relative'),('*          accuracy.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          The first M elements contain the selected eigenvalues in'),('*          ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  ISUPPZ  (output) INTEGER array, dimension ( 2*max(1,M) )'),('*          The support of the eigenvectors in Z, i.e., the indices'),('*          indicating the nonzero elements in Z. The i-th eigenvector'),('*          is nonzero only in elements ISUPPZ( 2*i-1 ) through'),('*          ISUPPZ( 2*i ).'),('********** Implemented only for RANGE = \'A\' or \'I\' and IU - IL = N - 1'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,2*N).'),('*          For optimal efficiency, LWORK >= (NB+1)*N,'),('*          where NB is the max of the blocksize for ZHETRD and for'),('*          ZUNMTR as returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LRWORK))'),('*          On exit, if INFO = 0, RWORK(1) returns the optimal'),('*          (and minimal) LRWORK.'),('*'),('* LRWORK   (input) INTEGER'),('*          The length of the array RWORK.  LRWORK >= max(1,24*N).'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal'),('*          (and minimal) LIWORK.'),('*'),('* LIWORK   (input) INTEGER'),('*          The dimension of the array IWORK.  LIWORK >= max(1,10*N).'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  Internal error'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Inderjit Dhillon, IBM Almaden, USA'),('*     Osni Marques, LBNL/NERSC, USA'),('*     Ken Stanley, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*     Jason Riedy, Computer Science Division, University of'),('*       California at Berkeley, USA'),('*');
/*!40000 ALTER TABLE `zheevr_Table148` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zheevx_Table120`
--

DROP TABLE IF EXISTS `zheevx_Table120`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zheevx_Table120` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zheevx_Table120`
--

LOCK TABLES `zheevx_Table120` WRITE;
/*!40000 ALTER TABLE `zheevx_Table120` DISABLE KEYS */;
INSERT INTO `zheevx_Table120` VALUES ('      SUBROUTINE ZHEEVX( JOBZ, RANGE, UPLO, N, A, LDA, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, WORK, LWORK, RWORK,'),('     $                   IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDA, LDZ, LWORK, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         A( LDA, * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHEEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a complex Hermitian matrix A.  Eigenvalues and eigenvectors can'),('*  be selected by specifying either a range of values or a range of'),('*  indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*          On exit, the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          On normal exit, the first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= 1, when N <= 1;'),('*          otherwise 2*N.'),('*          For optimal efficiency, LWORK >= (NB+1)*N,'),('*          where NB is the max of the blocksize for ZHETRD and for'),('*          ZUNMTR as returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `zheevx_Table120` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhegv_Table154`
--

DROP TABLE IF EXISTS `zhegv_Table154`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhegv_Table154` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhegv_Table154`
--

LOCK TABLES `zhegv_Table154` WRITE;
/*!40000 ALTER TABLE `zhegv_Table154` DISABLE KEYS */;
INSERT INTO `zhegv_Table154` VALUES ('      SUBROUTINE ZHEGV( ITYPE, JOBZ, UPLO, N, A, LDA, B, LDB, W, WORK,'),('     $                  LWORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDA, LDB, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHEGV computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.'),('*  Here A and B are assumed to be Hermitian and B is also'),('*  positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          matrix Z of eigenvectors.  The eigenvectors are normalized'),('*          as follows:'),('*          if ITYPE = 1 or 2, Z**H*B*Z = I;'),('*          if ITYPE = 3, Z**H*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then on exit the upper triangle (if UPLO=\'U\')'),('*          or the lower triangle (if UPLO=\'L\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)'),('*          On entry, the Hermitian positive definite matrix B.'),('*          If UPLO = \'U\', the leading N-by-N upper triangular part of B'),('*          contains the upper triangular part of the matrix B.'),('*          If UPLO = \'L\', the leading N-by-N lower triangular part of B'),('*          contains the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,2*N-1).'),('*          For optimal efficiency, LWORK >= (NB+1)*N,'),('*          where NB is the blocksize for ZHETRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(1, 3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  ZPOTRF or ZHEEV returned an error code:'),('*             <= N:  if INFO = i, ZHEEV failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not converge to zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `zhegv_Table154` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhegvd_Table178`
--

DROP TABLE IF EXISTS `zhegvd_Table178`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhegvd_Table178` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhegvd_Table178`
--

LOCK TABLES `zhegvd_Table178` WRITE;
/*!40000 ALTER TABLE `zhegvd_Table178` DISABLE KEYS */;
INSERT INTO `zhegvd_Table178` VALUES ('      SUBROUTINE ZHEGVD( ITYPE, JOBZ, UPLO, N, A, LDA, B, LDB, W, WORK,'),('     $                   LWORK, RWORK, LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDA, LDB, LIWORK, LRWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHEGVD computes all the eigenvalues, and optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be Hermitian and B is also positive definite.'),('*  If eigenvectors are desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit, if JOBZ = \'V\', then if INFO = 0, A contains the'),('*          matrix Z of eigenvectors.  The eigenvectors are normalized'),('*          as follows:'),('*          if ITYPE = 1 or 2, Z**H*B*Z = I;'),('*          if ITYPE = 3, Z**H*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then on exit the upper triangle (if UPLO=\'U\')'),('*          or the lower triangle (if UPLO=\'L\') of A, including the'),('*          diagonal, is destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)'),('*          On entry, the Hermitian matrix B.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of B contains the'),('*          upper triangular part of the matrix B.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of B contains'),('*          the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.'),('*          If N <= 1,                LWORK >= 1.'),('*          If JOBZ  = \'N\' and N > 1, LWORK >= N + 1.'),('*          If JOBZ  = \'V\' and N > 1, LWORK >= 2*N + N**2.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) DOUBLE PRECISION array, dimension (MAX(1,LRWORK))'),('*          On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of the array RWORK.'),('*          If N <= 1,                LRWORK >= 1.'),('*          If JOBZ  = \'N\' and N > 1, LRWORK >= N.'),('*          If JOBZ  = \'V\' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of the array IWORK.'),('*          If N <= 1,                LIWORK >= 1.'),('*          If JOBZ  = \'N\' and N > 1, LIWORK >= 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the optimal sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  ZPOTRF or ZHEEVD returned an error code:'),('*             <= N:  if INFO = i and JOBZ = \'N\', then the algorithm'),('*                    failed to converge; i off-diagonal elements of an'),('*                    intermediate tridiagonal form did not converge to'),('*                    zero;'),('*                    if INFO = i and JOBZ = \'V\', then the algorithm'),('*                    failed to compute an eigenvalue while working on'),('*                    the submatrix lying in rows and columns INFO/(N+1)'),('*                    through mod(INFO,N+1);'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*'),('*  Modified so that no backsubstitution is performed if ZHEEVD fails to'),('*  converge (NEIG in old code could be greater than N causing out of'),('*  bounds reference to A - reported by Ralf Meyer).  Also corrected the'),('*  description of INFO and the test on ITYPE. Sven, 16 Feb 05.');
/*!40000 ALTER TABLE `zhegvd_Table178` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhegvx_Table166`
--

DROP TABLE IF EXISTS `zhegvx_Table166`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhegvx_Table166` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhegvx_Table166`
--

LOCK TABLES `zhegvx_Table166` WRITE;
/*!40000 ALTER TABLE `zhegvx_Table166` DISABLE KEYS */;
INSERT INTO `zhegvx_Table166` VALUES ('      SUBROUTINE ZHEGVX( ITYPE, JOBZ, RANGE, UPLO, N, A, LDA, B, LDB,'),('     $                   VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK,'),('     $                   LWORK, RWORK, IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, ITYPE, IU, LDA, LDB, LDZ, LWORK, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * ),'),('     $                   Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHEGVX computes selected eigenvalues, and optionally, eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be Hermitian and B is also positive definite.'),('*  Eigenvalues and eigenvectors can be selected by specifying either a'),('*  range of values or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found.'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found.'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('**'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA, N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of A contains the'),('*          upper triangular part of the matrix A.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of A contains'),('*          the lower triangular part of the matrix A.'),('*'),('*          On exit,  the lower triangle (if UPLO=\'L\') or the upper'),('*          triangle (if UPLO=\'U\') of A, including the diagonal, is'),('*          destroyed.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB, N)'),('*          On entry, the Hermitian matrix B.  If UPLO = \'U\', the'),('*          leading N-by-N upper triangular part of B contains the'),('*          upper triangular part of the matrix B.  If UPLO = \'L\','),('*          the leading N-by-N lower triangular part of B contains'),('*          the lower triangular part of the matrix B.'),('*'),('*          On exit, if INFO <= N, the part of B containing the matrix is'),('*          overwritten by the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing A to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          The first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**T*B*Z = I;'),('*          if ITYPE = 3, Z**T*inv(B)*Z = I.'),('*'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of the array WORK.  LWORK >= max(1,2*N).'),('*          For optimal efficiency, LWORK >= (NB+1)*N,'),('*          where NB is the blocksize for ZHETRD returned by ILAENV.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  ZPOTRF or ZHEEVX returned an error code:'),('*             <= N:  if INFO = i, ZHEEVX failed to converge;'),('*                    i eigenvectors failed to converge.  Their indices'),('*                    are stored in array IFAIL.'),('*             > N:   if INFO = N + i, for 1 <= i <= N, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `zhegvx_Table166` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhesv_Table14`
--

DROP TABLE IF EXISTS `zhesv_Table14`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhesv_Table14` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhesv_Table14`
--

LOCK TABLES `zhesv_Table14` WRITE;
/*!40000 ALTER TABLE `zhesv_Table14` DISABLE KEYS */;
INSERT INTO `zhesv_Table14` VALUES ('      SUBROUTINE ZHESV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,'),('     $                  LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.3.0) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHESV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**H,  if UPLO = \'U\', or'),('*     A = L * D * L**H,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, and D is Hermitian and block diagonal with'),('*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then'),('*  used to solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.'),('*'),('*          On exit, if INFO = 0, the block diagonal matrix D and the'),('*          multipliers used to obtain the factor U or L from the'),('*          factorization A = U*D*U**H or A = L*D*L**H as computed by'),('*          ZHETRF.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by ZHETRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= 1, and for best performance'),('*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for'),('*          ZHETRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization'),('*               has been completed, but the block diagonal matrix D is'),('*               exactly singular, so the solution could not be computed.'),('*');
/*!40000 ALTER TABLE `zhesv_Table14` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhesvx_Table54`
--

DROP TABLE IF EXISTS `zhesvx_Table54`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhesvx_Table54` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhesvx_Table54`
--

LOCK TABLES `zhesvx_Table54` WRITE;
/*!40000 ALTER TABLE `zhesvx_Table54` DISABLE KEYS */;
INSERT INTO `zhesvx_Table54` VALUES ('      SUBROUTINE ZHESVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,'),('     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,'),('     $                   RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * )'),('      COMPLEX*16         A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHESVX uses the diagonal pivoting factorization to compute the'),('*  solution to a complex system of linear equations A * X = B,'),('*  where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.'),('*     The form of the factorization is'),('*        A = U * D * U**H,  if UPLO = \'U\', or'),('*        A = L * D * L**H,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices, and D is Hermitian and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AF and IPIV contain the factored form'),('*                  of A.  A, AF and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input) COMPLEX*16 array, dimension (LDA,N)'),('*          The Hermitian matrix A.  If UPLO = \'U\', the leading N-by-N'),('*          upper triangular part of A contains the upper triangular part'),('*          of the matrix A, and the strictly lower triangular part of A'),('*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower'),('*          triangular part of A contains the lower triangular part of'),('*          the matrix A, and the strictly upper triangular part of A is'),('*          not referenced.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**H or A = L*D*L**H as computed by ZHETRF.'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**H or A = L*D*L**H.'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by ZHETRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by ZHETRF.'),('*'),('*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= max(1,2*N), and for best'),('*          performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where'),('*          NB is the optimal blocksize for ZHETRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `zhesvx_Table54` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhpev_Table110`
--

DROP TABLE IF EXISTS `zhpev_Table110`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhpev_Table110` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhpev_Table110`
--

LOCK TABLES `zhpev_Table110` WRITE;
/*!40000 ALTER TABLE `zhpev_Table110` DISABLE KEYS */;
INSERT INTO `zhpev_Table110` VALUES ('      SUBROUTINE ZHPEV( JOBZ, UPLO, N, AP, W, Z, LDZ, WORK, RWORK,'),('     $                  INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHPEV computes all the eigenvalues and, optionally, eigenvectors of a'),('*  complex Hermitian matrix in packed storage.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (max(1, 2*N-1))'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(1, 3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit.'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `zhpev_Table110` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhpevd_Table138`
--

DROP TABLE IF EXISTS `zhpevd_Table138`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhpevd_Table138` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhpevd_Table138`
--

LOCK TABLES `zhpevd_Table138` WRITE;
/*!40000 ALTER TABLE `zhpevd_Table138` DISABLE KEYS */;
INSERT INTO `zhpevd_Table138` VALUES ('      SUBROUTINE ZHPEVD( JOBZ, UPLO, N, AP, W, Z, LDZ, WORK, LWORK,'),('     $                   RWORK, LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, LDZ, LIWORK, LRWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHPEVD computes all the eigenvalues and, optionally, eigenvectors of'),('*  a complex Hermitian matrix A in packed storage.  If eigenvectors are'),('*  desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the orthonormal'),('*          eigenvectors of the matrix A, with the i-th column of Z'),('*          holding the eigenvector associated with W(i).'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the required LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of array WORK.'),('*          If N <= 1,               LWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK must be at least N.'),('*          If JOBZ = \'V\' and N > 1, LWORK must be at least 2*N.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the required sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace/output) DOUBLE PRECISION array,'),('*                                         dimension (LRWORK)'),('*          On exit, if INFO = 0, RWORK(1) returns the required LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of array RWORK.'),('*          If N <= 1,               LRWORK must be at least 1.'),('*          If JOBZ = \'N\' and N > 1, LRWORK must be at least N.'),('*          If JOBZ = \'V\' and N > 1, LRWORK must be at least'),('*                    1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the required LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK must be at least 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK must be at least 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value.'),('*          > 0:  if INFO = i, the algorithm failed to converge; i'),('*                off-diagonal elements of an intermediate tridiagonal'),('*                form did not converge to zero.'),('*');
/*!40000 ALTER TABLE `zhpevd_Table138` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhpevx_Table124`
--

DROP TABLE IF EXISTS `zhpevx_Table124`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhpevx_Table124` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhpevx_Table124`
--

LOCK TABLES `zhpevx_Table124` WRITE;
/*!40000 ALTER TABLE `zhpevx_Table124` DISABLE KEYS */;
INSERT INTO `zhpevx_Table124` VALUES ('      SUBROUTINE ZHPEVX( JOBZ, RANGE, UPLO, N, AP, VL, VU, IL, IU,'),('     $                   ABSTOL, M, W, Z, LDZ, WORK, RWORK, IWORK,'),('     $                   IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, IU, LDZ, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHPEVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a complex Hermitian matrix A in packed storage.'),('*  Eigenvalues/vectors can be selected by specifying either a range of'),('*  values or a range of indices for the desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, AP is overwritten by values generated during the'),('*          reduction to tridiagonal form.  If UPLO = \'U\', the diagonal'),('*          and first superdiagonal of the tridiagonal matrix T overwrite'),('*          the corresponding elements of A, and if UPLO = \'L\', the'),('*          diagonal and first subdiagonal of T overwrite the'),('*          corresponding elements of A.'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AP to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*          See \"Computing Small Singular Values of Bidiagonal Matrices'),('*          with Guaranteed High Relative Accuracy,\" by Demmel and'),('*          Kahan, LAPACK Working Note #3.'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the selected eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, max(1,M))'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and'),('*          the index of the eigenvector is returned in IFAIL.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, then i eigenvectors failed to converge.'),('*                Their indices are stored in array IFAIL.'),('*');
/*!40000 ALTER TABLE `zhpevx_Table124` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhpgv_Table158`
--

DROP TABLE IF EXISTS `zhpgv_Table158`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhpgv_Table158` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhpgv_Table158`
--

LOCK TABLES `zhpgv_Table158` WRITE;
/*!40000 ALTER TABLE `zhpgv_Table158` DISABLE KEYS */;
INSERT INTO `zhpgv_Table158` VALUES ('      SUBROUTINE ZHPGV( ITYPE, JOBZ, UPLO, N, AP, BP, W, Z, LDZ, WORK,'),('     $                  RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDZ, N'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AP( * ), BP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHPGV computes all the eigenvalues and, optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.'),('*  Here A and B are assumed to be Hermitian, stored in packed format,'),('*  and B is also positive definite.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H, in the same storage'),('*          format as B.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors.  The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**H*B*Z = I;'),('*          if ITYPE = 3, Z**H*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (max(1, 2*N-1))'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (max(1, 3*N-2))'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  ZPPTRF or ZHPEV returned an error code:'),('*             <= N:  if INFO = i, ZHPEV failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not convergeto zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*');
/*!40000 ALTER TABLE `zhpgv_Table158` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhpgvd_Table182`
--

DROP TABLE IF EXISTS `zhpgvd_Table182`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhpgvd_Table182` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhpgvd_Table182`
--

LOCK TABLES `zhpgvd_Table182` WRITE;
/*!40000 ALTER TABLE `zhpgvd_Table182` DISABLE KEYS */;
INSERT INTO `zhpgvd_Table182` VALUES ('      SUBROUTINE ZHPGVD( ITYPE, JOBZ, UPLO, N, AP, BP, W, Z, LDZ, WORK,'),('     $                   LWORK, RWORK, LRWORK, IWORK, LIWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, UPLO'),('      INTEGER            INFO, ITYPE, LDZ, LIWORK, LRWORK, LWORK, N'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AP( * ), BP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHPGVD computes all the eigenvalues and, optionally, the eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be Hermitian, stored in packed format, and B is also'),('*  positive definite.'),('*  If eigenvectors are desired, it uses a divide and conquer algorithm.'),('*'),('*  The divide and conquer algorithm makes very mild assumptions about'),('*  floating point arithmetic. It will work on machines with a guard'),('*  digit in add/subtract, or on those binary machines without guard'),('*  digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or'),('*  Cray-2. It could conceivably fail on hexadecimal or decimal machines'),('*  without guard digits, but we know of none.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H, in the same storage'),('*          format as B.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          If INFO = 0, the eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)'),('*          If JOBZ = \'V\', then if INFO = 0, Z contains the matrix Z of'),('*          eigenvectors.  The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**H*B*Z = I;'),('*          if ITYPE = 3, Z**H*inv(B)*Z = I.'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the required LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The dimension of array WORK.'),('*          If N <= 1,               LWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LWORK >= N.'),('*          If JOBZ = \'V\' and N > 1, LWORK >= 2*N.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the required sizes of the WORK, RWORK and'),('*          IWORK arrays, returns these values as the first entries of'),('*          the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (MAX(1,LRWORK))'),('*          On exit, if INFO = 0, RWORK(1) returns the required LRWORK.'),('*'),('*  LRWORK  (input) INTEGER'),('*          The dimension of array RWORK.'),('*          If N <= 1,               LRWORK >= 1.'),('*          If JOBZ = \'N\' and N > 1, LRWORK >= N.'),('*          If JOBZ = \'V\' and N > 1, LRWORK >= 1 + 5*N + 2*N**2.'),('*'),('*          If LRWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  IWORK   (workspace/output) INTEGER array, dimension (MAX(1,LIWORK))'),('*          On exit, if INFO = 0, IWORK(1) returns the required LIWORK.'),('*'),('*  LIWORK  (input) INTEGER'),('*          The dimension of array IWORK.'),('*          If JOBZ  = \'N\' or N <= 1, LIWORK >= 1.'),('*          If JOBZ  = \'V\' and N > 1, LIWORK >= 3 + 5*N.'),('*'),('*          If LIWORK = -1, then a workspace query is assumed; the'),('*          routine only calculates the required sizes of the WORK, RWORK'),('*          and IWORK arrays, returns these values as the first entries'),('*          of the WORK, RWORK and IWORK arrays, and no error message'),('*          related to LWORK or LRWORK or LIWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  ZPPTRF or ZHPEVD returned an error code:'),('*             <= N:  if INFO = i, ZHPEVD failed to converge;'),('*                    i off-diagonal elements of an intermediate'),('*                    tridiagonal form did not convergeto zero;'),('*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `zhpgvd_Table182` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhpgvx_Table170`
--

DROP TABLE IF EXISTS `zhpgvx_Table170`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhpgvx_Table170` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhpgvx_Table170`
--

LOCK TABLES `zhpgvx_Table170` WRITE;
/*!40000 ALTER TABLE `zhpgvx_Table170` DISABLE KEYS */;
INSERT INTO `zhpgvx_Table170` VALUES ('      SUBROUTINE ZHPGVX( ITYPE, JOBZ, RANGE, UPLO, N, AP, BP, VL, VU,'),('     $                   IL, IU, ABSTOL, M, W, Z, LDZ, WORK, RWORK,'),('     $                   IWORK, IFAIL, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          JOBZ, RANGE, UPLO'),('      INTEGER            IL, INFO, ITYPE, IU, LDZ, M, N'),('      DOUBLE PRECISION   ABSTOL, VL, VU'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IFAIL( * ), IWORK( * )'),('      DOUBLE PRECISION   RWORK( * ), W( * )'),('      COMPLEX*16         AP( * ), BP( * ), WORK( * ), Z( LDZ, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHPGVX computes selected eigenvalues and, optionally, eigenvectors'),('*  of a complex generalized Hermitian-definite eigenproblem, of the form'),('*  A*x=(lambda)*B*x,  A*Bx=(lambda)*x,  or B*A*x=(lambda)*x.  Here A and'),('*  B are assumed to be Hermitian, stored in packed format, and B is also'),('*  positive definite.  Eigenvalues and eigenvectors can be selected by'),('*  specifying either a range of values or a range of indices for the'),('*  desired eigenvalues.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  ITYPE   (input) INTEGER'),('*          Specifies the problem type to be solved:'),('*          = 1:  A*x = (lambda)*B*x'),('*          = 2:  A*B*x = (lambda)*x'),('*          = 3:  B*A*x = (lambda)*x'),('*'),('*  JOBZ    (input) CHARACTER*1'),('*          = \'N\':  Compute eigenvalues only;'),('*          = \'V\':  Compute eigenvalues and eigenvectors.'),('*'),('*  RANGE   (input) CHARACTER*1'),('*          = \'A\': all eigenvalues will be found;'),('*          = \'V\': all eigenvalues in the half-open interval (VL,VU]'),('*                 will be found;'),('*          = \'I\': the IL-th through IU-th eigenvalues will be found.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangles of A and B are stored;'),('*          = \'L\':  Lower triangles of A and B are stored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrices A and B.  N >= 0.'),('*'),('*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*'),('*          On exit, the contents of AP are destroyed.'),('*'),('*  BP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          B, packed columnwise in a linear array.  The j-th column of B'),('*          is stored in the array BP as follows:'),('*          if UPLO = \'U\', BP(i + (j-1)*j/2) = B(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', BP(i + (j-1)*(2*n-j)/2) = B(i,j) for j<=i<=n.'),('*'),('*          On exit, the triangular factor U or L from the Cholesky'),('*          factorization B = U**H*U or B = L*L**H, in the same storage'),('*          format as B.'),('*'),('*  VL      (input) DOUBLE PRECISION'),('*  VU      (input) DOUBLE PRECISION'),('*          If RANGE=\'V\', the lower and upper bounds of the interval to'),('*          be searched for eigenvalues. VL < VU.'),('*          Not referenced if RANGE = \'A\' or \'I\'.'),('*'),('*  IL      (input) INTEGER'),('*  IU      (input) INTEGER'),('*          If RANGE=\'I\', the indices (in ascending order) of the'),('*          smallest and largest eigenvalues to be returned.'),('*          1 <= IL <= IU <= N, if N > 0; IL = 1 and IU = 0 if N = 0.'),('*          Not referenced if RANGE = \'A\' or \'V\'.'),('*'),('*  ABSTOL  (input) DOUBLE PRECISION'),('*          The absolute error tolerance for the eigenvalues.'),('*          An approximate eigenvalue is accepted as converged'),('*          when it is determined to lie in an interval [a,b]'),('*          of width less than or equal to'),('*'),('*                  ABSTOL + EPS *   max( |a|,|b| ) ,'),('*'),('*          where EPS is the machine precision.  If ABSTOL is less than'),('*          or equal to zero, then  EPS*|T|  will be used in its place,'),('*          where |T| is the 1-norm of the tridiagonal matrix obtained'),('*          by reducing AP to tridiagonal form.'),('*'),('*          Eigenvalues will be computed most accurately when ABSTOL is'),('*          set to twice the underflow threshold 2*DLAMCH(\'S\'), not zero.'),('*          If this routine returns with INFO>0, indicating that some'),('*          eigenvectors did not converge, try setting ABSTOL to'),('*          2*DLAMCH(\'S\').'),('*'),('*  M       (output) INTEGER'),('*          The total number of eigenvalues found.  0 <= M <= N.'),('*          If RANGE = \'A\', M = N, and if RANGE = \'I\', M = IU-IL+1.'),('*'),('*  W       (output) DOUBLE PRECISION array, dimension (N)'),('*          On normal exit, the first M elements contain the selected'),('*          eigenvalues in ascending order.'),('*'),('*  Z       (output) COMPLEX*16 array, dimension (LDZ, N)'),('*          If JOBZ = \'N\', then Z is not referenced.'),('*          If JOBZ = \'V\', then if INFO = 0, the first M columns of Z'),('*          contain the orthonormal eigenvectors of the matrix A'),('*          corresponding to the selected eigenvalues, with the i-th'),('*          column of Z holding the eigenvector associated with W(i).'),('*          The eigenvectors are normalized as follows:'),('*          if ITYPE = 1 or 2, Z**H*B*Z = I;'),('*          if ITYPE = 3, Z**H*inv(B)*Z = I.'),('*'),('*          If an eigenvector fails to converge, then that column of Z'),('*          contains the latest approximation to the eigenvector, and the'),('*          index of the eigenvector is returned in IFAIL.'),('*          Note: the user must ensure that at least max(1,M) columns are'),('*          supplied in the array Z; if RANGE = \'V\', the exact value of M'),('*          is not known in advance and an upper bound must be used.'),('*'),('*  LDZ     (input) INTEGER'),('*          The leading dimension of the array Z.  LDZ >= 1, and if'),('*          JOBZ = \'V\', LDZ >= max(1,N).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (7*N)'),('*'),('*  IWORK   (workspace) INTEGER array, dimension (5*N)'),('*'),('*  IFAIL   (output) INTEGER array, dimension (N)'),('*          If JOBZ = \'V\', then if INFO = 0, the first M elements of'),('*          IFAIL are zero.  If INFO > 0, then IFAIL contains the'),('*          indices of the eigenvectors that failed to converge.'),('*          If JOBZ = \'N\', then IFAIL is not referenced.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  ZPPTRF or ZHPEVX returned an error code:'),('*             <= N:  if INFO = i, ZHPEVX failed to converge;'),('*                    i eigenvectors failed to converge.  Their indices'),('*                    are stored in array IFAIL.'),('*             > N:   if INFO = N + i, for 1 <= i <= n, then the leading'),('*                    minor of order i of B is not positive definite.'),('*                    The factorization of B could not be completed and'),('*                    no eigenvalues or eigenvectors were computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  Based on contributions by'),('*     Mark Fahey, Department of Mathematics, Univ. of Kentucky, USA'),('*');
/*!40000 ALTER TABLE `zhpgvx_Table170` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhpsv_Table16`
--

DROP TABLE IF EXISTS `zhpsv_Table16`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhpsv_Table16` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhpsv_Table16`
--

LOCK TABLES `zhpsv_Table16` WRITE;
/*!40000 ALTER TABLE `zhpsv_Table16` DISABLE KEYS */;
INSERT INTO `zhpsv_Table16` VALUES ('      SUBROUTINE ZHPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX*16         AP( * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHPSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian matrix stored in packed format and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**H,  if UPLO = \'U\', or'),('*     A = L * D * L**H,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, D is Hermitian and block diagonal with 1-by-1'),('*  and 2-by-2 diagonal blocks.  The factored form of A is then used to'),('*  solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*          On exit, the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by ZHPTRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization'),('*                has been completed, but the block diagonal matrix D is'),('*                exactly singular, so the solution could not be'),('*                computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the Hermitian matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `zhpsv_Table16` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zhpsvx_Table56`
--

DROP TABLE IF EXISTS `zhpsvx_Table56`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zhpsvx_Table56` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zhpsvx_Table56`
--

LOCK TABLES `zhpsvx_Table56` WRITE;
/*!40000 ALTER TABLE `zhpsvx_Table56` DISABLE KEYS */;
INSERT INTO `zhpsvx_Table56` VALUES ('      SUBROUTINE ZHPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,'),('     $                   LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * )'),('      COMPLEX*16         AFP( * ), AP( * ), B( LDB, * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZHPSVX uses the diagonal pivoting factorization A = U*D*U**H or'),('*  A = L*D*L**H to compute the solution to a complex system of linear'),('*  equations A * X = B, where A is an N-by-N Hermitian matrix stored'),('*  in packed format and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as'),('*        A = U * D * U**H,  if UPLO = \'U\', or'),('*        A = L * D * L**H,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices and D is Hermitian and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AFP and IPIV contain the factored form of'),('*                  A.  AFP and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AFP and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          The upper or lower triangle of the Hermitian matrix A, packed'),('*          columnwise in a linear array.  The j-th column of A is stored'),('*          in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*  AFP     (input or output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          If FACT = \'F\', then AFP is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*          If FACT = \'N\', then AFP is an output argument and on exit'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by ZHPTRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by ZHPTRF.'),('*'),('*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the Hermitian matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `zhpsvx_Table56` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zpbsv_Table24`
--

DROP TABLE IF EXISTS `zpbsv_Table24`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zpbsv_Table24` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zpbsv_Table24`
--

LOCK TABLES `zpbsv_Table24` WRITE;
/*!40000 ALTER TABLE `zpbsv_Table24` DISABLE KEYS */;
INSERT INTO `zpbsv_Table24` VALUES ('      SUBROUTINE ZPBSV( UPLO, N, KD, NRHS, AB, LDAB, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, KD, LDAB, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX*16         AB( LDAB, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZPBSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite band matrix and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**H * U,  if UPLO = \'U\', or'),('*     A = L * L**H,  if UPLO = \'L\','),('*  where U is an upper triangular band matrix, and L is a lower'),('*  triangular band matrix, with the same number of superdiagonals or'),('*  subdiagonals as A.  The factored form of A is then used to solve the'),('*  system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first KD+1 rows of the array.  The'),('*          j-th column of A is stored in the j-th column of the array AB'),('*          as follows:'),('*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).'),('*          See below for further details.'),('*'),('*          On exit, if INFO = 0, the triangular factor U or L from the'),('*          Cholesky factorization A = U**H*U or A = L*L**H of the band'),('*          matrix A, in the same storage format as A.'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array AB.  LDAB >= KD+1.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  N = 6, KD = 2, and UPLO = \'U\':'),('*'),('*  On entry:                       On exit:'),('*'),('*      *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46'),('*      *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56'),('*     a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66'),('*'),('*  Similarly, if UPLO = \'L\' the format of A is as follows:'),('*'),('*  On entry:                       On exit:'),('*'),('*     a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66'),('*     a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *'),('*     a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *'),('*'),('*  Array elements marked * are not used by the routine.'),('*');
/*!40000 ALTER TABLE `zpbsv_Table24` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zpbsvx_Table64`
--

DROP TABLE IF EXISTS `zpbsvx_Table64`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zpbsvx_Table64` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zpbsvx_Table64`
--

LOCK TABLES `zpbsvx_Table64` WRITE;
/*!40000 ALTER TABLE `zpbsvx_Table64` DISABLE KEYS */;
INSERT INTO `zpbsvx_Table64` VALUES ('      SUBROUTINE ZPBSVX( FACT, UPLO, N, KD, NRHS, AB, LDAB, AFB, LDAFB,'),('     $                   EQUED, S, B, LDB, X, LDX, RCOND, FERR, BERR,'),('     $                   WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, KD, LDAB, LDAFB, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * ), S( * )'),('      COMPLEX*16         AB( LDAB, * ), AFB( LDAFB, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to'),('*  compute the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite band matrix and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U**H * U,  if UPLO = \'U\', or'),('*        A = L * L**H,  if UPLO = \'L\','),('*     where U is an upper triangular band matrix, and L is a lower'),('*     triangular band matrix.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFB contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  AB and AFB will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AFB and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFB and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  KD      (input) INTEGER'),('*          The number of superdiagonals of the matrix A if UPLO = \'U\','),('*          or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right-hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AB      (input/output) COMPLEX*16 array, dimension (LDAB,N)'),('*          On entry, the upper or lower triangle of the Hermitian band'),('*          matrix A, stored in the first KD+1 rows of the array, except'),('*          if FACT = \'F\' and EQUED = \'Y\', then A must contain the'),('*          equilibrated matrix diag(S)*A*diag(S).  The j-th column of A'),('*          is stored in the j-th column of the array AB as follows:'),('*          if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;'),('*          if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).'),('*          See below for further details.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  LDAB    (input) INTEGER'),('*          The leading dimension of the array A.  LDAB >= KD+1.'),('*'),('*  AFB     (input or output) COMPLEX*16 array, dimension (LDAFB,N)'),('*          If FACT = \'F\', then AFB is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the band matrix'),('*          A, in the same storage format as A (see AB).  If EQUED = \'Y\','),('*          then AFB is the factored form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFB is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H.'),('*'),('*          If FACT = \'E\', then AFB is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the equilibrated'),('*          matrix A (see the description of A for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAFB   (input) INTEGER'),('*          The leading dimension of the array AFB.  LDAFB >= KD+1.'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The band storage scheme is illustrated by the following example, when'),('*  N = 6, KD = 2, and UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the Hermitian matrix A:'),('*'),('*     a11  a12  a13'),('*          a22  a23  a24'),('*               a33  a34  a35'),('*                    a44  a45  a46'),('*                         a55  a56'),('*     (aij=conjg(aji))         a66'),('*'),('*  Band storage of the upper triangle of A:'),('*'),('*      *    *   a13  a24  a35  a46'),('*      *   a12  a23  a34  a45  a56'),('*     a11  a22  a33  a44  a55  a66'),('*'),('*  Similarly, if UPLO = \'L\' the format of A is as follows:'),('*'),('*     a11  a22  a33  a44  a55  a66'),('*     a21  a32  a43  a54  a65   *'),('*     a31  a42  a53  a64   *    *'),('*'),('*  Array elements marked * are not used by the routine.'),('*');
/*!40000 ALTER TABLE `zpbsvx_Table64` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zposv_Table20`
--

DROP TABLE IF EXISTS `zposv_Table20`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zposv_Table20` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zposv_Table20`
--

LOCK TABLES `zposv_Table20` WRITE;
/*!40000 ALTER TABLE `zposv_Table20` DISABLE KEYS */;
INSERT INTO `zposv_Table20` VALUES ('      SUBROUTINE ZPOSV( UPLO, N, NRHS, A, LDA, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDA, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX*16         A( LDA, * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZPOSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite matrix and X and B'),('*  are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**H* U,  if UPLO = \'U\', or'),('*     A = L * L**H,  if UPLO = \'L\','),('*  where U is an upper triangular matrix and  L is a lower triangular'),('*  matrix.  The factored form of A is then used to solve the system of'),('*  equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.'),('*'),('*          On exit, if INFO = 0, the factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*');
/*!40000 ALTER TABLE `zposv_Table20` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zposvx_Table60`
--

DROP TABLE IF EXISTS `zposvx_Table60`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zposvx_Table60` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zposvx_Table60`
--

LOCK TABLES `zposvx_Table60` WRITE;
/*!40000 ALTER TABLE `zposvx_Table60` DISABLE KEYS */;
INSERT INTO `zposvx_Table60` VALUES ('      SUBROUTINE ZPOSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, EQUED,'),('     $                   S, B, LDB, X, LDX, RCOND, FERR, BERR, WORK,'),('     $                   RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * ), S( * )'),('      COMPLEX*16         A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to'),('*  compute the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite matrix and X and B'),('*  are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U**H* U,  if UPLO = \'U\', or'),('*        A = L * L**H,  if UPLO = \'L\','),('*     where U is an upper triangular matrix and L is a lower triangular'),('*     matrix.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AF contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  A and AF will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AF and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the Hermitian matrix A, except if FACT = \'F\' and'),('*          EQUED = \'Y\', then A must contain the equilibrated matrix'),('*          diag(S)*A*diag(S).  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.  A is not modified if'),('*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H, in the same storage'),('*          format as A.  If EQUED .ne. \'N\', then AF is the factored form'),('*          of the equilibrated matrix diag(S)*A*diag(S).'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the original'),('*          matrix A.'),('*'),('*          If FACT = \'E\', then AF is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the equilibrated'),('*          matrix A (see the description of A for the form of the'),('*          equilibrated matrix).'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS righthand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `zposvx_Table60` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zppsv_Table28`
--

DROP TABLE IF EXISTS `zppsv_Table28`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zppsv_Table28` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zppsv_Table28`
--

LOCK TABLES `zppsv_Table28` WRITE;
/*!40000 ALTER TABLE `zppsv_Table28` DISABLE KEYS */;
INSERT INTO `zppsv_Table28` VALUES ('      SUBROUTINE ZPPSV( UPLO, N, NRHS, AP, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      COMPLEX*16         AP( * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZPPSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite matrix stored in'),('*  packed format and X and B are N-by-NRHS matrices.'),('*'),('*  The Cholesky decomposition is used to factor A as'),('*     A = U**H* U,  if UPLO = \'U\', or'),('*     A = L * L**H,  if UPLO = \'L\','),('*  where U is an upper triangular matrix and L is a lower triangular'),('*  matrix.  The factored form of A is then used to solve the system of'),('*  equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*          On exit, if INFO = 0, the factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H, in the same storage'),('*          format as A.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i of A is not'),('*                positive definite, so the factorization could not be'),('*                completed, and the solution has not been computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the Hermitian matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `zppsv_Table28` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zppsvx_Table68`
--

DROP TABLE IF EXISTS `zppsvx_Table68`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zppsvx_Table68` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zppsvx_Table68`
--

LOCK TABLES `zppsvx_Table68` WRITE;
/*!40000 ALTER TABLE `zppsvx_Table68` DISABLE KEYS */;
INSERT INTO `zppsvx_Table68` VALUES ('      SUBROUTINE ZPPSVX( FACT, UPLO, N, NRHS, AP, AFP, EQUED, S, B, LDB,'),('     $                   X, LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          EQUED, FACT, UPLO'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * ), S( * )'),('      COMPLEX*16         AFP( * ), AP( * ), B( LDB, * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to'),('*  compute the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N Hermitian positive definite matrix stored in'),('*  packed format and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'E\', real scaling factors are computed to equilibrate'),('*     the system:'),('*        diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B'),('*     Whether or not the system will be equilibrated depends on the'),('*     scaling of the matrix A, but if equilibration is used, A is'),('*     overwritten by diag(S)*A*diag(S) and B by diag(S)*B.'),('*'),('*  2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to'),('*     factor the matrix A (after equilibration if FACT = \'E\') as'),('*        A = U\'* U ,  if UPLO = \'U\', or'),('*        A = L * L\',  if UPLO = \'L\','),('*     where U is an upper triangular matrix, L is a lower triangular'),('*     matrix, and \' indicates conjugate transpose.'),('*'),('*  3. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  4. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  5. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  6. If equilibration was used, the matrix X is premultiplied by'),('*     diag(S) so that it solves the original system before'),('*     equilibration.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix A is'),('*          supplied on entry, and if not, whether the matrix A should be'),('*          equilibrated before it is factored.'),('*          = \'F\':  On entry, AFP contains the factored form of A.'),('*                  If EQUED = \'Y\', the matrix A has been equilibrated'),('*                  with scaling factors given by S.  AP and AFP will not'),('*                  be modified.'),('*          = \'N\':  The matrix A will be copied to AFP and factored.'),('*          = \'E\':  The matrix A will be equilibrated if necessary, then'),('*                  copied to AFP and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the Hermitian matrix'),('*          A, packed columnwise in a linear array, except if FACT = \'F\''),('*          and EQUED = \'Y\', then A must contain the equilibrated matrix'),('*          diag(S)*A*diag(S).  The j-th column of A is stored in the'),('*          array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.  A is not modified if'),('*          FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.'),('*'),('*          On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by'),('*          diag(S)*A*diag(S).'),('*'),('*  AFP     (input or output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          If FACT = \'F\', then AFP is an input argument and on entry'),('*          contains the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H, in the same storage'),('*          format as A.  If EQUED .ne. \'N\', then AFP is the factored'),('*          form of the equilibrated matrix A.'),('*'),('*          If FACT = \'N\', then AFP is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the original'),('*          matrix A.'),('*'),('*          If FACT = \'E\', then AFP is an output argument and on exit'),('*          returns the triangular factor U or L from the Cholesky'),('*          factorization A = U**H*U or A = L*L**H of the equilibrated'),('*          matrix A (see the description of AP for the form of the'),('*          equilibrated matrix).'),('*'),('*  EQUED   (input or output) CHARACTER*1'),('*          Specifies the form of equilibration that was done.'),('*          = \'N\':  No equilibration (always true if FACT = \'N\').'),('*          = \'Y\':  Equilibration was done, i.e., A has been replaced by'),('*                  diag(S) * A * diag(S).'),('*          EQUED is an input argument if FACT = \'F\'; otherwise, it is an'),('*          output argument.'),('*'),('*  S       (input or output) DOUBLE PRECISION array, dimension (N)'),('*          The scale factors for A; not accessed if EQUED = \'N\'.  S is'),('*          an input argument if FACT = \'F\'; otherwise, S is an output'),('*          argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S'),('*          must be positive.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\','),('*          B is overwritten by diag(S) * B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to'),('*          the original system of equations.  Note that if EQUED = \'Y\','),('*          A and B are modified on exit, and the solution to the'),('*          equilibrated system is inv(diag(S))*X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A after equilibration (if done).  If RCOND is less than the'),('*          machine precision (in particular, if RCOND = 0), the matrix'),('*          is singular to working precision.  This condition is'),('*          indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the Hermitian matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = conjg(aji))'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `zppsvx_Table68` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zptsv_Table32`
--

DROP TABLE IF EXISTS `zptsv_Table32`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zptsv_Table32` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zptsv_Table32`
--

LOCK TABLES `zptsv_Table32` WRITE;
/*!40000 ALTER TABLE `zptsv_Table32` DISABLE KEYS */;
INSERT INTO `zptsv_Table32` VALUES ('      SUBROUTINE ZPTSV( N, NRHS, D, E, B, LDB, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   D( * )'),('      COMPLEX*16         B( LDB, * ), E( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZPTSV computes the solution to a complex system of linear equations'),('*  A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal'),('*  matrix, and X and B are N-by-NRHS matrices.'),('*'),('*  A is factored as A = L*D*L**H, and the factored form of A is then'),('*  used to solve the system of equations.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  D       (input/output) DOUBLE PRECISION array, dimension (N)'),('*          On entry, the n diagonal elements of the tridiagonal matrix'),('*          A.  On exit, the n diagonal elements of the diagonal matrix'),('*          D from the factorization A = L*D*L**H.'),('*'),('*  E       (input/output) COMPLEX*16 array, dimension (N-1)'),('*          On entry, the (n-1) subdiagonal elements of the tridiagonal'),('*          matrix A.  On exit, the (n-1) subdiagonal elements of the'),('*          unit bidiagonal factor L from the L*D*L**H factorization of'),('*          A.  E can also be regarded as the superdiagonal of the unit'),('*          bidiagonal factor U from the U**H*D*U factorization of A.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,N)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, the leading minor of order i is not'),('*                positive definite, and the solution has not been'),('*                computed.  The factorization has not been completed'),('*                unless i = N.'),('*');
/*!40000 ALTER TABLE `zptsv_Table32` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zptsvx_Table72`
--

DROP TABLE IF EXISTS `zptsvx_Table72`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zptsvx_Table72` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zptsvx_Table72`
--

LOCK TABLES `zptsvx_Table72` WRITE;
/*!40000 ALTER TABLE `zptsvx_Table72` DISABLE KEYS */;
INSERT INTO `zptsvx_Table72` VALUES ('      SUBROUTINE ZPTSVX( FACT, N, NRHS, D, E, DF, EF, B, LDB, X, LDX,'),('     $                   RCOND, FERR, BERR, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      DOUBLE PRECISION   BERR( * ), D( * ), DF( * ), FERR( * ),'),('     $                   RWORK( * )'),('      COMPLEX*16         B( LDB, * ), E( * ), EF( * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZPTSVX uses the factorization A = L*D*L**H to compute the solution'),('*  to a complex system of linear equations A*X = B, where A is an'),('*  N-by-N Hermitian positive definite tridiagonal matrix and X and B'),('*  are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the matrix A is factored as A = L*D*L**H, where L'),('*     is a unit lower bidiagonal matrix and D is diagonal.  The'),('*     factorization can also be regarded as having the form'),('*     A = U**H*D*U.'),('*'),('*  2. If the leading i-by-i principal minor is not positive definite,'),('*     then the routine returns with INFO = i. Otherwise, the factored'),('*     form of A is used to estimate the condition number of the matrix'),('*     A.  If the reciprocal of the condition number is less than machine'),('*     precision, INFO = N+1 is returned as a warning, but the routine'),('*     still goes on to solve for X and compute error bounds as'),('*     described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of the matrix'),('*          A is supplied on entry.'),('*          = \'F\':  On entry, DF and EF contain the factored form of A.'),('*                  D, E, DF, and EF will not be modified.'),('*          = \'N\':  The matrix A will be copied to DF and EF and'),('*                  factored.'),('*'),('*  N       (input) INTEGER'),('*          The order of the matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  D       (input) DOUBLE PRECISION array, dimension (N)'),('*          The n diagonal elements of the tridiagonal matrix A.'),('*'),('*  E       (input) COMPLEX*16 array, dimension (N-1)'),('*          The (n-1) subdiagonal elements of the tridiagonal matrix A.'),('*'),('*  DF      (input or output) DOUBLE PRECISION array, dimension (N)'),('*          If FACT = \'F\', then DF is an input argument and on entry'),('*          contains the n diagonal elements of the diagonal matrix D'),('*          from the L*D*L**H factorization of A.'),('*          If FACT = \'N\', then DF is an output argument and on exit'),('*          contains the n diagonal elements of the diagonal matrix D'),('*          from the L*D*L**H factorization of A.'),('*'),('*  EF      (input or output) COMPLEX*16 array, dimension (N-1)'),('*          If FACT = \'F\', then EF is an input argument and on entry'),('*          contains the (n-1) subdiagonal elements of the unit'),('*          bidiagonal factor L from the L*D*L**H factorization of A.'),('*          If FACT = \'N\', then EF is an output argument and on exit'),('*          contains the (n-1) subdiagonal elements of the unit'),('*          bidiagonal factor L from the L*D*L**H factorization of A.'),('*'),('*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The reciprocal condition number of the matrix A.  If RCOND'),('*          is less than the machine precision (in particular, if'),('*          RCOND = 0), the matrix is singular to working precision.'),('*          This condition is indicated by a return code of INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in any'),('*          element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  the leading minor of order i of A is'),('*                       not positive definite, so the factorization'),('*                       could not be completed, and the solution has not'),('*                       been computed. RCOND = 0 is returned.'),('*                = N+1: U is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `zptsvx_Table72` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zspsv_Table40`
--

DROP TABLE IF EXISTS `zspsv_Table40`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zspsv_Table40` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zspsv_Table40`
--

LOCK TABLES `zspsv_Table40` WRITE;
/*!40000 ALTER TABLE `zspsv_Table40` DISABLE KEYS */;
INSERT INTO `zspsv_Table40` VALUES ('      SUBROUTINE ZSPSV( UPLO, N, NRHS, AP, IPIV, B, LDB, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDB, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX*16         AP( * ), B( LDB, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZSPSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric matrix stored in packed format and X'),('*  and B are N-by-NRHS matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**T,  if UPLO = \'U\', or'),('*     A = L * D * L**T,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, D is symmetric and block diagonal with 1-by-1'),('*  and 2-by-2 diagonal blocks.  The factored form of A is then used to'),('*  solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  AP      (input/output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          On entry, the upper or lower triangle of the symmetric matrix'),('*          A, packed columnwise in a linear array.  The j-th column of A'),('*          is stored in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*          On exit, the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by ZSPTRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  INFO    (output) INTEGER'),('*          = 0:  successful exit'),('*          < 0:  if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization'),('*                has been completed, but the block diagonal matrix D is'),('*                exactly singular, so the solution could not be'),('*                computed.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = aji)'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `zspsv_Table40` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zspsvx_Table80`
--

DROP TABLE IF EXISTS `zspsvx_Table80`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zspsvx_Table80` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zspsvx_Table80`
--

LOCK TABLES `zspsvx_Table80` WRITE;
/*!40000 ALTER TABLE `zspsvx_Table80` DISABLE KEYS */;
INSERT INTO `zspsvx_Table80` VALUES ('      SUBROUTINE ZSPSVX( FACT, UPLO, N, NRHS, AP, AFP, IPIV, B, LDB, X,'),('     $                   LDX, RCOND, FERR, BERR, WORK, RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDB, LDX, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * )'),('      COMPLEX*16         AFP( * ), AP( * ), B( LDB, * ), WORK( * ),'),('     $                   X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZSPSVX uses the diagonal pivoting factorization A = U*D*U**T or'),('*  A = L*D*L**T to compute the solution to a complex system of linear'),('*  equations A * X = B, where A is an N-by-N symmetric matrix stored'),('*  in packed format and X and B are N-by-NRHS matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A as'),('*        A = U * D * U**T,  if UPLO = \'U\', or'),('*        A = L * D * L**T,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices and D is symmetric and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AFP and IPIV contain the factored form'),('*                  of A.  AP, AFP and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AFP and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  AP      (input) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          The upper or lower triangle of the symmetric matrix A, packed'),('*          columnwise in a linear array.  The j-th column of A is stored'),('*          in the array AP as follows:'),('*          if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;'),('*          if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.'),('*          See below for further details.'),('*'),('*  AFP     (input or output) COMPLEX*16 array, dimension (N*(N+1)/2)'),('*          If FACT = \'F\', then AFP is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*          If FACT = \'N\', then AFP is an output argument and on exit'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as'),('*          a packed triangular matrix in the same storage format as A.'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by ZSPTRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by ZSPTRF.'),('*'),('*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace) COMPLEX*16 array, dimension (2*N)'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0:  if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*'),('*  Further Details'),('*  ==============='),('*'),('*  The packed storage scheme is illustrated by the following example'),('*  when N = 4, UPLO = \'U\':'),('*'),('*  Two-dimensional storage of the symmetric matrix A:'),('*'),('*     a11 a12 a13 a14'),('*         a22 a23 a24'),('*             a33 a34     (aij = aji)'),('*                 a44'),('*'),('*  Packed storage of the upper triangle of A:'),('*'),('*  AP = [ a11, a12, a22, a13, a23, a33, a14, a24, a34, a44 ]'),('*');
/*!40000 ALTER TABLE `zspsvx_Table80` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zsysv_Table36`
--

DROP TABLE IF EXISTS `zsysv_Table36`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zsysv_Table36` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zsysv_Table36`
--

LOCK TABLES `zsysv_Table36` WRITE;
/*!40000 ALTER TABLE `zsysv_Table36` DISABLE KEYS */;
INSERT INTO `zsysv_Table36` VALUES ('      SUBROUTINE ZSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK,'),('     $                  LWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     June 2010'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          UPLO'),('      INTEGER            INFO, LDA, LDB, LWORK, N, NRHS'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      COMPLEX*16         A( LDA, * ), B( LDB, * ), WORK( * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZSYSV computes the solution to a complex system of linear equations'),('*     A * X = B,'),('*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  The diagonal pivoting method is used to factor A as'),('*     A = U * D * U**T,  if UPLO = \'U\', or'),('*     A = L * D * L**T,  if UPLO = \'L\','),('*  where U (or L) is a product of permutation and unit upper (lower)'),('*  triangular matrices, and D is symmetric and block diagonal with'),('*  1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then'),('*  used to solve the system of equations A * X = B.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrix B.  NRHS >= 0.'),('*'),('*  A       (input/output) COMPLEX*16 array, dimension (LDA,N)'),('*          On entry, the symmetric matrix A.  If UPLO = \'U\', the leading'),('*          N-by-N upper triangular part of A contains the upper'),('*          triangular part of the matrix A, and the strictly lower'),('*          triangular part of A is not referenced.  If UPLO = \'L\', the'),('*          leading N-by-N lower triangular part of A contains the lower'),('*          triangular part of the matrix A, and the strictly upper'),('*          triangular part of A is not referenced.'),('*'),('*          On exit, if INFO = 0, the block diagonal matrix D and the'),('*          multipliers used to obtain the factor U or L from the'),('*          factorization A = U*D*U**T or A = L*D*L**T as computed by'),('*          ZSYTRF.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  IPIV    (output) INTEGER array, dimension (N)'),('*          Details of the interchanges and the block structure of D, as'),('*          determined by ZSYTRF.  If IPIV(k) > 0, then rows and columns'),('*          k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1'),('*          diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,'),('*          then rows and columns k-1 and -IPIV(k) were interchanged and'),('*          D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and'),('*          IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and'),('*          -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2'),('*          diagonal block.'),('*'),('*  B       (input/output) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          On entry, the N-by-NRHS right hand side matrix B.'),('*          On exit, if INFO = 0, the N-by-NRHS solution matrix X.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= 1, and for best performance'),('*          LWORK >= max(1,N*NB), where NB is the optimal blocksize for'),('*          ZSYTRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, D(i,i) is exactly zero.  The factorization'),('*               has been completed, but the block diagonal matrix D is'),('*               exactly singular, so the solution could not be computed.'),('*');
/*!40000 ALTER TABLE `zsysv_Table36` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `zsysvx_Table76`
--

DROP TABLE IF EXISTS `zsysvx_Table76`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `zsysvx_Table76` (
  `content` mediumtext,
  FULLTEXT KEY `content` (`content`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `zsysvx_Table76`
--

LOCK TABLES `zsysvx_Table76` WRITE;
/*!40000 ALTER TABLE `zsysvx_Table76` DISABLE KEYS */;
INSERT INTO `zsysvx_Table76` VALUES ('      SUBROUTINE ZSYSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B,'),('     $                   LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK,'),('     $                   RWORK, INFO )'),('*'),('*  -- LAPACK driver routine (version 3.2) --'),('*  -- LAPACK is a software package provided by Univ. of Tennessee,    --'),('*  -- Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..--'),('*     November 2006'),('*'),('*     .. Scalar Arguments ..'),('      CHARACTER          FACT, UPLO'),('      INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS'),('      DOUBLE PRECISION   RCOND'),('*     ..'),('*     .. Array Arguments ..'),('      INTEGER            IPIV( * )'),('      DOUBLE PRECISION   BERR( * ), FERR( * ), RWORK( * )'),('      COMPLEX*16         A( LDA, * ), AF( LDAF, * ), B( LDB, * ),'),('     $                   WORK( * ), X( LDX, * )'),('*     ..'),('*'),('*  Purpose'),('*  ======='),('*'),('*  ZSYSVX uses the diagonal pivoting factorization to compute the'),('*  solution to a complex system of linear equations A * X = B,'),('*  where A is an N-by-N symmetric matrix and X and B are N-by-NRHS'),('*  matrices.'),('*'),('*  Error bounds on the solution and a condition estimate are also'),('*  provided.'),('*'),('*  Description'),('*  ==========='),('*'),('*  The following steps are performed:'),('*'),('*  1. If FACT = \'N\', the diagonal pivoting method is used to factor A.'),('*     The form of the factorization is'),('*        A = U * D * U**T,  if UPLO = \'U\', or'),('*        A = L * D * L**T,  if UPLO = \'L\','),('*     where U (or L) is a product of permutation and unit upper (lower)'),('*     triangular matrices, and D is symmetric and block diagonal with'),('*     1-by-1 and 2-by-2 diagonal blocks.'),('*'),('*  2. If some D(i,i)=0, so that D is exactly singular, then the routine'),('*     returns with INFO = i. Otherwise, the factored form of A is used'),('*     to estimate the condition number of the matrix A.  If the'),('*     reciprocal of the condition number is less than machine precision,'),('*     INFO = N+1 is returned as a warning, but the routine still goes on'),('*     to solve for X and compute error bounds as described below.'),('*'),('*  3. The system of equations is solved for X using the factored form'),('*     of A.'),('*'),('*  4. Iterative refinement is applied to improve the computed solution'),('*     matrix and calculate error bounds and backward error estimates'),('*     for it.'),('*'),('*  Arguments'),('*  ========='),('*'),('*  FACT    (input) CHARACTER*1'),('*          Specifies whether or not the factored form of A has been'),('*          supplied on entry.'),('*          = \'F\':  On entry, AF and IPIV contain the factored form'),('*                  of A.  A, AF and IPIV will not be modified.'),('*          = \'N\':  The matrix A will be copied to AF and factored.'),('*'),('*  UPLO    (input) CHARACTER*1'),('*          = \'U\':  Upper triangle of A is stored;'),('*          = \'L\':  Lower triangle of A is stored.'),('*'),('*  N       (input) INTEGER'),('*          The number of linear equations, i.e., the order of the'),('*          matrix A.  N >= 0.'),('*'),('*  NRHS    (input) INTEGER'),('*          The number of right hand sides, i.e., the number of columns'),('*          of the matrices B and X.  NRHS >= 0.'),('*'),('*  A       (input) COMPLEX*16 array, dimension (LDA,N)'),('*          The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N'),('*          upper triangular part of A contains the upper triangular part'),('*          of the matrix A, and the strictly lower triangular part of A'),('*          is not referenced.  If UPLO = \'L\', the leading N-by-N lower'),('*          triangular part of A contains the lower triangular part of'),('*          the matrix A, and the strictly upper triangular part of A is'),('*          not referenced.'),('*'),('*  LDA     (input) INTEGER'),('*          The leading dimension of the array A.  LDA >= max(1,N).'),('*'),('*  AF      (input or output) COMPLEX*16 array, dimension (LDAF,N)'),('*          If FACT = \'F\', then AF is an input argument and on entry'),('*          contains the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T as computed by ZSYTRF.'),('*'),('*          If FACT = \'N\', then AF is an output argument and on exit'),('*          returns the block diagonal matrix D and the multipliers used'),('*          to obtain the factor U or L from the factorization'),('*          A = U*D*U**T or A = L*D*L**T.'),('*'),('*  LDAF    (input) INTEGER'),('*          The leading dimension of the array AF.  LDAF >= max(1,N).'),('*'),('*  IPIV    (input or output) INTEGER array, dimension (N)'),('*          If FACT = \'F\', then IPIV is an input argument and on entry'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by ZSYTRF.'),('*          If IPIV(k) > 0, then rows and columns k and IPIV(k) were'),('*          interchanged and D(k,k) is a 1-by-1 diagonal block.'),('*          If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and'),('*          columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)'),('*          is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) ='),('*          IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were'),('*          interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.'),('*'),('*          If FACT = \'N\', then IPIV is an output argument and on exit'),('*          contains details of the interchanges and the block structure'),('*          of D, as determined by ZSYTRF.'),('*'),('*  B       (input) COMPLEX*16 array, dimension (LDB,NRHS)'),('*          The N-by-NRHS right hand side matrix B.'),('*'),('*  LDB     (input) INTEGER'),('*          The leading dimension of the array B.  LDB >= max(1,N).'),('*'),('*  X       (output) COMPLEX*16 array, dimension (LDX,NRHS)'),('*          If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.'),('*'),('*  LDX     (input) INTEGER'),('*          The leading dimension of the array X.  LDX >= max(1,N).'),('*'),('*  RCOND   (output) DOUBLE PRECISION'),('*          The estimate of the reciprocal condition number of the matrix'),('*          A.  If RCOND is less than the machine precision (in'),('*          particular, if RCOND = 0), the matrix is singular to working'),('*          precision.  This condition is indicated by a return code of'),('*          INFO > 0.'),('*'),('*  FERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The estimated forward error bound for each solution vector'),('*          X(j) (the j-th column of the solution matrix X).'),('*          If XTRUE is the true solution corresponding to X(j), FERR(j)'),('*          is an estimated upper bound for the magnitude of the largest'),('*          element in (X(j) - XTRUE) divided by the magnitude of the'),('*          largest element in X(j).  The estimate is as reliable as'),('*          the estimate for RCOND, and is almost always a slight'),('*          overestimate of the true error.'),('*'),('*  BERR    (output) DOUBLE PRECISION array, dimension (NRHS)'),('*          The componentwise relative backward error of each solution'),('*          vector X(j) (i.e., the smallest relative change in'),('*          any element of A or B that makes X(j) an exact solution).'),('*'),('*  WORK    (workspace/output) COMPLEX*16 array, dimension (MAX(1,LWORK))'),('*          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.'),('*'),('*  LWORK   (input) INTEGER'),('*          The length of WORK.  LWORK >= max(1,2*N), and for best'),('*          performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where'),('*          NB is the optimal blocksize for ZSYTRF.'),('*'),('*          If LWORK = -1, then a workspace query is assumed; the routine'),('*          only calculates the optimal size of the WORK array, returns'),('*          this value as the first entry of the WORK array, and no error'),('*          message related to LWORK is issued by XERBLA.'),('*'),('*  RWORK   (workspace) DOUBLE PRECISION array, dimension (N)'),('*'),('*  INFO    (output) INTEGER'),('*          = 0: successful exit'),('*          < 0: if INFO = -i, the i-th argument had an illegal value'),('*          > 0: if INFO = i, and i is'),('*                <= N:  D(i,i) is exactly zero.  The factorization'),('*                       has been completed but the factor D is exactly'),('*                       singular, so the solution and error bounds could'),('*                       not be computed. RCOND = 0 is returned.'),('*                = N+1: D is nonsingular, but RCOND is less than machine'),('*                       precision, meaning that the matrix is singular'),('*                       to working precision.  Nevertheless, the'),('*                       solution and error bounds are computed because'),('*                       there are a number of situations where the'),('*                       computed solution can be more accurate than the'),('*                       value of RCOND would suggest.'),('*');
/*!40000 ALTER TABLE `zsysvx_Table76` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2011-03-30 17:12:13
