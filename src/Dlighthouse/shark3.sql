-- MySQL dump 10.13  Distrib 5.5.21, for osx10.5 (i386)
--
-- Host: localhost    Database: shark
-- ------------------------------------------------------
-- Server version	5.5.21

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!40101 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `Driver_routineinfo`
--

DROP TABLE IF EXISTS `Driver_routineinfo`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `Driver_routineinfo` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `routine` varchar(30) NOT NULL,
  `info` longtext,
  PRIMARY KEY (`id`)
) ENGINE=MyISAM AUTO_INCREMENT=457 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `Driver_routineinfo`
--

LOCK TABLES `Driver_routineinfo` WRITE;
/*!40000 ALTER TABLE `Driver_routineinfo` DISABLE KEYS */;
INSERT INTO `Driver_routineinfo` VALUES (1,'sgesv_1.txt','SGESV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N matrix and X and B are N-by-NRHS matrices.\nThe LU decomposition with partial pivoting and row interchanges is\nused to factor A as\n   A = P * L * U,\nwhere P is a permutation matrix, L is unit lower triangular, and U is\nupper triangular.  The factored form of A is then used to solve the\nsystem of equations A * X = B.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the N-by-N coefficient matrix A.\n         On exit, the factors L and U from the factorization\n         A = P*L*U; the unit diagonal elements of L are not stored.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices that define the permutation matrix P;\n         row i of the matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS matrix of right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n               has been completed, but the factor U is exactly\n               singular, so the solution could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGEsolve\n'),(2,'dgesv_2.txt','DGESV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N matrix and X and B are N-by-NRHS matrices.\nThe LU decomposition with partial pivoting and row interchanges is\nused to factor A as\n   A = P * L * U,\nwhere P is a permutation matrix, L is unit lower triangular, and U is\nupper triangular.  The factored form of A is then used to solve the\nsystem of equations A * X = B.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the N-by-N coefficient matrix A.\n         On exit, the factors L and U from the factorization\n         A = P*L*U; the unit diagonal elements of L are not stored.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices that define the permutation matrix P;\n         row i of the matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS matrix of right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n               has been completed, but the factor U is exactly\n               singular, so the solution could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEsolve\n'),(3,'cgesv_3.txt','CGESV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N matrix and X and B are N-by-NRHS matrices.\nThe LU decomposition with partial pivoting and row interchanges is\nused to factor A as\n   A = P * L * U,\nwhere P is a permutation matrix, L is unit lower triangular, and U is\nupper triangular.  The factored form of A is then used to solve the\nsystem of equations A * X = B.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the N-by-N coefficient matrix A.\n         On exit, the factors L and U from the factorization\n         A = P*L*U; the unit diagonal elements of L are not stored.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices that define the permutation matrix P;\n         row i of the matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS matrix of right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n               has been completed, but the factor U is exactly\n               singular, so the solution could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEsolve\n'),(4,'zgesv_4.txt','ZGESV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N matrix and X and B are N-by-NRHS matrices.\nThe LU decomposition with partial pivoting and row interchanges is\nused to factor A as\n   A = P * L * U,\nwhere P is a permutation matrix, L is unit lower triangular, and U is\nupper triangular.  The factored form of A is then used to solve the\nsystem of equations A * X = B.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the N-by-N coefficient matrix A.\n         On exit, the factors L and U from the factorization\n         A = P*L*U; the unit diagonal elements of L are not stored.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices that define the permutation matrix P;\n         row i of the matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS matrix of right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n               has been completed, but the factor U is exactly\n               singular, so the solution could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEsolve\n'),(5,'sgbsv_5.txt','SGBSV computes the solution to a real system of linear equations\nA * X = B, where A is a band matrix of order N with KL subdiagonals\nand KU superdiagonals, and X and B are N-by-NRHS matrices.\nThe LU decomposition with partial pivoting and row interchanges is\nused to factor A as A = L * U, where L is a product of permutation\nand unit lower triangular matrices with KL subdiagonals, and U is\nupper triangular with KL+KU superdiagonals.  The factored form of A\nis then used to solve the system of equations A * X = B.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AB\n         AB is REAL array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows KL+1 to\n         2*KL+KU+1; rows 1 to KL of the array need not be set.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)\n         On exit, details of the factorization: U is stored as an\n         upper triangular band matrix with KL+KU superdiagonals in\n         rows 1 to KL+KU+1, and the multipliers used during the\n         factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n         See below for further details.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices that define the permutation matrix P;\n         row i of the matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n               has been completed, but the factor U is exactly\n               singular, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGBsolve\n'),(6,'dgbsv_6.txt','DGBSV computes the solution to a real system of linear equations\nA * X = B, where A is a band matrix of order N with KL subdiagonals\nand KU superdiagonals, and X and B are N-by-NRHS matrices.\nThe LU decomposition with partial pivoting and row interchanges is\nused to factor A as A = L * U, where L is a product of permutation\nand unit lower triangular matrices with KL subdiagonals, and U is\nupper triangular with KL+KU superdiagonals.  The factored form of A\nis then used to solve the system of equations A * X = B.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows KL+1 to\n         2*KL+KU+1; rows 1 to KL of the array need not be set.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)\n         On exit, details of the factorization: U is stored as an\n         upper triangular band matrix with KL+KU superdiagonals in\n         rows 1 to KL+KU+1, and the multipliers used during the\n         factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n         See below for further details.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices that define the permutation matrix P;\n         row i of the matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n               has been completed, but the factor U is exactly\n               singular, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGBsolve\n'),(7,'cgbsv_7.txt','CGBSV computes the solution to a complex system of linear equations\nA * X = B, where A is a band matrix of order N with KL subdiagonals\nand KU superdiagonals, and X and B are N-by-NRHS matrices.\nThe LU decomposition with partial pivoting and row interchanges is\nused to factor A as A = L * U, where L is a product of permutation\nand unit lower triangular matrices with KL subdiagonals, and U is\nupper triangular with KL+KU superdiagonals.  The factored form of A\nis then used to solve the system of equations A * X = B.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows KL+1 to\n         2*KL+KU+1; rows 1 to KL of the array need not be set.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)\n         On exit, details of the factorization: U is stored as an\n         upper triangular band matrix with KL+KU superdiagonals in\n         rows 1 to KL+KU+1, and the multipliers used during the\n         factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n         See below for further details.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices that define the permutation matrix P;\n         row i of the matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n               has been completed, but the factor U is exactly\n               singular, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGBsolve\n'),(8,'zgbsv_8.txt','ZGBSV computes the solution to a complex system of linear equations\nA * X = B, where A is a band matrix of order N with KL subdiagonals\nand KU superdiagonals, and X and B are N-by-NRHS matrices.\nThe LU decomposition with partial pivoting and row interchanges is\nused to factor A as A = L * U, where L is a product of permutation\nand unit lower triangular matrices with KL subdiagonals, and U is\nupper triangular with KL+KU superdiagonals.  The factored form of A\nis then used to solve the system of equations A * X = B.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows KL+1 to\n         2*KL+KU+1; rows 1 to KL of the array need not be set.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KL+KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+KL)\n         On exit, details of the factorization: U is stored as an\n         upper triangular band matrix with KL+KU superdiagonals in\n         rows 1 to KL+KU+1, and the multipliers used during the\n         factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n         See below for further details.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices that define the permutation matrix P;\n         row i of the matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero.  The factorization\n               has been completed, but the factor U is exactly\n               singular, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GBsolve\n'),(9,'sgtsv_9.txt','SGTSV  solves the equation\n   A*X = B,\nwhere A is an n by n tridiagonal matrix, by Gaussian elimination with\npartial pivoting.\nNote that the equation  A**T*X = B  may be solved by interchanging the\norder of the arguments DU and DL.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] DL\n         DL is REAL array, dimension (N-1)\n         On entry, DL must contain the (n-1) sub-diagonal elements of\n         A.\n         On exit, DL is overwritten by the (n-2) elements of the\n         second super-diagonal of the upper triangular matrix U from\n         the LU factorization of A, in DL(1), ..., DL(n-2).\n\\param[in,out] D\n         D is REAL array, dimension (N)\n         On entry, D must contain the diagonal elements of A.\n         On exit, D is overwritten by the n diagonal elements of U.\n\\param[in,out] DU\n         DU is REAL array, dimension (N-1)\n         On entry, DU must contain the (n-1) super-diagonal elements\n         of A.\n         On exit, DU is overwritten by the (n-1) elements of the first\n         super-diagonal of U.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N by NRHS matrix of right hand side matrix B.\n         On exit, if INFO = 0, the N by NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, U(i,i) is exactly zero, and the solution\n              has not been computed.  The factorization has not been\n              completed unless i = N.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(10,'dgtsv_10.txt','DGTSV  solves the equation\n   A*X = B,\nwhere A is an n by n tridiagonal matrix, by Gaussian elimination with\npartial pivoting.\nNote that the equation  A**T*X = B  may be solved by interchanging the\norder of the arguments DU and DL.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] DL\n         DL is DOUBLE PRECISION array, dimension (N-1)\n         On entry, DL must contain the (n-1) sub-diagonal elements of\n         A.\n         On exit, DL is overwritten by the (n-2) elements of the\n         second super-diagonal of the upper triangular matrix U from\n         the LU factorization of A, in DL(1), ..., DL(n-2).\n\\param[in,out] D\n         D is DOUBLE PRECISION array, dimension (N)\n         On entry, D must contain the diagonal elements of A.\n         On exit, D is overwritten by the n diagonal elements of U.\n\\param[in,out] DU\n         DU is DOUBLE PRECISION array, dimension (N-1)\n         On entry, DU must contain the (n-1) super-diagonal elements\n         of A.\n         On exit, DU is overwritten by the (n-1) elements of the first\n         super-diagonal of U.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N by NRHS matrix of right hand side matrix B.\n         On exit, if INFO = 0, the N by NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, U(i,i) is exactly zero, and the solution\n              has not been computed.  The factorization has not been\n              completed unless i = N.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(11,'cgtsv_11.txt','CGTSV  solves the equation\n   A*X = B,\nwhere A is an N-by-N tridiagonal matrix, by Gaussian elimination with\npartial pivoting.\nNote that the equation  A**T *X = B  may be solved by interchanging the\norder of the arguments DU and DL.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] DL\n         DL is COMPLEX array, dimension (N-1)\n         On entry, DL must contain the (n-1) subdiagonal elements of\n         A.\n         On exit, DL is overwritten by the (n-2) elements of the\n         second superdiagonal of the upper triangular matrix U from\n         the LU factorization of A, in DL(1), ..., DL(n-2).\n\\param[in,out] D\n         D is COMPLEX array, dimension (N)\n         On entry, D must contain the diagonal elements of A.\n         On exit, D is overwritten by the n diagonal elements of U.\n\\param[in,out] DU\n         DU is COMPLEX array, dimension (N-1)\n         On entry, DU must contain the (n-1) superdiagonal elements\n         of A.\n         On exit, DU is overwritten by the (n-1) elements of the first\n         superdiagonal of U.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero, and the solution\n               has not been computed.  The factorization has not been\n               completed unless i = N.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(12,'zgtsv_12.txt','ZGTSV  solves the equation\n   A*X = B,\nwhere A is an N-by-N tridiagonal matrix, by Gaussian elimination with\npartial pivoting.\nNote that the equation  A**T *X = B  may be solved by interchanging the\norder of the arguments DU and DL.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] DL\n         DL is COMPLEX*16 array, dimension (N-1)\n         On entry, DL must contain the (n-1) subdiagonal elements of\n         A.\n         On exit, DL is overwritten by the (n-2) elements of the\n         second superdiagonal of the upper triangular matrix U from\n         the LU factorization of A, in DL(1), ..., DL(n-2).\n\\param[in,out] D\n         D is COMPLEX*16 array, dimension (N)\n         On entry, D must contain the diagonal elements of A.\n         On exit, D is overwritten by the n diagonal elements of U.\n\\param[in,out] DU\n         DU is COMPLEX*16 array, dimension (N-1)\n         On entry, DU must contain the (n-1) superdiagonal elements\n         of A.\n         On exit, DU is overwritten by the (n-1) elements of the first\n         superdiagonal of U.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero, and the solution\n               has not been computed.  The factorization has not been\n               completed unless i = N.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(13,'chesv_13.txt','CHESV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian matrix and X and B are N-by-NRHS\nmatrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**H,  if UPLO = \'U\', or\n   A = L * D * L**H,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is Hermitian and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\nused to solve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the block diagonal matrix D and the\n         multipliers used to obtain the factor U or L from the\n         factorization A = U*D*U**H or A = L*D*L**H as computed by\n         CHETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by CHETRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= 1, and for best performance\n         LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n         CHETRF.\n         for LWORK < N, TRS will be done with Level BLAS 2\n         for LWORK >= N, TRS will be done with Level BLAS 3\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, so the solution could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEsolve\n'),(14,'zhesv_14.txt','ZHESV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian matrix and X and B are N-by-NRHS\nmatrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**H,  if UPLO = \'U\', or\n   A = L * D * L**H,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is Hermitian and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\nused to solve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the block diagonal matrix D and the\n         multipliers used to obtain the factor U or L from the\n         factorization A = U*D*U**H or A = L*D*L**H as computed by\n         ZHETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by ZHETRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= 1, and for best performance\n         LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n         ZHETRF.\n         for LWORK < N, TRS will be done with Level BLAS 2\n         for LWORK >= N, TRS will be done with Level BLAS 3\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, so the solution could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEsolve\n'),(15,'chpsv_15.txt','CHPSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian matrix stored in packed format and X\nand B are N-by-NRHS matrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**H,  if UPLO = \'U\', or\n   A = L * D * L**H,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, D is Hermitian and block diagonal with 1-by-1\nand 2-by-2 diagonal blocks.  The factored form of A is then used to\nsolve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the Hermitian matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by CHPTRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, so the solution could not be\n               computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERsolve\n'),(16,'zhpsv_16.txt','ZHPSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian matrix stored in packed format and X\nand B are N-by-NRHS matrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**H,  if UPLO = \'U\', or\n   A = L * D * L**H,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, D is Hermitian and block diagonal with 1-by-1\nand 2-by-2 diagonal blocks.  The factored form of A is then used to\nsolve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the Hermitian matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by ZHPTRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, so the solution could not be\n               computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERsolve\n'),(17,'sposv_17.txt','SPOSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite matrix and X and B\nare N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**T* U,  if UPLO = \'U\', or\n   A = L * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is a lower triangular\nmatrix.  The factored form of A is then used to solve the system of\nequations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realPOsolve\n'),(18,'dposv_18.txt','DPOSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite matrix and X and B\nare N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**T* U,  if UPLO = \'U\', or\n   A = L * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is a lower triangular\nmatrix.  The factored form of A is then used to solve the system of\nequations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doublePOsolve\n'),(19,'cposv_19.txt','CPOSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite matrix and X and B\nare N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**H* U,  if UPLO = \'U\', or\n   A = L * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and  L is a lower triangular\nmatrix.  The factored form of A is then used to solve the system of\nequations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexPOsolve\n'),(20,'zposv_20.txt','ZPOSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite matrix and X and B\nare N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**H* U,  if UPLO = \'U\', or\n   A = L * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and  L is a lower triangular\nmatrix.  The factored form of A is then used to solve the system of\nequations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**H *U or A = L*L**H.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POsolve\n'),(21,'spbsv_21.txt','SPBSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite band matrix and X\nand B are N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular band matrix, and L is a lower\ntriangular band matrix, with the same number of superdiagonals or\nsubdiagonals as A.  The factored form of A is then used to solve the\nsystem of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AB\n         AB is REAL array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the symmetric band\n         matrix A, stored in the first KD+1 rows of the array.  The\n         j-th column of A is stored in the j-th column of the array AB\n         as follows:\n         if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n         See below for further details.\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**T*U or A = L*L**T of the band\n         matrix A, in the same storage format as A.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERsolve\n'),(22,'dpbsv_22.txt','DPBSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite band matrix and X\nand B are N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular band matrix, and L is a lower\ntriangular band matrix, with the same number of superdiagonals or\nsubdiagonals as A.  The factored form of A is then used to solve the\nsystem of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the symmetric band\n         matrix A, stored in the first KD+1 rows of the array.  The\n         j-th column of A is stored in the j-th column of the array AB\n         as follows:\n         if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n         See below for further details.\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**T*U or A = L*L**T of the band\n         matrix A, in the same storage format as A.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERsolve\n'),(23,'cpbsv_23.txt','CPBSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite band matrix and X\nand B are N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular band matrix, and L is a lower\ntriangular band matrix, with the same number of superdiagonals or\nsubdiagonals as A.  The factored form of A is then used to solve the\nsystem of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the Hermitian band\n         matrix A, stored in the first KD+1 rows of the array.  The\n         j-th column of A is stored in the j-th column of the array AB\n         as follows:\n         if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n         See below for further details.\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**H*U or A = L*L**H of the band\n         matrix A, in the same storage format as A.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERsolve\n'),(24,'zpbsv_24.txt','ZPBSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite band matrix and X\nand B are N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular band matrix, and L is a lower\ntriangular band matrix, with the same number of superdiagonals or\nsubdiagonals as A.  The factored form of A is then used to solve the\nsystem of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the Hermitian band\n         matrix A, stored in the first KD+1 rows of the array.  The\n         j-th column of A is stored in the j-th column of the array AB\n         as follows:\n         if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n         See below for further details.\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**H *U or A = L*L**H of the band\n         matrix A, in the same storage format as A.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERsolve\n'),(25,'sppsv_25.txt','SPPSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite matrix stored in\npacked format and X and B are N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**T* U,  if UPLO = \'U\', or\n   A = L * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is a lower triangular\nmatrix.  The factored form of A is then used to solve the system of\nequations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.  \n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T, in the same storage\n         format as A.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERsolve\n'),(26,'dppsv_26.txt','DPPSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite matrix stored in\npacked format and X and B are N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**T* U,  if UPLO = \'U\', or\n   A = L * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is a lower triangular\nmatrix.  The factored form of A is then used to solve the system of\nequations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T, in the same storage\n         format as A.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERsolve\n'),(27,'cppsv_27.txt','CPPSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite matrix stored in\npacked format and X and B are N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is a lower triangular\nmatrix.  The factored form of A is then used to solve the system of\nequations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the Hermitian matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H, in the same storage\n         format as A.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERsolve\n'),(28,'zppsv_28.txt','ZPPSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite matrix stored in\npacked format and X and B are N-by-NRHS matrices.\nThe Cholesky decomposition is used to factor A as\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is a lower triangular\nmatrix.  The factored form of A is then used to solve the system of\nequations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the Hermitian matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H, in the same storage\n         format as A.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of A is not\n               positive definite, so the factorization could not be\n               completed, and the solution has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERsolve\n'),(29,'sptsv_29.txt','SPTSV computes the solution to a real system of linear equations\nA*X = B, where A is an N-by-N symmetric positive definite tridiagonal\nmatrix, and X and B are N-by-NRHS matrices.\nA is factored as A = L*D*L**T, and the factored form of A is then\nused to solve the system of equations.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] D\n         D is REAL array, dimension (N)\n         On entry, the n diagonal elements of the tridiagonal matrix\n         A.  On exit, the n diagonal elements of the diagonal matrix\n         D from the factorization A = L*D*L**T.\n\\param[in,out] E\n         E is REAL array, dimension (N-1)\n         On entry, the (n-1) subdiagonal elements of the tridiagonal\n         matrix A.  On exit, the (n-1) subdiagonal elements of the\n         unit bidiagonal factor L from the L*D*L**T factorization of\n         A.  (E can also be regarded as the superdiagonal of the unit\n         bidiagonal factor U from the U**T*D*U factorization of A.)\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the solution has not been\n               computed.  The factorization has not been completed\n               unless i = N.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(30,'dptsv_30.txt','DPTSV computes the solution to a real system of linear equations\nA*X = B, where A is an N-by-N symmetric positive definite tridiagonal\nmatrix, and X and B are N-by-NRHS matrices.\nA is factored as A = L*D*L**T, and the factored form of A is then\nused to solve the system of equations.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] D\n         D is DOUBLE PRECISION array, dimension (N)\n         On entry, the n diagonal elements of the tridiagonal matrix\n         A.  On exit, the n diagonal elements of the diagonal matrix\n         D from the factorization A = L*D*L**T.\n\\param[in,out] E\n         E is DOUBLE PRECISION array, dimension (N-1)\n         On entry, the (n-1) subdiagonal elements of the tridiagonal\n         matrix A.  On exit, the (n-1) subdiagonal elements of the\n         unit bidiagonal factor L from the L*D*L**T factorization of\n         A.  (E can also be regarded as the superdiagonal of the unit\n         bidiagonal factor U from the U**T*D*U factorization of A.)\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the solution has not been\n               computed.  The factorization has not been completed\n               unless i = N.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(31,'cptsv_31.txt','CPTSV computes the solution to a complex system of linear equations\nA*X = B, where A is an N-by-N Hermitian positive definite tridiagonal\nmatrix, and X and B are N-by-NRHS matrices.\nA is factored as A = L*D*L**H, and the factored form of A is then\nused to solve the system of equations.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] D\n         D is REAL array, dimension (N)\n         On entry, the n diagonal elements of the tridiagonal matrix\n         A.  On exit, the n diagonal elements of the diagonal matrix\n         D from the factorization A = L*D*L**H.\n\\param[in,out] E\n         E is COMPLEX array, dimension (N-1)\n         On entry, the (n-1) subdiagonal elements of the tridiagonal\n         matrix A.  On exit, the (n-1) subdiagonal elements of the\n         unit bidiagonal factor L from the L*D*L**H factorization of\n         A.  E can also be regarded as the superdiagonal of the unit\n         bidiagonal factor U from the U**H*D*U factorization of A.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the solution has not been\n               computed.  The factorization has not been completed\n               unless i = N.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(32,'zptsv_32.txt','ZPTSV computes the solution to a complex system of linear equations\nA*X = B, where A is an N-by-N Hermitian positive definite tridiagonal\nmatrix, and X and B are N-by-NRHS matrices.\nA is factored as A = L*D*L**H, and the factored form of A is then\nused to solve the system of equations.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] D\n         D is DOUBLE PRECISION array, dimension (N)\n         On entry, the n diagonal elements of the tridiagonal matrix\n         A.  On exit, the n diagonal elements of the diagonal matrix\n         D from the factorization A = L*D*L**H.\n\\param[in,out] E\n         E is COMPLEX*16 array, dimension (N-1)\n         On entry, the (n-1) subdiagonal elements of the tridiagonal\n         matrix A.  On exit, the (n-1) subdiagonal elements of the\n         unit bidiagonal factor L from the L*D*L**H factorization of\n         A.  E can also be regarded as the superdiagonal of the unit\n         bidiagonal factor U from the U**H*D*U factorization of A.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the solution has not been\n               computed.  The factorization has not been completed\n               unless i = N.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(33,'ssysv_33.txt','SSYSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric matrix and X and B are N-by-NRHS\nmatrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**T,  if UPLO = \'U\', or\n   A = L * D * L**T,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\nused to solve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the block diagonal matrix D and the\n         multipliers used to obtain the factor U or L from the\n         factorization A = U*D*U**T or A = L*D*L**T as computed by\n         SSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by SSYTRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is REAL array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= 1, and for best performance\n         LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n         SSYTRF.\n         for LWORK < N, TRS will be done with Level BLAS 2\n         for LWORK >= N, TRS will be done with Level BLAS 3\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, so the solution could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYsolve\n'),(34,'dsysv_34.txt','DSYSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric matrix and X and B are N-by-NRHS\nmatrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**T,  if UPLO = \'U\', or\n   A = L * D * L**T,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\nused to solve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the block diagonal matrix D and the\n         multipliers used to obtain the factor U or L from the\n         factorization A = U*D*U**T or A = L*D*L**T as computed by\n         DSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by DSYTRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= 1, and for best performance\n         LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n         DSYTRF.\n         for LWORK < N, TRS will be done with Level BLAS 2\n         for LWORK >= N, TRS will be done with Level BLAS 3\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, so the solution could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYsolve\n'),(35,'csysv_35.txt','CSYSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric matrix and X and B are N-by-NRHS\nmatrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**T,  if UPLO = \'U\', or\n   A = L * D * L**T,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\nused to solve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the block diagonal matrix D and the\n         multipliers used to obtain the factor U or L from the\n         factorization A = U*D*U**T or A = L*D*L**T as computed by\n         CSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by CSYTRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= 1, and for best performance\n         LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n         CSYTRF.\n         for LWORK < N, TRS will be done with Level BLAS 2\n         for LWORK >= N, TRS will be done with Level BLAS 3\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, so the solution could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYsolve\n'),(36,'zsysv_36.txt','ZSYSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric matrix and X and B are N-by-NRHS\nmatrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**T,  if UPLO = \'U\', or\n   A = L * D * L**T,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then\nused to solve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the block diagonal matrix D and the\n         multipliers used to obtain the factor U or L from the\n         factorization A = U*D*U**T or A = L*D*L**T as computed by\n         ZSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by ZSYTRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= 1, and for best performance\n         LWORK >= max(1,N*NB), where NB is the optimal blocksize for\n         ZSYTRF.\n         for LWORK < N, TRS will be done with Level BLAS 2\n         for LWORK >= N, TRS will be done with Level BLAS 3\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, so the solution could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYsolve\n'),(37,'sspsv_37.txt','SSPSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric matrix stored in packed format and X\nand B are N-by-NRHS matrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**T,  if UPLO = \'U\', or\n   A = L * D * L**T,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, D is symmetric and block diagonal with 1-by-1\nand 2-by-2 diagonal blocks.  The factored form of A is then used to\nsolve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by SSPTRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, so the solution could not be\n               computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERsolve\n'),(38,'dspsv_38.txt','DSPSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric matrix stored in packed format and X\nand B are N-by-NRHS matrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**T,  if UPLO = \'U\', or\n   A = L * D * L**T,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, D is symmetric and block diagonal with 1-by-1\nand 2-by-2 diagonal blocks.  The factored form of A is then used to\nsolve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by DSPTRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, so the solution could not be\n               computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERsolve\n'),(39,'cspsv_39.txt','CSPSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric matrix stored in packed format and X\nand B are N-by-NRHS matrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**T,  if UPLO = \'U\', or\n   A = L * D * L**T,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, D is symmetric and block diagonal with 1-by-1\nand 2-by-2 diagonal blocks.  The factored form of A is then used to\nsolve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by CSPTRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, so the solution could not be\n               computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERsolve\n'),(40,'zspsv_40.txt','ZSPSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric matrix stored in packed format and X\nand B are N-by-NRHS matrices.\nThe diagonal pivoting method is used to factor A as\n   A = U * D * U**T,  if UPLO = \'U\', or\n   A = L * D * L**T,  if UPLO = \'L\',\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, D is symmetric and block diagonal with 1-by-1\nand 2-by-2 diagonal blocks.  The factored form of A is then used to\nsolve the system of equations A * X = B.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D, as\n         determined by ZSPTRF.  If IPIV(k) > 0, then rows and columns\n         k and IPIV(k) were interchanged, and D(k,k) is a 1-by-1\n         diagonal block.  If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0,\n         then rows and columns k-1 and -IPIV(k) were interchanged and\n         D(k-1:k,k-1:k) is a 2-by-2 diagonal block.  If UPLO = \'L\' and\n         IPIV(k) = IPIV(k+1) < 0, then rows and columns k+1 and\n         -IPIV(k) were interchanged and D(k:k+1,k:k+1) is a 2-by-2\n         diagonal block.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, so the solution could not be\n               computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERsolve\n'),(41,'sgesvx_41.txt','SGESVX uses the LU factorization to compute the solution to a real\nsystem of linear equations\n   A * X = B,\nwhere A is an N-by-N matrix and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n      TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n      TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n   matrix A (after equilibration if FACT = \'E\') as\n      A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n3. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AF and IPIV contain the factored form of A.\n                 If EQUED is not \'N\', the matrix A has been\n                 equilibrated with scaling factors given by R and C.\n                 A, AF, and IPIV are not modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Transpose)\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n         not \'N\', then A must have been equilibrated by the scaling\n         factors in R and/or C.  A is not modified if FACT = \'F\' or\n         \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if EQUED .ne. \'N\', A is scaled as follows:\n         EQUED = \'R\':  A := diag(R) * A\n         EQUED = \'C\':  A := A * diag(C)\n         EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is REAL array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the factors L and U from the factorization\n         A = P*L*U as computed by SGETRF.  If EQUED .ne. \'N\', then\n         AF is the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the factors L and U from the factorization A = P*L*U\n         of the original matrix A.\n         If FACT = \'E\', then AF is an output argument and on exit\n         returns the factors L and U from the factorization A = P*L*U\n         of the equilibrated matrix A (see the description of A for\n         the form of the equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the factorization A = P*L*U\n         as computed by SGETRF; row i of the matrix was interchanged\n         with row IPIV(i).\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = P*L*U\n         of the original matrix A.\n         If FACT = \'E\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = P*L*U\n         of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'R\':  Row equilibration, i.e., A has been premultiplied by\n                 diag(R).\n         = \'C\':  Column equilibration, i.e., A has been postmultiplied\n                 by diag(C).\n         = \'B\':  Both row and column equilibration, i.e., A has been\n                 replaced by diag(R) * A * diag(C).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] R\n         R is REAL array, dimension (N)\n         The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n         multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n         is not accessed.  R is an input argument if FACT = \'F\';\n         otherwise, R is an output argument.  If FACT = \'F\' and\n         EQUED = \'R\' or \'B\', each element of R must be positive.\n\\param[in,out] C\n         C is REAL array, dimension (N)\n         The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n         multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n         is not accessed.  C is an input argument if FACT = \'F\';\n         otherwise, C is an output argument.  If FACT = \'F\' and\n         EQUED = \'C\' or \'B\', each element of C must be positive.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit,\n         if EQUED = \'N\', B is not modified;\n         if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n         diag(R)*B;\n         if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n         overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n         to the original system of equations.  Note that A and B are\n         modified on exit if EQUED .ne. \'N\', and the solution to the\n         equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n         EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n         and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (4*N)\n         On exit, WORK(1) contains the reciprocal pivot growth\n         factor norm(A)/norm(U). The \"max absolute element\" norm is\n         used. If WORK(1) is much less than 1, then the stability\n         of the LU factorization of the (equilibrated) matrix A\n         could be poor. This also means that the solution X, condition\n         estimator RCOND, and forward error bound FERR could be\n         unreliable. If factorization fails with 0<INFO<=N, then\n         WORK(1) contains the reciprocal pivot growth factor for the\n         leading INFO columns of A.\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization has\n                      been completed, but the factor U is exactly\n                      singular, so the solution and error bounds\n                      could not be computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realGEsolve\n'),(42,'dgesvx_42.txt','DGESVX uses the LU factorization to compute the solution to a real\nsystem of linear equations\n   A * X = B,\nwhere A is an N-by-N matrix and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n      TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n      TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n   matrix A (after equilibration if FACT = \'E\') as\n      A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n3. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AF and IPIV contain the factored form of A.\n                 If EQUED is not \'N\', the matrix A has been\n                 equilibrated with scaling factors given by R and C.\n                 A, AF, and IPIV are not modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Transpose)\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n         not \'N\', then A must have been equilibrated by the scaling\n         factors in R and/or C.  A is not modified if FACT = \'F\' or\n         \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if EQUED .ne. \'N\', A is scaled as follows:\n         EQUED = \'R\':  A := diag(R) * A\n         EQUED = \'C\':  A := A * diag(C)\n         EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the factors L and U from the factorization\n         A = P*L*U as computed by DGETRF.  If EQUED .ne. \'N\', then\n         AF is the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the factors L and U from the factorization A = P*L*U\n         of the original matrix A.\n         If FACT = \'E\', then AF is an output argument and on exit\n         returns the factors L and U from the factorization A = P*L*U\n         of the equilibrated matrix A (see the description of A for\n         the form of the equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the factorization A = P*L*U\n         as computed by DGETRF; row i of the matrix was interchanged\n         with row IPIV(i).\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = P*L*U\n         of the original matrix A.\n         If FACT = \'E\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = P*L*U\n         of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'R\':  Row equilibration, i.e., A has been premultiplied by\n                 diag(R).\n         = \'C\':  Column equilibration, i.e., A has been postmultiplied\n                 by diag(C).\n         = \'B\':  Both row and column equilibration, i.e., A has been\n                 replaced by diag(R) * A * diag(C).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] R\n         R is DOUBLE PRECISION array, dimension (N)\n         The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n         multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n         is not accessed.  R is an input argument if FACT = \'F\';\n         otherwise, R is an output argument.  If FACT = \'F\' and\n         EQUED = \'R\' or \'B\', each element of R must be positive.\n\\param[in,out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n         multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n         is not accessed.  C is an input argument if FACT = \'F\';\n         otherwise, C is an output argument.  If FACT = \'F\' and\n         EQUED = \'C\' or \'B\', each element of C must be positive.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit,\n         if EQUED = \'N\', B is not modified;\n         if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n         diag(R)*B;\n         if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n         overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n         to the original system of equations.  Note that A and B are\n         modified on exit if EQUED .ne. \'N\', and the solution to the\n         equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n         EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n         and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (4*N)\n         On exit, WORK(1) contains the reciprocal pivot growth\n         factor norm(A)/norm(U). The \"max absolute element\" norm is\n         used. If WORK(1) is much less than 1, then the stability\n         of the LU factorization of the (equilibrated) matrix A\n         could be poor. This also means that the solution X, condition\n         estimator RCOND, and forward error bound FERR could be\n         unreliable. If factorization fails with 0<INFO<=N, then\n         WORK(1) contains the reciprocal pivot growth factor for the\n         leading INFO columns of A.\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization has\n                      been completed, but the factor U is exactly\n                      singular, so the solution and error bounds\n                      could not be computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleGEsolve\n'),(43,'cgesvx_43.txt','CGESVX uses the LU factorization to compute the solution to a complex\nsystem of linear equations\n   A * X = B,\nwhere A is an N-by-N matrix and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n      TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n      TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n   matrix A (after equilibration if FACT = \'E\') as\n      A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n3. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AF and IPIV contain the factored form of A.\n                 If EQUED is not \'N\', the matrix A has been\n                 equilibrated with scaling factors given by R and C.\n                 A, AF, and IPIV are not modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n         not \'N\', then A must have been equilibrated by the scaling\n         factors in R and/or C.  A is not modified if FACT = \'F\' or\n         \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if EQUED .ne. \'N\', A is scaled as follows:\n         EQUED = \'R\':  A := diag(R) * A\n         EQUED = \'C\':  A := A * diag(C)\n         EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the factors L and U from the factorization\n         A = P*L*U as computed by CGETRF.  If EQUED .ne. \'N\', then\n         AF is the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the factors L and U from the factorization A = P*L*U\n         of the original matrix A.\n         If FACT = \'E\', then AF is an output argument and on exit\n         returns the factors L and U from the factorization A = P*L*U\n         of the equilibrated matrix A (see the description of A for\n         the form of the equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the factorization A = P*L*U\n         as computed by CGETRF; row i of the matrix was interchanged\n         with row IPIV(i).\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = P*L*U\n         of the original matrix A.\n         If FACT = \'E\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = P*L*U\n         of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'R\':  Row equilibration, i.e., A has been premultiplied by\n                 diag(R).\n         = \'C\':  Column equilibration, i.e., A has been postmultiplied\n                 by diag(C).\n         = \'B\':  Both row and column equilibration, i.e., A has been\n                 replaced by diag(R) * A * diag(C).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] R\n         R is REAL array, dimension (N)\n         The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n         multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n         is not accessed.  R is an input argument if FACT = \'F\';\n         otherwise, R is an output argument.  If FACT = \'F\' and\n         EQUED = \'R\' or \'B\', each element of R must be positive.\n\\param[in,out] C\n         C is REAL array, dimension (N)\n         The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n         multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n         is not accessed.  C is an input argument if FACT = \'F\';\n         otherwise, C is an output argument.  If FACT = \'F\' and\n         EQUED = \'C\' or \'B\', each element of C must be positive.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit,\n         if EQUED = \'N\', B is not modified;\n         if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n         diag(R)*B;\n         if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n         overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n         to the original system of equations.  Note that A and B are\n         modified on exit if EQUED .ne. \'N\', and the solution to the\n         equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n         EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n         and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n         On exit, RWORK(1) contains the reciprocal pivot growth\n         factor norm(A)/norm(U). The \"max absolute element\" norm is\n         used. If RWORK(1) is much less than 1, then the stability\n         of the LU factorization of the (equilibrated) matrix A\n         could be poor. This also means that the solution X, condition\n         estimator RCOND, and forward error bound FERR could be\n         unreliable. If factorization fails with 0<INFO<=N, then\n         RWORK(1) contains the reciprocal pivot growth factor for the\n         leading INFO columns of A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization has\n                      been completed, but the factor U is exactly\n                      singular, so the solution and error bounds\n                      could not be computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexGEsolve\n'),(44,'zgesvx_44.txt','ZGESVX uses the LU factorization to compute the solution to a complex\nsystem of linear equations\n   A * X = B,\nwhere A is an N-by-N matrix and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n      TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n      TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n   matrix A (after equilibration if FACT = \'E\') as\n      A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n3. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AF and IPIV contain the factored form of A.\n                 If EQUED is not \'N\', the matrix A has been\n                 equilibrated with scaling factors given by R and C.\n                 A, AF, and IPIV are not modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n         not \'N\', then A must have been equilibrated by the scaling\n         factors in R and/or C.  A is not modified if FACT = \'F\' or\n         \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if EQUED .ne. \'N\', A is scaled as follows:\n         EQUED = \'R\':  A := diag(R) * A\n         EQUED = \'C\':  A := A * diag(C)\n         EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the factors L and U from the factorization\n         A = P*L*U as computed by ZGETRF.  If EQUED .ne. \'N\', then\n         AF is the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the factors L and U from the factorization A = P*L*U\n         of the original matrix A.\n         If FACT = \'E\', then AF is an output argument and on exit\n         returns the factors L and U from the factorization A = P*L*U\n         of the equilibrated matrix A (see the description of A for\n         the form of the equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the factorization A = P*L*U\n         as computed by ZGETRF; row i of the matrix was interchanged\n         with row IPIV(i).\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = P*L*U\n         of the original matrix A.\n         If FACT = \'E\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = P*L*U\n         of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'R\':  Row equilibration, i.e., A has been premultiplied by\n                 diag(R).\n         = \'C\':  Column equilibration, i.e., A has been postmultiplied\n                 by diag(C).\n         = \'B\':  Both row and column equilibration, i.e., A has been\n                 replaced by diag(R) * A * diag(C).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] R\n         R is DOUBLE PRECISION array, dimension (N)\n         The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n         multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n         is not accessed.  R is an input argument if FACT = \'F\';\n         otherwise, R is an output argument.  If FACT = \'F\' and\n         EQUED = \'R\' or \'B\', each element of R must be positive.\n\\param[in,out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n         multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n         is not accessed.  C is an input argument if FACT = \'F\';\n         otherwise, C is an output argument.  If FACT = \'F\' and\n         EQUED = \'C\' or \'B\', each element of C must be positive.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit,\n         if EQUED = \'N\', B is not modified;\n         if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n         diag(R)*B;\n         if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n         overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n         to the original system of equations.  Note that A and B are\n         modified on exit if EQUED .ne. \'N\', and the solution to the\n         equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n         EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n         and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n         On exit, RWORK(1) contains the reciprocal pivot growth\n         factor norm(A)/norm(U). The \"max absolute element\" norm is\n         used. If RWORK(1) is much less than 1, then the stability\n         of the LU factorization of the (equilibrated) matrix A\n         could be poor. This also means that the solution X, condition\n         estimator RCOND, and forward error bound FERR could be\n         unreliable. If factorization fails with 0<INFO<=N, then\n         RWORK(1) contains the reciprocal pivot growth factor for the\n         leading INFO columns of A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization has\n                      been completed, but the factor U is exactly\n                      singular, so the solution and error bounds\n                      could not be computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16GEsolve\n'),(45,'sgbsvx_45.txt','SGBSVX uses the LU factorization to compute the solution to a real\nsystem of linear equations A * X = B, A**T * X = B, or A**H * X = B,\nwhere A is a band matrix of order N with KL subdiagonals and KU\nsuperdiagonals, and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed by this subroutine:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n      TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n      TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n   matrix A (after equilibration if FACT = \'E\') as\n      A = L * U,\n   where L is a product of permutation and unit lower triangular\n   matrices with KL subdiagonals, and U is upper triangular with\n   KL+KU superdiagonals.\n3. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFB and IPIV contain the factored form of\n                 A.  If EQUED is not \'N\', the matrix A has been\n                 equilibrated with scaling factors given by R and C.\n                 AB, AFB, and IPIV are not modified.\n         = \'N\':  The matrix A will be copied to AFB and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFB and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Transpose)\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is REAL array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n         If FACT = \'F\' and EQUED is not \'N\', then A must have been\n         equilibrated by the scaling factors in R and/or C.  AB is not\n         modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n         EQUED = \'N\' on exit.\n         On exit, if EQUED .ne. \'N\', A is scaled as follows:\n         EQUED = \'R\':  A := diag(R) * A\n         EQUED = \'C\':  A := A * diag(C)\n         EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in,out] AFB\n         AFB is REAL array, dimension (LDAFB,N)\n         If FACT = \'F\', then AFB is an input argument and on entry\n         contains details of the LU factorization of the band matrix\n         A, as computed by SGBTRF.  U is stored as an upper triangular\n         band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n         and the multipliers used during the factorization are stored\n         in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n         the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AFB is an output argument and on exit\n         returns details of the LU factorization of A.\n         If FACT = \'E\', then AFB is an output argument and on exit\n         returns details of the LU factorization of the equilibrated\n         matrix A (see the description of AB for the form of the\n         equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the factorization A = L*U\n         as computed by SGBTRF; row i of the matrix was interchanged\n         with row IPIV(i).\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = L*U\n         of the original matrix A.\n         If FACT = \'E\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = L*U\n         of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'R\':  Row equilibration, i.e., A has been premultiplied by\n                 diag(R).\n         = \'C\':  Column equilibration, i.e., A has been postmultiplied\n                 by diag(C).\n         = \'B\':  Both row and column equilibration, i.e., A has been\n                 replaced by diag(R) * A * diag(C).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] R\n         R is REAL array, dimension (N)\n         The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n         multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n         is not accessed.  R is an input argument if FACT = \'F\';\n         otherwise, R is an output argument.  If FACT = \'F\' and\n         EQUED = \'R\' or \'B\', each element of R must be positive.\n\\param[in,out] C\n         C is REAL array, dimension (N)\n         The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n         multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n         is not accessed.  C is an input argument if FACT = \'F\';\n         otherwise, C is an output argument.  If FACT = \'F\' and\n         EQUED = \'C\' or \'B\', each element of C must be positive.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit,\n         if EQUED = \'N\', B is not modified;\n         if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n         diag(R)*B;\n         if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n         overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n         to the original system of equations.  Note that A and B are\n         modified on exit if EQUED .ne. \'N\', and the solution to the\n         equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n         EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n         and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n         On exit, WORK(1) contains the reciprocal pivot growth\n         factor norm(A)/norm(U). The \"max absolute element\" norm is\n         used. If WORK(1) is much less than 1, then the stability\n         of the LU factorization of the (equilibrated) matrix A\n         could be poor. This also means that the solution X, condition\n         estimator RCOND, and forward error bound FERR could be\n         unreliable. If factorization fails with 0<INFO<=N, then\n         WORK(1) contains the reciprocal pivot growth factor for the\n         leading INFO columns of A.\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization\n                      has been completed, but the factor U is exactly\n                      singular, so the solution and error bounds\n                      could not be computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realGBsolve\n'),(46,'dgbsvx_46.txt','DGBSVX uses the LU factorization to compute the solution to a real\nsystem of linear equations A * X = B, A**T * X = B, or A**H * X = B,\nwhere A is a band matrix of order N with KL subdiagonals and KU\nsuperdiagonals, and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed by this subroutine:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n      TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n      TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n   matrix A (after equilibration if FACT = \'E\') as\n      A = L * U,\n   where L is a product of permutation and unit lower triangular\n   matrices with KL subdiagonals, and U is upper triangular with\n   KL+KU superdiagonals.\n3. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFB and IPIV contain the factored form of\n                 A.  If EQUED is not \'N\', the matrix A has been\n                 equilibrated with scaling factors given by R and C.\n                 AB, AFB, and IPIV are not modified.\n         = \'N\':  The matrix A will be copied to AFB and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFB and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Transpose)\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n         If FACT = \'F\' and EQUED is not \'N\', then A must have been\n         equilibrated by the scaling factors in R and/or C.  AB is not\n         modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n         EQUED = \'N\' on exit.\n         On exit, if EQUED .ne. \'N\', A is scaled as follows:\n         EQUED = \'R\':  A := diag(R) * A\n         EQUED = \'C\':  A := A * diag(C)\n         EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in,out] AFB\n         AFB is DOUBLE PRECISION array, dimension (LDAFB,N)\n         If FACT = \'F\', then AFB is an input argument and on entry\n         contains details of the LU factorization of the band matrix\n         A, as computed by DGBTRF.  U is stored as an upper triangular\n         band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n         and the multipliers used during the factorization are stored\n         in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n         the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AFB is an output argument and on exit\n         returns details of the LU factorization of A.\n         If FACT = \'E\', then AFB is an output argument and on exit\n         returns details of the LU factorization of the equilibrated\n         matrix A (see the description of AB for the form of the\n         equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the factorization A = L*U\n         as computed by DGBTRF; row i of the matrix was interchanged\n         with row IPIV(i).\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = L*U\n         of the original matrix A.\n         If FACT = \'E\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = L*U\n         of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'R\':  Row equilibration, i.e., A has been premultiplied by\n                 diag(R).\n         = \'C\':  Column equilibration, i.e., A has been postmultiplied\n                 by diag(C).\n         = \'B\':  Both row and column equilibration, i.e., A has been\n                 replaced by diag(R) * A * diag(C).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] R\n         R is DOUBLE PRECISION array, dimension (N)\n         The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n         multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n         is not accessed.  R is an input argument if FACT = \'F\';\n         otherwise, R is an output argument.  If FACT = \'F\' and\n         EQUED = \'R\' or \'B\', each element of R must be positive.\n\\param[in,out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n         multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n         is not accessed.  C is an input argument if FACT = \'F\';\n         otherwise, C is an output argument.  If FACT = \'F\' and\n         EQUED = \'C\' or \'B\', each element of C must be positive.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit,\n         if EQUED = \'N\', B is not modified;\n         if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n         diag(R)*B;\n         if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n         overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n         to the original system of equations.  Note that A and B are\n         modified on exit if EQUED .ne. \'N\', and the solution to the\n         equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n         EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n         and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n         On exit, WORK(1) contains the reciprocal pivot growth\n         factor norm(A)/norm(U). The \"max absolute element\" norm is\n         used. If WORK(1) is much less than 1, then the stability\n         of the LU factorization of the (equilibrated) matrix A\n         could be poor. This also means that the solution X, condition\n         estimator RCOND, and forward error bound FERR could be\n         unreliable. If factorization fails with 0<INFO<=N, then\n         WORK(1) contains the reciprocal pivot growth factor for the\n         leading INFO columns of A.\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization\n                      has been completed, but the factor U is exactly\n                      singular, so the solution and error bounds\n                      could not be computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleGBsolve\n'),(47,'cgbsvx_47.txt','CGBSVX uses the LU factorization to compute the solution to a complex\nsystem of linear equations A * X = B, A**T * X = B, or A**H * X = B,\nwhere A is a band matrix of order N with KL subdiagonals and KU\nsuperdiagonals, and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed by this subroutine:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n      TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n      TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n   matrix A (after equilibration if FACT = \'E\') as\n      A = L * U,\n   where L is a product of permutation and unit lower triangular\n   matrices with KL subdiagonals, and U is upper triangular with\n   KL+KU superdiagonals.\n3. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFB and IPIV contain the factored form of\n                 A.  If EQUED is not \'N\', the matrix A has been\n                 equilibrated with scaling factors given by R and C.\n                 AB, AFB, and IPIV are not modified.\n         = \'N\':  The matrix A will be copied to AFB and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFB and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n         If FACT = \'F\' and EQUED is not \'N\', then A must have been\n         equilibrated by the scaling factors in R and/or C.  AB is not\n         modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n         EQUED = \'N\' on exit.\n         On exit, if EQUED .ne. \'N\', A is scaled as follows:\n         EQUED = \'R\':  A := diag(R) * A\n         EQUED = \'C\':  A := A * diag(C)\n         EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in,out] AFB\n         AFB is COMPLEX array, dimension (LDAFB,N)\n         If FACT = \'F\', then AFB is an input argument and on entry\n         contains details of the LU factorization of the band matrix\n         A, as computed by CGBTRF.  U is stored as an upper triangular\n         band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n         and the multipliers used during the factorization are stored\n         in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n         the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AFB is an output argument and on exit\n         returns details of the LU factorization of A.\n         If FACT = \'E\', then AFB is an output argument and on exit\n         returns details of the LU factorization of the equilibrated\n         matrix A (see the description of AB for the form of the\n         equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the factorization A = L*U\n         as computed by CGBTRF; row i of the matrix was interchanged\n         with row IPIV(i).\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = L*U\n         of the original matrix A.\n         If FACT = \'E\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = L*U\n         of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'R\':  Row equilibration, i.e., A has been premultiplied by\n                 diag(R).\n         = \'C\':  Column equilibration, i.e., A has been postmultiplied\n                 by diag(C).\n         = \'B\':  Both row and column equilibration, i.e., A has been\n                 replaced by diag(R) * A * diag(C).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] R\n         R is REAL array, dimension (N)\n         The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n         multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n         is not accessed.  R is an input argument if FACT = \'F\';\n         otherwise, R is an output argument.  If FACT = \'F\' and\n         EQUED = \'R\' or \'B\', each element of R must be positive.\n\\param[in,out] C\n         C is REAL array, dimension (N)\n         The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n         multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n         is not accessed.  C is an input argument if FACT = \'F\';\n         otherwise, C is an output argument.  If FACT = \'F\' and\n         EQUED = \'C\' or \'B\', each element of C must be positive.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit,\n         if EQUED = \'N\', B is not modified;\n         if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n         diag(R)*B;\n         if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n         overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n         to the original system of equations.  Note that A and B are\n         modified on exit if EQUED .ne. \'N\', and the solution to the\n         equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n         EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n         and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n         On exit, RWORK(1) contains the reciprocal pivot growth\n         factor norm(A)/norm(U). The \"max absolute element\" norm is\n         used. If RWORK(1) is much less than 1, then the stability\n         of the LU factorization of the (equilibrated) matrix A\n         could be poor. This also means that the solution X, condition\n         estimator RCOND, and forward error bound FERR could be\n         unreliable. If factorization fails with 0<INFO<=N, then\n         RWORK(1) contains the reciprocal pivot growth factor for the\n         leading INFO columns of A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization\n                      has been completed, but the factor U is exactly\n                      singular, so the solution and error bounds\n                      could not be computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexGBsolve\n'),(48,'zgbsvx_48.txt','ZGBSVX uses the LU factorization to compute the solution to a complex\nsystem of linear equations A * X = B, A**T * X = B, or A**H * X = B,\nwhere A is a band matrix of order N with KL subdiagonals and KU\nsuperdiagonals, and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed by this subroutine:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n      TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n      TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor the\n   matrix A (after equilibration if FACT = \'E\') as\n      A = L * U,\n   where L is a product of permutation and unit lower triangular\n   matrices with KL subdiagonals, and U is upper triangular with\n   KL+KU superdiagonals.\n3. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFB and IPIV contain the factored form of\n                 A.  If EQUED is not \'N\', the matrix A has been\n                 equilibrated with scaling factors given by R and C.\n                 AB, AFB, and IPIV are not modified.\n         = \'N\':  The matrix A will be copied to AFB and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFB and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n         If FACT = \'F\' and EQUED is not \'N\', then A must have been\n         equilibrated by the scaling factors in R and/or C.  AB is not\n         modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n         EQUED = \'N\' on exit.\n         On exit, if EQUED .ne. \'N\', A is scaled as follows:\n         EQUED = \'R\':  A := diag(R) * A\n         EQUED = \'C\':  A := A * diag(C)\n         EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in,out] AFB\n         AFB is COMPLEX*16 array, dimension (LDAFB,N)\n         If FACT = \'F\', then AFB is an input argument and on entry\n         contains details of the LU factorization of the band matrix\n         A, as computed by ZGBTRF.  U is stored as an upper triangular\n         band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n         and the multipliers used during the factorization are stored\n         in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n         the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AFB is an output argument and on exit\n         returns details of the LU factorization of A.\n         If FACT = \'E\', then AFB is an output argument and on exit\n         returns details of the LU factorization of the equilibrated\n         matrix A (see the description of AB for the form of the\n         equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the factorization A = L*U\n         as computed by ZGBTRF; row i of the matrix was interchanged\n         with row IPIV(i).\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = L*U\n         of the original matrix A.\n         If FACT = \'E\', then IPIV is an output argument and on exit\n         contains the pivot indices from the factorization A = L*U\n         of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'R\':  Row equilibration, i.e., A has been premultiplied by\n                 diag(R).\n         = \'C\':  Column equilibration, i.e., A has been postmultiplied\n                 by diag(C).\n         = \'B\':  Both row and column equilibration, i.e., A has been\n                 replaced by diag(R) * A * diag(C).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] R\n         R is DOUBLE PRECISION array, dimension (N)\n         The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n         multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n         is not accessed.  R is an input argument if FACT = \'F\';\n         otherwise, R is an output argument.  If FACT = \'F\' and\n         EQUED = \'R\' or \'B\', each element of R must be positive.\n\\param[in,out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n         multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n         is not accessed.  C is an input argument if FACT = \'F\';\n         otherwise, C is an output argument.  If FACT = \'F\' and\n         EQUED = \'C\' or \'B\', each element of C must be positive.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit,\n         if EQUED = \'N\', B is not modified;\n         if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n         diag(R)*B;\n         if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n         overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X\n         to the original system of equations.  Note that A and B are\n         modified on exit if EQUED .ne. \'N\', and the solution to the\n         equilibrated system is inv(diag(C))*X if TRANS = \'N\' and\n         EQUED = \'C\' or \'B\', or inv(diag(R))*X if TRANS = \'T\' or \'C\'\n         and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n         On exit, RWORK(1) contains the reciprocal pivot growth\n         factor norm(A)/norm(U). The \"max absolute element\" norm is\n         used. If RWORK(1) is much less than 1, then the stability\n         of the LU factorization of the (equilibrated) matrix A\n         could be poor. This also means that the solution X, condition\n         estimator RCOND, and forward error bound FERR could be\n         unreliable. If factorization fails with 0<INFO<=N, then\n         RWORK(1) contains the reciprocal pivot growth factor for the\n         leading INFO columns of A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization\n                      has been completed, but the factor U is exactly\n                      singular, so the solution and error bounds\n                      could not be computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16GBsolve\n'),(49,'sgtsvx_49.txt','SGTSVX uses the LU factorization to compute the solution to a real\nsystem of linear equations A * X = B or A**T * X = B,\nwhere A is a tridiagonal matrix of order N and X and B are N-by-NRHS\nmatrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the LU decomposition is used to factor the matrix A\n   as A = L * U, where L is a product of permutation and unit lower\n   bidiagonal matrices and U is upper triangular with nonzeros in\n   only the main diagonal and first two superdiagonals.\n2. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored\n                 form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV\n                 will not be modified.\n         = \'N\':  The matrix will be copied to DLF, DF, and DUF\n                 and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is REAL array, dimension (N-1)\n         The (n-1) subdiagonal elements of A.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n diagonal elements of A.\n\\param[in] DU\n         DU is REAL array, dimension (N-1)\n         The (n-1) superdiagonal elements of A.\n\\param[in,out] DLF\n         DLF is REAL array, dimension (N-1)\n         If FACT = \'F\', then DLF is an input argument and on entry\n         contains the (n-1) multipliers that define the matrix L from\n         the LU factorization of A as computed by SGTTRF.\n         If FACT = \'N\', then DLF is an output argument and on exit\n         contains the (n-1) multipliers that define the matrix L from\n         the LU factorization of A.\n\\param[in,out] DF\n         DF is REAL array, dimension (N)\n         If FACT = \'F\', then DF is an input argument and on entry\n         contains the n diagonal elements of the upper triangular\n         matrix U from the LU factorization of A.\n         If FACT = \'N\', then DF is an output argument and on exit\n         contains the n diagonal elements of the upper triangular\n         matrix U from the LU factorization of A.\n\\param[in,out] DUF\n         DUF is REAL array, dimension (N-1)\n         If FACT = \'F\', then DUF is an input argument and on entry\n         contains the (n-1) elements of the first superdiagonal of U.\n         If FACT = \'N\', then DUF is an output argument and on exit\n         contains the (n-1) elements of the first superdiagonal of U.\n\\param[in,out] DU2\n         DU2 is REAL array, dimension (N-2)\n         If FACT = \'F\', then DU2 is an input argument and on entry\n         contains the (n-2) elements of the second superdiagonal of\n         U.\n         If FACT = \'N\', then DU2 is an output argument and on exit\n         contains the (n-2) elements of the second superdiagonal of\n         U.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the LU factorization of A as\n         computed by SGTTRF.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the LU factorization of A;\n         row i of the matrix was interchanged with row IPIV(i).\n         IPIV(i) will always be either i or i+1; IPIV(i) = i indicates\n         a row interchange was not required.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization\n                      has not been completed unless i = N, but the\n                      factor U is exactly singular, so the solution\n                      and error bounds could not be computed.\n                      RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realOTHERcomputational\n'),(50,'dgtsvx_50.txt','DGTSVX uses the LU factorization to compute the solution to a real\nsystem of linear equations A * X = B or A**T * X = B,\nwhere A is a tridiagonal matrix of order N and X and B are N-by-NRHS\nmatrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the LU decomposition is used to factor the matrix A\n   as A = L * U, where L is a product of permutation and unit lower\n   bidiagonal matrices and U is upper triangular with nonzeros in\n   only the main diagonal and first two superdiagonals.\n2. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored\n                 form of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV\n                 will not be modified.\n         = \'N\':  The matrix will be copied to DLF, DF, and DUF\n                 and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) subdiagonal elements of A.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of A.\n\\param[in] DU\n         DU is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) superdiagonal elements of A.\n\\param[in,out] DLF\n         DLF is DOUBLE PRECISION array, dimension (N-1)\n         If FACT = \'F\', then DLF is an input argument and on entry\n         contains the (n-1) multipliers that define the matrix L from\n         the LU factorization of A as computed by DGTTRF.\n         If FACT = \'N\', then DLF is an output argument and on exit\n         contains the (n-1) multipliers that define the matrix L from\n         the LU factorization of A.\n\\param[in,out] DF\n         DF is DOUBLE PRECISION array, dimension (N)\n         If FACT = \'F\', then DF is an input argument and on entry\n         contains the n diagonal elements of the upper triangular\n         matrix U from the LU factorization of A.\n         If FACT = \'N\', then DF is an output argument and on exit\n         contains the n diagonal elements of the upper triangular\n         matrix U from the LU factorization of A.\n\\param[in,out] DUF\n         DUF is DOUBLE PRECISION array, dimension (N-1)\n         If FACT = \'F\', then DUF is an input argument and on entry\n         contains the (n-1) elements of the first superdiagonal of U.\n         If FACT = \'N\', then DUF is an output argument and on exit\n         contains the (n-1) elements of the first superdiagonal of U.\n\\param[in,out] DU2\n         DU2 is DOUBLE PRECISION array, dimension (N-2)\n         If FACT = \'F\', then DU2 is an input argument and on entry\n         contains the (n-2) elements of the second superdiagonal of\n         U.\n         If FACT = \'N\', then DU2 is an output argument and on exit\n         contains the (n-2) elements of the second superdiagonal of\n         U.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the LU factorization of A as\n         computed by DGTTRF.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the LU factorization of A;\n         row i of the matrix was interchanged with row IPIV(i).\n         IPIV(i) will always be either i or i+1; IPIV(i) = i indicates\n         a row interchange was not required.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization\n                      has not been completed unless i = N, but the\n                      factor U is exactly singular, so the solution\n                      and error bounds could not be computed.\n                      RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleOTHERcomputational\n'),(51,'cgtsvx_51.txt','CGTSVX uses the LU factorization to compute the solution to a complex\nsystem of linear equations A * X = B, A**T * X = B, or A**H * X = B,\nwhere A is a tridiagonal matrix of order N and X and B are N-by-NRHS\nmatrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the LU decomposition is used to factor the matrix A\n   as A = L * U, where L is a product of permutation and unit lower\n   bidiagonal matrices and U is upper triangular with nonzeros in\n   only the main diagonal and first two superdiagonals.\n2. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored form\n                 of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV will not\n                 be modified.\n         = \'N\':  The matrix will be copied to DLF, DF, and DUF\n                 and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is COMPLEX array, dimension (N-1)\n         The (n-1) subdiagonal elements of A.\n\\param[in] D\n         D is COMPLEX array, dimension (N)\n         The n diagonal elements of A.\n\\param[in] DU\n         DU is COMPLEX array, dimension (N-1)\n         The (n-1) superdiagonal elements of A.\n\\param[in,out] DLF\n         DLF is COMPLEX array, dimension (N-1)\n         If FACT = \'F\', then DLF is an input argument and on entry\n         contains the (n-1) multipliers that define the matrix L from\n         the LU factorization of A as computed by CGTTRF.\n         If FACT = \'N\', then DLF is an output argument and on exit\n         contains the (n-1) multipliers that define the matrix L from\n         the LU factorization of A.\n\\param[in,out] DF\n         DF is COMPLEX array, dimension (N)\n         If FACT = \'F\', then DF is an input argument and on entry\n         contains the n diagonal elements of the upper triangular\n         matrix U from the LU factorization of A.\n         If FACT = \'N\', then DF is an output argument and on exit\n         contains the n diagonal elements of the upper triangular\n         matrix U from the LU factorization of A.\n\\param[in,out] DUF\n         DUF is COMPLEX array, dimension (N-1)\n         If FACT = \'F\', then DUF is an input argument and on entry\n         contains the (n-1) elements of the first superdiagonal of U.\n         If FACT = \'N\', then DUF is an output argument and on exit\n         contains the (n-1) elements of the first superdiagonal of U.\n\\param[in,out] DU2\n         DU2 is COMPLEX array, dimension (N-2)\n         If FACT = \'F\', then DU2 is an input argument and on entry\n         contains the (n-2) elements of the second superdiagonal of\n         U.\n         If FACT = \'N\', then DU2 is an output argument and on exit\n         contains the (n-2) elements of the second superdiagonal of\n         U.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the LU factorization of A as\n         computed by CGTTRF.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the LU factorization of A;\n         row i of the matrix was interchanged with row IPIV(i).\n         IPIV(i) will always be either i or i+1; IPIV(i) = i indicates\n         a row interchange was not required.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization\n                      has not been completed unless i = N, but the\n                      factor U is exactly singular, so the solution\n                      and error bounds could not be computed.\n                      RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexOTHERcomputational\n'),(52,'zgtsvx_52.txt','ZGTSVX uses the LU factorization to compute the solution to a complex\nsystem of linear equations A * X = B, A**T * X = B, or A**H * X = B,\nwhere A is a tridiagonal matrix of order N and X and B are N-by-NRHS\nmatrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the LU decomposition is used to factor the matrix A\n   as A = L * U, where L is a product of permutation and unit lower\n   bidiagonal matrices and U is upper triangular with nonzeros in\n   only the main diagonal and first two superdiagonals.\n2. If some U(i,i)=0, so that U is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  DLF, DF, DUF, DU2, and IPIV contain the factored form\n                 of A; DL, D, DU, DLF, DF, DUF, DU2 and IPIV will not\n                 be modified.\n         = \'N\':  The matrix will be copied to DLF, DF, and DUF\n                 and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is COMPLEX*16 array, dimension (N-1)\n         The (n-1) subdiagonal elements of A.\n\\param[in] D\n         D is COMPLEX*16 array, dimension (N)\n         The n diagonal elements of A.\n\\param[in] DU\n         DU is COMPLEX*16 array, dimension (N-1)\n         The (n-1) superdiagonal elements of A.\n\\param[in,out] DLF\n         DLF is COMPLEX*16 array, dimension (N-1)\n         If FACT = \'F\', then DLF is an input argument and on entry\n         contains the (n-1) multipliers that define the matrix L from\n         the LU factorization of A as computed by ZGTTRF.\n         If FACT = \'N\', then DLF is an output argument and on exit\n         contains the (n-1) multipliers that define the matrix L from\n         the LU factorization of A.\n\\param[in,out] DF\n         DF is COMPLEX*16 array, dimension (N)\n         If FACT = \'F\', then DF is an input argument and on entry\n         contains the n diagonal elements of the upper triangular\n         matrix U from the LU factorization of A.\n         If FACT = \'N\', then DF is an output argument and on exit\n         contains the n diagonal elements of the upper triangular\n         matrix U from the LU factorization of A.\n\\param[in,out] DUF\n         DUF is COMPLEX*16 array, dimension (N-1)\n         If FACT = \'F\', then DUF is an input argument and on entry\n         contains the (n-1) elements of the first superdiagonal of U.\n         If FACT = \'N\', then DUF is an output argument and on exit\n         contains the (n-1) elements of the first superdiagonal of U.\n\\param[in,out] DU2\n         DU2 is COMPLEX*16 array, dimension (N-2)\n         If FACT = \'F\', then DU2 is an input argument and on entry\n         contains the (n-2) elements of the second superdiagonal of\n         U.\n         If FACT = \'N\', then DU2 is an output argument and on exit\n         contains the (n-2) elements of the second superdiagonal of\n         U.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains the pivot indices from the LU factorization of A as\n         computed by ZGTTRF.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains the pivot indices from the LU factorization of A;\n         row i of the matrix was interchanged with row IPIV(i).\n         IPIV(i) will always be either i or i+1; IPIV(i) = i indicates\n         a row interchange was not required.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  U(i,i) is exactly zero.  The factorization\n                      has not been completed unless i = N, but the\n                      factor U is exactly singular, so the solution\n                      and error bounds could not be computed.\n                      RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16OTHERcomputational\n'),(53,'chesvx_53.txt','CHESVX uses the diagonal pivoting factorization to compute the\nsolution to a complex system of linear equations A * X = B,\nwhere A is an N-by-N Hermitian matrix and X and B are N-by-NRHS\nmatrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n   The form of the factorization is\n      A = U * D * U**H,  if UPLO = \'U\', or\n      A = L * D * L**H,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is Hermitian and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AF and IPIV contain the factored form\n                 of A.  A, AF and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The Hermitian matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**H or A = L*D*L**H as computed by CHETRF.\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**H or A = L*D*L**H.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by CHETRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by CHETRF.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= max(1,2*N), and for best\n         performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where\n         NB is the optimal blocksize for CHETRF.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexHEsolve\n'),(54,'zhesvx_54.txt','ZHESVX uses the diagonal pivoting factorization to compute the\nsolution to a complex system of linear equations A * X = B,\nwhere A is an N-by-N Hermitian matrix and X and B are N-by-NRHS\nmatrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n   The form of the factorization is\n      A = U * D * U**H,  if UPLO = \'U\', or\n      A = L * D * L**H,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is Hermitian and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AF and IPIV contain the factored form\n                 of A.  A, AF and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The Hermitian matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**H or A = L*D*L**H as computed by ZHETRF.\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**H or A = L*D*L**H.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by ZHETRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by ZHETRF.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= max(1,2*N), and for best\n         performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where\n         NB is the optimal blocksize for ZHETRF.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16HEsolve\n'),(55,'chpsvx_55.txt','CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or\nA = L*D*L**H to compute the solution to a complex system of linear\nequations A * X = B, where A is an N-by-N Hermitian matrix stored\nin packed format and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n      A = U * D * U**H,  if UPLO = \'U\', or\n      A = L * D * L**H,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices and D is Hermitian and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AFP and IPIV contain the factored form of\n                 A.  AFP and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AFP and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the Hermitian matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n\\param[in,out] AFP\n         AFP is COMPLEX array, dimension (N*(N+1)/2)\n         If FACT = \'F\', then AFP is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n         If FACT = \'N\', then AFP is an output argument and on exit\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**H or A = L*D*L**H as computed by CHPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by CHPTRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by CHPTRF.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexOTHERsolve\n'),(56,'zhpsvx_56.txt','ZHPSVX uses the diagonal pivoting factorization A = U*D*U**H or\nA = L*D*L**H to compute the solution to a complex system of linear\nequations A * X = B, where A is an N-by-N Hermitian matrix stored\nin packed format and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n      A = U * D * U**H,  if UPLO = \'U\', or\n      A = L * D * L**H,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices and D is Hermitian and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AFP and IPIV contain the factored form of\n                 A.  AFP and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AFP and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the Hermitian matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n\\param[in,out] AFP\n         AFP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         If FACT = \'F\', then AFP is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n         If FACT = \'N\', then AFP is an output argument and on exit\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**H or A = L*D*L**H as computed by ZHPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by ZHPTRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by ZHPTRF.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16OTHERsolve\n'),(57,'sposvx_57.txt','SPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\ncompute the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite matrix and X and B\nare N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**T* U,  if UPLO = \'U\', or\n      A = L * L**T,  if UPLO = \'L\',\n   where U is an upper triangular matrix and L is a lower triangular\n   matrix.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AF contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  A and AF will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the symmetric matrix A, except if FACT = \'F\' and\n         EQUED = \'Y\', then A must contain the equilibrated matrix\n         diag(S)*A*diag(S).  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.  A is not modified if\n         FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is REAL array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T, in the same storage\n         format as A.  If EQUED .ne. \'N\', then AF is the factored form\n         of the equilibrated matrix diag(S)*A*diag(S).\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T of the original\n         matrix A.\n         If FACT = \'E\', then AF is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T of the equilibrated\n         matrix A (see the description of A for the form of the\n         equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realPOsolve\n'),(58,'dposvx_58.txt','DPOSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\ncompute the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite matrix and X and B\nare N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**T* U,  if UPLO = \'U\', or\n      A = L * L**T,  if UPLO = \'L\',\n   where U is an upper triangular matrix and L is a lower triangular\n   matrix.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AF contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  A and AF will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the symmetric matrix A, except if FACT = \'F\' and\n         EQUED = \'Y\', then A must contain the equilibrated matrix\n         diag(S)*A*diag(S).  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.  A is not modified if\n         FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T, in the same storage\n         format as A.  If EQUED .ne. \'N\', then AF is the factored form\n         of the equilibrated matrix diag(S)*A*diag(S).\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T of the original\n         matrix A.\n         If FACT = \'E\', then AF is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T of the equilibrated\n         matrix A (see the description of A for the form of the\n         equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doublePOsolve\n'),(59,'cposvx_59.txt','CPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\ncompute the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite matrix and X and B\nare N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**H* U,  if UPLO = \'U\', or\n      A = L * L**H,  if UPLO = \'L\',\n   where U is an upper triangular matrix and L is a lower triangular\n   matrix.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AF contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  A and AF will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the Hermitian matrix A, except if FACT = \'F\' and\n         EQUED = \'Y\', then A must contain the equilibrated matrix\n         diag(S)*A*diag(S).  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.  A is not modified if\n         FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H, in the same storage\n         format as A.  If EQUED .ne. \'N\', then AF is the factored form\n         of the equilibrated matrix diag(S)*A*diag(S).\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H of the original\n         matrix A.\n         If FACT = \'E\', then AF is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H of the equilibrated\n         matrix A (see the description of A for the form of the\n         equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS righthand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexPOsolve\n'),(60,'zposvx_60.txt','ZPOSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\ncompute the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite matrix and X and B\nare N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**H* U,  if UPLO = \'U\', or\n      A = L * L**H,  if UPLO = \'L\',\n   where U is an upper triangular matrix and L is a lower triangular\n   matrix.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AF contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  A and AF will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the Hermitian matrix A, except if FACT = \'F\' and\n         EQUED = \'Y\', then A must contain the equilibrated matrix\n         diag(S)*A*diag(S).  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.  A is not modified if\n         FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**H *U or A = L*L**H, in the same storage\n         format as A.  If EQUED .ne. \'N\', then AF is the factored form\n         of the equilibrated matrix diag(S)*A*diag(S).\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H *U or A = L*L**H of the original\n         matrix A.\n         If FACT = \'E\', then AF is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H *U or A = L*L**H of the equilibrated\n         matrix A (see the description of A for the form of the\n         equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS righthand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16POsolve\n'),(61,'spbsvx_61.txt','SPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\ncompute the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite band matrix and X\nand B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**T * U,  if UPLO = \'U\', or\n      A = L * L**T,  if UPLO = \'L\',\n   where U is an upper triangular band matrix, and L is a lower\n   triangular band matrix.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFB contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  AB and AFB will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AFB and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFB and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right-hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is REAL array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the symmetric band\n         matrix A, stored in the first KD+1 rows of the array, except\n         if FACT = \'F\' and EQUED = \'Y\', then A must contain the\n         equilibrated matrix diag(S)*A*diag(S).  The j-th column of A\n         is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n         See below for further details.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= KD+1.\n\\param[in,out] AFB\n         AFB is REAL array, dimension (LDAFB,N)\n         If FACT = \'F\', then AFB is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T of the band matrix\n         A, in the same storage format as A (see AB).  If EQUED = \'Y\',\n         then AFB is the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AFB is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T.\n         If FACT = \'E\', then AFB is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T of the equilibrated\n         matrix A (see the description of A for the form of the\n         equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= KD+1.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realOTHERsolve\n'),(62,'dpbsvx_62.txt','DPBSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\ncompute the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite band matrix and X\nand B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**T * U,  if UPLO = \'U\', or\n      A = L * L**T,  if UPLO = \'L\',\n   where U is an upper triangular band matrix, and L is a lower\n   triangular band matrix.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFB contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  AB and AFB will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AFB and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFB and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right-hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the symmetric band\n         matrix A, stored in the first KD+1 rows of the array, except\n         if FACT = \'F\' and EQUED = \'Y\', then A must contain the\n         equilibrated matrix diag(S)*A*diag(S).  The j-th column of A\n         is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n         See below for further details.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= KD+1.\n\\param[in,out] AFB\n         AFB is DOUBLE PRECISION array, dimension (LDAFB,N)\n         If FACT = \'F\', then AFB is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T of the band matrix\n         A, in the same storage format as A (see AB).  If EQUED = \'Y\',\n         then AFB is the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AFB is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T.\n         If FACT = \'E\', then AFB is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T of the equilibrated\n         matrix A (see the description of A for the form of the\n         equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= KD+1.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleOTHERsolve\n'),(63,'cpbsvx_63.txt','CPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\ncompute the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite band matrix and X\nand B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**H * U,  if UPLO = \'U\', or\n      A = L * L**H,  if UPLO = \'L\',\n   where U is an upper triangular band matrix, and L is a lower\n   triangular band matrix.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFB contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  AB and AFB will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AFB and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFB and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right-hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the Hermitian band\n         matrix A, stored in the first KD+1 rows of the array, except\n         if FACT = \'F\' and EQUED = \'Y\', then A must contain the\n         equilibrated matrix diag(S)*A*diag(S).  The j-th column of A\n         is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n         See below for further details.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= KD+1.\n\\param[in,out] AFB\n         AFB is COMPLEX array, dimension (LDAFB,N)\n         If FACT = \'F\', then AFB is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H of the band matrix\n         A, in the same storage format as A (see AB).  If EQUED = \'Y\',\n         then AFB is the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AFB is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H.\n         If FACT = \'E\', then AFB is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H of the equilibrated\n         matrix A (see the description of A for the form of the\n         equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= KD+1.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexOTHERsolve\n'),(64,'zpbsvx_64.txt','ZPBSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\ncompute the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite band matrix and X\nand B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**H * U,  if UPLO = \'U\', or\n      A = L * L**H,  if UPLO = \'L\',\n   where U is an upper triangular band matrix, and L is a lower\n   triangular band matrix.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFB contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  AB and AFB will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AFB and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFB and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right-hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the Hermitian band\n         matrix A, stored in the first KD+1 rows of the array, except\n         if FACT = \'F\' and EQUED = \'Y\', then A must contain the\n         equilibrated matrix diag(S)*A*diag(S).  The j-th column of A\n         is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(KD+1+i-j,j) = A(i,j) for max(1,j-KD)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(N,j+KD).\n         See below for further details.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= KD+1.\n\\param[in,out] AFB\n         AFB is COMPLEX*16 array, dimension (LDAFB,N)\n         If FACT = \'F\', then AFB is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**H *U or A = L*L**H of the band matrix\n         A, in the same storage format as A (see AB).  If EQUED = \'Y\',\n         then AFB is the factored form of the equilibrated matrix A.\n         If FACT = \'N\', then AFB is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H *U or A = L*L**H.\n         If FACT = \'E\', then AFB is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H *U or A = L*L**H of the equilibrated\n         matrix A (see the description of A for the form of the\n         equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= KD+1.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16OTHERsolve\n'),(65,'sppsvx_65.txt','SPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\ncompute the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite matrix stored in\npacked format and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**T* U,  if UPLO = \'U\', or\n      A = L * L**T,  if UPLO = \'L\',\n   where U is an upper triangular matrix and L is a lower triangular\n   matrix.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFP contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  AP and AFP will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AFP and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFP and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array, except if FACT = \'F\'\n         and EQUED = \'Y\', then A must contain the equilibrated matrix\n         diag(S)*A*diag(S).  The j-th column of A is stored in the\n         array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.  A is not modified if\n         FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in,out] AFP\n         AFP is REAL array, dimension\n                           (N*(N+1)/2)\n         If FACT = \'F\', then AFP is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T, in the same storage\n         format as A.  If EQUED .ne. \'N\', then AFP is the factored\n         form of the equilibrated matrix A.\n         If FACT = \'N\', then AFP is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T * U or A = L * L**T of the original\n         matrix A.\n         If FACT = \'E\', then AFP is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T * U or A = L * L**T of the equilibrated\n         matrix A (see the description of AP for the form of the\n         equilibrated matrix).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realOTHERsolve\n'),(66,'dppsvx_66.txt','DPPSVX uses the Cholesky factorization A = U**T*U or A = L*L**T to\ncompute the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite matrix stored in\npacked format and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**T* U,  if UPLO = \'U\', or\n      A = L * L**T,  if UPLO = \'L\',\n   where U is an upper triangular matrix and L is a lower triangular\n   matrix.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFP contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  AP and AFP will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AFP and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFP and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array, except if FACT = \'F\'\n         and EQUED = \'Y\', then A must contain the equilibrated matrix\n         diag(S)*A*diag(S).  The j-th column of A is stored in the\n         array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.  A is not modified if\n         FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in,out] AFP\n         AFP is DOUBLE PRECISION array, dimension\n                           (N*(N+1)/2)\n         If FACT = \'F\', then AFP is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T, in the same storage\n         format as A.  If EQUED .ne. \'N\', then AFP is the factored\n         form of the equilibrated matrix A.\n         If FACT = \'N\', then AFP is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T * U or A = L * L**T of the original\n         matrix A.\n         If FACT = \'E\', then AFP is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**T * U or A = L * L**T of the equilibrated\n         matrix A (see the description of AP for the form of the\n         equilibrated matrix).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleOTHERsolve\n'),(67,'cppsvx_67.txt','CPPSVX uses the Cholesky factorization A = U**H*U or A = L*L**H to\ncompute the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite matrix stored in\npacked format and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**H * U ,  if UPLO = \'U\', or\n      A = L * L**H,  if UPLO = \'L\',\n   where U is an upper triangular matrix, L is a lower triangular\n   matrix, and **H indicates conjugate transpose.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFP contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  AP and AFP will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AFP and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFP and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the Hermitian matrix\n         A, packed columnwise in a linear array, except if FACT = \'F\'\n         and EQUED = \'Y\', then A must contain the equilibrated matrix\n         diag(S)*A*diag(S).  The j-th column of A is stored in the\n         array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.  A is not modified if\n         FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in,out] AFP\n         AFP is COMPLEX array, dimension (N*(N+1)/2)\n         If FACT = \'F\', then AFP is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H, in the same storage\n         format as A.  If EQUED .ne. \'N\', then AFP is the factored\n         form of the equilibrated matrix A.\n         If FACT = \'N\', then AFP is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H * U or A = L * L**H of the original\n         matrix A.\n         If FACT = \'E\', then AFP is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H of the equilibrated\n         matrix A (see the description of AP for the form of the\n         equilibrated matrix).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexOTHERsolve\n'),(68,'zppsvx_68.txt','ZPPSVX uses the Cholesky factorization A = U**H * U or A = L * L**H to\ncompute the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite matrix stored in\npacked format and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n      diag(S) * A * diag(S) * inv(diag(S)) * X = diag(S) * B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**H * U ,  if UPLO = \'U\', or\n      A = L * L**H,  if UPLO = \'L\',\n   where U is an upper triangular matrix, L is a lower triangular\n   matrix, and **H indicates conjugate transpose.\n3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n4. The system of equations is solved for X using the factored form\n   of A.\n5. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\n6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix A is\n         supplied on entry, and if not, whether the matrix A should be\n         equilibrated before it is factored.\n         = \'F\':  On entry, AFP contains the factored form of A.\n                 If EQUED = \'Y\', the matrix A has been equilibrated\n                 with scaling factors given by S.  AP and AFP will not\n                 be modified.\n         = \'N\':  The matrix A will be copied to AFP and factored.\n         = \'E\':  The matrix A will be equilibrated if necessary, then\n                 copied to AFP and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the Hermitian matrix\n         A, packed columnwise in a linear array, except if FACT = \'F\'\n         and EQUED = \'Y\', then A must contain the equilibrated matrix\n         diag(S)*A*diag(S).  The j-th column of A is stored in the\n         array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.  A is not modified if\n         FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n         On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n         diag(S)*A*diag(S).\n\\param[in,out] AFP\n         AFP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         If FACT = \'F\', then AFP is an input argument and on entry\n         contains the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H, in the same storage\n         format as A.  If EQUED .ne. \'N\', then AFP is the factored\n         form of the equilibrated matrix A.\n         If FACT = \'N\', then AFP is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H * U or A = L * L**H of the original\n         matrix A.\n         If FACT = \'E\', then AFP is an output argument and on exit\n         returns the triangular factor U or L from the Cholesky\n         factorization A = U**H * U or A = L * L**H of the equilibrated\n         matrix A (see the description of AP for the form of the\n         equilibrated matrix).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n         Specifies the form of equilibration that was done.\n         = \'N\':  No equilibration (always true if FACT = \'N\').\n         = \'Y\':  Equilibration was done, i.e., A has been replaced by\n                 diag(S) * A * diag(S).\n         EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n         output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         The scale factors for A; not accessed if EQUED = \'N\'.  S is\n         an input argument if FACT = \'F\'; otherwise, S is an output\n         argument.  If FACT = \'F\' and EQUED = \'Y\', each element of S\n         must be positive.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the N-by-NRHS right hand side matrix B.\n         On exit, if EQUED = \'N\', B is not modified; if EQUED = \'Y\',\n         B is overwritten by diag(S) * B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X to\n         the original system of equations.  Note that if EQUED = \'Y\',\n         A and B are modified on exit, and the solution to the\n         equilibrated system is inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A after equilibration (if done).  If RCOND is less than the\n         machine precision (in particular, if RCOND = 0), the matrix\n         is singular to working precision.  This condition is\n         indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16OTHERsolve\n'),(69,'sptsvx_69.txt','SPTSVX uses the factorization A = L*D*L**T to compute the solution\nto a real system of linear equations A*X = B, where A is an N-by-N\nsymmetric positive definite tridiagonal matrix and X and B are\nN-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the matrix A is factored as A = L*D*L**T, where L\n   is a unit lower bidiagonal matrix and D is diagonal.  The\n   factorization can also be regarded as having the form\n   A = U**T*D*U.\n2. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, DF and EF contain the factored form of A.\n                 D, E, DF, and EF will not be modified.\n         = \'N\':  The matrix A will be copied to DF and EF and\n                 factored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n diagonal elements of the tridiagonal matrix A.\n\\param[in] E\n         E is REAL array, dimension (N-1)\n         The (n-1) subdiagonal elements of the tridiagonal matrix A.\n\\param[in,out] DF\n         DF is REAL array, dimension (N)\n         If FACT = \'F\', then DF is an input argument and on entry\n         contains the n diagonal elements of the diagonal matrix D\n         from the L*D*L**T factorization of A.\n         If FACT = \'N\', then DF is an output argument and on exit\n         contains the n diagonal elements of the diagonal matrix D\n         from the L*D*L**T factorization of A.\n\\param[in,out] EF\n         EF is REAL array, dimension (N-1)\n         If FACT = \'F\', then EF is an input argument and on entry\n         contains the (n-1) subdiagonal elements of the unit\n         bidiagonal factor L from the L*D*L**T factorization of A.\n         If FACT = \'N\', then EF is an output argument and on exit\n         contains the (n-1) subdiagonal elements of the unit\n         bidiagonal factor L from the L*D*L**T factorization of A.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n         If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal condition number of the matrix A.  If RCOND\n         is less than the machine precision (in particular, if\n         RCOND = 0), the matrix is singular to working precision.\n         This condition is indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in any\n         element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realOTHERcomputational\n'),(70,'dptsvx_70.txt','DPTSVX uses the factorization A = L*D*L**T to compute the solution\nto a real system of linear equations A*X = B, where A is an N-by-N\nsymmetric positive definite tridiagonal matrix and X and B are\nN-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the matrix A is factored as A = L*D*L**T, where L\n   is a unit lower bidiagonal matrix and D is diagonal.  The\n   factorization can also be regarded as having the form\n   A = U**T*D*U.\n2. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, DF and EF contain the factored form of A.\n                 D, E, DF, and EF will not be modified.\n         = \'N\':  The matrix A will be copied to DF and EF and\n                 factored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the tridiagonal matrix A.\n\\param[in] E\n         E is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) subdiagonal elements of the tridiagonal matrix A.\n\\param[in,out] DF\n         DF is DOUBLE PRECISION array, dimension (N)\n         If FACT = \'F\', then DF is an input argument and on entry\n         contains the n diagonal elements of the diagonal matrix D\n         from the L*D*L**T factorization of A.\n         If FACT = \'N\', then DF is an output argument and on exit\n         contains the n diagonal elements of the diagonal matrix D\n         from the L*D*L**T factorization of A.\n\\param[in,out] EF\n         EF is DOUBLE PRECISION array, dimension (N-1)\n         If FACT = \'F\', then EF is an input argument and on entry\n         contains the (n-1) subdiagonal elements of the unit\n         bidiagonal factor L from the L*D*L**T factorization of A.\n         If FACT = \'N\', then EF is an output argument and on exit\n         contains the (n-1) subdiagonal elements of the unit\n         bidiagonal factor L from the L*D*L**T factorization of A.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0 of INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal condition number of the matrix A.  If RCOND\n         is less than the machine precision (in particular, if\n         RCOND = 0), the matrix is singular to working precision.\n         This condition is indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in any\n         element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleOTHERcomputational\n'),(71,'cptsvx_71.txt','CPTSVX uses the factorization A = L*D*L**H to compute the solution\nto a complex system of linear equations A*X = B, where A is an\nN-by-N Hermitian positive definite tridiagonal matrix and X and B\nare N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the matrix A is factored as A = L*D*L**H, where L\n   is a unit lower bidiagonal matrix and D is diagonal.  The\n   factorization can also be regarded as having the form\n   A = U**H*D*U.\n2. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix\n         A is supplied on entry.\n         = \'F\':  On entry, DF and EF contain the factored form of A.\n                 D, E, DF, and EF will not be modified.\n         = \'N\':  The matrix A will be copied to DF and EF and\n                 factored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n diagonal elements of the tridiagonal matrix A.\n\\param[in] E\n         E is COMPLEX array, dimension (N-1)\n         The (n-1) subdiagonal elements of the tridiagonal matrix A.\n\\param[in,out] DF\n         DF is REAL array, dimension (N)\n         If FACT = \'F\', then DF is an input argument and on entry\n         contains the n diagonal elements of the diagonal matrix D\n         from the L*D*L**H factorization of A.\n         If FACT = \'N\', then DF is an output argument and on exit\n         contains the n diagonal elements of the diagonal matrix D\n         from the L*D*L**H factorization of A.\n\\param[in,out] EF\n         EF is COMPLEX array, dimension (N-1)\n         If FACT = \'F\', then EF is an input argument and on entry\n         contains the (n-1) subdiagonal elements of the unit\n         bidiagonal factor L from the L*D*L**H factorization of A.\n         If FACT = \'N\', then EF is an output argument and on exit\n         contains the (n-1) subdiagonal elements of the unit\n         bidiagonal factor L from the L*D*L**H factorization of A.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal condition number of the matrix A.  If RCOND\n         is less than the machine precision (in particular, if\n         RCOND = 0), the matrix is singular to working precision.\n         This condition is indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in any\n         element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexOTHERcomputational\n'),(72,'zptsvx_72.txt','ZPTSVX uses the factorization A = L*D*L**H to compute the solution\nto a complex system of linear equations A*X = B, where A is an\nN-by-N Hermitian positive definite tridiagonal matrix and X and B\nare N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the matrix A is factored as A = L*D*L**H, where L\n   is a unit lower bidiagonal matrix and D is diagonal.  The\n   factorization can also be regarded as having the form\n   A = U**H*D*U.\n2. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A.  If the reciprocal of the condition number is less than machine\n   precision, INFO = N+1 is returned as a warning, but the routine\n   still goes on to solve for X and compute error bounds as\n   described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of the matrix\n         A is supplied on entry.\n         = \'F\':  On entry, DF and EF contain the factored form of A.\n                 D, E, DF, and EF will not be modified.\n         = \'N\':  The matrix A will be copied to DF and EF and\n                 factored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the tridiagonal matrix A.\n\\param[in] E\n         E is COMPLEX*16 array, dimension (N-1)\n         The (n-1) subdiagonal elements of the tridiagonal matrix A.\n\\param[in,out] DF\n         DF is DOUBLE PRECISION array, dimension (N)\n         If FACT = \'F\', then DF is an input argument and on entry\n         contains the n diagonal elements of the diagonal matrix D\n         from the L*D*L**H factorization of A.\n         If FACT = \'N\', then DF is an output argument and on exit\n         contains the n diagonal elements of the diagonal matrix D\n         from the L*D*L**H factorization of A.\n\\param[in,out] EF\n         EF is COMPLEX*16 array, dimension (N-1)\n         If FACT = \'F\', then EF is an input argument and on entry\n         contains the (n-1) subdiagonal elements of the unit\n         bidiagonal factor L from the L*D*L**H factorization of A.\n         If FACT = \'N\', then EF is an output argument and on exit\n         contains the (n-1) subdiagonal elements of the unit\n         bidiagonal factor L from the L*D*L**H factorization of A.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal condition number of the matrix A.  If RCOND\n         is less than the machine precision (in particular, if\n         RCOND = 0), the matrix is singular to working precision.\n         This condition is indicated by a return code of INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in any\n         element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  the leading minor of order i of A is\n                      not positive definite, so the factorization\n                      could not be completed, and the solution has not\n                      been computed. RCOND = 0 is returned.\n               = N+1: U is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16OTHERcomputational\n'),(73,'ssysvx_73.txt','SSYSVX uses the diagonal pivoting factorization to compute the\nsolution to a real system of linear equations A * X = B,\nwhere A is an N-by-N symmetric matrix and X and B are N-by-NRHS\nmatrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n   The form of the factorization is\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AF and IPIV contain the factored form of\n                 A.  AF and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is REAL array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by SSYTRF.\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by SSYTRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by SSYTRF.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= max(1,3*N), and for best\n         performance, when FACT = \'N\', LWORK >= max(1,3*N,N*NB), where\n         NB is the optimal blocksize for SSYTRF.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realSYsolve\n'),(74,'dsysvx_74.txt','DSYSVX uses the diagonal pivoting factorization to compute the\nsolution to a real system of linear equations A * X = B,\nwhere A is an N-by-N symmetric matrix and X and B are N-by-NRHS\nmatrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n   The form of the factorization is\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AF and IPIV contain the factored form of\n                 A.  AF and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by DSYTRF.\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by DSYTRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by DSYTRF.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= max(1,3*N), and for best\n         performance, when FACT = \'N\', LWORK >= max(1,3*N,N*NB), where\n         NB is the optimal blocksize for DSYTRF.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleSYsolve\n'),(75,'csysvx_75.txt','CSYSVX uses the diagonal pivoting factorization to compute the\nsolution to a complex system of linear equations A * X = B,\nwhere A is an N-by-N symmetric matrix and X and B are N-by-NRHS\nmatrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n   The form of the factorization is\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AF and IPIV contain the factored form\n                 of A.  A, AF and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by CSYTRF.\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by CSYTRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by CSYTRF.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= max(1,2*N), and for best\n         performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where\n         NB is the optimal blocksize for CSYTRF.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexSYsolve\n'),(76,'zsysvx_76.txt','ZSYSVX uses the diagonal pivoting factorization to compute the\nsolution to a complex system of linear equations A * X = B,\nwhere A is an N-by-N symmetric matrix and X and B are N-by-NRHS\nmatrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A.\n   The form of the factorization is\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AF and IPIV contain the factored form\n                 of A.  A, AF and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n         If FACT = \'F\', then AF is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by ZSYTRF.\n         If FACT = \'N\', then AF is an output argument and on exit\n         returns the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by ZSYTRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by ZSYTRF.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >= max(1,2*N), and for best\n         performance, when FACT = \'N\', LWORK >= max(1,2*N,N*NB), where\n         NB is the optimal blocksize for ZSYTRF.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16SYsolve\n'),(77,'sspsvx_77.txt','SSPSVX uses the diagonal pivoting factorization A = U*D*U**T or\nA = L*D*L**T to compute the solution to a real system of linear\nequations A * X = B, where A is an N-by-N symmetric matrix stored\nin packed format and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AFP and IPIV contain the factored form of\n                 A.  AP, AFP and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AFP and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n\\param[in,out] AFP\n         AFP is REAL array, dimension\n                           (N*(N+1)/2)\n         If FACT = \'F\', then AFP is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n         If FACT = \'N\', then AFP is an output argument and on exit\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by SSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by SSPTRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by SSPTRF.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realOTHERsolve\n'),(78,'dspsvx_78.txt','DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or\nA = L*D*L**T to compute the solution to a real system of linear\nequations A * X = B, where A is an N-by-N symmetric matrix stored\nin packed format and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AFP and IPIV contain the factored form of\n                 A.  AP, AFP and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AFP and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n\\param[in,out] AFP\n         AFP is DOUBLE PRECISION array, dimension\n                           (N*(N+1)/2)\n         If FACT = \'F\', then AFP is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n         If FACT = \'N\', then AFP is an output argument and on exit\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by DSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by DSPTRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by DSPTRF.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleOTHERsolve\n'),(79,'cspsvx_79.txt','CSPSVX uses the diagonal pivoting factorization A = U*D*U**T or\nA = L*D*L**T to compute the solution to a complex system of linear\nequations A * X = B, where A is an N-by-N symmetric matrix stored\nin packed format and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AFP and IPIV contain the factored form\n                 of A.  AP, AFP and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AFP and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n\\param[in,out] AFP\n         AFP is COMPLEX array, dimension (N*(N+1)/2)\n         If FACT = \'F\', then AFP is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n         If FACT = \'N\', then AFP is an output argument and on exit\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by CSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by CSPTRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by CSPTRF.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexOTHERsolve\n'),(80,'zspsvx_80.txt','ZSPSVX uses the diagonal pivoting factorization A = U*D*U**T or\nA = L*D*L**T to compute the solution to a complex system of linear\nequations A * X = B, where A is an N-by-N symmetric matrix stored\nin packed format and X and B are N-by-NRHS matrices.\nError bounds on the solution and a condition estimate are also\nprovided.\n\\par Description:\nThe following steps are performed:\n1. If FACT = \'N\', the diagonal pivoting method is used to factor A as\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n2. If some D(i,i)=0, so that D is exactly singular, then the routine\n   returns with INFO = i. Otherwise, the factored form of A is used\n   to estimate the condition number of the matrix A.  If the\n   reciprocal of the condition number is less than machine precision,\n   INFO = N+1 is returned as a warning, but the routine still goes on\n   to solve for X and compute error bounds as described below.\n3. The system of equations is solved for X using the factored form\n   of A.\n4. Iterative refinement is applied to improve the computed solution\n   matrix and calculate error bounds and backward error estimates\n   for it.\nArguments:\n\\param[in] FACT\n         FACT is CHARACTER*1\n         Specifies whether or not the factored form of A has been\n         supplied on entry.\n         = \'F\':  On entry, AFP and IPIV contain the factored form\n                 of A.  AP, AFP and IPIV will not be modified.\n         = \'N\':  The matrix A will be copied to AFP and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n\\param[in,out] AFP\n         AFP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         If FACT = \'F\', then AFP is an input argument and on entry\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n         If FACT = \'N\', then AFP is an output argument and on exit\n         contains the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L from the factorization\n         A = U*D*U**T or A = L*D*L**T as computed by ZSPTRF, stored as\n         a packed triangular matrix in the same storage format as A.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         If FACT = \'F\', then IPIV is an input argument and on entry\n         contains details of the interchanges and the block structure\n         of D, as determined by ZSPTRF.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n         If FACT = \'N\', then IPIV is an output argument and on exit\n         contains details of the interchanges and the block structure\n         of D, as determined by ZSPTRF.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0 or INFO = N+1, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The estimate of the reciprocal condition number of the matrix\n         A.  If RCOND is less than the machine precision (in\n         particular, if RCOND = 0), the matrix is singular to working\n         precision.  This condition is indicated by a return code of\n         INFO > 0.\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= N:  D(i,i) is exactly zero.  The factorization\n                      has been completed but the factor D is exactly\n                      singular, so the solution and error bounds could\n                      not be computed. RCOND = 0 is returned.\n               = N+1: D is nonsingular, but RCOND is less than machine\n                      precision, meaning that the matrix is singular\n                      to working precision.  Nevertheless, the\n                      solution and error bounds are computed because\n                      there are a number of situations where the\n                      computed solution can be more accurate than the\n                      value of RCOND would suggest.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16OTHERsolve\n'),(81,'sgetrf_81.txt','SGETRF computes an LU factorization of a general M-by-N matrix A\nusing partial pivoting with row interchanges.\nThe factorization has the form\n   A = P * L * U\nwhere P is a permutation matrix, L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\nThis is the right-looking Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the M-by-N matrix to be factored.\n         On exit, the factors L and U from the factorization\n         A = P*L*U; the unit diagonal elements of L are not stored.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (min(M,N))\n         The pivot indices; for 1 <= i <= min(M,N), row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero. The factorization\n               has been completed, but the factor U is exactly\n               singular, and division by zero will occur if it is used\n               to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGEcomputational\n'),(82,'dgetrf_82.txt','DGETRF computes an LU factorization of a general M-by-N matrix A\nusing partial pivoting with row interchanges.\nThe factorization has the form\n   A = P * L * U\nwhere P is a permutation matrix, L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\nThis is the right-looking Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the M-by-N matrix to be factored.\n         On exit, the factors L and U from the factorization\n         A = P*L*U; the unit diagonal elements of L are not stored.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (min(M,N))\n         The pivot indices; for 1 <= i <= min(M,N), row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero. The factorization\n               has been completed, but the factor U is exactly\n               singular, and division by zero will occur if it is used\n               to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEcomputational\n'),(83,'cgetrf_83.txt','CGETRF computes an LU factorization of a general M-by-N matrix A\nusing partial pivoting with row interchanges.\nThe factorization has the form\n   A = P * L * U\nwhere P is a permutation matrix, L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\nThis is the right-looking Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the M-by-N matrix to be factored.\n         On exit, the factors L and U from the factorization\n         A = P*L*U; the unit diagonal elements of L are not stored.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (min(M,N))\n         The pivot indices; for 1 <= i <= min(M,N), row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero. The factorization\n               has been completed, but the factor U is exactly\n               singular, and division by zero will occur if it is used\n               to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEcomputational\n'),(84,'zgetrf_84.txt','ZGETRF computes an LU factorization of a general M-by-N matrix A\nusing partial pivoting with row interchanges.\nThe factorization has the form\n   A = P * L * U\nwhere P is a permutation matrix, L is lower triangular with unit\ndiagonal elements (lower trapezoidal if m > n), and U is upper\ntriangular (upper trapezoidal if m < n).\nThis is the right-looking Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the M-by-N matrix to be factored.\n         On exit, the factors L and U from the factorization\n         A = P*L*U; the unit diagonal elements of L are not stored.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (min(M,N))\n         The pivot indices; for 1 <= i <= min(M,N), row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero. The factorization\n               has been completed, but the factor U is exactly\n               singular, and division by zero will occur if it is used\n               to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEcomputational\n'),(85,'sgbtrf_85.txt','SGBTRF computes an LU factorization of a real m-by-n band matrix A\nusing partial pivoting with row interchanges.\nThis is the blocked version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in,out] AB\n         AB is REAL array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows KL+1 to\n         2*KL+KU+1; rows 1 to KL of the array need not be set.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)\n         On exit, details of the factorization: U is stored as an\n         upper triangular band matrix with KL+KU superdiagonals in\n         rows 1 to KL+KU+1, and the multipliers used during the\n         factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n         See below for further details.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (min(M,N))\n         The pivot indices; for 1 <= i <= min(M,N), row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = +i, U(i,i) is exactly zero. The factorization\n              has been completed, but the factor U is exactly\n              singular, and division by zero will occur if it is used\n              to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGBcomputational\n'),(86,'dgbtrf_86.txt','DGBTRF computes an LU factorization of a real m-by-n band matrix A\nusing partial pivoting with row interchanges.\nThis is the blocked version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in,out] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows KL+1 to\n         2*KL+KU+1; rows 1 to KL of the array need not be set.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)\n         On exit, details of the factorization: U is stored as an\n         upper triangular band matrix with KL+KU superdiagonals in\n         rows 1 to KL+KU+1, and the multipliers used during the\n         factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n         See below for further details.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (min(M,N))\n         The pivot indices; for 1 <= i <= min(M,N), row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = +i, U(i,i) is exactly zero. The factorization\n              has been completed, but the factor U is exactly\n              singular, and division by zero will occur if it is used\n              to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGBcomputational\n'),(87,'cgbtrf_87.txt','CGBTRF computes an LU factorization of a complex m-by-n band matrix A\nusing partial pivoting with row interchanges.\nThis is the blocked version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in,out] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows KL+1 to\n         2*KL+KU+1; rows 1 to KL of the array need not be set.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)\n         On exit, details of the factorization: U is stored as an\n         upper triangular band matrix with KL+KU superdiagonals in\n         rows 1 to KL+KU+1, and the multipliers used during the\n         factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n         See below for further details.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (min(M,N))\n         The pivot indices; for 1 <= i <= min(M,N), row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = +i, U(i,i) is exactly zero. The factorization\n              has been completed, but the factor U is exactly\n              singular, and division by zero will occur if it is used\n              to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGBcomputational\n'),(88,'zgbtrf_88.txt','ZGBTRF computes an LU factorization of a complex m-by-n band matrix A\nusing partial pivoting with row interchanges.\nThis is the blocked version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in,out] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows KL+1 to\n         2*KL+KU+1; rows 1 to KL of the array need not be set.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl)\n         On exit, details of the factorization: U is stored as an\n         upper triangular band matrix with KL+KU superdiagonals in\n         rows 1 to KL+KU+1, and the multipliers used during the\n         factorization are stored in rows KL+KU+2 to 2*KL+KU+1.\n         See below for further details.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (min(M,N))\n         The pivot indices; for 1 <= i <= min(M,N), row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = +i, U(i,i) is exactly zero. The factorization\n              has been completed, but the factor U is exactly\n              singular, and division by zero will occur if it is used\n              to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GBcomputational\n'),(89,'sgttrf_89.txt','SGTTRF computes an LU factorization of a real tridiagonal matrix A\nusing elimination with partial pivoting and row interchanges.\nThe factorization has the form\n   A = L * U\nwhere L is a product of permutation and unit lower bidiagonal\nmatrices and U is upper triangular with nonzeros in only the main\ndiagonal and first two superdiagonals.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.\n\\param[in,out] DL\n         DL is REAL array, dimension (N-1)\n         On entry, DL must contain the (n-1) sub-diagonal elements of\n         A.\n         On exit, DL is overwritten by the (n-1) multipliers that\n         define the matrix L from the LU factorization of A.\n\\param[in,out] D\n         D is REAL array, dimension (N)\n         On entry, D must contain the diagonal elements of A.\n         On exit, D is overwritten by the n diagonal elements of the\n         upper triangular matrix U from the LU factorization of A.\n\\param[in,out] DU\n         DU is REAL array, dimension (N-1)\n         On entry, DU must contain the (n-1) super-diagonal elements\n         of A.\n         On exit, DU is overwritten by the (n-1) elements of the first\n         super-diagonal of U.\n\\param[out] DU2\n         DU2 is REAL array, dimension (N-2)\n         On exit, DU2 is overwritten by the (n-2) elements of the\n         second super-diagonal of U.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -k, the k-th argument had an illegal value\n         > 0:  if INFO = k, U(k,k) is exactly zero. The factorization\n               has been completed, but the factor U is exactly\n               singular, and division by zero will occur if it is used\n               to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(90,'dgttrf_90.txt','DGTTRF computes an LU factorization of a real tridiagonal matrix A\nusing elimination with partial pivoting and row interchanges.\nThe factorization has the form\n   A = L * U\nwhere L is a product of permutation and unit lower bidiagonal\nmatrices and U is upper triangular with nonzeros in only the main\ndiagonal and first two superdiagonals.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.\n\\param[in,out] DL\n         DL is DOUBLE PRECISION array, dimension (N-1)\n         On entry, DL must contain the (n-1) sub-diagonal elements of\n         A.\n         On exit, DL is overwritten by the (n-1) multipliers that\n         define the matrix L from the LU factorization of A.\n\\param[in,out] D\n         D is DOUBLE PRECISION array, dimension (N)\n         On entry, D must contain the diagonal elements of A.\n         On exit, D is overwritten by the n diagonal elements of the\n         upper triangular matrix U from the LU factorization of A.\n\\param[in,out] DU\n         DU is DOUBLE PRECISION array, dimension (N-1)\n         On entry, DU must contain the (n-1) super-diagonal elements\n         of A.\n         On exit, DU is overwritten by the (n-1) elements of the first\n         super-diagonal of U.\n\\param[out] DU2\n         DU2 is DOUBLE PRECISION array, dimension (N-2)\n         On exit, DU2 is overwritten by the (n-2) elements of the\n         second super-diagonal of U.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -k, the k-th argument had an illegal value\n         > 0:  if INFO = k, U(k,k) is exactly zero. The factorization\n               has been completed, but the factor U is exactly\n               singular, and division by zero will occur if it is used\n               to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(91,'cgttrf_91.txt','CGTTRF computes an LU factorization of a complex tridiagonal matrix A\nusing elimination with partial pivoting and row interchanges.\nThe factorization has the form\n   A = L * U\nwhere L is a product of permutation and unit lower bidiagonal\nmatrices and U is upper triangular with nonzeros in only the main\ndiagonal and first two superdiagonals.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.\n\\param[in,out] DL\n         DL is COMPLEX array, dimension (N-1)\n         On entry, DL must contain the (n-1) sub-diagonal elements of\n         A.\n         On exit, DL is overwritten by the (n-1) multipliers that\n         define the matrix L from the LU factorization of A.\n\\param[in,out] D\n         D is COMPLEX array, dimension (N)\n         On entry, D must contain the diagonal elements of A.\n         On exit, D is overwritten by the n diagonal elements of the\n         upper triangular matrix U from the LU factorization of A.\n\\param[in,out] DU\n         DU is COMPLEX array, dimension (N-1)\n         On entry, DU must contain the (n-1) super-diagonal elements\n         of A.\n         On exit, DU is overwritten by the (n-1) elements of the first\n         super-diagonal of U.\n\\param[out] DU2\n         DU2 is COMPLEX array, dimension (N-2)\n         On exit, DU2 is overwritten by the (n-2) elements of the\n         second super-diagonal of U.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -k, the k-th argument had an illegal value\n         > 0:  if INFO = k, U(k,k) is exactly zero. The factorization\n               has been completed, but the factor U is exactly\n               singular, and division by zero will occur if it is used\n               to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(92,'zgttrf_92.txt','ZGTTRF computes an LU factorization of a complex tridiagonal matrix A\nusing elimination with partial pivoting and row interchanges.\nThe factorization has the form\n   A = L * U\nwhere L is a product of permutation and unit lower bidiagonal\nmatrices and U is upper triangular with nonzeros in only the main\ndiagonal and first two superdiagonals.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.\n\\param[in,out] DL\n         DL is COMPLEX*16 array, dimension (N-1)\n         On entry, DL must contain the (n-1) sub-diagonal elements of\n         A.\n         On exit, DL is overwritten by the (n-1) multipliers that\n         define the matrix L from the LU factorization of A.\n\\param[in,out] D\n         D is COMPLEX*16 array, dimension (N)\n         On entry, D must contain the diagonal elements of A.\n         On exit, D is overwritten by the n diagonal elements of the\n         upper triangular matrix U from the LU factorization of A.\n\\param[in,out] DU\n         DU is COMPLEX*16 array, dimension (N-1)\n         On entry, DU must contain the (n-1) super-diagonal elements\n         of A.\n         On exit, DU is overwritten by the (n-1) elements of the first\n         super-diagonal of U.\n\\param[out] DU2\n         DU2 is COMPLEX*16 array, dimension (N-2)\n         On exit, DU2 is overwritten by the (n-2) elements of the\n         second super-diagonal of U.\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -k, the k-th argument had an illegal value\n         > 0:  if INFO = k, U(k,k) is exactly zero. The factorization\n               has been completed, but the factor U is exactly\n               singular, and division by zero will occur if it is used\n               to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(93,'spotrf_93.txt','SPOTRF computes the Cholesky factorization of a real symmetric\npositive definite matrix A.\nThe factorization has the form\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nThis is the block version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realPOcomputational\n'),(94,'dpotrf_94.txt','DPOTRF computes the Cholesky factorization of a real symmetric\npositive definite matrix A.\nThe factorization has the form\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nThis is the block version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doublePOcomputational\n'),(95,'cpotrf_95.txt','CPOTRF computes the Cholesky factorization of a complex Hermitian\npositive definite matrix A.\nThe factorization has the form\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L  * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nThis is the block version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexPOcomputational\n'),(96,'zpotrf_96.txt','ZPOTRF computes the Cholesky factorization of a complex Hermitian\npositive definite matrix A.\nThe factorization has the form\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L  * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nThis is the block version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization A = U**H *U or A = L*L**H.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POcomputational\n'),(97,'spptrf_97.txt','SPPTRF computes the Cholesky factorization of a real symmetric\npositive definite matrix A stored in packed format.\nThe factorization has the form\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**T*U or A = L*L**T, in the same\n         storage format as A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(98,'dpptrf_98.txt','DPPTRF computes the Cholesky factorization of a real symmetric\npositive definite matrix A stored in packed format.\nThe factorization has the form\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**T*U or A = L*L**T, in the same\n         storage format as A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(99,'cpptrf_99.txt','CPPTRF computes the Cholesky factorization of a complex Hermitian\npositive definite matrix A stored in packed format.\nThe factorization has the form\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L  * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the Hermitian matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**H*U or A = L*L**H, in the same\n         storage format as A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(100,'zpptrf_100.txt','ZPPTRF computes the Cholesky factorization of a complex Hermitian\npositive definite matrix A stored in packed format.\nThe factorization has the form\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L  * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the Hermitian matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**H*U or A = L*L**H, in the same\n         storage format as A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(101,'spbtrf_101.txt','SPBTRF computes the Cholesky factorization of a real symmetric\npositive definite band matrix A.\nThe factorization has the form\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in,out] AB\n         AB is REAL array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the symmetric band\n         matrix A, stored in the first KD+1 rows of the array.  The\n         j-th column of A is stored in the j-th column of the array AB\n         as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**T*U or A = L*L**T of the band\n         matrix A, in the same storage format as A.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(102,'dpbtrf_102.txt','DPBTRF computes the Cholesky factorization of a real symmetric\npositive definite band matrix A.\nThe factorization has the form\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in,out] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the symmetric band\n         matrix A, stored in the first KD+1 rows of the array.  The\n         j-th column of A is stored in the j-th column of the array AB\n         as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**T*U or A = L*L**T of the band\n         matrix A, in the same storage format as A.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(103,'cpbtrf_103.txt','CPBTRF computes the Cholesky factorization of a complex Hermitian\npositive definite band matrix A.\nThe factorization has the form\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L  * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in,out] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the Hermitian band\n         matrix A, stored in the first KD+1 rows of the array.  The\n         j-th column of A is stored in the j-th column of the array AB\n         as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**H*U or A = L*L**H of the band\n         matrix A, in the same storage format as A.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(104,'zpbtrf_104.txt','ZPBTRF computes the Cholesky factorization of a complex Hermitian\npositive definite band matrix A.\nThe factorization has the form\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L  * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in,out] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         On entry, the upper or lower triangle of the Hermitian band\n         matrix A, stored in the first KD+1 rows of the array.  The\n         j-th column of A is stored in the j-th column of the array AB\n         as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         On exit, if INFO = 0, the triangular factor U or L from the\n         Cholesky factorization A = U**H*U or A = L*L**H of the band\n         matrix A, in the same storage format as A.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(105,'spttrf_105.txt','SPTTRF computes the L*D*L**T factorization of a real symmetric\npositive definite tridiagonal matrix A.  The factorization may also\nbe regarded as having the form A = U**T*D*U.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] D\n         D is REAL array, dimension (N)\n         On entry, the n diagonal elements of the tridiagonal matrix\n         A.  On exit, the n diagonal elements of the diagonal matrix\n         D from the L*D*L**T factorization of A.\n\\param[in,out] E\n         E is REAL array, dimension (N-1)\n         On entry, the (n-1) subdiagonal elements of the tridiagonal\n         matrix A.  On exit, the (n-1) subdiagonal elements of the\n         unit bidiagonal factor L from the L*D*L**T factorization of A.\n         E can also be regarded as the superdiagonal of the unit\n         bidiagonal factor U from the U**T*D*U factorization of A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\n         > 0: if INFO = k, the leading minor of order k is not\n              positive definite; if k < N, the factorization could not\n              be completed, while if k = N, the factorization was\n              completed, but D(N) <= 0.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup auxOTHERcomputational\n'),(106,'dpttrf_106.txt','DPTTRF computes the L*D*L**T factorization of a real symmetric\npositive definite tridiagonal matrix A.  The factorization may also\nbe regarded as having the form A = U**T*D*U.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] D\n         D is DOUBLE PRECISION array, dimension (N)\n         On entry, the n diagonal elements of the tridiagonal matrix\n         A.  On exit, the n diagonal elements of the diagonal matrix\n         D from the L*D*L**T factorization of A.\n\\param[in,out] E\n         E is DOUBLE PRECISION array, dimension (N-1)\n         On entry, the (n-1) subdiagonal elements of the tridiagonal\n         matrix A.  On exit, the (n-1) subdiagonal elements of the\n         unit bidiagonal factor L from the L*D*L**T factorization of A.\n         E can also be regarded as the superdiagonal of the unit\n         bidiagonal factor U from the U**T*D*U factorization of A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\n         > 0: if INFO = k, the leading minor of order k is not\n              positive definite; if k < N, the factorization could not\n              be completed, while if k = N, the factorization was\n              completed, but D(N) <= 0.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup auxOTHERcomputational\n'),(107,'cpttrf_107.txt','CPTTRF computes the L*D*L**H factorization of a complex Hermitian\npositive definite tridiagonal matrix A.  The factorization may also\nbe regarded as having the form A = U**H *D*U.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] D\n         D is REAL array, dimension (N)\n         On entry, the n diagonal elements of the tridiagonal matrix\n         A.  On exit, the n diagonal elements of the diagonal matrix\n         D from the L*D*L**H factorization of A.\n\\param[in,out] E\n         E is COMPLEX array, dimension (N-1)\n         On entry, the (n-1) subdiagonal elements of the tridiagonal\n         matrix A.  On exit, the (n-1) subdiagonal elements of the\n         unit bidiagonal factor L from the L*D*L**H factorization of A.\n         E can also be regarded as the superdiagonal of the unit\n         bidiagonal factor U from the U**H *D*U factorization of A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\n         > 0: if INFO = k, the leading minor of order k is not\n              positive definite; if k < N, the factorization could not\n              be completed, while if k = N, the factorization was\n              completed, but D(N) <= 0.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(108,'zpttrf_108.txt','ZPTTRF computes the L*D*L**H factorization of a complex Hermitian\npositive definite tridiagonal matrix A.  The factorization may also\nbe regarded as having the form A = U**H *D*U.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] D\n         D is DOUBLE PRECISION array, dimension (N)\n         On entry, the n diagonal elements of the tridiagonal matrix\n         A.  On exit, the n diagonal elements of the diagonal matrix\n         D from the L*D*L**H factorization of A.\n\\param[in,out] E\n         E is COMPLEX*16 array, dimension (N-1)\n         On entry, the (n-1) subdiagonal elements of the tridiagonal\n         matrix A.  On exit, the (n-1) subdiagonal elements of the\n         unit bidiagonal factor L from the L*D*L**H factorization of A.\n         E can also be regarded as the superdiagonal of the unit\n         bidiagonal factor U from the U**H *D*U factorization of A.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\n         > 0: if INFO = k, the leading minor of order k is not\n              positive definite; if k < N, the factorization could not\n              be completed, while if k = N, the factorization was\n              completed, but D(N) <= 0.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(109,'ssytrf_109.txt','SSYTRF computes the factorization of a real symmetric matrix A using\nthe Bunch-Kaufman diagonal pivoting method.  The form of the\nfactorization is\n   A = U*D*U**T  or  A = L*D*L**T\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with \n1-by-1 and 2-by-2 diagonal blocks.\nThis is the blocked version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L (see below for further details).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] WORK\n         WORK is REAL array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >=1.  For best performance\n         LWORK >= N*NB, where NB is the block size returned by ILAENV.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, and division by zero will occur if it\n               is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYcomputational\n'),(110,'dsytrf_110.txt','DSYTRF computes the factorization of a real symmetric matrix A using\nthe Bunch-Kaufman diagonal pivoting method.  The form of the\nfactorization is\n   A = U*D*U**T  or  A = L*D*L**T\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.\nThis is the blocked version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L (see below for further details).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >=1.  For best performance\n         LWORK >= N*NB, where NB is the block size returned by ILAENV.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, and division by zero will occur if it\n               is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYcomputational\n'),(111,'chetrf_111.txt','CHETRF computes the factorization of a complex Hermitian matrix A\nusing the Bunch-Kaufman diagonal pivoting method.  The form of the\nfactorization is\n   A = U*D*U**H  or  A = L*D*L**H\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is Hermitian and block diagonal with \n1-by-1 and 2-by-2 diagonal blocks.\nThis is the blocked version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L (see below for further details).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >=1.  For best performance\n         LWORK >= N*NB, where NB is the block size returned by ILAENV.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, and division by zero will occur if it\n               is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEcomputational\n'),(112,'zhetrf_112.txt','ZHETRF computes the factorization of a complex Hermitian matrix A\nusing the Bunch-Kaufman diagonal pivoting method.  The form of the\nfactorization is\n   A = U*D*U**H  or  A = L*D*L**H\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is Hermitian and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.\nThis is the blocked version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the Hermitian matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L (see below for further details).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >=1.  For best performance\n         LWORK >= N*NB, where NB is the block size returned by ILAENV.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, and division by zero will occur if it\n               is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEcomputational\n'),(113,'csytrf_113.txt','CSYTRF computes the factorization of a complex symmetric matrix A\nusing the Bunch-Kaufman diagonal pivoting method.  The form of the\nfactorization is\n   A = U*D*U**T  or  A = L*D*L**T\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\nwith 1-by-1 and 2-by-2 diagonal blocks.\nThis is the blocked version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L (see below for further details).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >=1.  For best performance\n         LWORK >= N*NB, where NB is the block size returned by ILAENV.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, and division by zero will occur if it\n               is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n'),(114,'zsytrf_114.txt','ZSYTRF computes the factorization of a complex symmetric matrix A\nusing the Bunch-Kaufman diagonal pivoting method.  The form of the\nfactorization is\n   A = U*D*U**T  or  A = L*D*L**T\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\nwith 1-by-1 and 2-by-2 diagonal blocks.\nThis is the blocked version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L (see below for further details).\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\n         On exit, if INFO = 0, WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The length of WORK.  LWORK >=1.  For best performance\n         LWORK >= N*NB, where NB is the block size returned by ILAENV.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization\n               has been completed, but the block diagonal matrix D is\n               exactly singular, and division by zero will occur if it\n               is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n'),(115,'ssptrf_115.txt','SSPTRF computes the factorization of a real symmetric matrix A stored\nin packed format using the Bunch-Kaufman diagonal pivoting method:\n   A = U*D*U**T  or  A = L*D*L**T\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L, stored as a packed triangular\n         matrix overwriting A (see below for further details).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, and division by zero will occur if it\n              is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(116,'dsptrf_116.txt','DSPTRF computes the factorization of a real symmetric matrix A stored\nin packed format using the Bunch-Kaufman diagonal pivoting method:\n   A = U*D*U**T  or  A = L*D*L**T\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L, stored as a packed triangular\n         matrix overwriting A (see below for further details).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, and division by zero will occur if it\n              is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(117,'chptrf_117.txt','CHPTRF computes the factorization of a complex Hermitian packed\nmatrix A using the Bunch-Kaufman diagonal pivoting method:\n   A = U*D*U**H  or  A = L*D*L**H\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is Hermitian and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the Hermitian matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L, stored as a packed triangular\n         matrix overwriting A (see below for further details).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, and division by zero will occur if it\n              is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(118,'zhptrf_118.txt','ZHPTRF computes the factorization of a complex Hermitian packed\nmatrix A using the Bunch-Kaufman diagonal pivoting method:\n   A = U*D*U**H  or  A = L*D*L**H\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is Hermitian and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the Hermitian matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L, stored as a packed triangular\n         matrix overwriting A (see below for further details).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, and division by zero will occur if it\n              is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(119,'csptrf_119.txt','CSPTRF computes the factorization of a complex symmetric matrix A\nstored in packed format using the Bunch-Kaufman diagonal pivoting\nmethod:\n   A = U*D*U**T  or  A = L*D*L**T\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L, stored as a packed triangular\n         matrix overwriting A (see below for further details).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, and division by zero will occur if it\n              is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(120,'zsptrf_120.txt','ZSPTRF computes the factorization of a complex symmetric matrix A\nstored in packed format using the Bunch-Kaufman diagonal pivoting\nmethod:\n   A = U*D*U**T  or  A = L*D*L**T\nwhere U (or L) is a product of permutation and unit upper (lower)\ntriangular matrices, and D is symmetric and block diagonal with\n1-by-1 and 2-by-2 diagonal blocks.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangle of the symmetric matrix\n         A, packed columnwise in a linear array.  The j-th column of A\n         is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         On exit, the block diagonal matrix D and the multipliers used\n         to obtain the factor U or L, stored as a packed triangular\n         matrix overwriting A (see below for further details).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D.\n         If IPIV(k) > 0, then rows and columns k and IPIV(k) were\n         interchanged and D(k,k) is a 1-by-1 diagonal block.\n         If UPLO = \'U\' and IPIV(k) = IPIV(k-1) < 0, then rows and\n         columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)\n         is a 2-by-2 diagonal block.  If UPLO = \'L\' and IPIV(k) =\n         IPIV(k+1) < 0, then rows and columns k+1 and -IPIV(k) were\n         interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) is exactly zero.  The factorization\n              has been completed, but the block diagonal matrix D is\n              exactly singular, and division by zero will occur if it\n              is used to solve a system of equations.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(121,'sgetrs_121.txt','SGETRS solves a system of linear equations\n   A * X = B  or  A**T * X = B\nwith a general N-by-N matrix A using the LU factorization computed\nby SGETRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T* X = B  (Transpose)\n         = \'C\':  A**T* X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by SGETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from SGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGEcomputational\n'),(122,'dgetrs_122.txt','DGETRS solves a system of linear equations\n   A * X = B  or  A**T * X = B\nwith a general N-by-N matrix A using the LU factorization computed\nby DGETRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T* X = B  (Transpose)\n         = \'C\':  A**T* X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by DGETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from DGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEcomputational\n'),(123,'cgetrs_123.txt','CGETRS solves a system of linear equations\n   A * X = B,  A**T * X = B,  or  A**H * X = B\nwith a general N-by-N matrix A using the LU factorization computed\nby CGETRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by CGETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from CGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEcomputational\n'),(124,'zgetrs_124.txt','ZGETRS solves a system of linear equations\n   A * X = B,  A**T * X = B,  or  A**H * X = B\nwith a general N-by-N matrix A using the LU factorization computed\nby ZGETRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by ZGETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from ZGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEcomputational\n'),(125,'sgbtrs_125.txt','SGBTRS solves a system of linear equations\n   A * X = B  or  A**T * X = B\nwith a general band matrix A using the LU factorization computed\nby SGBTRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T* X = B  (Transpose)\n         = \'C\':  A**T* X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by SGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= N, row i of the matrix was\n         interchanged with row IPIV(i).\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGBcomputational\n'),(126,'dgbtrs_126.txt','DGBTRS solves a system of linear equations\n   A * X = B  or  A**T * X = B\nwith a general band matrix A using the LU factorization computed\nby DGBTRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T* X = B  (Transpose)\n         = \'C\':  A**T* X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by DGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= N, row i of the matrix was\n         interchanged with row IPIV(i).\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGBcomputational\n'),(127,'cgbtrs_127.txt','CGBTRS solves a system of linear equations\n   A * X = B,  A**T * X = B,  or  A**H * X = B\nwith a general band matrix A using the LU factorization computed\nby CGBTRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by CGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= N, row i of the matrix was\n         interchanged with row IPIV(i).\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGBcomputational\n'),(128,'zgbtrs_128.txt','ZGBTRS solves a system of linear equations\n   A * X = B,  A**T * X = B,  or  A**H * X = B\nwith a general band matrix A using the LU factorization computed\nby ZGBTRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by ZGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= N, row i of the matrix was\n         interchanged with row IPIV(i).\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GBcomputational\n'),(129,'sgttrs_129.txt','SGTTRS solves one of the systems of equations\n   A*X = B  or  A**T*X = B,\nwith a tridiagonal matrix A using the LU factorization computed\nby SGTTRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T* X = B  (Transpose)\n         = \'C\':  A**T* X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is REAL array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DU\n         DU is REAL array, dimension (N-1)\n         The (n-1) elements of the first super-diagonal of U.\n\\param[in] DU2\n         DU2 is REAL array, dimension (N-2)\n         The (n-2) elements of the second super-diagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the matrix of right hand side vectors B.\n         On exit, B is overwritten by the solution vectors X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(130,'dgttrs_130.txt','DGTTRS solves one of the systems of equations\n   A*X = B  or  A**T*X = B,\nwith a tridiagonal matrix A using the LU factorization computed\nby DGTTRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T* X = B  (Transpose)\n         = \'C\':  A**T* X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DU\n         DU is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) elements of the first super-diagonal of U.\n\\param[in] DU2\n         DU2 is DOUBLE PRECISION array, dimension (N-2)\n         The (n-2) elements of the second super-diagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the matrix of right hand side vectors B.\n         On exit, B is overwritten by the solution vectors X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(131,'cgttrs_131.txt','CGTTRS solves one of the systems of equations\n   A * X = B,  A**T * X = B,  or  A**H * X = B,\nwith a tridiagonal matrix A using the LU factorization computed\nby CGTTRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is COMPLEX array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A.\n\\param[in] D\n         D is COMPLEX array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DU\n         DU is COMPLEX array, dimension (N-1)\n         The (n-1) elements of the first super-diagonal of U.\n\\param[in] DU2\n         DU2 is COMPLEX array, dimension (N-2)\n         The (n-2) elements of the second super-diagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the matrix of right hand side vectors B.\n         On exit, B is overwritten by the solution vectors X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -k, the k-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(132,'zgttrs_132.txt','ZGTTRS solves one of the systems of equations\n   A * X = B,  A**T * X = B,  or  A**H * X = B,\nwith a tridiagonal matrix A using the LU factorization computed\nby ZGTTRF.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations.\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is COMPLEX*16 array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A.\n\\param[in] D\n         D is COMPLEX*16 array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DU\n         DU is COMPLEX*16 array, dimension (N-1)\n         The (n-1) elements of the first super-diagonal of U.\n\\param[in] DU2\n         DU2 is COMPLEX*16 array, dimension (N-2)\n         The (n-2) elements of the second super-diagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the matrix of right hand side vectors B.\n         On exit, B is overwritten by the solution vectors X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -k, the k-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(133,'spotrs_133.txt','SPOTRS solves a system of linear equations A*X = B with a symmetric\npositive definite matrix A using the Cholesky factorization\nA = U**T*U or A = L*L**T computed by SPOTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, as computed by SPOTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realPOcomputational\n'),(134,'dpotrs_134.txt','DPOTRS solves a system of linear equations A*X = B with a symmetric\npositive definite matrix A using the Cholesky factorization\nA = U**T*U or A = L*L**T computed by DPOTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, as computed by DPOTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doublePOcomputational\n'),(135,'cpotrs_135.txt','CPOTRS solves a system of linear equations A*X = B with a Hermitian\npositive definite matrix A using the Cholesky factorization \nA = U**H*U or A = L*L**H computed by CPOTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H, as computed by CPOTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexPOcomputational\n'),(136,'zpotrs_136.txt','ZPOTRS solves a system of linear equations A*X = B with a Hermitian\npositive definite matrix A using the Cholesky factorization\nA = U**H * U or A = L * L**H computed by ZPOTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H * U or A = L * L**H, as computed by ZPOTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POcomputational\n'),(137,'spptrs_137.txt','SPPTRS solves a system of linear equations A*X = B with a symmetric\npositive definite matrix A in packed storage using the Cholesky\nfactorization A = U**T*U or A = L*L**T computed by SPPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, packed columnwise in a linear\n         array.  The j-th column of U or L is stored in the array AP\n         as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(138,'dpptrs_138.txt','DPPTRS solves a system of linear equations A*X = B with a symmetric\npositive definite matrix A in packed storage using the Cholesky\nfactorization A = U**T*U or A = L*L**T computed by DPPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, packed columnwise in a linear\n         array.  The j-th column of U or L is stored in the array AP\n         as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(139,'cpptrs_139.txt','CPPTRS solves a system of linear equations A*X = B with a Hermitian\npositive definite matrix A in packed storage using the Cholesky\nfactorization A = U**H*U or A = L*L**H computed by CPPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H, packed columnwise in a linear\n         array.  The j-th column of U or L is stored in the array AP\n         as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(140,'zpptrs_140.txt','ZPPTRS solves a system of linear equations A*X = B with a Hermitian\npositive definite matrix A in packed storage using the Cholesky\nfactorization A = U**H * U or A = L * L**H computed by ZPPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H * U or A = L * L**H, packed columnwise in a linear\n         array.  The j-th column of U or L is stored in the array AP\n         as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(141,'spbtrs_141.txt','SPBTRS solves a system of linear equations A*X = B with a symmetric\npositive definite band matrix A using the Cholesky factorization\nA = U**T*U or A = L*L**T computed by SPBTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor stored in AB;\n         = \'L\':  Lower triangular factor stored in AB.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T of the band matrix A, stored in the\n         first KD+1 rows of the array.  The j-th column of U or L is\n         stored in the j-th column of the array AB as follows:\n         if UPLO =\'U\', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO =\'L\', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(142,'dpbtrs_142.txt','DPBTRS solves a system of linear equations A*X = B with a symmetric\npositive definite band matrix A using the Cholesky factorization\nA = U**T*U or A = L*L**T computed by DPBTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor stored in AB;\n         = \'L\':  Lower triangular factor stored in AB.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T of the band matrix A, stored in the\n         first KD+1 rows of the array.  The j-th column of U or L is\n         stored in the j-th column of the array AB as follows:\n         if UPLO =\'U\', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO =\'L\', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(143,'cpbtrs_143.txt','CPBTRS solves a system of linear equations A*X = B with a Hermitian\npositive definite band matrix A using the Cholesky factorization\nA = U**H*U or A = L*L**H computed by CPBTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor stored in AB;\n         = \'L\':  Lower triangular factor stored in AB.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H of the band matrix A, stored in the\n         first KD+1 rows of the array.  The j-th column of U or L is\n         stored in the j-th column of the array AB as follows:\n         if UPLO =\'U\', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO =\'L\', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(144,'zpbtrs_144.txt','ZPBTRS solves a system of linear equations A*X = B with a Hermitian\npositive definite band matrix A using the Cholesky factorization\nA = U**H *U or A = L*L**H computed by ZPBTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor stored in AB;\n         = \'L\':  Lower triangular factor stored in AB.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H *U or A = L*L**H of the band matrix A, stored in the\n         first KD+1 rows of the array.  The j-th column of U or L is\n         stored in the j-th column of the array AB as follows:\n         if UPLO =\'U\', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO =\'L\', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(145,'spttrs_145.txt','SPTTRS solves a tridiagonal system of the form\n   A * X = B\nusing the L*D*L**T factorization of A computed by SPTTRF.  D is a\ndiagonal matrix specified in the vector D, L is a unit bidiagonal\nmatrix whose subdiagonal is specified in the vector E, and X and B\nare N by NRHS matrices.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the tridiagonal matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from the\n         L*D*L**T factorization of A.\n\\param[in] E\n         E is REAL array, dimension (N-1)\n         The (n-1) subdiagonal elements of the unit bidiagonal factor\n         L from the L*D*L**T factorization of A.  E can also be regarded\n         as the superdiagonal of the unit bidiagonal factor U from the\n         factorization A = U**T*D*U.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side vectors B for the system of\n         linear equations.\n         On exit, the solution vectors, X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(146,'dpttrs_146.txt','DPTTRS solves a tridiagonal system of the form\n   A * X = B\nusing the L*D*L**T factorization of A computed by DPTTRF.  D is a\ndiagonal matrix specified in the vector D, L is a unit bidiagonal\nmatrix whose subdiagonal is specified in the vector E, and X and B\nare N by NRHS matrices.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the tridiagonal matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from the\n         L*D*L**T factorization of A.\n\\param[in] E\n         E is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) subdiagonal elements of the unit bidiagonal factor\n         L from the L*D*L**T factorization of A.  E can also be regarded\n         as the superdiagonal of the unit bidiagonal factor U from the\n         factorization A = U**T*D*U.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side vectors B for the system of\n         linear equations.\n         On exit, the solution vectors, X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(147,'cpttrs_147.txt','CPTTRS solves a tridiagonal system of the form\n   A * X = B\nusing the factorization A = U**H*D*U or A = L*D*L**H computed by CPTTRF.\nD is a diagonal matrix specified in the vector D, U (or L) is a unit\nbidiagonal matrix whose superdiagonal (subdiagonal) is specified in\nthe vector E, and X and B are N by NRHS matrices.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies the form of the factorization and whether the\n         vector E is the superdiagonal of the upper bidiagonal factor\n         U or the subdiagonal of the lower bidiagonal factor L.\n         = \'U\':  A = U**H*D*U, E is the superdiagonal of U\n         = \'L\':  A = L*D*L**H, E is the subdiagonal of L\n\\param[in] N\n         N is INTEGER\n         The order of the tridiagonal matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from the\n         factorization A = U**H*D*U or A = L*D*L**H.\n\\param[in] E\n         E is COMPLEX array, dimension (N-1)\n         If UPLO = \'U\', the (n-1) superdiagonal elements of the unit\n         bidiagonal factor U from the factorization A = U**H*D*U.\n         If UPLO = \'L\', the (n-1) subdiagonal elements of the unit\n         bidiagonal factor L from the factorization A = L*D*L**H.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side vectors B for the system of\n         linear equations.\n         On exit, the solution vectors, X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(148,'zpttrs_148.txt','ZPTTRS solves a tridiagonal system of the form\n   A * X = B\nusing the factorization A = U**H *D* U or A = L*D*L**H computed by ZPTTRF.\nD is a diagonal matrix specified in the vector D, U (or L) is a unit\nbidiagonal matrix whose superdiagonal (subdiagonal) is specified in\nthe vector E, and X and B are N by NRHS matrices.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies the form of the factorization and whether the\n         vector E is the superdiagonal of the upper bidiagonal factor\n         U or the subdiagonal of the lower bidiagonal factor L.\n         = \'U\':  A = U**H *D*U, E is the superdiagonal of U\n         = \'L\':  A = L*D*L**H, E is the subdiagonal of L\n\\param[in] N\n         N is INTEGER\n         The order of the tridiagonal matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from the\n         factorization A = U**H *D*U or A = L*D*L**H.\n\\param[in] E\n         E is COMPLEX*16 array, dimension (N-1)\n         If UPLO = \'U\', the (n-1) superdiagonal elements of the unit\n         bidiagonal factor U from the factorization A = U**H*D*U.\n         If UPLO = \'L\', the (n-1) subdiagonal elements of the unit\n         bidiagonal factor L from the factorization A = L*D*L**H.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side vectors B for the system of\n         linear equations.\n         On exit, the solution vectors, X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(149,'ssytrs_149.txt','SSYTRS solves a system of linear equations A*X = B with a real\nsymmetric matrix A using the factorization A = U*D*U**T or\nA = L*D*L**T computed by SSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by SSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by SSYTRF.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYcomputational\n'),(150,'dsytrs_150.txt','DSYTRS solves a system of linear equations A*X = B with a real\nsymmetric matrix A using the factorization A = U*D*U**T or\nA = L*D*L**T computed by DSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by DSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by DSYTRF.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYcomputational\n'),(151,'csytrs_151.txt','CSYTRS solves a system of linear equations A*X = B with a complex\nsymmetric matrix A using the factorization A = U*D*U**T or\nA = L*D*L**T computed by CSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by CSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CSYTRF.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n'),(152,'zsytrs_152.txt','ZSYTRS solves a system of linear equations A*X = B with a complex\nsymmetric matrix A using the factorization A = U*D*U**T or\nA = L*D*L**T computed by ZSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by ZSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZSYTRF.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n'),(153,'ssptrs_153.txt','SSPTRS solves a system of linear equations A*X = B with a real\nsymmetric matrix A stored in packed format using the factorization\nA = U*D*U**T or A = L*D*L**T computed by SSPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by SSPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by SSPTRF.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(154,'dsptrs_154.txt','DSPTRS solves a system of linear equations A*X = B with a real\nsymmetric matrix A stored in packed format using the factorization\nA = U*D*U**T or A = L*D*L**T computed by DSPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by DSPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by DSPTRF.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(155,'csptrs_155.txt','CSPTRS solves a system of linear equations A*X = B with a complex\nsymmetric matrix A stored in packed format using the factorization\nA = U*D*U**T or A = L*D*L**T computed by CSPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by CSPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CSPTRF.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(156,'zsptrs_156.txt','ZSPTRS solves a system of linear equations A*X = B with a complex\nsymmetric matrix A stored in packed format using the factorization\nA = U*D*U**T or A = L*D*L**T computed by ZSPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by ZSPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZSPTRF.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(157,'chetrs_157.txt','CHETRS solves a system of linear equations A*X = B with a complex\nHermitian matrix A using the factorization A = U*D*U**H or\nA = L*D*L**H computed by CHETRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by CHETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CHETRF.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEcomputational\n'),(158,'zhetrs_158.txt','ZHETRS solves a system of linear equations A*X = B with a complex\nHermitian matrix A using the factorization A = U*D*U**H or\nA = L*D*L**H computed by ZHETRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by ZHETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZHETRF.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEcomputational\n'),(159,'chptrs_159.txt','CHPTRS solves a system of linear equations A*X = B with a complex\nHermitian matrix A stored in packed format using the factorization\nA = U*D*U**H or A = L*D*L**H computed by CHPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by CHPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CHPTRF.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(160,'zhptrs_160.txt','ZHPTRS solves a system of linear equations A*X = B with a complex\nHermitian matrix A stored in packed format using the factorization\nA = U*D*U**H or A = L*D*L**H computed by ZHPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by ZHPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZHPTRF.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(161,'strtrs_161.txt','STRTRS solves a triangular system of the form\n   A * X = B  or  A**T * X = B,\nwhere A is a triangular matrix of order N, and B is an N-by-NRHS\nmatrix.  A check is made to verify that A is nonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, the i-th diagonal element of A is zero,\n              indicating that the matrix is singular and the solutions\n              X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(162,'dtrtrs_162.txt','DTRTRS solves a triangular system of the form\n   A * X = B  or  A**T * X = B,\nwhere A is a triangular matrix of order N, and B is an N-by-NRHS\nmatrix.  A check is made to verify that A is nonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, the i-th diagonal element of A is zero,\n              indicating that the matrix is singular and the solutions\n              X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(163,'ctrtrs_163.txt','CTRTRS solves a triangular system of the form\n   A * X = B,  A**T * X = B,  or  A**H * X = B,\nwhere A is a triangular matrix of order N, and B is an N-by-NRHS\nmatrix.  A check is made to verify that A is nonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, the i-th diagonal element of A is zero,\n              indicating that the matrix is singular and the solutions\n              X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(164,'ztrtrs_164.txt','ZTRTRS solves a triangular system of the form\n   A * X = B,  A**T * X = B,  or  A**H * X = B,\nwhere A is a triangular matrix of order N, and B is an N-by-NRHS\nmatrix.  A check is made to verify that A is nonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, the i-th diagonal element of A is zero,\n              indicating that the matrix is singular and the solutions\n              X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(165,'stptrs_165.txt','STPTRS solves a triangular system of the form\n   A * X = B  or  A**T * X = B,\nwhere A is a triangular matrix of order N stored in packed format,\nand B is an N-by-NRHS matrix.  A check is made to verify that A is\nnonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element of A is zero,\n               indicating that the matrix is singular and the\n               solutions X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(166,'dtptrs_166.txt','DTPTRS solves a triangular system of the form\n   A * X = B  or  A**T * X = B,\nwhere A is a triangular matrix of order N stored in packed format,\nand B is an N-by-NRHS matrix.  A check is made to verify that A is\nnonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element of A is zero,\n               indicating that the matrix is singular and the\n               solutions X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(167,'ctptrs_167.txt','CTPTRS solves a triangular system of the form\n   A * X = B,  A**T * X = B,  or  A**H * X = B,\nwhere A is a triangular matrix of order N stored in packed format,\nand B is an N-by-NRHS matrix.  A check is made to verify that A is\nnonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element of A is zero,\n               indicating that the matrix is singular and the\n               solutions X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(168,'ztptrs_168.txt','ZTPTRS solves a triangular system of the form\n   A * X = B,  A**T * X = B,  or  A**H * X = B,\nwhere A is a triangular matrix of order N stored in packed format,\nand B is an N-by-NRHS matrix.  A check is made to verify that A is\nnonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element of A is zero,\n               indicating that the matrix is singular and the\n               solutions X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(169,'stbtrs_169.txt','STBTRS solves a triangular system of the form\n   A * X = B  or  A**T * X = B,\nwhere A is a triangular band matrix of order N, and B is an\nN-by NRHS matrix.  A check is made to verify that A is nonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of AB.  The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element of A is zero,\n               indicating that the matrix is singular and the\n               solutions X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(170,'dtbtrs_170.txt','DTBTRS solves a triangular system of the form\n   A * X = B  or  A**T * X = B,\nwhere A is a triangular band matrix of order N, and B is an\nN-by NRHS matrix.  A check is made to verify that A is nonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of AB.  The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element of A is zero,\n               indicating that the matrix is singular and the\n               solutions X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(171,'ctbtrs_171.txt','CTBTRS solves a triangular system of the form\n   A * X = B,  A**T * X = B,  or  A**H * X = B,\nwhere A is a triangular band matrix of order N, and B is an\nN-by-NRHS matrix.  A check is made to verify that A is nonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of AB.  The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element of A is zero,\n               indicating that the matrix is singular and the\n               solutions X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(172,'ztbtrs_172.txt','ZTBTRS solves a triangular system of the form\n   A * X = B,  A**T * X = B,  or  A**H * X = B,\nwhere A is a triangular band matrix of order N, and B is an\nN-by-NRHS matrix.  A check is made to verify that A is nonsingular.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of AB.  The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, if INFO = 0, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element of A is zero,\n               indicating that the matrix is singular and the\n               solutions X have not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(173,'sgecon_173.txt','SGECON estimates the reciprocal of the condition number of a general\nreal matrix A, in either the 1-norm or the infinity-norm, using\nthe LU factorization computed by SGETRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by SGETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] ANORM\n         ANORM is REAL\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is REAL array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGEcomputational\n'),(174,'dgecon_174.txt','DGECON estimates the reciprocal of the condition number of a general\nreal matrix A, in either the 1-norm or the infinity-norm, using\nthe LU factorization computed by DGETRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by DGETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEcomputational\n'),(175,'cgecon_175.txt','CGECON estimates the reciprocal of the condition number of a general\ncomplex matrix A, in either the 1-norm or the infinity-norm, using\nthe LU factorization computed by CGETRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by CGETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] ANORM\n         ANORM is REAL\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEcomputational\n'),(176,'zgecon_176.txt','ZGECON estimates the reciprocal of the condition number of a general\ncomplex matrix A, in either the 1-norm or the infinity-norm, using\nthe LU factorization computed by ZGETRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by ZGETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEcomputational\n'),(177,'sgbcon_177.txt','SGBCON estimates the reciprocal of the condition number of a real\ngeneral band matrix A, in either the 1-norm or the infinity-norm,\nusing the LU factorization computed by SGBTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by SGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= N, row i of the matrix was\n         interchanged with row IPIV(i).\n\\param[in] ANORM\n         ANORM is REAL\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGBcomputational\n'),(178,'dgbcon_178.txt','DGBCON estimates the reciprocal of the condition number of a real\ngeneral band matrix A, in either the 1-norm or the infinity-norm,\nusing the LU factorization computed by DGBTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by DGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= N, row i of the matrix was\n         interchanged with row IPIV(i).\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGBcomputational\n'),(179,'cgbcon_179.txt','CGBCON estimates the reciprocal of the condition number of a complex\ngeneral band matrix A, in either the 1-norm or the infinity-norm,\nusing the LU factorization computed by CGBTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by CGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= N, row i of the matrix was\n         interchanged with row IPIV(i).\n\\param[in] ANORM\n         ANORM is REAL\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGBcomputational\n'),(180,'zgbcon_180.txt','ZGBCON estimates the reciprocal of the condition number of a complex\ngeneral band matrix A, in either the 1-norm or the infinity-norm,\nusing the LU factorization computed by ZGBTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by ZGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= N, row i of the matrix was\n         interchanged with row IPIV(i).\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GBcomputational\n'),(181,'sgtcon_181.txt','SGTCON estimates the reciprocal of the condition number of a real\ntridiagonal matrix A using the LU factorization as computed by\nSGTTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] DL\n         DL is REAL array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A as computed by SGTTRF.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DU\n         DU is REAL array, dimension (N-1)\n         The (n-1) elements of the first superdiagonal of U.\n\\param[in] DU2\n         DU2 is REAL array, dimension (N-2)\n         The (n-2) elements of the second superdiagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in] ANORM\n         ANORM is REAL\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is REAL array, dimension (2*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(182,'dgtcon_182.txt','DGTCON estimates the reciprocal of the condition number of a real\ntridiagonal matrix A using the LU factorization as computed by\nDGTTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] DL\n         DL is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A as computed by DGTTRF.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DU\n         DU is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) elements of the first superdiagonal of U.\n\\param[in] DU2\n         DU2 is DOUBLE PRECISION array, dimension (N-2)\n         The (n-2) elements of the second superdiagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(183,'cgtcon_183.txt','CGTCON estimates the reciprocal of the condition number of a complex\ntridiagonal matrix A using the LU factorization as computed by\nCGTTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] DL\n         DL is COMPLEX array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A as computed by CGTTRF.\n\\param[in] D\n         D is COMPLEX array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DU\n         DU is COMPLEX array, dimension (N-1)\n         The (n-1) elements of the first superdiagonal of U.\n\\param[in] DU2\n         DU2 is COMPLEX array, dimension (N-2)\n         The (n-2) elements of the second superdiagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in] ANORM\n         ANORM is REAL\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(184,'zgtcon_184.txt','ZGTCON estimates the reciprocal of the condition number of a complex\ntridiagonal matrix A using the LU factorization as computed by\nZGTTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] DL\n         DL is COMPLEX*16 array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A as computed by ZGTTRF.\n\\param[in] D\n         D is COMPLEX*16 array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DU\n         DU is COMPLEX*16 array, dimension (N-1)\n         The (n-1) elements of the first superdiagonal of U.\n\\param[in] DU2\n         DU2 is COMPLEX*16 array, dimension (N-2)\n         The (n-2) elements of the second superdiagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         If NORM = \'1\' or \'O\', the 1-norm of the original matrix A.\n         If NORM = \'I\', the infinity-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(185,'spocon_185.txt','SPOCON estimates the reciprocal of the condition number (in the \n1-norm) of a real symmetric positive definite matrix using the\nCholesky factorization A = U**T*U or A = L*L**T computed by SPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, as computed by SPOTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm (or infinity-norm) of the symmetric matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realPOcomputational\n'),(186,'dpocon_186.txt','DPOCON estimates the reciprocal of the condition number (in the\n1-norm) of a real symmetric positive definite matrix using the\nCholesky factorization A = U**T*U or A = L*L**T computed by DPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, as computed by DPOTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm (or infinity-norm) of the symmetric matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doublePOcomputational\n'),(187,'cpocon_187.txt','CPOCON estimates the reciprocal of the condition number (in the\n1-norm) of a complex Hermitian positive definite matrix using the\nCholesky factorization A = U**H*U or A = L*L**H computed by CPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H, as computed by CPOTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm (or infinity-norm) of the Hermitian matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexPOcomputational\n'),(188,'zpocon_188.txt','ZPOCON estimates the reciprocal of the condition number (in the\n1-norm) of a complex Hermitian positive definite matrix using the\nCholesky factorization A = U**H*U or A = L*L**H computed by ZPOTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H, as computed by ZPOTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm (or infinity-norm) of the Hermitian matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POcomputational\n'),(189,'sppcon_189.txt','SPPCON estimates the reciprocal of the condition number (in the\n1-norm) of a real symmetric positive definite packed matrix using\nthe Cholesky factorization A = U**T*U or A = L*L**T computed by\nSPPTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, packed columnwise in a linear\n         array.  The j-th column of U or L is stored in the array AP\n         as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm (or infinity-norm) of the symmetric matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(190,'dppcon_190.txt','DPPCON estimates the reciprocal of the condition number (in the\n1-norm) of a real symmetric positive definite packed matrix using\nthe Cholesky factorization A = U**T*U or A = L*L**T computed by\nDPPTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, packed columnwise in a linear\n         array.  The j-th column of U or L is stored in the array AP\n         as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm (or infinity-norm) of the symmetric matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(191,'cppcon_191.txt','CPPCON estimates the reciprocal of the condition number (in the \n1-norm) of a complex Hermitian positive definite packed matrix using\nthe Cholesky factorization A = U**H*U or A = L*L**H computed by\nCPPTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H, packed columnwise in a linear\n         array.  The j-th column of U or L is stored in the array AP\n         as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm (or infinity-norm) of the Hermitian matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(192,'zppcon_192.txt','ZPPCON estimates the reciprocal of the condition number (in the\n1-norm) of a complex Hermitian positive definite packed matrix using\nthe Cholesky factorization A = U**H*U or A = L*L**H computed by\nZPPTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H, packed columnwise in a linear\n         array.  The j-th column of U or L is stored in the array AP\n         as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm (or infinity-norm) of the Hermitian matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(193,'spbcon_193.txt','SPBCON estimates the reciprocal of the condition number (in the\n1-norm) of a real symmetric positive definite band matrix using the\nCholesky factorization A = U**T*U or A = L*L**T computed by SPBTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor stored in AB;\n         = \'L\':  Lower triangular factor stored in AB.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T of the band matrix A, stored in the\n         first KD+1 rows of the array.  The j-th column of U or L is\n         stored in the j-th column of the array AB as follows:\n         if UPLO =\'U\', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO =\'L\', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm (or infinity-norm) of the symmetric band matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(194,'dpbcon_194.txt','DPBCON estimates the reciprocal of the condition number (in the\n1-norm) of a real symmetric positive definite band matrix using the\nCholesky factorization A = U**T*U or A = L*L**T computed by DPBTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor stored in AB;\n         = \'L\':  Lower triangular factor stored in AB.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T of the band matrix A, stored in the\n         first KD+1 rows of the array.  The j-th column of U or L is\n         stored in the j-th column of the array AB as follows:\n         if UPLO =\'U\', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO =\'L\', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm (or infinity-norm) of the symmetric band matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(195,'cpbcon_195.txt','CPBCON estimates the reciprocal of the condition number (in the\n1-norm) of a complex Hermitian positive definite band matrix using\nthe Cholesky factorization A = U**H*U or A = L*L**H computed by\nCPBTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor stored in AB;\n         = \'L\':  Lower triangular factor stored in AB.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of sub-diagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H of the band matrix A, stored in the\n         first KD+1 rows of the array.  The j-th column of U or L is\n         stored in the j-th column of the array AB as follows:\n         if UPLO =\'U\', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO =\'L\', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm (or infinity-norm) of the Hermitian band matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(196,'zpbcon_196.txt','ZPBCON estimates the reciprocal of the condition number (in the\n1-norm) of a complex Hermitian positive definite band matrix using\nthe Cholesky factorization A = U**H*U or A = L*L**H computed by\nZPBTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor stored in AB;\n         = \'L\':  Lower triangular factor stored in AB.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of sub-diagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H of the band matrix A, stored in the\n         first KD+1 rows of the array.  The j-th column of U or L is\n         stored in the j-th column of the array AB as follows:\n         if UPLO =\'U\', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO =\'L\', AB(1+i-j,j)    = L(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm (or infinity-norm) of the Hermitian band matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(197,'sptcon_197.txt','SPTCON computes the reciprocal of the condition number (in the\n1-norm) of a real symmetric positive definite tridiagonal matrix\nusing the factorization A = L*D*L**T or A = U**T*D*U computed by\nSPTTRF.\nNorm(inv(A)) is computed by a direct method, and the reciprocal of\nthe condition number is computed as\n             RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from the\n         factorization of A, as computed by SPTTRF.\n\\param[in] E\n         E is REAL array, dimension (N-1)\n         The (n-1) off-diagonal elements of the unit bidiagonal factor\n         U or L from the factorization of A,  as computed by SPTTRF.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the\n         1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(198,'dptcon_198.txt','DPTCON computes the reciprocal of the condition number (in the\n1-norm) of a real symmetric positive definite tridiagonal matrix\nusing the factorization A = L*D*L**T or A = U**T*D*U computed by\nDPTTRF.\nNorm(inv(A)) is computed by a direct method, and the reciprocal of\nthe condition number is computed as\n             RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from the\n         factorization of A, as computed by DPTTRF.\n\\param[in] E\n         E is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) off-diagonal elements of the unit bidiagonal factor\n         U or L from the factorization of A,  as computed by DPTTRF.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the\n         1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(199,'cptcon_199.txt','CPTCON computes the reciprocal of the condition number (in the\n1-norm) of a complex Hermitian positive definite tridiagonal matrix\nusing the factorization A = L*D*L**H or A = U**H*D*U computed by\nCPTTRF.\nNorm(inv(A)) is computed by a direct method, and the reciprocal of\nthe condition number is computed as\n                 RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from the\n         factorization of A, as computed by CPTTRF.\n\\param[in] E\n         E is COMPLEX array, dimension (N-1)\n         The (n-1) off-diagonal elements of the unit bidiagonal factor\n         U or L from the factorization of A, as computed by CPTTRF.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the\n         1-norm of inv(A) computed in this routine.\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(200,'zptcon_200.txt','ZPTCON computes the reciprocal of the condition number (in the\n1-norm) of a complex Hermitian positive definite tridiagonal matrix\nusing the factorization A = L*D*L**H or A = U**H*D*U computed by\nZPTTRF.\nNorm(inv(A)) is computed by a direct method, and the reciprocal of\nthe condition number is computed as\n                 RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from the\n         factorization of A, as computed by ZPTTRF.\n\\param[in] E\n         E is COMPLEX*16 array, dimension (N-1)\n         The (n-1) off-diagonal elements of the unit bidiagonal factor\n         U or L from the factorization of A, as computed by ZPTTRF.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is the\n         1-norm of inv(A) computed in this routine.\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(201,'checon_201.txt','CHECON estimates the reciprocal of the condition number of a complex\nHermitian matrix A using the factorization A = U*D*U**H or\nA = L*D*L**H computed by CHETRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by CHETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CHETRF.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEcomputational\n'),(202,'zhecon_202.txt','ZHECON estimates the reciprocal of the condition number of a complex\nHermitian matrix A using the factorization A = U*D*U**H or\nA = L*D*L**H computed by ZHETRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by ZHETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZHETRF.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEcomputational\n'),(203,'ssycon_203.txt','SSYCON estimates the reciprocal of the condition number (in the\n1-norm) of a real symmetric matrix A using the factorization\nA = U*D*U**T or A = L*D*L**T computed by SSYTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by SSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by SSYTRF.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is REAL array, dimension (2*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYcomputational\n'),(204,'dsycon_204.txt','DSYCON estimates the reciprocal of the condition number (in the\n1-norm) of a real symmetric matrix A using the factorization\nA = U*D*U**T or A = L*D*L**T computed by DSYTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by DSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by DSYTRF.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYcomputational\n'),(205,'csycon_205.txt','CSYCON estimates the reciprocal of the condition number (in the\n1-norm) of a complex symmetric matrix A using the factorization\nA = U*D*U**T or A = L*D*L**T computed by CSYTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by CSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CSYTRF.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n'),(206,'zsycon_206.txt','ZSYCON estimates the reciprocal of the condition number (in the\n1-norm) of a complex symmetric matrix A using the factorization\nA = U*D*U**T or A = L*D*L**T computed by ZSYTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by ZSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZSYTRF.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n'),(207,'sspcon_207.txt','SSPCON estimates the reciprocal of the condition number (in the\n1-norm) of a real symmetric packed matrix A using the factorization\nA = U*D*U**T or A = L*D*L**T computed by SSPTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by SSPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by SSPTRF.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is REAL array, dimension (2*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(208,'dspcon_208.txt','DSPCON estimates the reciprocal of the condition number (in the\n1-norm) of a real symmetric packed matrix A using the factorization\nA = U*D*U**T or A = L*D*L**T computed by DSPTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by DSPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by DSPTRF.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(209,'cspcon_209.txt','CSPCON estimates the reciprocal of the condition number (in the\n1-norm) of a complex symmetric packed matrix A using the\nfactorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by CSPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CSPTRF.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(210,'zspcon_210.txt','ZSPCON estimates the reciprocal of the condition number (in the\n1-norm) of a complex symmetric packed matrix A using the\nfactorization A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by ZSPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZSPTRF.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(211,'chpcon_211.txt','CHPCON estimates the reciprocal of the condition number of a complex\nHermitian packed matrix A using the factorization A = U*D*U**H or\nA = L*D*L**H computed by CHPTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by CHPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CHPTRF.\n\\param[in] ANORM\n         ANORM is REAL\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(212,'zhpcon_212.txt','ZHPCON estimates the reciprocal of the condition number of a complex\nHermitian packed matrix A using the factorization A = U*D*U**H or\nA = L*D*L**H computed by ZHPTRF.\nAn estimate is obtained for norm(inv(A)), and the reciprocal of the\ncondition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by ZHPTRF, stored as a\n         packed triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZHPTRF.\n\\param[in] ANORM\n         ANORM is DOUBLE PRECISION\n         The 1-norm of the original matrix A.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an\n         estimate of the 1-norm of inv(A) computed in this routine.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(213,'strcon_213.txt','STRCON estimates the reciprocal of the condition number of a\ntriangular matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(214,'dtrcon_214.txt','DTRCON estimates the reciprocal of the condition number of a\ntriangular matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(215,'ctrcon_215.txt','CTRCON estimates the reciprocal of the condition number of a\ntriangular matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(216,'ztrcon_216.txt','ZTRCON estimates the reciprocal of the condition number of a\ntriangular matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(217,'stbcon_217.txt','STBCON estimates the reciprocal of the condition number of a\ntriangular band matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of the array. The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(218,'dtbcon_218.txt','DTBCON estimates the reciprocal of the condition number of a\ntriangular band matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of the array. The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(219,'ctbcon_219.txt','CTBCON estimates the reciprocal of the condition number of a\ntriangular band matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of the array. The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(220,'ztbcon_220.txt','ZTBCON estimates the reciprocal of the condition number of a\ntriangular band matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of the array. The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(221,'stpcon_221.txt','STPCON estimates the reciprocal of the condition number of a packed\ntriangular matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(222,'dtpcon_222.txt','DTPCON estimates the reciprocal of the condition number of a packed\ntriangular matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(223,'ctpcon_223.txt','CTPCON estimates the reciprocal of the condition number of a packed\ntriangular matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[out] RCOND\n         RCOND is REAL\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(224,'ztpcon_224.txt','ZTPCON estimates the reciprocal of the condition number of a packed\ntriangular matrix A, in either the 1-norm or the infinity-norm.\nThe norm of A is computed and an estimate is obtained for\nnorm(inv(A)), then the reciprocal of the condition number is\ncomputed as\n   RCOND = 1 / ( norm(A) * norm(inv(A)) ).\nArguments:\n\\param[in] NORM\n         NORM is CHARACTER*1\n         Specifies whether the 1-norm condition number or the\n         infinity-norm condition number is required:\n         = \'1\' or \'O\':  1-norm;\n         = \'I\':         Infinity-norm.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n         The reciprocal of the condition number of the matrix A,\n         computed as RCOND = 1/(norm(A) * norm(inv(A))).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(225,'sgerfs_225.txt','SGERFS improves the computed solution to a system of linear\nequations and provides error bounds and backward error estimates for\nthe solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The original N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is REAL array, dimension (LDAF,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by SGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from SGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by SGETRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGEcomputational\n'),(226,'dgerfs_226.txt','DGERFS improves the computed solution to a system of linear\nequations and provides error bounds and backward error estimates for\nthe solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The original N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by DGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from DGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by DGETRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEcomputational\n'),(227,'cgerfs_227.txt','CGERFS improves the computed solution to a system of linear\nequations and provides error bounds and backward error estimates for\nthe solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The original N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by CGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from CGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CGETRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEcomputational\n'),(228,'zgerfs_228.txt','ZGERFS improves the computed solution to a system of linear\nequations and provides error bounds and backward error estimates for\nthe solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The original N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n         The factors L and U from the factorization A = P*L*U\n         as computed by ZGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from ZGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZGETRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEcomputational\n'),(229,'sgbrfs_229.txt','SGBRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is banded, and provides\nerror bounds and backward error estimates for the solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         The original band matrix A, stored in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is REAL array, dimension (LDAFB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by SGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from SGBTRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by SGBTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGBcomputational\n'),(230,'dgbrfs_230.txt','DGBRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is banded, and provides\nerror bounds and backward error estimates for the solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         The original band matrix A, stored in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is DOUBLE PRECISION array, dimension (LDAFB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by DGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from DGBTRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by DGBTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGBcomputational\n'),(231,'cgbrfs_231.txt','CGBRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is banded, and provides\nerror bounds and backward error estimates for the solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         The original band matrix A, stored in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is COMPLEX array, dimension (LDAFB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by CGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from CGBTRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CGBTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGBcomputational\n'),(232,'zgbrfs_232.txt','ZGBRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is banded, and provides\nerror bounds and backward error estimates for the solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         The original band matrix A, stored in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is COMPLEX*16 array, dimension (LDAFB,N)\n         Details of the LU factorization of the band matrix A, as\n         computed by ZGBTRF.  U is stored as an upper triangular band\n         matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n         the multipliers used during the factorization are stored in\n         rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from ZGBTRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZGBTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GBcomputational\n'),(233,'sgtrfs_233.txt','SGTRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is tridiagonal, and provides\nerror bounds and backward error estimates for the solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is REAL array, dimension (N-1)\n         The (n-1) subdiagonal elements of A.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The diagonal elements of A.\n\\param[in] DU\n         DU is REAL array, dimension (N-1)\n         The (n-1) superdiagonal elements of A.\n\\param[in] DLF\n         DLF is REAL array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A as computed by SGTTRF.\n\\param[in] DF\n         DF is REAL array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DUF\n         DUF is REAL array, dimension (N-1)\n         The (n-1) elements of the first superdiagonal of U.\n\\param[in] DU2\n         DU2 is REAL array, dimension (N-2)\n         The (n-2) elements of the second superdiagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by SGTTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(234,'dgtrfs_234.txt','DGTRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is tridiagonal, and provides\nerror bounds and backward error estimates for the solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) subdiagonal elements of A.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The diagonal elements of A.\n\\param[in] DU\n         DU is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) superdiagonal elements of A.\n\\param[in] DLF\n         DLF is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A as computed by DGTTRF.\n\\param[in] DF\n         DF is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DUF\n         DUF is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) elements of the first superdiagonal of U.\n\\param[in] DU2\n         DU2 is DOUBLE PRECISION array, dimension (N-2)\n         The (n-2) elements of the second superdiagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by DGTTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(235,'cgtrfs_235.txt','CGTRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is tridiagonal, and provides\nerror bounds and backward error estimates for the solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is COMPLEX array, dimension (N-1)\n         The (n-1) subdiagonal elements of A.\n\\param[in] D\n         D is COMPLEX array, dimension (N)\n         The diagonal elements of A.\n\\param[in] DU\n         DU is COMPLEX array, dimension (N-1)\n         The (n-1) superdiagonal elements of A.\n\\param[in] DLF\n         DLF is COMPLEX array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A as computed by CGTTRF.\n\\param[in] DF\n         DF is COMPLEX array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DUF\n         DUF is COMPLEX array, dimension (N-1)\n         The (n-1) elements of the first superdiagonal of U.\n\\param[in] DU2\n         DU2 is COMPLEX array, dimension (N-2)\n         The (n-2) elements of the second superdiagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CGTTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(236,'zgtrfs_236.txt','ZGTRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is tridiagonal, and provides\nerror bounds and backward error estimates for the solution.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] DL\n         DL is COMPLEX*16 array, dimension (N-1)\n         The (n-1) subdiagonal elements of A.\n\\param[in] D\n         D is COMPLEX*16 array, dimension (N)\n         The diagonal elements of A.\n\\param[in] DU\n         DU is COMPLEX*16 array, dimension (N-1)\n         The (n-1) superdiagonal elements of A.\n\\param[in] DLF\n         DLF is COMPLEX*16 array, dimension (N-1)\n         The (n-1) multipliers that define the matrix L from the\n         LU factorization of A as computed by ZGTTRF.\n\\param[in] DF\n         DF is COMPLEX*16 array, dimension (N)\n         The n diagonal elements of the upper triangular matrix U from\n         the LU factorization of A.\n\\param[in] DUF\n         DUF is COMPLEX*16 array, dimension (N-1)\n         The (n-1) elements of the first superdiagonal of U.\n\\param[in] DU2\n         DU2 is COMPLEX*16 array, dimension (N-2)\n         The (n-2) elements of the second superdiagonal of U.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices; for 1 <= i <= n, row i of the matrix was\n         interchanged with row IPIV(i).  IPIV(i) will always be either\n         i or i+1; IPIV(i) = i indicates a row interchange was not\n         required.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZGTTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(237,'cherfs_237.txt','CHERFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian indefinite, and\nprovides error bounds and backward error estimates for the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The Hermitian matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n         The factored form of the matrix A.  AF contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**H or\n         A = L*D*L**H as computed by CHETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CHETRF.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CHETRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEcomputational\n'),(238,'zherfs_238.txt','ZHERFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian indefinite, and\nprovides error bounds and backward error estimates for the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The Hermitian matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n         The factored form of the matrix A.  AF contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**H or\n         A = L*D*L**H as computed by ZHETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZHETRF.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZHETRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEcomputational\n'),(239,'chprfs_239.txt','CHPRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian indefinite\nand packed, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the Hermitian matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in] AFP\n         AFP is COMPLEX array, dimension (N*(N+1)/2)\n         The factored form of the matrix A.  AFP contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**H or\n         A = L*D*L**H as computed by CHPTRF, stored as a packed\n         triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CHPTRF.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CHPTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(240,'zhprfs_240.txt','ZHPRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian indefinite\nand packed, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the Hermitian matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in] AFP\n         AFP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The factored form of the matrix A.  AFP contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**H or\n         A = L*D*L**H as computed by ZHPTRF, stored as a packed\n         triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZHPTRF.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZHPTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(241,'sporfs_241.txt','SPORFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric positive definite,\nand provides error bounds and backward error estimates for the\nsolution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is REAL array, dimension (LDAF,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, as computed by SPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by SPOTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realPOcomputational\n'),(242,'dporfs_242.txt','DPORFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric positive definite,\nand provides error bounds and backward error estimates for the\nsolution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, as computed by DPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by DPOTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doublePOcomputational\n'),(243,'cporfs_243.txt','CPORFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian positive definite,\nand provides error bounds and backward error estimates for the\nsolution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The Hermitian matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H, as computed by CPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CPOTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexPOcomputational\n'),(244,'zporfs_244.txt','ZPORFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian positive definite,\nand provides error bounds and backward error estimates for the\nsolution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The Hermitian matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H, as computed by ZPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZPOTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POcomputational\n'),(245,'spbrfs_245.txt','SPBRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric positive definite\nand banded, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         The upper or lower triangle of the symmetric band matrix A,\n         stored in the first KD+1 rows of the array.  The j-th column\n         of A is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] AFB\n         AFB is REAL array, dimension (LDAFB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T of the band matrix A as computed by\n         SPBTRF, in the same storage format as A (see AB).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= KD+1.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by SPBTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(246,'dpbrfs_246.txt','DPBRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric positive definite\nand banded, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         The upper or lower triangle of the symmetric band matrix A,\n         stored in the first KD+1 rows of the array.  The j-th column\n         of A is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] AFB\n         AFB is DOUBLE PRECISION array, dimension (LDAFB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T of the band matrix A as computed by\n         DPBTRF, in the same storage format as A (see AB).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= KD+1.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by DPBTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(247,'cpbrfs_247.txt','CPBRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian positive definite\nand banded, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         The upper or lower triangle of the Hermitian band matrix A,\n         stored in the first KD+1 rows of the array.  The j-th column\n         of A is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] AFB\n         AFB is COMPLEX array, dimension (LDAFB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H of the band matrix A as computed by\n         CPBTRF, in the same storage format as A (see AB).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= KD+1.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CPBTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(248,'zpbrfs_248.txt','ZPBRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian positive definite\nand banded, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         The upper or lower triangle of the Hermitian band matrix A,\n         stored in the first KD+1 rows of the array.  The j-th column\n         of A is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] AFB\n         AFB is COMPLEX*16 array, dimension (LDAFB,N)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H of the band matrix A as computed by\n         ZPBTRF, in the same storage format as A (see AB).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n         The leading dimension of the array AFB.  LDAFB >= KD+1.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZPBTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(249,'spprfs_249.txt','SPPRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric positive definite\nand packed, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in] AFP\n         AFP is REAL array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, as computed by SPPTRF/CPPTRF,\n         packed columnwise in a linear array in the same format as A\n         (see AP).\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by SPPTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(250,'dpprfs_250.txt','DPPRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric positive definite\nand packed, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in] AFP\n         AFP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**T*U or A = L*L**T, as computed by DPPTRF/ZPPTRF,\n         packed columnwise in a linear array in the same format as A\n         (see AP).\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by DPPTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(251,'cpprfs_251.txt','CPPRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian positive definite\nand packed, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the Hermitian matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in] AFP\n         AFP is COMPLEX array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H, as computed by SPPTRF/CPPTRF,\n         packed columnwise in a linear array in the same format as A\n         (see AP).\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CPPTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(252,'zpprfs_252.txt','ZPPRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian positive definite\nand packed, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the Hermitian matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in] AFP\n         AFP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The triangular factor U or L from the Cholesky factorization\n         A = U**H*U or A = L*L**H, as computed by DPPTRF/ZPPTRF,\n         packed columnwise in a linear array in the same format as A\n         (see AP).\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZPPTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(253,'sptrfs_253.txt','SPTRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric positive definite\nand tridiagonal, and provides error bounds and backward error\nestimates for the solution.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n diagonal elements of the tridiagonal matrix A.\n\\param[in] E\n         E is REAL array, dimension (N-1)\n         The (n-1) subdiagonal elements of the tridiagonal matrix A.\n\\param[in] DF\n         DF is REAL array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from the\n         factorization computed by SPTTRF.\n\\param[in] EF\n         EF is REAL array, dimension (N-1)\n         The (n-1) subdiagonal elements of the unit bidiagonal factor\n         L from the factorization computed by SPTTRF.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by SPTTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(254,'dptrfs_254.txt','DPTRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric positive definite\nand tridiagonal, and provides error bounds and backward error\nestimates for the solution.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the tridiagonal matrix A.\n\\param[in] E\n         E is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) subdiagonal elements of the tridiagonal matrix A.\n\\param[in] DF\n         DF is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from the\n         factorization computed by DPTTRF.\n\\param[in] EF\n         EF is DOUBLE PRECISION array, dimension (N-1)\n         The (n-1) subdiagonal elements of the unit bidiagonal factor\n         L from the factorization computed by DPTTRF.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by DPTTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(255,'cptrfs_255.txt','CPTRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian positive definite\nand tridiagonal, and provides error bounds and backward error\nestimates for the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the superdiagonal or the subdiagonal of the\n         tridiagonal matrix A is stored and the form of the\n         factorization:\n         = \'U\':  E is the superdiagonal of A, and A = U**H*D*U;\n         = \'L\':  E is the subdiagonal of A, and A = L*D*L**H.\n         (The two forms are equivalent if A is real.)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] D\n         D is REAL array, dimension (N)\n         The n real diagonal elements of the tridiagonal matrix A.\n\\param[in] E\n         E is COMPLEX array, dimension (N-1)\n         The (n-1) off-diagonal elements of the tridiagonal matrix A\n         (see UPLO).\n\\param[in] DF\n         DF is REAL array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from\n         the factorization computed by CPTTRF.\n\\param[in] EF\n         EF is COMPLEX array, dimension (N-1)\n         The (n-1) off-diagonal elements of the unit bidiagonal\n         factor U or L from the factorization computed by CPTTRF\n         (see UPLO).\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CPTTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(256,'zptrfs_256.txt','ZPTRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is Hermitian positive definite\nand tridiagonal, and provides error bounds and backward error\nestimates for the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the superdiagonal or the subdiagonal of the\n         tridiagonal matrix A is stored and the form of the\n         factorization:\n         = \'U\':  E is the superdiagonal of A, and A = U**H*D*U;\n         = \'L\':  E is the subdiagonal of A, and A = L*D*L**H.\n         (The two forms are equivalent if A is real.)\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] D\n         D is DOUBLE PRECISION array, dimension (N)\n         The n real diagonal elements of the tridiagonal matrix A.\n\\param[in] E\n         E is COMPLEX*16 array, dimension (N-1)\n         The (n-1) off-diagonal elements of the tridiagonal matrix A\n         (see UPLO).\n\\param[in] DF\n         DF is DOUBLE PRECISION array, dimension (N)\n         The n diagonal elements of the diagonal matrix D from\n         the factorization computed by ZPTTRF.\n\\param[in] EF\n         EF is COMPLEX*16 array, dimension (N-1)\n         The (n-1) off-diagonal elements of the unit bidiagonal\n         factor U or L from the factorization computed by ZPTTRF\n         (see UPLO).\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZPTTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(257,'ssyrfs_257.txt','SSYRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric indefinite, and\nprovides error bounds and backward error estimates for the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is REAL array, dimension (LDAF,N)\n         The factored form of the matrix A.  AF contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**T or\n         A = L*D*L**T as computed by SSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by SSYTRF.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by SSYTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYcomputational\n'),(258,'dsyrfs_258.txt','DSYRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric indefinite, and\nprovides error bounds and backward error estimates for the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n         The factored form of the matrix A.  AF contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**T or\n         A = L*D*L**T as computed by DSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by DSYTRF.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by DSYTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYcomputational\n'),(259,'csyrfs_259.txt','CSYRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric indefinite, and\nprovides error bounds and backward error estimates for the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n         The factored form of the matrix A.  AF contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**T or\n         A = L*D*L**T as computed by CSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CSYTRF.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CSYTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n'),(260,'zsyrfs_260.txt','ZSYRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric indefinite, and\nprovides error bounds and backward error estimates for the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of A contains the upper triangular part\n         of the matrix A, and the strictly lower triangular part of A\n         is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of A contains the lower triangular part of\n         the matrix A, and the strictly upper triangular part of A is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n         The factored form of the matrix A.  AF contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**T or\n         A = L*D*L**T as computed by ZSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n         The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZSYTRF.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZSYTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n'),(261,'ssprfs_261.txt','SSPRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric indefinite\nand packed, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in] AFP\n         AFP is REAL array, dimension (N*(N+1)/2)\n         The factored form of the matrix A.  AFP contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**T or\n         A = L*D*L**T as computed by SSPTRF, stored as a packed\n         triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by SSPTRF.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by SSPTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(262,'dsprfs_262.txt','DSPRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric indefinite\nand packed, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in] AFP\n         AFP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The factored form of the matrix A.  AFP contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**T or\n         A = L*D*L**T as computed by DSPTRF, stored as a packed\n         triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by DSPTRF.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by DSPTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(263,'csprfs_263.txt','CSPRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric indefinite\nand packed, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in] AFP\n         AFP is COMPLEX array, dimension (N*(N+1)/2)\n         The factored form of the matrix A.  AFP contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**T or\n         A = L*D*L**T as computed by CSPTRF, stored as a packed\n         triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CSPTRF.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by CSPTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(264,'zsprfs_264.txt','ZSPRFS improves the computed solution to a system of linear\nequations when the coefficient matrix is symmetric indefinite\nand packed, and provides error bounds and backward error estimates\nfor the solution.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n\\param[in] AFP\n         AFP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The factored form of the matrix A.  AFP contains the block\n         diagonal matrix D and the multipliers used to obtain the\n         factor U or L from the factorization A = U*D*U**T or\n         A = L*D*L**T as computed by ZSPTRF, stored as a packed\n         triangular matrix.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZSPTRF.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         On entry, the solution matrix X, as computed by ZSPTRS.\n         On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n\\par Internal Parameters:\n ITMAX is the maximum number of steps of iterative refinement.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(265,'strrfs_265.txt','STRRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular\ncoefficient matrix.\nThe solution matrix X must be computed by STRTRS or some other\nmeans before entering this routine.  STRRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is REAL array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(266,'dtrrfs_266.txt','DTRRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular\ncoefficient matrix.\nThe solution matrix X must be computed by DTRTRS or some other\nmeans before entering this routine.  DTRRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(267,'ctrrfs_267.txt','CTRRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular\ncoefficient matrix.\nThe solution matrix X must be computed by CTRTRS or some other\nmeans before entering this routine.  CTRRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(268,'ztrrfs_268.txt','ZTRRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular\ncoefficient matrix.\nThe solution matrix X must be computed by ZTRTRS or some other\nmeans before entering this routine.  ZTRRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The triangular matrix A.  If UPLO = \'U\', the leading N-by-N\n         upper triangular part of the array A contains the upper\n         triangular matrix, and the strictly lower triangular part of\n         A is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n         triangular part of the array A contains the lower triangular\n         matrix, and the strictly upper triangular part of A is not\n         referenced.  If DIAG = \'U\', the diagonal elements of A are\n         also not referenced and are assumed to be 1.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(269,'stbrfs_269.txt','STBRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular band\ncoefficient matrix.\nThe solution matrix X must be computed by STBTRS or some other\nmeans before entering this routine.  STBRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of the array. The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is REAL array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(270,'dtbrfs_270.txt','DTBRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular band\ncoefficient matrix.\nThe solution matrix X must be computed by DTBTRS or some other\nmeans before entering this routine.  DTBRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of the array. The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(271,'ctbrfs_271.txt','CTBRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular band\ncoefficient matrix.\nThe solution matrix X must be computed by CTBTRS or some other\nmeans before entering this routine.  CTBRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of the array. The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(272,'ztbrfs_272.txt','ZTBRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular band\ncoefficient matrix.\nThe solution matrix X must be computed by ZTBTRS or some other\nmeans before entering this routine.  ZTBRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals or subdiagonals of the\n         triangular band matrix A.  KD >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         The upper or lower triangular band matrix A, stored in the\n         first kd+1 rows of the array. The j-th column of A is stored\n         in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KD+1.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(273,'stprfs_273.txt','STPRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular packed\ncoefficient matrix.\nThe solution matrix X must be computed by STPTRS or some other\nmeans before entering this routine.  STPRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is REAL array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(274,'dtprfs_274.txt','DTPRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular packed\ncoefficient matrix.\nThe solution matrix X must be computed by DTPTRS or some other\nmeans before entering this routine.  DTPRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B  (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2*n-j)/2) = A(i,j) for j<=i<=n.\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(275,'ctprfs_275.txt','CTPRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular packed\ncoefficient matrix.\nThe solution matrix X must be computed by CTPTRS or some other\nmeans before entering this routine.  CTPRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         The right hand side matrix B. \n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is REAL array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(276,'ztprfs_276.txt','ZTPRFS provides error bounds and backward error estimates for the\nsolution to a system of linear equations with a triangular packed\ncoefficient matrix.\nThe solution matrix X must be computed by ZTPTRS or some other\nmeans before entering this routine.  ZTPRFS does not do iterative\nrefinement because doing so cannot improve the backward error.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n         Specifies the form of the system of equations:\n         = \'N\':  A * X = B     (No transpose)\n         = \'T\':  A**T * X = B  (Transpose)\n         = \'C\':  A**H * X = B  (Conjugate transpose)\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrices B and X.  NRHS >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The upper or lower triangular matrix A, packed columnwise in\n         a linear array.  The j-th column of A is stored in the array\n         AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n         If DIAG = \'U\', the diagonal elements of A are not referenced\n         and are assumed to be 1.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         The solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] FERR\n         FERR is DOUBLE PRECISION array, dimension (NRHS)\n         The estimated forward error bound for each solution vector\n         X(j) (the j-th column of the solution matrix X).\n         If XTRUE is the true solution corresponding to X(j), FERR(j)\n         is an estimated upper bound for the magnitude of the largest\n         element in (X(j) - XTRUE) divided by the magnitude of the\n         largest element in X(j).  The estimate is as reliable as\n         the estimate for RCOND, and is almost always a slight\n         overestimate of the true error.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n         The componentwise relative backward error of each solution\n         vector X(j) (i.e., the smallest relative change in\n         any element of A or B that makes X(j) an exact solution).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(277,'sgetri_277.txt','SGETRI computes the inverse of a matrix using the LU factorization\ncomputed by SGETRF.\nThis method inverts U and then computes inv(A) by solving the system\ninv(A)*L = inv(U) for inv(A).\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the factors L and U from the factorization\n         A = P*L*U as computed by SGETRF.\n         On exit, if INFO = 0, the inverse of the original matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from SGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] WORK\n         WORK is REAL array, dimension (MAX(1,LWORK))\n         On exit, if INFO=0, then WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The dimension of the array WORK.  LWORK >= max(1,N).\n         For optimal performance LWORK >= N*NB, where NB is\n         the optimal blocksize returned by ILAENV.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is\n               singular and its inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGEcomputational\n'),(278,'dgetri_278.txt','DGETRI computes the inverse of a matrix using the LU factorization\ncomputed by DGETRF.\nThis method inverts U and then computes inv(A) by solving the system\ninv(A)*L = inv(U) for inv(A).\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the factors L and U from the factorization\n         A = P*L*U as computed by DGETRF.\n         On exit, if INFO = 0, the inverse of the original matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from DGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))\n         On exit, if INFO=0, then WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The dimension of the array WORK.  LWORK >= max(1,N).\n         For optimal performance LWORK >= N*NB, where NB is\n         the optimal blocksize returned by ILAENV.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is\n               singular and its inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEcomputational\n'),(279,'cgetri_279.txt','CGETRI computes the inverse of a matrix using the LU factorization\ncomputed by CGETRF.\nThis method inverts U and then computes inv(A) by solving the system\ninv(A)*L = inv(U) for inv(A).\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the factors L and U from the factorization\n         A = P*L*U as computed by CGETRF.\n         On exit, if INFO = 0, the inverse of the original matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from CGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (MAX(1,LWORK))\n         On exit, if INFO=0, then WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The dimension of the array WORK.  LWORK >= max(1,N).\n         For optimal performance LWORK >= N*NB, where NB is\n         the optimal blocksize returned by ILAENV.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is\n               singular and its inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEcomputational\n'),(280,'zgetri_280.txt','ZGETRI computes the inverse of a matrix using the LU factorization\ncomputed by ZGETRF.\nThis method inverts U and then computes inv(A) by solving the system\ninv(A)*L = inv(U) for inv(A).\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the factors L and U from the factorization\n         A = P*L*U as computed by ZGETRF.\n         On exit, if INFO = 0, the inverse of the original matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices from ZGETRF; for 1<=i<=N, row i of the\n         matrix was interchanged with row IPIV(i).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))\n         On exit, if INFO=0, then WORK(1) returns the optimal LWORK.\n\\param[in] LWORK\n         LWORK is INTEGER\n         The dimension of the array WORK.  LWORK >= max(1,N).\n         For optimal performance LWORK >= N*NB, where NB is\n         the optimal blocksize returned by ILAENV.\n         If LWORK = -1, then a workspace query is assumed; the routine\n         only calculates the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array, and no error\n         message related to LWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is\n               singular and its inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEcomputational\n'),(281,'chetri_281.txt','CHETRI computes the inverse of a complex Hermitian indefinite matrix\nA using the factorization A = U*D*U**H or A = L*D*L**H computed by\nCHETRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by CHETRF.\n         On exit, if INFO = 0, the (Hermitian) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CHETRF.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEcomputational\n'),(282,'zhetri_282.txt','ZHETRI computes the inverse of a complex Hermitian indefinite matrix\nA using the factorization A = U*D*U**H or A = L*D*L**H computed by\nZHETRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by ZHETRF.\n         On exit, if INFO = 0, the (Hermitian) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZHETRF.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEcomputational\n'),(283,'chptri_283.txt','CHPTRI computes the inverse of a complex Hermitian indefinite matrix\nA in packed storage using the factorization A = U*D*U**H or\nA = L*D*L**H computed by CHPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by CHPTRF,\n         stored as a packed triangular matrix.\n         On exit, if INFO = 0, the (Hermitian) inverse of the original\n         matrix, stored as a packed triangular matrix. The j-th column\n         of inv(A) is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;\n         if UPLO = \'L\',\n            AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CHPTRF.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(284,'zhptri_284.txt','ZHPTRI computes the inverse of a complex Hermitian indefinite matrix\nA in packed storage using the factorization A = U*D*U**H or\nA = L*D*L**H computed by ZHPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by ZHPTRF,\n         stored as a packed triangular matrix.\n         On exit, if INFO = 0, the (Hermitian) inverse of the original\n         matrix, stored as a packed triangular matrix. The j-th column\n         of inv(A) is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;\n         if UPLO = \'L\',\n            AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZHPTRF.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(285,'spotri_285.txt','SPOTRI computes the inverse of a real symmetric positive definite\nmatrix A using the Cholesky factorization A = U**T*U or A = L*L**T\ncomputed by SPOTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T, as computed by\n         SPOTRF.\n         On exit, the upper or lower triangle of the (symmetric)\n         inverse of A, overwriting the input factor U or L.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realPOcomputational\n'),(286,'dpotri_286.txt','DPOTRI computes the inverse of a real symmetric positive definite\nmatrix A using the Cholesky factorization A = U**T*U or A = L*L**T\ncomputed by DPOTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T, as computed by\n         DPOTRF.\n         On exit, the upper or lower triangle of the (symmetric)\n         inverse of A, overwriting the input factor U or L.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doublePOcomputational\n'),(287,'cpotri_287.txt','CPOTRI computes the inverse of a complex Hermitian positive definite\nmatrix A using the Cholesky factorization A = U**H*U or A = L*L**H\ncomputed by CPOTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H, as computed by\n         CPOTRF.\n         On exit, the upper or lower triangle of the (Hermitian)\n         inverse of A, overwriting the input factor U or L.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexPOcomputational\n'),(288,'zpotri_288.txt','ZPOTRI computes the inverse of a complex Hermitian positive definite\nmatrix A using the Cholesky factorization A = U**H*U or A = L*L**H\ncomputed by ZPOTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H, as computed by\n         ZPOTRF.\n         On exit, the upper or lower triangle of the (Hermitian)\n         inverse of A, overwriting the input factor U or L.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POcomputational\n'),(289,'spptri_289.txt','SPPTRI computes the inverse of a real symmetric positive definite\nmatrix A using the Cholesky factorization A = U**T*U or A = L*L**T\ncomputed by SPPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor is stored in AP;\n         = \'L\':  Lower triangular factor is stored in AP.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         On entry, the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T, packed columnwise as\n         a linear array.  The j-th column of U or L is stored in the\n         array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n         On exit, the upper or lower triangle of the (symmetric)\n         inverse of A, overwriting the input factor U or L.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(290,'dpptri_290.txt','DPPTRI computes the inverse of a real symmetric positive definite\nmatrix A using the Cholesky factorization A = U**T*U or A = L*L**T\ncomputed by DPPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor is stored in AP;\n         = \'L\':  Lower triangular factor is stored in AP.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         On entry, the triangular factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T, packed columnwise as\n         a linear array.  The j-th column of U or L is stored in the\n         array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n         On exit, the upper or lower triangle of the (symmetric)\n         inverse of A, overwriting the input factor U or L.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(291,'cpptri_291.txt','CPPTRI computes the inverse of a complex Hermitian positive definite\nmatrix A using the Cholesky factorization A = U**H*U or A = L*L**H\ncomputed by CPPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor is stored in AP;\n         = \'L\':  Lower triangular factor is stored in AP.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H, packed columnwise as\n         a linear array.  The j-th column of U or L is stored in the\n         array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n         On exit, the upper or lower triangle of the (Hermitian)\n         inverse of A, overwriting the input factor U or L.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(292,'zpptri_292.txt','ZPPTRI computes the inverse of a complex Hermitian positive definite\nmatrix A using the Cholesky factorization A = U**H*U or A = L*L**H\ncomputed by ZPPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular factor is stored in AP;\n         = \'L\':  Lower triangular factor is stored in AP.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the triangular factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H, packed columnwise as\n         a linear array.  The j-th column of U or L is stored in the\n         array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = U(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = L(i,j) for j<=i<=n.\n         On exit, the upper or lower triangle of the (Hermitian)\n         inverse of A, overwriting the input factor U or L.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(293,'ssytri_293.txt','SSYTRI computes the inverse of a real symmetric indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nSSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by SSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by SSYTRF.\n\\param[out] WORK\n         WORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYcomputational\n'),(294,'dsytri_294.txt','DSYTRI computes the inverse of a real symmetric indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nDSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by DSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by DSYTRF.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYcomputational\n'),(295,'csytri_295.txt','CSYTRI computes the inverse of a complex symmetric indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nCSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by CSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CSYTRF.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n'),(296,'zsytri_296.txt','ZSYTRI computes the inverse of a complex symmetric indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nZSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by ZSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZSYTRF.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n'),(297,'ssptri_297.txt','SSPTRI computes the inverse of a real symmetric indefinite matrix\nA in packed storage using the factorization A = U*D*U**T or\nA = L*D*L**T computed by SSPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by SSPTRF,\n         stored as a packed triangular matrix.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix, stored as a packed triangular matrix. The j-th column\n         of inv(A) is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;\n         if UPLO = \'L\',\n            AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by SSPTRF.\n\\param[out] WORK\n         WORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(298,'dsptri_298.txt','DSPTRI computes the inverse of a real symmetric indefinite matrix\nA in packed storage using the factorization A = U*D*U**T or\nA = L*D*L**T computed by DSPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by DSPTRF,\n         stored as a packed triangular matrix.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix, stored as a packed triangular matrix. The j-th column\n         of inv(A) is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;\n         if UPLO = \'L\',\n            AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by DSPTRF.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(299,'csptri_299.txt','CSPTRI computes the inverse of a complex symmetric indefinite matrix\nA in packed storage using the factorization A = U*D*U**T or\nA = L*D*L**T computed by CSPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by CSPTRF,\n         stored as a packed triangular matrix.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix, stored as a packed triangular matrix. The j-th column\n         of inv(A) is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;\n         if UPLO = \'L\',\n            AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CSPTRF.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(300,'zsptri_300.txt','ZSPTRI computes the inverse of a complex symmetric indefinite matrix\nA in packed storage using the factorization A = U*D*U**T or\nA = L*D*L**T computed by ZSPTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the block diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by ZSPTRF,\n         stored as a packed triangular matrix.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix, stored as a packed triangular matrix. The j-th column\n         of inv(A) is stored in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = inv(A)(i,j) for 1<=i<=j;\n         if UPLO = \'L\',\n            AP(i + (j-1)*(2n-j)/2) = inv(A)(i,j) for j<=i<=n.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZSPTRF.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(301,'strtri_301.txt','STRTRI computes the inverse of a real upper or lower triangular\nmatrix A.\nThis is the Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the triangular matrix A.  If UPLO = \'U\', the\n         leading N-by-N upper triangular part of the array A contains\n         the upper triangular matrix, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of the array A contains\n         the lower triangular matrix, and the strictly upper\n         triangular part of A is not referenced.  If DIAG = \'U\', the\n         diagonal elements of A are also not referenced and are\n         assumed to be 1.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, A(i,i) is exactly zero.  The triangular\n              matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(302,'dtrtri_302.txt','DTRTRI computes the inverse of a real upper or lower triangular\nmatrix A.\nThis is the Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the triangular matrix A.  If UPLO = \'U\', the\n         leading N-by-N upper triangular part of the array A contains\n         the upper triangular matrix, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of the array A contains\n         the lower triangular matrix, and the strictly upper\n         triangular part of A is not referenced.  If DIAG = \'U\', the\n         diagonal elements of A are also not referenced and are\n         assumed to be 1.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, A(i,i) is exactly zero.  The triangular\n              matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(303,'ctrtri_303.txt','CTRTRI computes the inverse of a complex upper or lower triangular\nmatrix A.\nThis is the Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the triangular matrix A.  If UPLO = \'U\', the\n         leading N-by-N upper triangular part of the array A contains\n         the upper triangular matrix, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of the array A contains\n         the lower triangular matrix, and the strictly upper\n         triangular part of A is not referenced.  If DIAG = \'U\', the\n         diagonal elements of A are also not referenced and are\n         assumed to be 1.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, A(i,i) is exactly zero.  The triangular\n              matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(304,'ztrtri_304.txt','ZTRTRI computes the inverse of a complex upper or lower triangular\nmatrix A.\nThis is the Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the triangular matrix A.  If UPLO = \'U\', the\n         leading N-by-N upper triangular part of the array A contains\n         the upper triangular matrix, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of the array A contains\n         the lower triangular matrix, and the strictly upper\n         triangular part of A is not referenced.  If DIAG = \'U\', the\n         diagonal elements of A are also not referenced and are\n         assumed to be 1.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, A(i,i) is exactly zero.  The triangular\n              matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(305,'stptri_305.txt','STPTRI computes the inverse of a real upper or lower triangular\nmatrix A stored in packed format.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangular matrix A, stored\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same packed storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, A(i,i) is exactly zero.  The triangular\n               matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(306,'dtptri_306.txt','DTPTRI computes the inverse of a real upper or lower triangular\nmatrix A stored in packed format.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangular matrix A, stored\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same packed storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, A(i,i) is exactly zero.  The triangular\n               matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(307,'ctptri_307.txt','CTPTRI computes the inverse of a complex upper or lower triangular\nmatrix A stored in packed format.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangular matrix A, stored\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same packed storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, A(i,i) is exactly zero.  The triangular\n               matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(308,'ztptri_308.txt','ZTPTRI computes the inverse of a complex upper or lower triangular\nmatrix A stored in packed format.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         On entry, the upper or lower triangular matrix A, stored\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*((2*n-j)/2) = A(i,j) for j<=i<=n.\n         See below for further details.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same packed storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, A(i,i) is exactly zero.  The triangular\n               matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(309,'sgeequ_309.txt','SGEEQU computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.\nR(i) and C(j) are restricted to be between SMLNUM = smallest safe\nnumber and BIGNUM = largest safe number.  Use of these scaling\nfactors is not guaranteed to reduce the condition number of A but\nworks well in practice.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The M-by-N matrix whose equilibration factors are\n         to be computed.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] R\n         R is REAL array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is REAL array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is REAL\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is REAL\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGEcomputational\n'),(310,'dgeequ_310.txt','DGEEQU computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.\nR(i) and C(j) are restricted to be between SMLNUM = smallest safe\nnumber and BIGNUM = largest safe number.  Use of these scaling\nfactors is not guaranteed to reduce the condition number of A but\nworks well in practice.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The M-by-N matrix whose equilibration factors are\n         to be computed.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] R\n         R is DOUBLE PRECISION array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is DOUBLE PRECISION\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is DOUBLE PRECISION\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEcomputational\n'),(311,'cgeequ_311.txt','CGEEQU computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.\nR(i) and C(j) are restricted to be between SMLNUM = smallest safe\nnumber and BIGNUM = largest safe number.  Use of these scaling\nfactors is not guaranteed to reduce the condition number of A but\nworks well in practice.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The M-by-N matrix whose equilibration factors are\n         to be computed.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] R\n         R is REAL array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is REAL array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is REAL\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is REAL\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEcomputational\n'),(312,'zgeequ_312.txt','ZGEEQU computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.\nR(i) and C(j) are restricted to be between SMLNUM = smallest safe\nnumber and BIGNUM = largest safe number.  Use of these scaling\nfactors is not guaranteed to reduce the condition number of A but\nworks well in practice.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The M-by-N matrix whose equilibration factors are\n         to be computed.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] R\n         R is DOUBLE PRECISION array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is DOUBLE PRECISION\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is DOUBLE PRECISION\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEcomputational\n'),(313,'sgbequ_313.txt','SGBEQU computes row and column scalings intended to equilibrate an\nM-by-N band matrix A and reduce its condition number.  R returns the\nrow scale factors and C the column scale factors, chosen to try to\nmake the largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.\nR(i) and C(j) are restricted to be between SMLNUM = smallest safe\nnumber and BIGNUM = largest safe number.  Use of these scaling\nfactors is not guaranteed to reduce the condition number of A but\nworks well in practice.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         The band matrix A, stored in rows 1 to KL+KU+1.  The j-th\n         column of A is stored in the j-th column of the array AB as\n         follows:\n         AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[out] R\n         R is REAL array, dimension (M)\n         If INFO = 0, or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is REAL array, dimension (N)\n         If INFO = 0, C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is REAL\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is REAL\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGBcomputational\n'),(314,'dgbequ_314.txt','DGBEQU computes row and column scalings intended to equilibrate an\nM-by-N band matrix A and reduce its condition number.  R returns the\nrow scale factors and C the column scale factors, chosen to try to\nmake the largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.\nR(i) and C(j) are restricted to be between SMLNUM = smallest safe\nnumber and BIGNUM = largest safe number.  Use of these scaling\nfactors is not guaranteed to reduce the condition number of A but\nworks well in practice.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         The band matrix A, stored in rows 1 to KL+KU+1.  The j-th\n         column of A is stored in the j-th column of the array AB as\n         follows:\n         AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[out] R\n         R is DOUBLE PRECISION array, dimension (M)\n         If INFO = 0, or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is DOUBLE PRECISION\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is DOUBLE PRECISION\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGBcomputational\n'),(315,'cgbequ_315.txt','CGBEQU computes row and column scalings intended to equilibrate an\nM-by-N band matrix A and reduce its condition number.  R returns the\nrow scale factors and C the column scale factors, chosen to try to\nmake the largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.\nR(i) and C(j) are restricted to be between SMLNUM = smallest safe\nnumber and BIGNUM = largest safe number.  Use of these scaling\nfactors is not guaranteed to reduce the condition number of A but\nworks well in practice.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         The band matrix A, stored in rows 1 to KL+KU+1.  The j-th\n         column of A is stored in the j-th column of the array AB as\n         follows:\n         AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[out] R\n         R is REAL array, dimension (M)\n         If INFO = 0, or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is REAL array, dimension (N)\n         If INFO = 0, C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is REAL\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is REAL\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGBcomputational\n'),(316,'zgbequ_316.txt','ZGBEQU computes row and column scalings intended to equilibrate an\nM-by-N band matrix A and reduce its condition number.  R returns the\nrow scale factors and C the column scale factors, chosen to try to\nmake the largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have absolute value 1.\nR(i) and C(j) are restricted to be between SMLNUM = smallest safe\nnumber and BIGNUM = largest safe number.  Use of these scaling\nfactors is not guaranteed to reduce the condition number of A but\nworks well in practice.\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         The band matrix A, stored in rows 1 to KL+KU+1.  The j-th\n         column of A is stored in the j-th column of the array AB as\n         follows:\n         AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(m,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[out] R\n         R is DOUBLE PRECISION array, dimension (M)\n         If INFO = 0, or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is DOUBLE PRECISION\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is DOUBLE PRECISION\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GBcomputational\n'),(317,'spoequ_317.txt','SPOEQU computes row and column scalings intended to equilibrate a\nsymmetric positive definite matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The N-by-N symmetric positive definite matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realPOcomputational\n'),(318,'dpoequ_318.txt','DPOEQU computes row and column scalings intended to equilibrate a\nsymmetric positive definite matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The N-by-N symmetric positive definite matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doublePOcomputational\n'),(319,'cpoequ_319.txt','CPOEQU computes row and column scalings intended to equilibrate a\nHermitian positive definite matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The N-by-N Hermitian positive definite matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexPOcomputational\n'),(320,'zpoequ_320.txt','ZPOEQU computes row and column scalings intended to equilibrate a\nHermitian positive definite matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The N-by-N Hermitian positive definite matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POcomputational\n'),(321,'spbequ_321.txt','SPBEQU computes row and column scalings intended to equilibrate a\nsymmetric positive definite band matrix A and reduce its condition\nnumber (with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular of A is stored;\n         = \'L\':  Lower triangular of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n         The upper or lower triangle of the symmetric band matrix A,\n         stored in the first KD+1 rows of the array.  The j-th column\n         of A is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= KD+1.\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value.\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(322,'dpbequ_322.txt','DPBEQU computes row and column scalings intended to equilibrate a\nsymmetric positive definite band matrix A and reduce its condition\nnumber (with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular of A is stored;\n         = \'L\':  Lower triangular of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         The upper or lower triangle of the symmetric band matrix A,\n         stored in the first KD+1 rows of the array.  The j-th column\n         of A is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= KD+1.\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value.\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(323,'cpbequ_323.txt','CPBEQU computes row and column scalings intended to equilibrate a\nHermitian positive definite band matrix A and reduce its condition\nnumber (with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular of A is stored;\n         = \'L\':  Lower triangular of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n         The upper or lower triangle of the Hermitian band matrix A,\n         stored in the first KD+1 rows of the array.  The j-th column\n         of A is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= KD+1.\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value.\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(324,'zpbequ_324.txt','ZPBEQU computes row and column scalings intended to equilibrate a\nHermitian positive definite band matrix A and reduce its condition\nnumber (with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangular of A is stored;\n         = \'L\':  Lower triangular of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] KD\n         KD is INTEGER\n         The number of superdiagonals of the matrix A if UPLO = \'U\',\n         or the number of subdiagonals if UPLO = \'L\'.  KD >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n         The upper or lower triangle of the Hermitian band matrix A,\n         stored in the first KD+1 rows of the array.  The j-th column\n         of A is stored in the j-th column of the array AB as follows:\n         if UPLO = \'U\', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)<=i<=j;\n         if UPLO = \'L\', AB(1+i-j,j)    = A(i,j) for j<=i<=min(n,j+kd).\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= KD+1.\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value.\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(325,'sppequ_325.txt','SPPEQU computes row and column scalings intended to equilibrate a\nsymmetric positive definite matrix A in packed storage and reduce\nits condition number (with respect to the two-norm).  S contains the\nscale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix\nB with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.\nThis choice of S puts the condition number of B within a factor N of\nthe smallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is REAL array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(326,'dppequ_326.txt','DPPEQU computes row and column scalings intended to equilibrate a\nsymmetric positive definite matrix A in packed storage and reduce\nits condition number (with respect to the two-norm).  S contains the\nscale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix\nB with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.\nThis choice of S puts the condition number of B within a factor N of\nthe smallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is DOUBLE PRECISION array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the symmetric matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(327,'cppequ_327.txt','CPPEQU computes row and column scalings intended to equilibrate a\nHermitian positive definite matrix A in packed storage and reduce\nits condition number (with respect to the two-norm).  S contains the\nscale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix\nB with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.\nThis choice of S puts the condition number of B within a factor N of\nthe smallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is COMPLEX array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the Hermitian matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(328,'zppequ_328.txt','ZPPEQU computes row and column scalings intended to equilibrate a\nHermitian positive definite matrix A in packed storage and reduce\nits condition number (with respect to the two-norm).  S contains the\nscale factors, S(i)=1/sqrt(A(i,i)), chosen so that the scaled matrix\nB with elements B(i,j)=S(i)*A(i,j)*S(j) has ones on the diagonal.\nThis choice of S puts the condition number of B within a factor N of\nthe smallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] AP\n         AP is COMPLEX*16 array, dimension (N*(N+1)/2)\n         The upper or lower triangle of the Hermitian matrix A, packed\n         columnwise in a linear array.  The j-th column of A is stored\n         in the array AP as follows:\n         if UPLO = \'U\', AP(i + (j-1)*j/2) = A(i,j) for 1<=i<=j;\n         if UPLO = \'L\', AP(i + (j-1)*(2n-j)/2) = A(i,j) for j<=i<=n.\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n');
INSERT INTO `Driver_routineinfo` VALUES (329,'dsgesv_329.txt','DSGESV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N matrix and X and B are N-by-NRHS matrices.\nDSGESV first attempts to factorize the matrix in SINGLE PRECISION\nand use this factorization within an iterative refinement procedure\nto produce a solution with DOUBLE PRECISION normwise backward error\nquality (see below). If the approach fails the method switches to a\nDOUBLE PRECISION factorization and solve.\nThe iterative refinement is not going to be a winning strategy if\nthe ratio SINGLE PRECISION performance over DOUBLE PRECISION\nperformance is too small. A reasonable strategy should take the\nnumber of right-hand sides and the size of the matrix into account.\nThis might be done with a call to ILAENV in the future. Up to now, we\nalways try iterative refinement.\nThe iterative refinement process is stopped if\n    ITER > ITERMAX\nor for all the RHS we have:\n    RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX\nwhere\n    o ITER is the number of the current iteration in the iterative\n      refinement process\n    o RNRM is the infinity-norm of the residual\n    o XNRM is the infinity-norm of the solution\n    o ANRM is the infinity-operator-norm of the matrix A\n    o EPS is the machine epsilon returned by DLAMCH(\'Epsilon\')\nThe value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00\nrespectively.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array,\n         dimension (LDA,N)\n         On entry, the N-by-N coefficient matrix A.\n         On exit, if iterative refinement has been successfully used\n         (INFO.EQ.0 and ITER.GE.0, see description below), then A is\n         unchanged, if double precision factorization has been used\n         (INFO.EQ.0 and ITER.LT.0, see description below), then the\n         array A contains the factors L and U from the factorization\n         A = P*L*U; the unit diagonal elements of L are not stored.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices that define the permutation matrix P;\n         row i of the matrix was interchanged with row IPIV(i).\n         Corresponds either to the single precision factorization\n         (if INFO.EQ.0 and ITER.GE.0) or the double precision\n         factorization (if INFO.EQ.0 and ITER.LT.0).\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (N,NRHS)\n         This array is used to hold the residual vectors.\n\\param[out] SWORK\n         SWORK is REAL array, dimension (N*(N+NRHS))\n         This array is used to use the single precision matrix and the\n         right-hand sides or solutions in single precision.\n\\param[out] ITER\n         ITER is INTEGER\n         < 0: iterative refinement has failed, double precision\n              factorization has been performed\n              -1 : the routine fell back to full precision for\n                   implementation- or machine-specific reasons\n              -2 : narrowing the precision induced an overflow,\n                   the routine fell back to full precision\n              -3 : failure of SGETRF\n              -31: stop the iterative refinement after the 30th\n                   iterations\n         > 0: iterative refinement has been sucessfully used.\n              Returns the number of iterations\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) computed in DOUBLE PRECISION is\n               exactly zero.  The factorization has been completed,\n               but the factor U is exactly singular, so the solution\n               could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEsolve\n'),(330,'zcgesv_330.txt','ZCGESV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N matrix and X and B are N-by-NRHS matrices.\nZCGESV first attempts to factorize the matrix in COMPLEX and use this\nfactorization within an iterative refinement procedure to produce a\nsolution with COMPLEX*16 normwise backward error quality (see below).\nIf the approach fails the method switches to a COMPLEX*16\nfactorization and solve.\nThe iterative refinement is not going to be a winning strategy if\nthe ratio COMPLEX performance over COMPLEX*16 performance is too\nsmall. A reasonable strategy should take the number of right-hand\nsides and the size of the matrix into account. This might be done\nwith a call to ILAENV in the future. Up to now, we always try\niterative refinement.\nThe iterative refinement process is stopped if\n    ITER > ITERMAX\nor for all the RHS we have:\n    RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX\nwhere\n    o ITER is the number of the current iteration in the iterative\n      refinement process\n    o RNRM is the infinity-norm of the residual\n    o XNRM is the infinity-norm of the solution\n    o ANRM is the infinity-operator-norm of the matrix A\n    o EPS is the machine epsilon returned by DLAMCH(\'Epsilon\')\nThe value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00\nrespectively.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array,\n         dimension (LDA,N)\n         On entry, the N-by-N coefficient matrix A.\n         On exit, if iterative refinement has been successfully used\n         (INFO.EQ.0 and ITER.GE.0, see description below), then A is\n         unchanged, if double precision factorization has been used\n         (INFO.EQ.0 and ITER.LT.0, see description below), then the\n         array A contains the factors L and U from the factorization\n         A = P*L*U; the unit diagonal elements of L are not stored.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] IPIV\n         IPIV is INTEGER array, dimension (N)\n         The pivot indices that define the permutation matrix P;\n         row i of the matrix was interchanged with row IPIV(i).\n         Corresponds either to the single precision factorization\n         (if INFO.EQ.0 and ITER.GE.0) or the double precision\n         factorization (if INFO.EQ.0 and ITER.LT.0).\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N*NRHS)\n         This array is used to hold the residual vectors.\n\\param[out] SWORK\n         SWORK is COMPLEX array, dimension (N*(N+NRHS))\n         This array is used to use the single precision matrix and the\n         right-hand sides or solutions in single precision.\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] ITER\n         ITER is INTEGER\n         < 0: iterative refinement has failed, COMPLEX*16\n              factorization has been performed\n              -1 : the routine fell back to full precision for\n                   implementation- or machine-specific reasons\n              -2 : narrowing the precision induced an overflow,\n                   the routine fell back to full precision\n              -3 : failure of CGETRF\n              -31: stop the iterative refinement after the 30th\n                   iterations\n         > 0: iterative refinement has been sucessfully used.\n              Returns the number of iterations\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, U(i,i) computed in COMPLEX*16 is exactly\n               zero.  The factorization has been completed, but the\n               factor U is exactly singular, so the solution\n               could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEsolve\n'),(331,'dsposv_331.txt','DSPOSV computes the solution to a real system of linear equations\n   A * X = B,\nwhere A is an N-by-N symmetric positive definite matrix and X and B\nare N-by-NRHS matrices.\nDSPOSV first attempts to factorize the matrix in SINGLE PRECISION\nand use this factorization within an iterative refinement procedure\nto produce a solution with DOUBLE PRECISION normwise backward error\nquality (see below). If the approach fails the method switches to a\nDOUBLE PRECISION factorization and solve.\nThe iterative refinement is not going to be a winning strategy if\nthe ratio SINGLE PRECISION performance over DOUBLE PRECISION\nperformance is too small. A reasonable strategy should take the\nnumber of right-hand sides and the size of the matrix into account.\nThis might be done with a call to ILAENV in the future. Up to now, we\nalways try iterative refinement.\nThe iterative refinement process is stopped if\n    ITER > ITERMAX\nor for all the RHS we have:\n    RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX\nwhere\n    o ITER is the number of the current iteration in the iterative\n      refinement process\n    o RNRM is the infinity-norm of the residual\n    o XNRM is the infinity-norm of the solution\n    o ANRM is the infinity-operator-norm of the matrix A\n    o EPS is the machine epsilon returned by DLAMCH(\'Epsilon\')\nThe value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00\nrespectively.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array,\n         dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if iterative refinement has been successfully used\n         (INFO.EQ.0 and ITER.GE.0, see description below), then A is\n         unchanged, if double precision factorization has been used\n         (INFO.EQ.0 and ITER.LT.0, see description below), then the\n         array A contains the factor U or L from the Cholesky\n         factorization A = U**T*U or A = L*L**T.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n         If INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (N,NRHS)\n         This array is used to hold the residual vectors.\n\\param[out] SWORK\n         SWORK is REAL array, dimension (N*(N+NRHS))\n         This array is used to use the single precision matrix and the\n         right-hand sides or solutions in single precision.\n\\param[out] ITER\n         ITER is INTEGER\n         < 0: iterative refinement has failed, double precision\n              factorization has been performed\n              -1 : the routine fell back to full precision for\n                   implementation- or machine-specific reasons\n              -2 : narrowing the precision induced an overflow,\n                   the routine fell back to full precision\n              -3 : failure of SPOTRF\n              -31: stop the iterative refinement after the 30th\n                   iterations\n         > 0: iterative refinement has been sucessfully used.\n              Returns the number of iterations\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of (DOUBLE\n               PRECISION) A is not positive definite, so the\n               factorization could not be completed, and the solution\n               has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doublePOsolve\n'),(332,'zcposv_332.txt','ZCPOSV computes the solution to a complex system of linear equations\n   A * X = B,\nwhere A is an N-by-N Hermitian positive definite matrix and X and B\nare N-by-NRHS matrices.\nZCPOSV first attempts to factorize the matrix in COMPLEX and use this\nfactorization within an iterative refinement procedure to produce a\nsolution with COMPLEX*16 normwise backward error quality (see below).\nIf the approach fails the method switches to a COMPLEX*16\nfactorization and solve.\nThe iterative refinement is not going to be a winning strategy if\nthe ratio COMPLEX performance over COMPLEX*16 performance is too\nsmall. A reasonable strategy should take the number of right-hand\nsides and the size of the matrix into account. This might be done\nwith a call to ILAENV in the future. Up to now, we always try\niterative refinement.\nThe iterative refinement process is stopped if\n    ITER > ITERMAX\nor for all the RHS we have:\n    RNRM < SQRT(N)*XNRM*ANRM*EPS*BWDMAX\nwhere\n    o ITER is the number of the current iteration in the iterative\n      refinement process\n    o RNRM is the infinity-norm of the residual\n    o XNRM is the infinity-norm of the solution\n    o ANRM is the infinity-operator-norm of the matrix A\n    o EPS is the machine epsilon returned by DLAMCH(\'Epsilon\')\nThe value ITERMAX and BWDMAX are fixed to 30 and 1.0D+00\nrespectively.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The number of linear equations, i.e., the order of the\n         matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array,\n         dimension (LDA,N)\n         On entry, the Hermitian matrix A. If UPLO = \'U\', the leading\n         N-by-N upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading N-by-N lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         Note that the imaginary parts of the diagonal\n         elements need not be set and are assumed to be zero.\n         On exit, if iterative refinement has been successfully used\n         (INFO.EQ.0 and ITER.GE.0, see description below), then A is\n         unchanged, if double precision factorization has been used\n         (INFO.EQ.0 and ITER.LT.0, see description below), then the\n         array A contains the factor U or L from the Cholesky\n         factorization A = U**H*U or A = L*L**H.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         The N-by-NRHS right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n         If INFO = 0, the N-by-NRHS solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n         The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N*NRHS)\n         This array is used to hold the residual vectors.\n\\param[out] SWORK\n         SWORK is COMPLEX array, dimension (N*(N+NRHS))\n         This array is used to use the single precision matrix and the\n         right-hand sides or solutions in single precision.\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N)\n\\param[out] ITER\n         ITER is INTEGER\n         < 0: iterative refinement has failed, COMPLEX*16\n              factorization has been performed\n              -1 : the routine fell back to full precision for\n                   implementation- or machine-specific reasons\n              -2 : narrowing the precision induced an overflow,\n                   the routine fell back to full precision\n              -3 : failure of CPOTRF\n              -31: stop the iterative refinement after the 30th\n                   iterations\n         > 0: iterative refinement has been sucessfully used.\n              Returns the number of iterations\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i of\n               (COMPLEX*16) A is not positive definite, so the\n               factorization could not be completed, and the solution\n               has not been computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POsolve\n'),(333,'spftrs_333.txt','SPFTRS solves a system of linear equations A*X = B with a symmetric\npositive definite matrix A using the Cholesky factorization\nA = U**T*U or A = L*L**T computed by SPFTRF.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'T\':  The Transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of RFP A is stored;\n         = \'L\':  Lower triangle of RFP A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension ( N*(N+1)/2 )\n         The triangular factor U or L from the Cholesky factorization\n         of RFP A = U**H*U or RFP A = L*L**T, as computed by SPFTRF.\n         See note below for more details about RFP A.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(334,'dpftrs_334.txt','DPFTRS solves a system of linear equations A*X = B with a symmetric\npositive definite matrix A using the Cholesky factorization\nA = U**T*U or A = L*L**T computed by DPFTRF.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'T\':  The Transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of RFP A is stored;\n         = \'L\':  Lower triangle of RFP A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension ( N*(N+1)/2 ).\n         The triangular factor U or L from the Cholesky factorization\n         of RFP A = U**T*U or RFP A = L*L**T, as computed by DPFTRF.\n         See note below for more details about RFP A.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(335,'cpftrs_335.txt','CPFTRS solves a system of linear equations A*X = B with a Hermitian\npositive definite matrix A using the Cholesky factorization\nA = U**H*U or A = L*L**H computed by CPFTRF.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'C\':  The Conjugate-transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of RFP A is stored;\n         = \'L\':  Lower triangle of RFP A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension ( N*(N+1)/2 );\n         The triangular factor U or L from the Cholesky factorization\n         of RFP A = U**H*U or RFP A = L*L**H, as computed by CPFTRF.\n         See note below for more details about RFP A.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(336,'zpftrs_336.txt','ZPFTRS solves a system of linear equations A*X = B with a Hermitian\npositive definite matrix A using the Cholesky factorization\nA = U**H*U or A = L*L**H computed by ZPFTRF.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'C\':  The Conjugate-transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of RFP A is stored;\n         = \'L\':  Lower triangle of RFP A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension ( N*(N+1)/2 );\n         The triangular factor U or L from the Cholesky factorization\n         of RFP A = U**H*U or RFP A = L*L**H, as computed by ZPFTRF.\n         See note below for more details about RFP A.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(337,'ssytrs2_337.txt','SSYTRS2 solves a system of linear equations A*X = B with a real\nsymmetric matrix A using the factorization A = U*D*U**T or\nA = L*D*L**T computed by SSYTRF and converted by SSYCONV.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by SSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by SSYTRF.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYcomputational\n'),(338,'dsytrs2_338.txt','DSYTRS2 solves a system of linear equations A*X = B with a real\nsymmetric matrix A using the factorization A = U*D*U**T or\nA = L*D*L**T computed by DSYTRF and converted by DSYCONV.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by DSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by DSYTRF.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYcomputational\n'),(339,'csytrs2_339.txt','CSYTRS2 solves a system of linear equations A*X = B with a COMPLEX\nsymmetric matrix A using the factorization A = U*D*U**T or\nA = L*D*L**T computed by CSYTRF and converted by CSYCONV.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by CSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CSYTRF.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n'),(340,'zsytrs2_340.txt','ZSYTRS2 solves a system of linear equations A*X = B with a real\nsymmetric matrix A using the factorization A = U*D*U**T or\nA = L*D*L**T computed by ZSYTRF and converted by ZSYCONV.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by ZSYTRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZSYTRF.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n'),(341,'chetrs2_341.txt','CHETRS2 solves a system of linear equations A*X = B with a complex\nHermitian matrix A using the factorization A = U*D*U**H or\nA = L*D*L**H computed by CHETRF and converted by CSYCONV.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by CHETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by CHETRF.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEcomputational\n'),(342,'zhetrs2_342.txt','ZHETRS2 solves a system of linear equations A*X = B with a complex\nHermitian matrix A using the factorization A = U*D*U**H or\nA = L*D*L**H computed by ZHETRF and converted by ZSYCONV.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n         The number of right hand sides, i.e., the number of columns\n         of the matrix B.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The block diagonal matrix D and the multipliers used to\n         obtain the factor U or L as computed by ZHETRF.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the block structure of D\n         as determined by ZHETRF.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n         On entry, the right hand side matrix B.\n         On exit, the solution matrix X.\n\\param[in] LDB\n         LDB is INTEGER\n         The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] WORK\n         WORK is REAL array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEcomputational\n'),(343,'sgesvxx_343.txt','   SGESVXX uses the LU factorization to compute the solution to a\n   real system of linear equations  A * X = B,  where A is an\n   N-by-N matrix and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. SGESVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   SGESVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   SGESVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what SGESVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n     TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n     TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n     TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n     A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n   3. If some U(i,i)=0, so that U is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND). If the reciprocal of the condition number is less\n   than machine precision, the routine still goes on to solve for X\n   and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by R and C.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n    not \'N\', then A must have been equilibrated by the scaling\n    factors in R and/or C.  A is not modified if FACT = \'F\' or\n    \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n    On exit, if EQUED .ne. \'N\', A is scaled as follows:\n    EQUED = \'R\':  A := diag(R) * A\n    EQUED = \'C\':  A := A * diag(C)\n    EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is REAL array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the factors L and U from the factorization\n    A = P*L*U as computed by SGETRF.  If EQUED .ne. \'N\', then\n    AF is the factored form of the equilibrated matrix A.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the equilibrated matrix A (see the description of A for\n    the form of the equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains the pivot indices from the factorization A = P*L*U\n    as computed by SGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] R\n         R is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is REAL array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n       diag(R)*B;\n    if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n       overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit\n    if EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(C))*X if TRANS = \'N\' and EQUED = \'C\' or \'B\', or\n    inv(diag(R))*X if TRANS = \'T\' or \'C\' and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is REAL\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.  In SGESVX, this quantity is\n    returned in WORK(1).\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is REAL array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realGEsolve\n'),(344,'dgesvxx_344.txt','   DGESVXX uses the LU factorization to compute the solution to a\n   double precision system of linear equations  A * X = B,  where A is an\n   N-by-N matrix and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. DGESVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   DGESVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   DGESVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what DGESVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', double precision scaling factors are computed to equilibrate\n   the system:\n     TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n     TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n     TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n     A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n   3. If some U(i,i)=0, so that U is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND). If the reciprocal of the condition number is less\n   than machine precision, the routine still goes on to solve for X\n   and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by R and C.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n    not \'N\', then A must have been equilibrated by the scaling\n    factors in R and/or C.  A is not modified if FACT = \'F\' or\n    \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n    On exit, if EQUED .ne. \'N\', A is scaled as follows:\n    EQUED = \'R\':  A := diag(R) * A\n    EQUED = \'C\':  A := A * diag(C)\n    EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the factors L and U from the factorization\n    A = P*L*U as computed by DGETRF.  If EQUED .ne. \'N\', then\n    AF is the factored form of the equilibrated matrix A.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the equilibrated matrix A (see the description of A for\n    the form of the equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains the pivot indices from the factorization A = P*L*U\n    as computed by DGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] R\n         R is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n       diag(R)*B;\n    if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n       overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit\n    if EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(C))*X if TRANS = \'N\' and EQUED = \'C\' or \'B\', or\n    inv(diag(R))*X if TRANS = \'T\' or \'C\' and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is DOUBLE PRECISION\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.  In DGESVX, this quantity is\n    returned in WORK(1).\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension (NPARAMS)\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the extra-precise refinement algorithm.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleGEsolve\n'),(345,'cgesvxx_345.txt','   CGESVXX uses the LU factorization to compute the solution to a\n   complex system of linear equations  A * X = B,  where A is an\n   N-by-N matrix and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. CGESVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   CGESVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   CGESVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what CGESVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n     TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n     TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n     TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n     A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n   3. If some U(i,i)=0, so that U is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND). If the reciprocal of the condition number is less\n   than machine precision, the routine still goes on to solve for X\n   and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by R and C.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n    not \'N\', then A must have been equilibrated by the scaling\n    factors in R and/or C.  A is not modified if FACT = \'F\' or\n    \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n    On exit, if EQUED .ne. \'N\', A is scaled as follows:\n    EQUED = \'R\':  A := diag(R) * A\n    EQUED = \'C\':  A := A * diag(C)\n    EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the factors L and U from the factorization\n    A = P*L*U as computed by CGETRF.  If EQUED .ne. \'N\', then\n    AF is the factored form of the equilibrated matrix A.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the equilibrated matrix A (see the description of A for\n    the form of the equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains the pivot indices from the factorization A = P*L*U\n    as computed by CGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] R\n         R is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is REAL array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n       diag(R)*B;\n    if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n       overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit\n    if EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(C))*X if TRANS = \'N\' and EQUED = \'C\' or \'B\', or\n    inv(diag(R))*X if TRANS = \'T\' or \'C\' and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is REAL\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.  In CGESVX, this quantity is\n    returned in WORK(1).\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexGEsolve\n'),(346,'zgesvxx_346.txt','   ZGESVXX uses the LU factorization to compute the solution to a\n   complex*16 system of linear equations  A * X = B,  where A is an\n   N-by-N matrix and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. ZGESVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   ZGESVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   ZGESVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what ZGESVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', double precision scaling factors are computed to equilibrate\n   the system:\n     TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n     TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n     TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n     A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n   3. If some U(i,i)=0, so that U is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND). If the reciprocal of the condition number is less\n   than machine precision, the routine still goes on to solve for X\n   and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by R and C.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.  If FACT = \'F\' and EQUED is\n    not \'N\', then A must have been equilibrated by the scaling\n    factors in R and/or C.  A is not modified if FACT = \'F\' or\n    \'N\', or if FACT = \'E\' and EQUED = \'N\' on exit.\n    On exit, if EQUED .ne. \'N\', A is scaled as follows:\n    EQUED = \'R\':  A := diag(R) * A\n    EQUED = \'C\':  A := A * diag(C)\n    EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the factors L and U from the factorization\n    A = P*L*U as computed by ZGETRF.  If EQUED .ne. \'N\', then\n    AF is the factored form of the equilibrated matrix A.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the equilibrated matrix A (see the description of A for\n    the form of the equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains the pivot indices from the factorization A = P*L*U\n    as computed by ZGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] R\n         R is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n       diag(R)*B;\n    if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n       overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit\n    if EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(C))*X if TRANS = \'N\' and EQUED = \'C\' or \'B\', or\n    inv(diag(R))*X if TRANS = \'T\' or \'C\' and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is DOUBLE PRECISION\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.  In ZGESVX, this quantity is\n    returned in WORK(1).\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the extra-precise refinement algorithm.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16GEsolve\n'),(347,'sgbsvxx_347.txt','   SGBSVXX uses the LU factorization to compute the solution to a\n   real system of linear equations  A * X = B,  where A is an\n   N-by-N matrix and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. SGBSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   SGBSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   SGBSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what SGBSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n     TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n     TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n     TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n     A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n   3. If some U(i,i)=0, so that U is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND). If the reciprocal of the condition number is less\n   than machine precision, the routine still goes on to solve for X\n   and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by R and C.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is REAL array, dimension (LDAB,N)\n    On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n    If FACT = \'F\' and EQUED is not \'N\', then AB must have been\n    equilibrated by the scaling factors in R and/or C.  AB is not\n    modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n    EQUED = \'N\' on exit.\n    On exit, if EQUED .ne. \'N\', A is scaled as follows:\n    EQUED = \'R\':  A := diag(R) * A\n    EQUED = \'C\':  A := A * diag(C)\n    EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in,out] AFB\n         AFB is REAL array, dimension (LDAFB,N)\n    If FACT = \'F\', then AFB is an input argument and on entry\n    contains details of the LU factorization of the band matrix\n    A, as computed by SGBTRF.  U is stored as an upper triangular\n    band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n    and the multipliers used during the factorization are stored\n    in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n    the factored form of the equilibrated matrix A.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the equilibrated matrix A (see the description of A for\n    the form of the equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains the pivot indices from the factorization A = P*L*U\n    as computed by SGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] R\n         R is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is REAL array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n       diag(R)*B;\n    if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n       overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit\n    if EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(C))*X if TRANS = \'N\' and EQUED = \'C\' or \'B\', or\n    inv(diag(R))*X if TRANS = \'T\' or \'C\' and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is REAL\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.  In SGESVX, this quantity is\n    returned in WORK(1).\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is REAL array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realGBsolve\n'),(348,'dgbsvxx_348.txt','   DGBSVXX uses the LU factorization to compute the solution to a\n   double precision system of linear equations  A * X = B,  where A is an\n   N-by-N matrix and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. DGBSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   DGBSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   DGBSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what DGBSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', double precision scaling factors are computed to equilibrate\n   the system:\n     TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n     TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n     TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n     A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n   3. If some U(i,i)=0, so that U is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND). If the reciprocal of the condition number is less\n   than machine precision, the routine still goes on to solve for X\n   and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by R and C.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n    On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n    If FACT = \'F\' and EQUED is not \'N\', then AB must have been\n    equilibrated by the scaling factors in R and/or C.  AB is not\n    modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n    EQUED = \'N\' on exit.\n    On exit, if EQUED .ne. \'N\', A is scaled as follows:\n    EQUED = \'R\':  A := diag(R) * A\n    EQUED = \'C\':  A := A * diag(C)\n    EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in,out] AFB\n         AFB is DOUBLE PRECISION array, dimension (LDAFB,N)\n    If FACT = \'F\', then AFB is an input argument and on entry\n    contains details of the LU factorization of the band matrix\n    A, as computed by DGBTRF.  U is stored as an upper triangular\n    band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n    and the multipliers used during the factorization are stored\n    in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n    the factored form of the equilibrated matrix A.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the equilibrated matrix A (see the description of A for\n    the form of the equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains the pivot indices from the factorization A = P*L*U\n    as computed by DGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] R\n         R is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n       diag(R)*B;\n    if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n       overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit\n    if EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(C))*X if TRANS = \'N\' and EQUED = \'C\' or \'B\', or\n    inv(diag(R))*X if TRANS = \'T\' or \'C\' and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is DOUBLE PRECISION\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.  In DGESVX, this quantity is\n    returned in WORK(1).\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension (NPARAMS)\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the extra-precise refinement algorithm.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleGBsolve\n'),(349,'cgbsvxx_349.txt','   CGBSVXX uses the LU factorization to compute the solution to a\n   complex system of linear equations  A * X = B,  where A is an\n   N-by-N matrix and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. CGBSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   CGBSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   CGBSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what CGBSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n     TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n     TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n     TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n     A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n   3. If some U(i,i)=0, so that U is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND). If the reciprocal of the condition number is less\n   than machine precision, the routine still goes on to solve for X\n   and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by R and C.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n    On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n    If FACT = \'F\' and EQUED is not \'N\', then AB must have been\n    equilibrated by the scaling factors in R and/or C.  AB is not\n    modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n    EQUED = \'N\' on exit.\n    On exit, if EQUED .ne. \'N\', A is scaled as follows:\n    EQUED = \'R\':  A := diag(R) * A\n    EQUED = \'C\':  A := A * diag(C)\n    EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in,out] AFB\n         AFB is COMPLEX array, dimension (LDAFB,N)\n    If FACT = \'F\', then AFB is an input argument and on entry\n    contains details of the LU factorization of the band matrix\n    A, as computed by CGBTRF.  U is stored as an upper triangular\n    band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n    and the multipliers used during the factorization are stored\n    in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n    the factored form of the equilibrated matrix A.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the equilibrated matrix A (see the description of A for\n    the form of the equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains the pivot indices from the factorization A = P*L*U\n    as computed by SGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] R\n         R is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is REAL array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n       diag(R)*B;\n    if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n       overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit\n    if EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(C))*X if TRANS = \'N\' and EQUED = \'C\' or \'B\', or\n    inv(diag(R))*X if TRANS = \'T\' or \'C\' and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is REAL\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.  In SGESVX, this quantity is\n    returned in WORK(1).\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexGBsolve\n'),(350,'zgbsvxx_350.txt','   ZGBSVXX uses the LU factorization to compute the solution to a\n   complex*16 system of linear equations  A * X = B,  where A is an\n   N-by-N matrix and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. ZGBSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   ZGBSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   ZGBSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what ZGBSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', double precision scaling factors are computed to equilibrate\n   the system:\n     TRANS = \'N\':  diag(R)*A*diag(C)     *inv(diag(C))*X = diag(R)*B\n     TRANS = \'T\': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*B\n     TRANS = \'C\': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS=\'N\')\n   or diag(C)*B (if TRANS = \'T\' or \'C\').\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n     A = P * L * U,\n   where P is a permutation matrix, L is a unit lower triangular\n   matrix, and U is upper triangular.\n   3. If some U(i,i)=0, so that U is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND). If the reciprocal of the condition number is less\n   than machine precision, the routine still goes on to solve for X\n   and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(C) (if TRANS = \'N\') or diag(R) (if TRANS = \'T\' or \'C\') so\n   that it solves the original system before equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by R and C.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n    On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n    If FACT = \'F\' and EQUED is not \'N\', then AB must have been\n    equilibrated by the scaling factors in R and/or C.  AB is not\n    modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and\n    EQUED = \'N\' on exit.\n    On exit, if EQUED .ne. \'N\', A is scaled as follows:\n    EQUED = \'R\':  A := diag(R) * A\n    EQUED = \'C\':  A := A * diag(C)\n    EQUED = \'B\':  A := diag(R) * A * diag(C).\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in,out] AFB\n         AFB is COMPLEX*16 array, dimension (LDAFB,N)\n    If FACT = \'F\', then AFB is an input argument and on entry\n    contains details of the LU factorization of the band matrix\n    A, as computed by ZGBTRF.  U is stored as an upper triangular\n    band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n    and the multipliers used during the factorization are stored\n    in rows KL+KU+2 to 2*KL+KU+1.  If EQUED .ne. \'N\', then AFB is\n    the factored form of the equilibrated matrix A.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the factors L and U from the factorization A = P*L*U\n    of the equilibrated matrix A (see the description of A for\n    the form of the equilibrated matrix).\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains the pivot indices from the factorization A = P*L*U\n    as computed by DGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the original matrix A.\n    If FACT = \'E\', then IPIV is an output argument and on exit\n    contains the pivot indices from the factorization A = P*L*U\n    of the equilibrated matrix A.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] R\n         R is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if TRANS = \'N\' and EQUED = \'R\' or \'B\', B is overwritten by\n       diag(R)*B;\n    if TRANS = \'T\' or \'C\' and EQUED = \'C\' or \'B\', B is\n       overwritten by diag(C)*B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit\n    if EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(C))*X if TRANS = \'N\' and EQUED = \'C\' or \'B\', or\n    inv(diag(R))*X if TRANS = \'T\' or \'C\' and EQUED = \'R\' or \'B\'.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is DOUBLE PRECISION\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.  In DGESVX, this quantity is\n    returned in WORK(1).\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the extra-precise refinement algorithm.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16GBsolve\n'),(351,'sposvxx_351.txt','   SPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T\n   to compute the solution to a real system of linear equations\n   A * X = B, where A is an N-by-N symmetric positive definite matrix\n   and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. SPOSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   SPOSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   SPOSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what SPOSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n     diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n   2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**T* U,  if UPLO = \'U\', or\n      A = L * L**T,  if UPLO = \'L\',\n   where U is an upper triangular matrix and L is a lower triangular\n   matrix.\n   3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A (see argument RCOND).  If the reciprocal of the condition number\n   is less than machine precision, the routine still goes on to solve\n   for X and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF contains the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by S.\n              A and AF are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n    On entry, the symmetric matrix A, except if FACT = \'F\' and EQUED =\n    \'Y\', then A must contain the equilibrated matrix\n    diag(S)*A*diag(S).  If UPLO = \'U\', the leading N-by-N upper\n    triangular part of A contains the upper triangular part of the\n    matrix A, and the strictly lower triangular part of A is not\n    referenced.  If UPLO = \'L\', the leading N-by-N lower triangular\n    part of A contains the lower triangular part of the matrix A, and\n    the strictly upper triangular part of A is not referenced.  A is\n    not modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED =\n    \'N\' on exit.\n    On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n    diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is REAL array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T, in the same storage\n    format as A.  If EQUED .ne. \'N\', then AF is the factored\n    form of the equilibrated matrix diag(S)*A*diag(S).\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T of the original\n    matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T of the equilibrated\n    matrix A (see the description of A for the form of the\n    equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if EQUED = \'Y\', B is overwritten by diag(S)*B;\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit if\n    EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is REAL\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is REAL array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realPOsolve\n'),(352,'dposvxx_352.txt','   DPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T\n   to compute the solution to a double precision system of linear equations\n   A * X = B, where A is an N-by-N symmetric positive definite matrix\n   and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. DPOSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   DPOSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   DPOSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what DPOSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', double precision scaling factors are computed to equilibrate\n   the system:\n     diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n   2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**T* U,  if UPLO = \'U\', or\n      A = L * L**T,  if UPLO = \'L\',\n   where U is an upper triangular matrix and L is a lower triangular\n   matrix.\n   3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A (see argument RCOND).  If the reciprocal of the condition number\n   is less than machine precision, the routine still goes on to solve\n   for X and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF contains the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by S.\n              A and AF are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n    On entry, the symmetric matrix A, except if FACT = \'F\' and EQUED =\n    \'Y\', then A must contain the equilibrated matrix\n    diag(S)*A*diag(S).  If UPLO = \'U\', the leading N-by-N upper\n    triangular part of A contains the upper triangular part of the\n    matrix A, and the strictly lower triangular part of A is not\n    referenced.  If UPLO = \'L\', the leading N-by-N lower triangular\n    part of A contains the lower triangular part of the matrix A, and\n    the strictly upper triangular part of A is not referenced.  A is\n    not modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED =\n    \'N\' on exit.\n    On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n    diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T, in the same storage\n    format as A.  If EQUED .ne. \'N\', then AF is the factored\n    form of the equilibrated matrix diag(S)*A*diag(S).\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T of the original\n    matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T of the equilibrated\n    matrix A (see the description of A for the form of the\n    equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if EQUED = \'Y\', B is overwritten by diag(S)*B;\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit if\n    EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is DOUBLE PRECISION\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the extra-precise refinement algorithm.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doublePOsolve\n'),(353,'cposvxx_353.txt','   CPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T\n   to compute the solution to a complex system of linear equations\n   A * X = B, where A is an N-by-N symmetric positive definite matrix\n   and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. CPOSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   CPOSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   CPOSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what CPOSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n     diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n   2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**T* U,  if UPLO = \'U\', or\n      A = L * L**T,  if UPLO = \'L\',\n   where U is an upper triangular matrix and L is a lower triangular\n   matrix.\n   3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A (see argument RCOND).  If the reciprocal of the condition number\n   is less than machine precision, the routine still goes on to solve\n   for X and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF contains the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by S.\n              A and AF are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n    On entry, the symmetric matrix A, except if FACT = \'F\' and EQUED =\n    \'Y\', then A must contain the equilibrated matrix\n    diag(S)*A*diag(S).  If UPLO = \'U\', the leading N-by-N upper\n    triangular part of A contains the upper triangular part of the\n    matrix A, and the strictly lower triangular part of A is not\n    referenced.  If UPLO = \'L\', the leading N-by-N lower triangular\n    part of A contains the lower triangular part of the matrix A, and\n    the strictly upper triangular part of A is not referenced.  A is\n    not modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED =\n    \'N\' on exit.\n    On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n    diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T, in the same storage\n    format as A.  If EQUED .ne. \'N\', then AF is the factored\n    form of the equilibrated matrix diag(S)*A*diag(S).\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T of the original\n    matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T of the equilibrated\n    matrix A (see the description of A for the form of the\n    equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if EQUED = \'Y\', B is overwritten by diag(S)*B;\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit if\n    EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is REAL\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexPOsolve\n'),(354,'zposvxx_354.txt','   ZPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T\n   to compute the solution to a complex*16 system of linear equations\n   A * X = B, where A is an N-by-N symmetric positive definite matrix\n   and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. ZPOSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   ZPOSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   ZPOSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what ZPOSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', double precision scaling factors are computed to equilibrate\n   the system:\n     diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n   2. If FACT = \'N\' or \'E\', the Cholesky decomposition is used to\n   factor the matrix A (after equilibration if FACT = \'E\') as\n      A = U**T* U,  if UPLO = \'U\', or\n      A = L * L**T,  if UPLO = \'L\',\n   where U is an upper triangular matrix and L is a lower triangular\n   matrix.\n   3. If the leading i-by-i principal minor is not positive definite,\n   then the routine returns with INFO = i. Otherwise, the factored\n   form of A is used to estimate the condition number of the matrix\n   A (see argument RCOND).  If the reciprocal of the condition number\n   is less than machine precision, the routine still goes on to solve\n   for X and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(S) so that it solves the original system before\n   equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF contains the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by S.\n              A and AF are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    On entry, the symmetric matrix A, except if FACT = \'F\' and EQUED =\n    \'Y\', then A must contain the equilibrated matrix\n    diag(S)*A*diag(S).  If UPLO = \'U\', the leading N-by-N upper\n    triangular part of A contains the upper triangular part of the\n    matrix A, and the strictly lower triangular part of A is not\n    referenced.  If UPLO = \'L\', the leading N-by-N lower triangular\n    part of A contains the lower triangular part of the matrix A, and\n    the strictly upper triangular part of A is not referenced.  A is\n    not modified if FACT = \'F\' or \'N\', or if FACT = \'E\' and EQUED =\n    \'N\' on exit.\n    On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n    diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T, in the same storage\n    format as A.  If EQUED .ne. \'N\', then AF is the factored\n    form of the equilibrated matrix diag(S)*A*diag(S).\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T of the original\n    matrix A.\n    If FACT = \'E\', then AF is an output argument and on exit\n    returns the triangular factor U or L from the Cholesky\n    factorization A = U**T*U or A = L*L**T of the equilibrated\n    matrix A (see the description of A for the form of the\n    equilibrated matrix).\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if EQUED = \'Y\', B is overwritten by diag(S)*B;\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit if\n    EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is DOUBLE PRECISION\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the extra-precise refinement algorithm.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16POsolve\n'),(355,'ssysvxx_355.txt','   SSYSVXX uses the diagonal pivoting factorization to compute the\n   solution to a real system of linear equations A * X = B, where A\n   is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. SSYSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   SSYSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   SSYSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what SSYSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n     diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n   3. If some D(i,i)=0, so that D is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND).  If the reciprocal of the condition number is\n   less than machine precision, the routine still goes on to solve\n   for X and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(R) so that it solves the original system before\n   equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by S.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n    On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n    diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is REAL array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T as computed by SSYTRF.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains details of the interchanges and the block\n    structure of D, as determined by SSYTRF.  If IPIV(k) > 0,\n    then rows and columns k and IPIV(k) were interchanged and\n    D(k,k) is a 1-by-1 diagonal block.  If UPLO = \'U\' and\n    IPIV(k) = IPIV(k-1) < 0, then rows and columns k-1 and\n    -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2\n    diagonal block.  If UPLO = \'L\' and IPIV(k) = IPIV(k+1) < 0,\n    then rows and columns k+1 and -IPIV(k) were interchanged\n    and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains details of the interchanges and the block\n    structure of D, as determined by SSYTRF.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in,out] B\n         B is REAL array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if EQUED = \'Y\', B is overwritten by diag(S)*B;\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is REAL array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit if\n    EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is REAL\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is REAL array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realSYcomputational\n'),(356,'dsysvxx_356.txt','   DSYSVXX uses the diagonal pivoting factorization to compute the\n   solution to a double precision system of linear equations A * X = B, where A\n   is an N-by-N symmetric matrix and X and B are N-by-NRHS matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. DSYSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   DSYSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   DSYSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what DSYSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', double precision scaling factors are computed to equilibrate\n   the system:\n     diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n   3. If some D(i,i)=0, so that D is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND).  If the reciprocal of the condition number is\n   less than machine precision, the routine still goes on to solve\n   for X and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(R) so that it solves the original system before\n   equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by S.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n    On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n    diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T as computed by DSYTRF.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains details of the interchanges and the block\n    structure of D, as determined by DSYTRF.  If IPIV(k) > 0,\n    then rows and columns k and IPIV(k) were interchanged and\n    D(k,k) is a 1-by-1 diagonal block.  If UPLO = \'U\' and\n    IPIV(k) = IPIV(k-1) < 0, then rows and columns k-1 and\n    -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2\n    diagonal block.  If UPLO = \'L\' and IPIV(k) = IPIV(k+1) < 0,\n    then rows and columns k+1 and -IPIV(k) were interchanged\n    and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains details of the interchanges and the block\n    structure of D, as determined by DSYTRF.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in,out] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if EQUED = \'Y\', B is overwritten by diag(S)*B;\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit if\n    EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is DOUBLE PRECISION\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension (NPARAMS)\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the extra-precise refinement algorithm.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleSYcomputational\n'),(357,'csysvxx_357.txt','   CSYSVXX uses the diagonal pivoting factorization to compute the\n   solution to a complex system of linear equations A * X = B, where\n   A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n   matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. CSYSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   CSYSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   CSYSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what CSYSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n     diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n   3. If some D(i,i)=0, so that D is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND).  If the reciprocal of the condition number is\n   less than machine precision, the routine still goes on to solve\n   for X and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(R) so that it solves the original system before\n   equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by S.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n    On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n    diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T as computed by SSYTRF.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains details of the interchanges and the block\n    structure of D, as determined by SSYTRF.  If IPIV(k) > 0,\n    then rows and columns k and IPIV(k) were interchanged and\n    D(k,k) is a 1-by-1 diagonal block.  If UPLO = \'U\' and\n    IPIV(k) = IPIV(k-1) < 0, then rows and columns k-1 and\n    -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2\n    diagonal block.  If UPLO = \'L\' and IPIV(k) = IPIV(k+1) < 0,\n    then rows and columns k+1 and -IPIV(k) were interchanged\n    and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains details of the interchanges and the block\n    structure of D, as determined by SSYTRF.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if EQUED = \'Y\', B is overwritten by diag(S)*B;\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit if\n    EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is REAL\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexSYsolve\n'),(358,'zsysvxx_358.txt','   ZSYSVXX uses the diagonal pivoting factorization to compute the\n   solution to a complex*16 system of linear equations A * X = B, where\n   A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n   matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. ZSYSVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   ZSYSVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   ZSYSVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what ZSYSVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', double precision scaling factors are computed to equilibrate\n   the system:\n     diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n   3. If some D(i,i)=0, so that D is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND).  If the reciprocal of the condition number is\n   less than machine precision, the routine still goes on to solve\n   for X and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(R) so that it solves the original system before\n   equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by S.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n    On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n    diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T as computed by DSYTRF.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains details of the interchanges and the block\n    structure of D, as determined by DSYTRF.  If IPIV(k) > 0,\n    then rows and columns k and IPIV(k) were interchanged and\n    D(k,k) is a 1-by-1 diagonal block.  If UPLO = \'U\' and\n    IPIV(k) = IPIV(k-1) < 0, then rows and columns k-1 and\n    -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2\n    diagonal block.  If UPLO = \'L\' and IPIV(k) = IPIV(k+1) < 0,\n    then rows and columns k+1 and -IPIV(k) were interchanged\n    and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains details of the interchanges and the block\n    structure of D, as determined by DSYTRF.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if EQUED = \'Y\', B is overwritten by diag(S)*B;\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit if\n    EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is DOUBLE PRECISION\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the extra-precise refinement algorithm.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16SYsolve\n'),(359,'chesvxx_359.txt','   CHESVXX uses the diagonal pivoting factorization to compute the\n   solution to a complex system of linear equations A * X = B, where\n   A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n   matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. CHESVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   CHESVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   CHESVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what CHESVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', real scaling factors are computed to equilibrate\n   the system:\n     diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n   3. If some D(i,i)=0, so that D is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND).  If the reciprocal of the condition number is\n   less than machine precision, the routine still goes on to solve\n   for X and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(R) so that it solves the original system before\n   equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by S.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n    On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n    diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T as computed by SSYTRF.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains details of the interchanges and the block\n    structure of D, as determined by CHETRF.  If IPIV(k) > 0,\n    then rows and columns k and IPIV(k) were interchanged and\n    D(k,k) is a 1-by-1 diagonal block.  If UPLO = \'U\' and\n    IPIV(k) = IPIV(k-1) < 0, then rows and columns k-1 and\n    -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2\n    diagonal block.  If UPLO = \'L\' and IPIV(k) = IPIV(k+1) < 0,\n    then rows and columns k+1 and -IPIV(k) were interchanged\n    and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains details of the interchanges and the block\n    structure of D, as determined by CHETRF.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in,out] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if EQUED = \'Y\', B is overwritten by diag(S)*B;\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit if\n    EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is REAL\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexHEsolve\n'),(360,'zhesvxx_360.txt','   ZHESVXX uses the diagonal pivoting factorization to compute the\n   solution to a complex*16 system of linear equations A * X = B, where\n   A is an N-by-N symmetric matrix and X and B are N-by-NRHS\n   matrices.\n   If requested, both normwise and maximum componentwise error bounds\n   are returned. ZHESVXX will return a solution with a tiny\n   guaranteed error (O(eps) where eps is the working machine\n   precision) unless the matrix is very ill-conditioned, in which\n   case a warning is returned. Relevant condition numbers also are\n   calculated and returned.\n   ZHESVXX accepts user-provided factorizations and equilibration\n   factors; see the definitions of the FACT and EQUED options.\n   Solving with refinement and using a factorization from a previous\n   ZHESVXX call will also produce a solution with either O(eps)\n   errors or warnings, but we cannot make that claim for general\n   user-provided factorizations and equilibration factors if they\n   differ from what ZHESVXX would itself produce.\n\\par Description:\n   The following steps are performed:\n   1. If FACT = \'E\', double precision scaling factors are computed to equilibrate\n   the system:\n     diag(S)*A*diag(S)     *inv(diag(S))*X = diag(S)*B\n   Whether or not the system will be equilibrated depends on the\n   scaling of the matrix A, but if equilibration is used, A is\n   overwritten by diag(S)*A*diag(S) and B by diag(S)*B.\n   2. If FACT = \'N\' or \'E\', the LU decomposition is used to factor\n   the matrix A (after equilibration if FACT = \'E\') as\n      A = U * D * U**T,  if UPLO = \'U\', or\n      A = L * D * L**T,  if UPLO = \'L\',\n   where U (or L) is a product of permutation and unit upper (lower)\n   triangular matrices, and D is symmetric and block diagonal with\n   1-by-1 and 2-by-2 diagonal blocks.\n   3. If some D(i,i)=0, so that D is exactly singular, then the\n   routine returns with INFO = i. Otherwise, the factored form of A\n   is used to estimate the condition number of the matrix A (see\n   argument RCOND).  If the reciprocal of the condition number is\n   less than machine precision, the routine still goes on to solve\n   for X and compute error bounds as described below.\n   4. The system of equations is solved for X using the factored form\n   of A.\n   5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero),\n   the routine will use iterative refinement to try to get a small\n   error and error bounds.  Refinement calculates the residual to at\n   least twice the working precision.\n   6. If equilibration was used, the matrix X is premultiplied by\n   diag(R) so that it solves the original system before\n   equilibration.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] FACT\n         FACT is CHARACTER*1\n    Specifies whether or not the factored form of the matrix A is\n    supplied on entry, and if not, whether the matrix A should be\n    equilibrated before it is factored.\n      = \'F\':  On entry, AF and IPIV contain the factored form of A.\n              If EQUED is not \'N\', the matrix A has been\n              equilibrated with scaling factors given by S.\n              A, AF, and IPIV are not modified.\n      = \'N\':  The matrix A will be copied to AF and factored.\n      = \'E\':  The matrix A will be equilibrated if necessary, then\n              copied to AF and factored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n    On exit, if FACT = \'E\' and EQUED = \'Y\', A is overwritten by\n    diag(S)*A*diag(S).\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in,out] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    If FACT = \'F\', then AF is an input argument and on entry\n    contains the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T as computed by DSYTRF.\n    If FACT = \'N\', then AF is an output argument and on exit\n    returns the block diagonal matrix D and the multipliers\n    used to obtain the factor U or L from the factorization A =\n    U*D*U**T or A = L*D*L**T.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] IPIV\n         IPIV is INTEGER array, dimension (N)\n    If FACT = \'F\', then IPIV is an input argument and on entry\n    contains details of the interchanges and the block\n    structure of D, as determined by ZHETRF.  If IPIV(k) > 0,\n    then rows and columns k and IPIV(k) were interchanged and\n    D(k,k) is a 1-by-1 diagonal block.  If UPLO = \'U\' and\n    IPIV(k) = IPIV(k-1) < 0, then rows and columns k-1 and\n    -IPIV(k) were interchanged and D(k-1:k,k-1:k) is a 2-by-2\n    diagonal block.  If UPLO = \'L\' and IPIV(k) = IPIV(k+1) < 0,\n    then rows and columns k+1 and -IPIV(k) were interchanged\n    and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.\n    If FACT = \'N\', then IPIV is an output argument and on exit\n    contains details of the interchanges and the block\n    structure of D, as determined by ZHETRF.\n\\param[in,out] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done.\n      = \'N\':  No equilibration (always true if FACT = \'N\').\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n    EQUED is an input argument if FACT = \'F\'; otherwise, it is an\n    output argument.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in,out] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n    On entry, the N-by-NRHS right hand side matrix B.\n    On exit,\n    if EQUED = \'N\', B is not modified;\n    if EQUED = \'Y\', B is overwritten by diag(S)*B;\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n    If INFO = 0, the N-by-NRHS solution matrix X to the original\n    system of equations.  Note that A and B are modified on exit if\n    EQUED .ne. \'N\', and the solution to the equilibrated system is\n    inv(diag(S))*X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] RPVGRW\n         RPVGRW is DOUBLE PRECISION\n    Reciprocal pivot growth.  On exit, this contains the reciprocal\n    pivot growth factor norm(A)/norm(U). The \"max absolute element\"\n    norm is used.  If this is much less than 1, then the stability of\n    the LU factorization of the (equilibrated) matrix A could be poor.\n    This also means that the solution X, estimated condition numbers,\n    and error bounds could be unreliable. If factorization fails with\n    0<INFO<=N, then this contains the reciprocal pivot growth factor\n    for the leading INFO columns of A.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the extra-precise refinement algorithm.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16HEsolve\n'),(361,'spftrf_361.txt','SPFTRF computes the Cholesky factorization of a real symmetric\npositive definite matrix A.\nThe factorization has the form\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nThis is the block version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'T\':  The Transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of RFP A is stored;\n         = \'L\':  Lower triangle of RFP A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension ( N*(N+1)/2 );\n         On entry, the symmetric matrix A in RFP format. RFP format is\n         described by TRANSR, UPLO, and N as follows: If TRANSR = \'N\'\n         then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'T\' then RFP is\n         the transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the NT elements of\n         upper packed A. If UPLO = \'L\' the RFP A contains the elements\n         of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =\n         \'T\'. When TRANSR is \'N\' the LDA is N+1 when N is even and N\n         is odd. See the Note below for more details.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization RFP A = U**T*U or RFP A = L*L**T.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(362,'dpftrf_362.txt','DPFTRF computes the Cholesky factorization of a real symmetric\npositive definite matrix A.\nThe factorization has the form\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nThis is the block version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'T\':  The Transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of RFP A is stored;\n         = \'L\':  Lower triangle of RFP A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension ( N*(N+1)/2 );\n         On entry, the symmetric matrix A in RFP format. RFP format is\n         described by TRANSR, UPLO, and N as follows: If TRANSR = \'N\'\n         then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'T\' then RFP is\n         the transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the NT elements of\n         upper packed A. If UPLO = \'L\' the RFP A contains the elements\n         of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =\n         \'T\'. When TRANSR is \'N\' the LDA is N+1 when N is even and N\n         is odd. See the Note below for more details.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization RFP A = U**T*U or RFP A = L*L**T.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(363,'cpftrf_363.txt','DPFTRF computes the Cholesky factorization of a real symmetric\npositive definite matrix A.\nThe factorization has the form\n   A = U**T * U,  if UPLO = \'U\', or\n   A = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nThis is the block version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'T\':  The Transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of RFP A is stored;\n         = \'L\':  Lower triangle of RFP A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension ( N*(N+1)/2 );\n         On entry, the symmetric matrix A in RFP format. RFP format is\n         described by TRANSR, UPLO, and N as follows: If TRANSR = \'N\'\n         then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'T\' then RFP is\n         the transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the NT elements of\n         upper packed A. If UPLO = \'L\' the RFP A contains the elements\n         of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =\n         \'T\'. When TRANSR is \'N\' the LDA is N+1 when N is even and N\n         is odd. See the Note below for more details.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization RFP A = U**T*U or RFP A = L*L**T.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(364,'zpftrf_364.txt','ZPFTRF computes the Cholesky factorization of a complex Hermitian\npositive definite matrix A.\nThe factorization has the form\n   A = U**H * U,  if UPLO = \'U\', or\n   A = L  * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular.\nThis is the block version of the algorithm, calling Level 3 BLAS.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'C\':  The Conjugate-transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of RFP A is stored;\n         = \'L\':  Lower triangle of RFP A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension ( N*(N+1)/2 );\n         On entry, the Hermitian matrix A in RFP format. RFP format is\n         described by TRANSR, UPLO, and N as follows: If TRANSR = \'N\'\n         then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'C\' then RFP is\n         the Conjugate-transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the nt elements of\n         upper packed A. If UPLO = \'L\' the RFP A contains the elements\n         of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =\n         \'C\'. When TRANSR is \'N\' the LDA is N+1 when N is even and N\n         is odd. See the Note below for more details.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization RFP A = U**H*U or RFP A = L*L**H.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the leading minor of order i is not\n               positive definite, and the factorization could not be\n               completed.\n Further Notes on RFP Format:\n We first consider Standard Packed Format when N is even.\n We give an example where N = 6.\n    AP is Upper             AP is Lower\n  00 01 02 03 04 05       00\n     11 12 13 14 15       10 11\n        22 23 24 25       20 21 22\n           33 34 35       30 31 32 33\n              44 45       40 41 42 43 44\n                 55       50 51 52 53 54 55\n Let TRANSR = \'N\'. RFP holds AP as follows:\n For UPLO = \'U\' the upper trapezoid A(0:5,0:2) consists of the last\n three columns of AP upper. The lower triangle A(4:6,0:2) consists of\n conjugate-transpose of the first three columns of AP upper.\n For UPLO = \'L\' the lower trapezoid A(1:6,0:2) consists of the first\n three columns of AP lower. The upper triangle A(0:2,0:2) consists of\n conjugate-transpose of the last three columns of AP lower.\n To denote conjugate we place -- above the element. This covers the\n case N even and TRANSR = \'N\'.\n        RFP A                   RFP A\n                               -- -- --\n       03 04 05                33 43 53\n                                  -- --\n       13 14 15                00 44 54\n                                     --\n       23 24 25                10 11 55\n       33 34 35                20 21 22\n       --\n       00 44 45                30 31 32\n       -- --\n       01 11 55                40 41 42\n       -- -- --\n       02 12 22                50 51 52\n Now let TRANSR = \'C\'. RFP A in both UPLO cases is just the conjugate-\n transpose of RFP A above. One therefore gets:\n          RFP A                   RFP A\n    -- -- -- --                -- -- -- -- -- --\n    03 13 23 33 00 01 02    33 00 10 20 30 40 50\n    -- -- -- -- --                -- -- -- -- --\n    04 14 24 34 44 11 12    43 44 11 21 31 41 51\n    -- -- -- -- -- --                -- -- -- --\n    05 15 25 35 45 55 22    53 54 55 22 32 42 52\n We next  consider Standard Packed Format when N is odd.\n We give an example where N = 5.\n    AP is Upper                 AP is Lower\n  00 01 02 03 04              00\n     11 12 13 14              10 11\n        22 23 24              20 21 22\n           33 34              30 31 32 33\n              44              40 41 42 43 44\n Let TRANSR = \'N\'. RFP holds AP as follows:\n For UPLO = \'U\' the upper trapezoid A(0:4,0:2) consists of the last\n three columns of AP upper. The lower triangle A(3:4,0:1) consists of\n conjugate-transpose of the first two   columns of AP upper.\n For UPLO = \'L\' the lower trapezoid A(0:4,0:2) consists of the first\n three columns of AP lower. The upper triangle A(0:1,1:2) consists of\n conjugate-transpose of the last two   columns of AP lower.\n To denote conjugate we place -- above the element. This covers the\n case N odd  and TRANSR = \'N\'.\n        RFP A                   RFP A\n                                  -- --\n       02 03 04                00 33 43\n                                     --\n       12 13 14                10 11 44\n       22 23 24                20 21 22\n       --\n       00 33 34                30 31 32\n       -- --\n       01 11 44                40 41 42\n Now let TRANSR = \'C\'. RFP A in both UPLO cases is just the conjugate-\n transpose of RFP A above. One therefore gets:\n          RFP A                   RFP A\n    -- -- --                   -- -- -- -- -- --\n    02 12 22 00 01             00 10 20 30 40 50\n    -- -- -- --                   -- -- -- -- --\n    03 13 23 33 11             33 11 21 31 41 51\n    -- -- -- -- --                   -- -- -- --\n    04 14 24 34 44             43 44 22 32 42 52\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(365,'spstrf_365.txt','SPSTRF computes the Cholesky factorization with complete\npivoting of a real symmetric positive semidefinite matrix A.\nThe factorization has the form\n   P**T * A * P = U**T * U ,  if UPLO = \'U\',\n   P**T * A * P = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular, and\nP is stored as vector PIV.\nThis algorithm does not attempt to check that A is positive\nsemidefinite. This version of the algorithm calls level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the upper or lower triangular part of the\n         symmetric matrix A is stored.\n         = \'U\':  Upper triangular\n         = \'L\':  Lower triangular\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         n by n upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading n by n lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization as above.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] PIV\n         PIV is INTEGER array, dimension (N)\n         PIV is such that the nonzero entries are P( PIV(K), K ) = 1.\n\\param[out] RANK\n         RANK is INTEGER\n         The rank of A given by the number of steps the algorithm\n         completed.\n\\param[in] TOL\n         TOL is REAL\n         User defined tolerance. If TOL < 0, then N*U*MAX( A(K,K) )\n         will be used. The algorithm terminates at the (K-1)st step\n         if the pivot <= TOL.\n\\param[out] WORK\n         WORK is REAL array, dimension (2*N)\n         Work space.\n\\param[out] INFO\n         INFO is INTEGER\n         < 0: If INFO = -K, the K-th argument had an illegal value,\n         = 0: algorithm completed successfully, and\n         > 0: the matrix A is either rank deficient with computed rank\n              as returned in RANK, or is indefinite.  See Section 7 of\n              LAPACK Working Note #161 for further information.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(366,'dpstrf_366.txt','DPSTRF computes the Cholesky factorization with complete\npivoting of a real symmetric positive semidefinite matrix A.\nThe factorization has the form\n   P**T * A * P = U**T * U ,  if UPLO = \'U\',\n   P**T * A * P = L  * L**T,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular, and\nP is stored as vector PIV.\nThis algorithm does not attempt to check that A is positive\nsemidefinite. This version of the algorithm calls level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the upper or lower triangular part of the\n         symmetric matrix A is stored.\n         = \'U\':  Upper triangular\n         = \'L\':  Lower triangular\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         n by n upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading n by n lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization as above.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] PIV\n         PIV is INTEGER array, dimension (N)\n         PIV is such that the nonzero entries are P( PIV(K), K ) = 1.\n\\param[out] RANK\n         RANK is INTEGER\n         The rank of A given by the number of steps the algorithm\n         completed.\n\\param[in] TOL\n         TOL is DOUBLE PRECISION\n         User defined tolerance. If TOL < 0, then N*U*MAX( A(K,K) )\n         will be used. The algorithm terminates at the (K-1)st step\n         if the pivot <= TOL.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (2*N)\n         Work space.\n\\param[out] INFO\n         INFO is INTEGER\n         < 0: If INFO = -K, the K-th argument had an illegal value,\n         = 0: algorithm completed successfully, and\n         > 0: the matrix A is either rank deficient with computed rank\n              as returned in RANK, or is indefinite.  See Section 7 of\n              LAPACK Working Note #161 for further information.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(367,'cpstrf_367.txt','CPSTRF computes the Cholesky factorization with complete\npivoting of a complex Hermitian positive semidefinite matrix A.\nThe factorization has the form\n   P**T * A * P = U**H * U ,  if UPLO = \'U\',\n   P**T * A * P = L  * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular, and\nP is stored as vector PIV.\nThis algorithm does not attempt to check that A is positive\nsemidefinite. This version of the algorithm calls level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the upper or lower triangular part of the\n         symmetric matrix A is stored.\n         = \'U\':  Upper triangular\n         = \'L\':  Lower triangular\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         n by n upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading n by n lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization as above.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] PIV\n         PIV is INTEGER array, dimension (N)\n         PIV is such that the nonzero entries are P( PIV(K), K ) = 1.\n\\param[out] RANK\n         RANK is INTEGER\n         The rank of A given by the number of steps the algorithm\n         completed.\n\\param[in] TOL\n         TOL is REAL\n         User defined tolerance. If TOL < 0, then N*U*MAX( A(K,K) )\n         will be used. The algorithm terminates at the (K-1)st step\n         if the pivot <= TOL.\n\\param[out] WORK\n         WORK is REAL array, dimension (2*N)\n         Work space.\n\\param[out] INFO\n         INFO is INTEGER\n         < 0: If INFO = -K, the K-th argument had an illegal value,\n         = 0: algorithm completed successfully, and\n         > 0: the matrix A is either rank deficient with computed rank\n              as returned in RANK, or is indefinite.  See Section 7 of\n              LAPACK Working Note #161 for further information.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(368,'zpstrf_368.txt','ZPSTRF computes the Cholesky factorization with complete\npivoting of a complex Hermitian positive semidefinite matrix A.\nThe factorization has the form\n   P**T * A * P = U**H * U ,  if UPLO = \'U\',\n   P**T * A * P = L  * L**H,  if UPLO = \'L\',\nwhere U is an upper triangular matrix and L is lower triangular, and\nP is stored as vector PIV.\nThis algorithm does not attempt to check that A is positive\nsemidefinite. This version of the algorithm calls level 3 BLAS.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the upper or lower triangular part of the\n         symmetric matrix A is stored.\n         = \'U\':  Upper triangular\n         = \'L\':  Lower triangular\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the symmetric matrix A.  If UPLO = \'U\', the leading\n         n by n upper triangular part of A contains the upper\n         triangular part of the matrix A, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading n by n lower triangular part of A contains the lower\n         triangular part of the matrix A, and the strictly upper\n         triangular part of A is not referenced.\n         On exit, if INFO = 0, the factor U or L from the Cholesky\n         factorization as above.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] PIV\n         PIV is INTEGER array, dimension (N)\n         PIV is such that the nonzero entries are P( PIV(K), K ) = 1.\n\\param[out] RANK\n         RANK is INTEGER\n         The rank of A given by the number of steps the algorithm\n         completed.\n\\param[in] TOL\n         TOL is DOUBLE PRECISION\n         User defined tolerance. If TOL < 0, then N*U*MAX( A(K,K) )\n         will be used. The algorithm terminates at the (K-1)st step\n         if the pivot <= TOL.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (2*N)\n         Work space.\n\\param[out] INFO\n         INFO is INTEGER\n         < 0: If INFO = -K, the K-th argument had an illegal value,\n         = 0: algorithm completed successfully, and\n         > 0: the matrix A is either rank deficient with computed rank\n              as returned in RANK, or is indefinite.  See Section 7 of\n              LAPACK Working Note #161 for further information.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(369,'spftri_369.txt','SPFTRI computes the inverse of a real (symmetric) positive definite\nmatrix A using the Cholesky factorization A = U**T*U or A = L*L**T\ncomputed by SPFTRF.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'T\':  The Transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension ( N*(N+1)/2 )\n         On entry, the symmetric matrix A in RFP format. RFP format is\n         described by TRANSR, UPLO, and N as follows: If TRANSR = \'N\'\n         then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'T\' then RFP is\n         the transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the nt elements of\n         upper packed A. If UPLO = \'L\' the RFP A contains the elements\n         of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =\n         \'T\'. When TRANSR is \'N\' the LDA is N+1 when N is even and N\n         is odd. See the Note below for more details.\n         On exit, the symmetric inverse of the original matrix, in the\n         same storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(370,'dpftri_370.txt','DPFTRI computes the inverse of a (real) symmetric positive definite\nmatrix A using the Cholesky factorization A = U**T*U or A = L*L**T\ncomputed by DPFTRF.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'T\':  The Transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension ( N*(N+1)/2 )\n         On entry, the symmetric matrix A in RFP format. RFP format is\n         described by TRANSR, UPLO, and N as follows: If TRANSR = \'N\'\n         then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'T\' then RFP is\n         the transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the nt elements of\n         upper packed A. If UPLO = \'L\' the RFP A contains the elements\n         of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =\n         \'T\'. When TRANSR is \'N\' the LDA is N+1 when N is even and N\n         is odd. See the Note below for more details.\n         On exit, the symmetric inverse of the original matrix, in the\n         same storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(371,'cpftri_371.txt','CPFTRI computes the inverse of a complex Hermitian positive definite\nmatrix A using the Cholesky factorization A = U**H*U or A = L*L**H\ncomputed by CPFTRF.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'C\':  The Conjugate-transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension ( N*(N+1)/2 );\n         On entry, the Hermitian matrix A in RFP format. RFP format is\n         described by TRANSR, UPLO, and N as follows: If TRANSR = \'N\'\n         then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'C\' then RFP is\n         the Conjugate-transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the nt elements of\n         upper packed A. If UPLO = \'L\' the RFP A contains the elements\n         of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =\n         \'C\'. When TRANSR is \'N\' the LDA is N+1 when N is even and N\n         is odd. See the Note below for more details.\n         On exit, the Hermitian inverse of the original matrix, in the\n         same storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(372,'zpftri_372.txt','ZPFTRI computes the inverse of a complex Hermitian positive definite\nmatrix A using the Cholesky factorization A = U**H*U or A = L*L**H\ncomputed by ZPFTRF.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'C\':  The Conjugate-transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangle of A is stored;\n         = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension ( N*(N+1)/2 );\n         On entry, the Hermitian matrix A in RFP format. RFP format is\n         described by TRANSR, UPLO, and N as follows: If TRANSR = \'N\'\n         then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'C\' then RFP is\n         the Conjugate-transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the nt elements of\n         upper packed A. If UPLO = \'L\' the RFP A contains the elements\n         of lower packed A. The LDA of RFP A is (N+1)/2 when TRANSR =\n         \'C\'. When TRANSR is \'N\' the LDA is N+1 when N is even and N\n         is odd. See the Note below for more details.\n         On exit, the Hermitian inverse of the original matrix, in the\n         same storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the (i,i) element of the factor U or L is\n               zero, and the inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(373,'stftri_373.txt','STFTRI computes the inverse of a triangular matrix A stored in RFP\nformat.\nThis is a Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'T\':  The Transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (NT);\n         NT=N*(N+1)/2. On entry, the triangular factor of a Hermitian\n         Positive Definite matrix A in RFP format. RFP format is\n         described by TRANSR, UPLO, and N as follows: If TRANSR = \'N\'\n         then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'T\' then RFP is\n         the transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the nt elements of\n         upper packed A; If UPLO = \'L\' the RFP A contains the nt\n         elements of lower packed A. The LDA of RFP A is (N+1)/2 when\n         TRANSR = \'T\'. When TRANSR is \'N\' the LDA is N+1 when N is\n         even and N is odd. See the Note below for more details.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, A(i,i) is exactly zero.  The triangular\n              matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(374,'dtftri_374.txt','DTFTRI computes the inverse of a triangular matrix A stored in RFP\nformat.\nThis is a Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'T\':  The Transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (0:nt-1);\n         nt=N*(N+1)/2. On entry, the triangular factor of a Hermitian\n         Positive Definite matrix A in RFP format. RFP format is\n         described by TRANSR, UPLO, and N as follows: If TRANSR = \'N\'\n         then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'T\' then RFP is\n         the transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the nt elements of\n         upper packed A; If UPLO = \'L\' the RFP A contains the nt\n         elements of lower packed A. The LDA of RFP A is (N+1)/2 when\n         TRANSR = \'T\'. When TRANSR is \'N\' the LDA is N+1 when N is\n         even and N is odd. See the Note below for more details.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, A(i,i) is exactly zero.  The triangular\n              matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(375,'ctftri_375.txt','CTFTRI computes the inverse of a triangular matrix A stored in RFP\nformat.\nThis is a Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'C\':  The Conjugate-transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension ( N*(N+1)/2 );\n         On entry, the triangular matrix A in RFP format. RFP format\n         is described by TRANSR, UPLO, and N as follows: If TRANSR =\n         \'N\' then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'C\' then RFP is\n         the Conjugate-transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the nt elements of\n         upper packed A; If UPLO = \'L\' the RFP A contains the nt\n         elements of lower packed A. The LDA of RFP A is (N+1)/2 when\n         TRANSR = \'C\'. When TRANSR is \'N\' the LDA is N+1 when N is\n         even and N is odd. See the Note below for more details.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, A(i,i) is exactly zero.  The triangular\n              matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(376,'ztftri_376.txt','ZTFTRI computes the inverse of a triangular matrix A stored in RFP\nformat.\nThis is a Level 3 BLAS version of the algorithm.\nArguments:\n\\param[in] TRANSR\n         TRANSR is CHARACTER*1\n         = \'N\':  The Normal TRANSR of RFP A is stored;\n         = \'C\':  The Conjugate-transpose TRANSR of RFP A is stored.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  A is upper triangular;\n         = \'L\':  A is lower triangular.\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         = \'N\':  A is non-unit triangular;\n         = \'U\':  A is unit triangular.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension ( N*(N+1)/2 );\n         On entry, the triangular matrix A in RFP format. RFP format\n         is described by TRANSR, UPLO, and N as follows: If TRANSR =\n         \'N\' then RFP A is (0:N,0:k-1) when N is even; k=N/2. RFP A is\n         (0:N-1,0:k) when N is odd; k=N/2. IF TRANSR = \'C\' then RFP is\n         the Conjugate-transpose of RFP A as defined when\n         TRANSR = \'N\'. The contents of RFP A are defined by UPLO as\n         follows: If UPLO = \'U\' the RFP A contains the nt elements of\n         upper packed A; If UPLO = \'L\' the RFP A contains the nt\n         elements of lower packed A. The LDA of RFP A is (N+1)/2 when\n         TRANSR = \'C\'. When TRANSR is \'N\' the LDA is N+1 when N is\n         even and N is odd. See the Note below for more details.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, A(i,i) is exactly zero.  The triangular\n              matrix is singular and its inverse can not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(377,'ssytri2_377.txt','SSYTRI2 computes the inverse of a REAL hermitian indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nSSYTRF. SSYTRI2 sets the LEADING DIMENSION of the workspace\nbefore calling SSYTRI2X that actually computes the inverse.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the NB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by SSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NB structure of D\n         as determined by SSYTRF.\n\\param[out] WORK\n         WORK is REAL array, dimension (N+NB+1)*(NB+3)\n\\param[in] LWORK\n         LWORK is INTEGER\n         The dimension of the array WORK.\n         WORK is size >= (N+NB+1)*(NB+3)\n         If LDWORK = -1, then a workspace query is assumed; the routine\n          calculates:\n             - the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array,\n             - and no error message related to LDWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYcomputational\n'),(378,'dsytri2_378.txt','DSYTRI2 computes the inverse of a DOUBLE PRECISION hermitian indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nDSYTRF. DSYTRI2 sets the LEADING DIMENSION of the workspace\nbefore calling DSYTRI2X that actually computes the inverse.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the NB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by DSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NB structure of D\n         as determined by DSYTRF.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (N+NB+1)*(NB+3)\n\\param[in] LWORK\n         LWORK is INTEGER\n         The dimension of the array WORK.\n         WORK is size >= (N+NB+1)*(NB+3)\n         If LDWORK = -1, then a workspace query is assumed; the routine\n          calculates:\n             - the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array,\n             - and no error message related to LDWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYcomputational\n'),(379,'csytri2_379.txt','CSYTRI2 computes the inverse of a COMPLEX hermitian indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nCSYTRF. CSYTRI2 sets the LEADING DIMENSION of the workspace\nbefore calling CSYTRI2X that actually computes the inverse.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the NB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by CSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NB structure of D\n         as determined by CSYTRF.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N+NB+1)*(NB+3)\n\\param[in] LWORK\n         LWORK is INTEGER\n         The dimension of the array WORK.\n         WORK is size >= (N+NB+1)*(NB+3)\n         If LDWORK = -1, then a workspace query is assumed; the routine\n          calculates:\n             - the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array,\n             - and no error message related to LDWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n'),(380,'zsytri2_380.txt','ZSYTRI2 computes the inverse of a COMPLEX*16 hermitian indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nZSYTRF. ZSYTRI2 sets the LEADING DIMENSION of the workspace\nbefore calling ZSYTRI2X that actually computes the inverse.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the NB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by ZSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NB structure of D\n         as determined by ZSYTRF.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N+NB+1)*(NB+3)\n\\param[in] LWORK\n         LWORK is INTEGER\n         The dimension of the array WORK.\n         WORK is size >= (N+NB+1)*(NB+3)\n         If LDWORK = -1, then a workspace query is assumed; the routine\n          calculates:\n             - the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array,\n             - and no error message related to LDWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n'),(381,'chetri2_381.txt','CHETRI2 computes the inverse of a COMPLEX hermitian indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nCHETRF. CHETRI2 set the LEADING DIMENSION of the workspace\nbefore calling CHETRI2X that actually computes the inverse.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the NB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by CHETRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NB structure of D\n         as determined by CHETRF.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N+NB+1)*(NB+3)\n\\param[in] LWORK\n         LWORK is INTEGER\n         The dimension of the array WORK.\n         WORK is size >= (N+NB+1)*(NB+3)\n         If LDWORK = -1, then a workspace query is assumed; the routine\n          calculates:\n             - the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array,\n             - and no error message related to LDWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEcomputational\n'),(382,'zhetri2_382.txt','ZHETRI2 computes the inverse of a COMPLEX*16 hermitian indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nZHETRF. ZHETRI2 set the LEADING DIMENSION of the workspace\nbefore calling ZHETRI2X that actually computes the inverse.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the NB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by ZHETRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NB structure of D\n         as determined by ZHETRF.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N+NB+1)*(NB+3)\n\\param[in] LWORK\n         LWORK is INTEGER\n         The dimension of the array WORK.\n         WORK is size >= (N+NB+1)*(NB+3)\n         If LDWORK = -1, then a workspace query is assumed; the routine\n          calculates:\n             - the optimal size of the WORK array, returns\n         this value as the first entry of the WORK array,\n             - and no error message related to LDWORK is issued by XERBLA.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEcomputational\n'),(383,'ssytri2x_383.txt','SSYTRI2X computes the inverse of a real symmetric indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nSSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the NNB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by SSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NNB structure of D\n         as determined by SSYTRF.\n\\param[out] WORK\n         WORK is REAL array, dimension (N+NNB+1,NNB+3)\n\\param[in] NB\n         NB is INTEGER\n         Block size\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYcomputational\n'),(384,'dsytri2x_384.txt','DSYTRI2X computes the inverse of a real symmetric indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nDSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the NNB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by DSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NNB structure of D\n         as determined by DSYTRF.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (N+NNB+1,NNB+3)\n\\param[in] NB\n         NB is INTEGER\n         Block size\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYcomputational\n'),(385,'csytri2x_385.txt','CSYTRI2X computes the inverse of a real symmetric indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nCSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the NNB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by CSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NNB structure of D\n         as determined by CSYTRF.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N+NNB+1,NNB+3)\n\\param[in] NB\n         NB is INTEGER\n         Block size\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n'),(386,'zsytri2x_386.txt','ZSYTRI2X computes the inverse of a complex symmetric indefinite matrix\nA using the factorization A = U*D*U**T or A = L*D*L**T computed by\nZSYTRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the NNB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by ZSYTRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NNB structure of D\n         as determined by ZSYTRF.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N+NNB+1,NNB+3)\n\\param[in] NB\n         NB is INTEGER\n         Block size\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n'),(387,'chetri2x_387.txt','CHETRI2X computes the inverse of a complex Hermitian indefinite matrix\nA using the factorization A = U*D*U**H or A = L*D*L**H computed by\nCHETRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the NNB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by CHETRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NNB structure of D\n         as determined by CHETRF.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (N+NNB+1,NNB+3)\n\\param[in] NB\n         NB is INTEGER\n         Block size\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEcomputational\n'),(388,'zhetri2x_388.txt','ZHETRI2X computes the inverse of a COMPLEX*16 Hermitian indefinite matrix\nA using the factorization A = U*D*U**H or A = L*D*L**H computed by\nZHETRF.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**H;\n         = \'L\':  Lower triangular, form is A = L*D*L**H.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the NNB diagonal matrix D and the multipliers\n         used to obtain the factor U or L as computed by ZHETRF.\n         On exit, if INFO = 0, the (symmetric) inverse of the original\n         matrix.  If UPLO = \'U\', the upper triangular part of the\n         inverse is formed and the part of A below the diagonal is not\n         referenced; if UPLO = \'L\' the lower triangular part of the\n         inverse is formed and the part of A above the diagonal is\n         not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n         Details of the interchanges and the NNB structure of D\n         as determined by ZHETRF.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (N+NNB+1,NNB+3)\n\\param[in] NB\n         NB is INTEGER\n         Block size\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -i, the i-th argument had an illegal value\n         > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its\n              inverse could not be computed.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEcomputational\n'),(389,'strti2_389.txt','STRTI2 computes the inverse of a real upper or lower triangular\nmatrix.\nThis is the Level 2 BLAS version of the algorithm.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the matrix A is upper or lower triangular.\n         = \'U\':  Upper triangular\n         = \'L\':  Lower triangular\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         Specifies whether or not the matrix A is unit triangular.\n         = \'N\':  Non-unit triangular\n         = \'U\':  Unit triangular\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is REAL array, dimension (LDA,N)\n         On entry, the triangular matrix A.  If UPLO = \'U\', the\n         leading n by n upper triangular part of the array A contains\n         the upper triangular matrix, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading n by n lower triangular part of the array A contains\n         the lower triangular matrix, and the strictly upper\n         triangular part of A is not referenced.  If DIAG = \'U\', the\n         diagonal elements of A are also not referenced and are\n         assumed to be 1.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realOTHERcomputational\n'),(390,'dtrti2_390.txt','DTRTI2 computes the inverse of a real upper or lower triangular\nmatrix.\nThis is the Level 2 BLAS version of the algorithm.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the matrix A is upper or lower triangular.\n         = \'U\':  Upper triangular\n         = \'L\':  Lower triangular\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         Specifies whether or not the matrix A is unit triangular.\n         = \'N\':  Non-unit triangular\n         = \'U\':  Unit triangular\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         On entry, the triangular matrix A.  If UPLO = \'U\', the\n         leading n by n upper triangular part of the array A contains\n         the upper triangular matrix, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading n by n lower triangular part of the array A contains\n         the lower triangular matrix, and the strictly upper\n         triangular part of A is not referenced.  If DIAG = \'U\', the\n         diagonal elements of A are also not referenced and are\n         assumed to be 1.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleOTHERcomputational\n'),(391,'ctrti2_391.txt','CTRTI2 computes the inverse of a complex upper or lower triangular\nmatrix.\nThis is the Level 2 BLAS version of the algorithm.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the matrix A is upper or lower triangular.\n         = \'U\':  Upper triangular\n         = \'L\':  Lower triangular\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         Specifies whether or not the matrix A is unit triangular.\n         = \'N\':  Non-unit triangular\n         = \'U\':  Unit triangular\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX array, dimension (LDA,N)\n         On entry, the triangular matrix A.  If UPLO = \'U\', the\n         leading n by n upper triangular part of the array A contains\n         the upper triangular matrix, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading n by n lower triangular part of the array A contains\n         the lower triangular matrix, and the strictly upper\n         triangular part of A is not referenced.  If DIAG = \'U\', the\n         diagonal elements of A are also not referenced and are\n         assumed to be 1.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexOTHERcomputational\n'),(392,'ztrti2_392.txt','ZTRTI2 computes the inverse of a complex upper or lower triangular\nmatrix.\nThis is the Level 2 BLAS version of the algorithm.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the matrix A is upper or lower triangular.\n         = \'U\':  Upper triangular\n         = \'L\':  Lower triangular\n\\param[in] DIAG\n         DIAG is CHARACTER*1\n         Specifies whether or not the matrix A is unit triangular.\n         = \'N\':  Non-unit triangular\n         = \'U\':  Unit triangular\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in,out] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         On entry, the triangular matrix A.  If UPLO = \'U\', the\n         leading n by n upper triangular part of the array A contains\n         the upper triangular matrix, and the strictly lower\n         triangular part of A is not referenced.  If UPLO = \'L\', the\n         leading n by n lower triangular part of the array A contains\n         the lower triangular matrix, and the strictly upper\n         triangular part of A is not referenced.  If DIAG = \'U\', the\n         diagonal elements of A are also not referenced and are\n         assumed to be 1.\n         On exit, the (triangular) inverse of the original matrix, in\n         the same storage format.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] INFO\n         INFO is INTEGER\n         = 0: successful exit\n         < 0: if INFO = -k, the k-th argument had an illegal value\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16OTHERcomputational\n'),(393,'sgeequb_393.txt','SGEEQUB computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most\nthe radix.\nR(i) and C(j) are restricted to be a power of the radix between\nSMLNUM = smallest safe number and BIGNUM = largest safe number.  Use\nof these scaling factors is not guaranteed to reduce the condition\nnumber of A but works well in practice.\nThis routine differs from SGEEQU by restricting the scaling factors\nto a power of the radix.  Baring over- and underflow, scaling by\nthese factors introduces no additional rounding errors.  However, the\nscaled entries\' magnitured are no longer approximately 1 but lie\nbetween sqrt(radix) and 1/sqrt(radix).\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The M-by-N matrix whose equilibration factors are\n         to be computed.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] R\n         R is REAL array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is REAL array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is REAL\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is REAL\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGEcomputational\n'),(394,'dgeequb_394.txt','DGEEQUB computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most\nthe radix.\nR(i) and C(j) are restricted to be a power of the radix between\nSMLNUM = smallest safe number and BIGNUM = largest safe number.  Use\nof these scaling factors is not guaranteed to reduce the condition\nnumber of A but works well in practice.\nThis routine differs from DGEEQU by restricting the scaling factors\nto a power of the radix.  Baring over- and underflow, scaling by\nthese factors introduces no additional rounding errors.  However, the\nscaled entries\' magnitured are no longer approximately 1 but lie\nbetween sqrt(radix) and 1/sqrt(radix).\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The M-by-N matrix whose equilibration factors are\n         to be computed.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] R\n         R is DOUBLE PRECISION array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is DOUBLE PRECISION\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is DOUBLE PRECISION\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEcomputational\n'),(395,'cgeequb_395.txt','CGEEQUB computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most\nthe radix.\nR(i) and C(j) are restricted to be a power of the radix between\nSMLNUM = smallest safe number and BIGNUM = largest safe number.  Use\nof these scaling factors is not guaranteed to reduce the condition\nnumber of A but works well in practice.\nThis routine differs from CGEEQU by restricting the scaling factors\nto a power of the radix.  Baring over- and underflow, scaling by\nthese factors introduces no additional rounding errors.  However, the\nscaled entries\' magnitured are no longer approximately 1 but lie\nbetween sqrt(radix) and 1/sqrt(radix).\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The M-by-N matrix whose equilibration factors are\n         to be computed.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] R\n         R is REAL array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is REAL array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is REAL\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is REAL\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEcomputational\n'),(396,'zgeequb_396.txt','ZGEEQUB computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most\nthe radix.\nR(i) and C(j) are restricted to be a power of the radix between\nSMLNUM = smallest safe number and BIGNUM = largest safe number.  Use\nof these scaling factors is not guaranteed to reduce the condition\nnumber of A but works well in practice.\nThis routine differs from ZGEEQU by restricting the scaling factors\nto a power of the radix.  Baring over- and underflow, scaling by\nthese factors introduces no additional rounding errors.  However, the\nscaled entries\' magnitured are no longer approximately 1 but lie\nbetween sqrt(radix) and 1/sqrt(radix).\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The M-by-N matrix whose equilibration factors are\n         to be computed.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,M).\n\\param[out] R\n         R is DOUBLE PRECISION array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is DOUBLE PRECISION\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is DOUBLE PRECISION\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEcomputational\n'),(397,'sgbequb_397.txt','SGBEQUB computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most\nthe radix.\nR(i) and C(j) are restricted to be a power of the radix between\nSMLNUM = smallest safe number and BIGNUM = largest safe number.  Use\nof these scaling factors is not guaranteed to reduce the condition\nnumber of A but works well in practice.\nThis routine differs from SGEEQU by restricting the scaling factors\nto a power of the radix.  Baring over- and underflow, scaling by\nthese factors introduces no additional rounding errors.  However, the\nscaled entries\' magnitured are no longer approximately 1 but lie\nbetween sqrt(radix) and 1/sqrt(radix).\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= max(1,M).\n\\param[out] R\n         R is REAL array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is REAL array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is REAL\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is REAL\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGBcomputational\n'),(398,'dgbequb_398.txt','DGBEQUB computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most\nthe radix.\nR(i) and C(j) are restricted to be a power of the radix between\nSMLNUM = smallest safe number and BIGNUM = largest safe number.  Use\nof these scaling factors is not guaranteed to reduce the condition\nnumber of A but works well in practice.\nThis routine differs from DGEEQU by restricting the scaling factors\nto a power of the radix.  Baring over- and underflow, scaling by\nthese factors introduces no additional rounding errors.  However, the\nscaled entries\' magnitured are no longer approximately 1 but lie\nbetween sqrt(radix) and 1/sqrt(radix).\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= max(1,M).\n\\param[out] R\n         R is DOUBLE PRECISION array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is DOUBLE PRECISION\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is DOUBLE PRECISION\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGBcomputational\n'),(399,'cgbequb_399.txt','CGBEQUB computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most\nthe radix.\nR(i) and C(j) are restricted to be a power of the radix between\nSMLNUM = smallest safe number and BIGNUM = largest safe number.  Use\nof these scaling factors is not guaranteed to reduce the condition\nnumber of A but works well in practice.\nThis routine differs from CGEEQU by restricting the scaling factors\nto a power of the radix.  Baring over- and underflow, scaling by\nthese factors introduces no additional rounding errors.  However, the\nscaled entries\' magnitured are no longer approximately 1 but lie\nbetween sqrt(radix) and 1/sqrt(radix).\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= max(1,M).\n\\param[out] R\n         R is REAL array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is REAL array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is REAL\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is REAL\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGBcomputational\n'),(400,'zgbequb_400.txt','ZGBEQUB computes row and column scalings intended to equilibrate an\nM-by-N matrix A and reduce its condition number.  R returns the row\nscale factors and C the column scale factors, chosen to try to make\nthe largest element in each row and column of the matrix B with\nelements B(i,j)=R(i)*A(i,j)*C(j) have an absolute value of at most\nthe radix.\nR(i) and C(j) are restricted to be a power of the radix between\nSMLNUM = smallest safe number and BIGNUM = largest safe number.  Use\nof these scaling factors is not guaranteed to reduce the condition\nnumber of A but works well in practice.\nThis routine differs from ZGEEQU by restricting the scaling factors\nto a power of the radix.  Baring over- and underflow, scaling by\nthese factors introduces no additional rounding errors.  However, the\nscaled entries\' magnitured are no longer approximately 1 but lie\nbetween sqrt(radix) and 1/sqrt(radix).\nArguments:\n\\param[in] M\n         M is INTEGER\n         The number of rows of the matrix A.  M >= 0.\n\\param[in] N\n         N is INTEGER\n         The number of columns of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n         The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n         The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n         On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n         The j-th column of A is stored in the j-th column of the\n         array AB as follows:\n         AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n\\param[in] LDAB\n         LDAB is INTEGER\n         The leading dimension of the array A.  LDAB >= max(1,M).\n\\param[out] R\n         R is DOUBLE PRECISION array, dimension (M)\n         If INFO = 0 or INFO > M, R contains the row scale factors\n         for A.\n\\param[out] C\n         C is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0,  C contains the column scale factors for A.\n\\param[out] ROWCND\n         ROWCND is DOUBLE PRECISION\n         If INFO = 0 or INFO > M, ROWCND contains the ratio of the\n         smallest R(i) to the largest R(i).  If ROWCND >= 0.1 and\n         AMAX is neither too large nor too small, it is not worth\n         scaling by R.\n\\param[out] COLCND\n         COLCND is DOUBLE PRECISION\n         If INFO = 0, COLCND contains the ratio of the smallest\n         C(i) to the largest C(i).  If COLCND >= 0.1, it is not\n         worth scaling by C.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i,  and i is\n               <= M:  the i-th row of A is exactly zero\n               >  M:  the (i-M)-th column of A is exactly zero\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GBcomputational\n'),(401,'ssyequb_401.txt','SSYEQUB computes row and column scalings intended to equilibrate a\nsymmetric matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The N-by-N symmetric matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] WORK\n         WORK is REAL array, dimension (3*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYcomputational\n\\par References:\n Livne, O.E. and Golub, G.H., \"Scaling by Binormalization\", \\n\n Numerical Algorithms, vol. 35, no. 1, pp. 97-120, January 2004. \\n\n DOI 10.1023/B:NUMA.0000016606.32820.69 \\n\n Tech report version: http://ruready.utah.edu/archive/papers/bin.pdf\n'),(402,'dsyequb_402.txt','DSYEQUB computes row and column scalings intended to equilibrate a\nsymmetric matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The N-by-N symmetric matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYcomputational\n\\par References:\n Livne, O.E. and Golub, G.H., \"Scaling by Binormalization\", \\n\n Numerical Algorithms, vol. 35, no. 1, pp. 97-120, January 2004. \\n\n DOI 10.1023/B:NUMA.0000016606.32820.69 \\n\n Tech report version: http://ruready.utah.edu/archive/papers/bin.pdf\n'),(403,'csyequb_403.txt','CSYEQUB computes row and column scalings intended to equilibrate a\nsymmetric matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The N-by-N symmetric matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (3*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n\\par References:\n Livne, O.E. and Golub, G.H., \"Scaling by Binormalization\", \\n\n Numerical Algorithms, vol. 35, no. 1, pp. 97-120, January 2004. \\n\n DOI 10.1023/B:NUMA.0000016606.32820.69 \\n\n Tech report version: http://ruready.utah.edu/archive/papers/bin.pdf\n'),(404,'zsyequb_404.txt','ZSYEQUB computes row and column scalings intended to equilibrate a\nsymmetric matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         Specifies whether the details of the factorization are stored\n         as an upper or lower triangular matrix.\n         = \'U\':  Upper triangular, form is A = U*D*U**T;\n         = \'L\':  Lower triangular, form is A = L*D*L**T.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The N-by-N symmetric matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (3*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n\\par References:\n Livne, O.E. and Golub, G.H., \"Scaling by Binormalization\", \\n\n Numerical Algorithms, vol. 35, no. 1, pp. 97-120, January 2004. \\n\n DOI 10.1023/B:NUMA.0000016606.32820.69 \\n \n Tech report version: http://ruready.utah.edu/archive/papers/bin.pdf\n'),(405,'spoequb_405.txt','SPOEQU computes row and column scalings intended to equilibrate a\nsymmetric positive definite matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n         The N-by-N symmetric positive definite matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realPOcomputational\n'),(406,'dpoequb_406.txt','DPOEQU computes row and column scalings intended to equilibrate a\nsymmetric positive definite matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n         The N-by-N symmetric positive definite matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doublePOcomputational\n'),(407,'cpoequb_407.txt','CPOEQUB computes row and column scalings intended to equilibrate a\nsymmetric positive definite matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The N-by-N symmetric positive definite matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexPOcomputational\n'),(408,'zpoequb_408.txt','ZPOEQUB computes row and column scalings intended to equilibrate a\nsymmetric positive definite matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The N-by-N symmetric positive definite matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POcomputational\n'),(409,'cheequb_409.txt','CHEEQUB computes row and column scalings intended to equilibrate a\nHermitian matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangles of A and B are stored;\n         = \'L\':  Lower triangles of A and B are stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n         The N-by-N Hermitian matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is REAL array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is REAL\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is REAL\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (3*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexHEcomputational\n'),(410,'zheequb_410.txt','ZHEEQUB computes row and column scalings intended to equilibrate a\nHermitian matrix A and reduce its condition number\n(with respect to the two-norm).  S contains the scale factors,\nS(i) = 1/sqrt(A(i,i)), chosen so that the scaled matrix B with\nelements B(i,j) = S(i)*A(i,j)*S(j) has ones on the diagonal.  This\nchoice of S puts the condition number of B within a factor N of the\nsmallest possible condition number over all possible diagonal\nscalings.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n         = \'U\':  Upper triangles of A and B are stored;\n         = \'L\':  Lower triangles of A and B are stored.\n\\param[in] N\n         N is INTEGER\n         The order of the matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n         The N-by-N Hermitian matrix whose scaling\n         factors are to be computed.  Only the diagonal elements of A\n         are referenced.\n\\param[in] LDA\n         LDA is INTEGER\n         The leading dimension of the array A.  LDA >= max(1,N).\n\\param[out] S\n         S is DOUBLE PRECISION array, dimension (N)\n         If INFO = 0, S contains the scale factors for A.\n\\param[out] SCOND\n         SCOND is DOUBLE PRECISION\n         If INFO = 0, S contains the ratio of the smallest S(i) to\n         the largest S(i).  If SCOND >= 0.1 and AMAX is neither too\n         large nor too small, it is not worth scaling by S.\n\\param[out] AMAX\n         AMAX is DOUBLE PRECISION\n         Absolute value of largest matrix element.  If AMAX is very\n         close to overflow or very close to underflow, the matrix\n         should be scaled.\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (3*N)\n\\param[out] INFO\n         INFO is INTEGER\n         = 0:  successful exit\n         < 0:  if INFO = -i, the i-th argument had an illegal value\n         > 0:  if INFO = i, the i-th diagonal element is nonpositive.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16HEcomputational\n'),(411,'sgerfsx_411.txt','   SGERFSX improves the computed solution to a system of linear\n   equations and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED, R\n   and C below. In this case, the solution and error bounds returned\n   are for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n    The original N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is REAL array, dimension (LDAF,N)\n    The factors L and U from the factorization A = P*L*U\n    as computed by SGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from SGETRF; for 1<=i<=N, row i of the\n    matrix was interchanged with row IPIV(i).\n\\param[in] R\n         R is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  \n    If R is accessed, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] C\n         C is REAL array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed. \n    If C is accessed, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by SGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is REAL array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGEcomputational\n'),(412,'dgerfsx_412.txt','   DGERFSX improves the computed solution to a system of linear\n   equations and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED, R\n   and C below. In this case, the solution and error bounds returned\n   are for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n    The original N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n    The factors L and U from the factorization A = P*L*U\n    as computed by DGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from DGETRF; for 1<=i<=N, row i of the\n    matrix was interchanged with row IPIV(i).\n\\param[in] R\n         R is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  \n    If R is accessed, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed. \n    If C is accessed, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by DGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension (NPARAMS)\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEcomputational\n'),(413,'cgerfsx_413.txt','   CGERFSX improves the computed solution to a system of linear\n   equations and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED, R\n   and C below. In this case, the solution and error bounds returned\n   are for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    The original N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The factors L and U from the factorization A = P*L*U\n    as computed by CGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from CGETRF; for 1<=i<=N, row i of the\n    matrix was interchanged with row IPIV(i).\n\\param[in] R\n         R is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed. \n    If R is accessed, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] C\n         C is REAL array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed. \n    If C is accessed, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by CGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEcomputational\n'),(414,'zgerfsx_414.txt','   ZGERFSX improves the computed solution to a system of linear\n   equations and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED, R\n   and C below. In this case, the solution and error bounds returned\n   are for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    The original N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The factors L and U from the factorization A = P*L*U\n    as computed by ZGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from ZGETRF; for 1<=i<=N, row i of the\n    matrix was interchanged with row IPIV(i).\n\\param[in] R\n         R is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  \n    If R is accessed, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.\n    If C is accessed, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by ZGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEcomputational\n'),(415,'sgbrfsx_415.txt','   SGBRFSX improves the computed solution to a system of linear\n   equations and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED, R\n   and C below. In this case, the solution and error bounds returned\n   are for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n    The original band matrix A, stored in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is DOUBLE PRECISION array, dimension (LDAFB,N)\n    Details of the LU factorization of the band matrix A, as\n    computed by DGBTRF.  U is stored as an upper triangular band\n    matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n    the multipliers used during the factorization are stored in\n    rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from SGETRF; for 1<=i<=N, row i of the\n    matrix was interchanged with row IPIV(i).\n\\param[in,out] R\n         R is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is REAL array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by SGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is REAL array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realGBcomputational\n'),(416,'dgbrfsx_416.txt','   DGBRFSX improves the computed solution to a system of linear\n   equations and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED, R\n   and C below. In this case, the solution and error bounds returned\n   are for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n    The original band matrix A, stored in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is DOUBLE PRECISION array, dimension (LDAFB,N)\n    Details of the LU factorization of the band matrix A, as\n    computed by DGBTRF.  U is stored as an upper triangular band\n    matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n    the multipliers used during the factorization are stored in\n    rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from DGETRF; for 1<=i<=N, row i of the\n    matrix was interchanged with row IPIV(i).\n\\param[in,out] R\n         R is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by DGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension (NPARAMS)\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleGBcomputational\n'),(417,'cgbrfsx_417.txt','   CGBRFSX improves the computed solution to a system of linear\n   equations and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED, R\n   and C below. In this case, the solution and error bounds returned\n   are for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n    The original band matrix A, stored in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is COMPLEX array, dimension (LDAFB,N)\n    Details of the LU factorization of the band matrix A, as\n    computed by DGBTRF.  U is stored as an upper triangular band\n    matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n    the multipliers used during the factorization are stored in\n    rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from SGETRF; for 1<=i<=N, row i of the\n    matrix was interchanged with row IPIV(i).\n\\param[in,out] R\n         R is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is REAL array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by SGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexGBcomputational\n'),(418,'zgbrfsx_418.txt','   ZGBRFSX improves the computed solution to a system of linear\n   equations and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED, R\n   and C below. In this case, the solution and error bounds returned\n   are for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate transpose = Transpose)\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'R\':  Row equilibration, i.e., A has been premultiplied by\n              diag(R).\n      = \'C\':  Column equilibration, i.e., A has been postmultiplied\n              by diag(C).\n      = \'B\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(R) * A * diag(C).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n    The original band matrix A, stored in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(ku+1+i-j,j) = A(i,j) for max(1,j-ku)<=i<=min(n,j+kl).\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is COMPLEX*16 array, dimension (LDAFB,N)\n    Details of the LU factorization of the band matrix A, as\n    computed by DGBTRF.  U is stored as an upper triangular band\n    matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and\n    the multipliers used during the factorization are stored in\n    rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL*KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from DGETRF; for 1<=i<=N, row i of the\n    matrix was interchanged with row IPIV(i).\n\\param[in,out] R\n         R is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'R\' or \'B\', A is\n    multiplied on the left by diag(R); if EQUED = \'N\' or \'C\', R\n    is not accessed.  R is an input argument if FACT = \'F\';\n    otherwise, R is an output argument.  If FACT = \'F\' and\n    EQUED = \'R\' or \'B\', each element of R must be positive.\n    If R is output, each element of R is a power of the radix.\n    If R is input, each element of R should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in,out] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The column scale factors for A.  If EQUED = \'C\' or \'B\', A is\n    multiplied on the right by diag(C); if EQUED = \'N\' or \'R\', C\n    is not accessed.  C is an input argument if FACT = \'F\';\n    otherwise, C is an output argument.  If FACT = \'F\' and\n    EQUED = \'C\' or \'B\', each element of C must be positive.\n    If C is output, each element of C is a power of the radix.\n    If C is input, each element of C should be a power of the radix\n    to ensure a reliable solution and error estimates. Scaling by\n    powers of the radix does not cause rounding errors unless the\n    result underflows or overflows. Rounding errors during scaling\n    lead to refining with a matrix that is not equivalent to the\n    input matrix, producing error estimates that may not be\n    reliable.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by DGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is COMPLEX*16 array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16GBcomputational\n'),(419,'sporfsx_419.txt','   SPORFSX improves the computed solution to a system of linear\n   equations when the coefficient matrix is symmetric positive\n   definite, and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED and S\n   below. In this case, the solution and error bounds returned are\n   for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular part\n    of the matrix A, and the strictly lower triangular part of A\n    is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n    triangular part of A contains the lower triangular part of\n    the matrix A, and the strictly upper triangular part of A is\n    not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is REAL array, dimension (LDAF,N)\n    The triangular factor U or L from the Cholesky factorization\n    A = U**T*U or A = L*L**T, as computed by SPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] S\n         S is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by SGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is REAL array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realPOcomputational\n'),(420,'dporfsx_420.txt','   DPORFSX improves the computed solution to a system of linear\n   equations when the coefficient matrix is symmetric positive\n   definite, and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED and S\n   below. In this case, the solution and error bounds returned are\n   for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular part\n    of the matrix A, and the strictly lower triangular part of A\n    is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n    triangular part of A contains the lower triangular part of\n    the matrix A, and the strictly upper triangular part of A is\n    not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n    The triangular factor U or L from the Cholesky factorization\n    A = U**T*U or A = L*L**T, as computed by DPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by DGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension (NPARAMS)\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doublePOcomputational\n'),(421,'cporfsx_421.txt','   CPORFSX improves the computed solution to a system of linear\n   equations when the coefficient matrix is symmetric positive\n   definite, and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED and S\n   below. In this case, the solution and error bounds returned are\n   for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular part\n    of the matrix A, and the strictly lower triangular part of A\n    is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n    triangular part of A contains the lower triangular part of\n    the matrix A, and the strictly upper triangular part of A is\n    not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The triangular factor U or L from the Cholesky factorization\n    A = U**T*U or A = L*L**T, as computed by SPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] S\n         S is REAL array, dimension (N)\n    The row scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by SGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexPOcomputational\n'),(422,'zporfsx_422.txt','   ZPORFSX improves the computed solution to a system of linear\n   equations when the coefficient matrix is symmetric positive\n   definite, and provides error bounds and backward error estimates\n   for the solution.  In addition to normwise error bound, the code\n   provides maximum componentwise error bound if possible.  See\n   comments for ERR_BNDS_NORM and ERR_BNDS_COMP for details of the\n   error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED and S\n   below. In this case, the solution and error bounds returned are\n   for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular part\n    of the matrix A, and the strictly lower triangular part of A\n    is not referenced.  If UPLO = \'L\', the leading N-by-N lower\n    triangular part of A contains the lower triangular part of\n    the matrix A, and the strictly upper triangular part of A is\n    not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The triangular factor U or L from the Cholesky factorization\n    A = U**T*U or A = L*L**T, as computed by DPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n    The row scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by DGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16POcomputational\n'),(423,'ssyrfsx_423.txt','   SSYRFSX improves the computed solution to a system of linear\n   equations when the coefficient matrix is symmetric indefinite, and\n   provides error bounds and backward error estimates for the\n   solution.  In addition to normwise error bound, the code provides\n   maximum componentwise error bound if possible.  See comments for\n   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED and S\n   below. In this case, the solution and error bounds returned are\n   for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is REAL array, dimension (LDAF,N)\n    The factored form of the matrix A.  AF contains the block\n    diagonal matrix D and the multipliers used to obtain the\n    factor U or L from the factorization A = U*D*U**T or A =\n    L*D*L**T as computed by SSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by SSYTRF.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in] B\n         B is REAL array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is REAL array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by SGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is REAL array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup realSYcomputational\n'),(424,'dsyrfsx_424.txt','   DSYRFSX improves the computed solution to a system of linear\n   equations when the coefficient matrix is symmetric indefinite, and\n   provides error bounds and backward error estimates for the\n   solution.  In addition to normwise error bound, the code provides\n   maximum componentwise error bound if possible.  See comments for\n   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED and S\n   below. In this case, the solution and error bounds returned are\n   for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n    The factored form of the matrix A.  AF contains the block\n    diagonal matrix D and the multipliers used to obtain the\n    factor U or L from the factorization A = U*D*U**T or A =\n    L*D*L**T as computed by DSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by DSYTRF.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in] B\n         B is DOUBLE PRECISION array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is DOUBLE PRECISION array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by DGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension (NPARAMS)\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is DOUBLE PRECISION array, dimension (4*N)\n\\param[out] IWORK\n         IWORK is INTEGER array, dimension (N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup doubleSYcomputational\n'),(425,'csyrfsx_425.txt','   CSYRFSX improves the computed solution to a system of linear\n   equations when the coefficient matrix is symmetric indefinite, and\n   provides error bounds and backward error estimates for the\n   solution.  In addition to normwise error bound, the code provides\n   maximum componentwise error bound if possible.  See comments for\n   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED and S\n   below. In this case, the solution and error bounds returned are\n   for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The factored form of the matrix A.  AF contains the block\n    diagonal matrix D and the multipliers used to obtain the\n    factor U or L from the factorization A = U*D*U**T or A =\n    L*D*L**T as computed by SSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by SSYTRF.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by SGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexSYcomputational\n'),(426,'zsyrfsx_426.txt','   ZSYRFSX improves the computed solution to a system of linear\n   equations when the coefficient matrix is symmetric indefinite, and\n   provides error bounds and backward error estimates for the\n   solution.  In addition to normwise error bound, the code provides\n   maximum componentwise error bound if possible.  See comments for\n   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED and S\n   below. In this case, the solution and error bounds returned are\n   for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The factored form of the matrix A.  AF contains the block\n    diagonal matrix D and the multipliers used to obtain the\n    factor U or L from the factorization A = U*D*U**T or A =\n    L*D*L**T as computed by DSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by DSYTRF.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by DGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16SYcomputational\n'),(427,'cherfsx_427.txt','   CHERFSX improves the computed solution to a system of linear\n   equations when the coefficient matrix is Hermitian indefinite, and\n   provides error bounds and backward error estimates for the\n   solution.  In addition to normwise error bound, the code provides\n   maximum componentwise error bound if possible.  See comments for\n   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED and S\n   below. In this case, the solution and error bounds returned are\n   for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The factored form of the matrix A.  AF contains the block\n    diagonal matrix D and the multipliers used to obtain the\n    factor U or L from the factorization A = U*D*U**T or A =\n    L*D*L**T as computed by SSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by SSYTRF.\n\\param[in,out] S\n         S is REAL array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in] B\n         B is COMPLEX array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by SGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is REAL\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is REAL array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is REAL array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * slamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * slamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * slamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is REAL array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is REAL array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complexHEcomputational\n'),(428,'zherfsx_428.txt','   ZHERFSX improves the computed solution to a system of linear\n   equations when the coefficient matrix is Hermitian indefinite, and\n   provides error bounds and backward error estimates for the\n   solution.  In addition to normwise error bound, the code provides\n   maximum componentwise error bound if possible.  See comments for\n   ERR_BNDS_NORM and ERR_BNDS_COMP for details of the error bounds.\n   The original system of linear equations may have been equilibrated\n   before calling this routine, as described by arguments EQUED and S\n   below. In this case, the solution and error bounds returned are\n   for the original unequilibrated system.\nArguments:\n    Some optional parameters are bundled in the PARAMS array.  These\n    settings determine how refinement is performed, but often the\n    defaults are acceptable.  If the defaults are acceptable, users\n    can pass NPARAMS = 0 which prevents the source code from accessing\n    the PARAMS argument.\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] EQUED\n         EQUED is CHARACTER*1\n    Specifies the form of equilibration that was done to A\n    before calling this routine. This is needed to compute\n    the solution and error bounds correctly.\n      = \'N\':  No equilibration\n      = \'Y\':  Both row and column equilibration, i.e., A has been\n              replaced by diag(S) * A * diag(S).\n              The right hand side B has been changed accordingly.\n\\param[in] N\n         N is INTEGER\n    The order of the matrix A.  N >= 0.\n\\param[in] NRHS\n         NRHS is INTEGER\n    The number of right hand sides, i.e., the number of columns\n    of the matrices B and X.  NRHS >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    The symmetric matrix A.  If UPLO = \'U\', the leading N-by-N\n    upper triangular part of A contains the upper triangular\n    part of the matrix A, and the strictly lower triangular\n    part of A is not referenced.  If UPLO = \'L\', the leading\n    N-by-N lower triangular part of A contains the lower\n    triangular part of the matrix A, and the strictly upper\n    triangular part of A is not referenced.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The factored form of the matrix A.  AF contains the block\n    diagonal matrix D and the multipliers used to obtain the\n    factor U or L from the factorization A = U*D*U**T or A =\n    L*D*L**T as computed by DSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by DSYTRF.\n\\param[in,out] S\n         S is DOUBLE PRECISION array, dimension (N)\n    The scale factors for A.  If EQUED = \'Y\', A is multiplied on\n    the left and right by diag(S).  S is an input argument if FACT =\n    \'F\'; otherwise, S is an output argument.  If FACT = \'F\' and EQUED\n    = \'Y\', each element of S must be positive.  If S is output, each\n    element of S is a power of the radix. If S is input, each element\n    of S should be a power of the radix to ensure a reliable solution\n    and error estimates. Scaling by powers of the radix does not cause\n    rounding errors unless the result underflows or overflows.\n    Rounding errors during scaling lead to refining with a matrix that\n    is not equivalent to the input matrix, producing error estimates\n    that may not be reliable.\n\\param[in] B\n         B is COMPLEX*16 array, dimension (LDB,NRHS)\n    The right hand side matrix B.\n\\param[in] LDB\n         LDB is INTEGER\n    The leading dimension of the array B.  LDB >= max(1,N).\n\\param[in,out] X\n         X is COMPLEX*16 array, dimension (LDX,NRHS)\n    On entry, the solution matrix X, as computed by DGETRS.\n    On exit, the improved solution matrix X.\n\\param[in] LDX\n         LDX is INTEGER\n    The leading dimension of the array X.  LDX >= max(1,N).\n\\param[out] RCOND\n         RCOND is DOUBLE PRECISION\n    Reciprocal scaled condition number.  This is an estimate of the\n    reciprocal Skeel condition number of the matrix A after\n    equilibration (if done).  If this is less than the machine\n    precision (in particular, if it is zero), the matrix is singular\n    to working precision.  Note that the error may still be small even\n    if this number is very small and the matrix appears ill-\n    conditioned.\n\\param[out] BERR\n         BERR is DOUBLE PRECISION array, dimension (NRHS)\n    Componentwise relative backward error.  This is the\n    componentwise relative backward error of each solution vector X(j)\n    (i.e., the smallest relative change in any element of A or B that\n    makes X(j) an exact solution).\n\\param[in] N_ERR_BNDS\n         N_ERR_BNDS is INTEGER\n    Number of error bounds to return for each right hand side\n    and each type (normwise or componentwise).  See ERR_BNDS_NORM and\n    ERR_BNDS_COMP below.\n\\param[out] ERR_BNDS_NORM\n         ERR_BNDS_NORM is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    normwise relative error, which is defined as follows:\n    Normwise relative error in the ith solution vector:\n            max_j (abs(XTRUE(j,i) - X(j,i)))\n           ------------------------------\n                 max_j abs(X(j,i))\n    The array is indexed by the type of error information as described\n    below. There currently are up to three pieces of information\n    returned.\n    The first index in ERR_BNDS_NORM(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_NORM(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated normwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*A, where S scales each row by a power of the\n             radix so all absolute row sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[out] ERR_BNDS_COMP\n         ERR_BNDS_COMP is DOUBLE PRECISION array, dimension (NRHS, N_ERR_BNDS)\n    For each right-hand side, this array contains information about\n    various error bounds and condition numbers corresponding to the\n    componentwise relative error, which is defined as follows:\n    Componentwise relative error in the ith solution vector:\n                   abs(XTRUE(j,i) - X(j,i))\n            max_j ----------------------\n                        abs(X(j,i))\n    The array is indexed by the right-hand side i (on which the\n    componentwise relative error depends), and the type of error\n    information as described below. There currently are up to three\n    pieces of information returned for each right-hand side. If\n    componentwise accuracy is not requested (PARAMS(3) = 0.0), then\n    ERR_BNDS_COMP is not accessed.  If N_ERR_BNDS .LT. 3, then at most\n    the first (:,N_ERR_BNDS) entries are returned.\n    The first index in ERR_BNDS_COMP(i,:) corresponds to the ith\n    right-hand side.\n    The second index in ERR_BNDS_COMP(:,err) contains the following\n    three fields:\n    err = 1 \"Trust/don\'t trust\" boolean. Trust the answer if the\n             reciprocal condition number is less than the threshold\n             sqrt(n) * dlamch(\'Epsilon\').\n    err = 2 \"Guaranteed\" error bound: The estimated forward error,\n             almost certainly within a factor of 10 of the true error\n             so long as the next entry is greater than the threshold\n             sqrt(n) * dlamch(\'Epsilon\'). This error bound should only\n             be trusted if the previous boolean is true.\n    err = 3  Reciprocal condition number: Estimated componentwise\n             reciprocal condition number.  Compared with the threshold\n             sqrt(n) * dlamch(\'Epsilon\') to determine if the error\n             estimate is \"guaranteed\". These reciprocal condition\n             numbers are 1 / (norm(Z^{-1},inf) * norm(Z,inf)) for some\n             appropriately scaled matrix Z.\n             Let Z = S*(A*diag(x)), where x is the solution for the\n             current right-hand side and S scales each row of\n             A*diag(x) by a power of the radix so all absolute row\n             sums of Z are approximately 1.\n    See Lapack Working Note 165 for further details and extra\n    cautions.\n\\param[in] NPARAMS\n         NPARAMS is INTEGER\n    Specifies the number of parameters set in PARAMS.  If .LE. 0, the\n    PARAMS array is never referenced and default values are used.\n\\param[in,out] PARAMS\n         PARAMS is DOUBLE PRECISION array, dimension NPARAMS\n    Specifies algorithm parameters.  If an entry is .LT. 0.0, then\n    that entry will be filled with default value used for that\n    parameter.  Only positions up to NPARAMS are accessed; defaults\n    are used for higher-numbered parameters.\n      PARAMS(LA_LINRX_ITREF_I = 1) : Whether to perform iterative\n           refinement or not.\n        Default: 1.0D+0\n           = 0.0 : No refinement is performed, and no error bounds are\n                   computed.\n           = 1.0 : Use the double-precision refinement algorithm,\n                   possibly with doubled-single computations if the\n                   compilation environment does not support DOUBLE\n                   PRECISION.\n             (other values are reserved for future use)\n      PARAMS(LA_LINRX_ITHRESH_I = 2) : Maximum number of residual\n           computations allowed for refinement.\n        Default: 10\n        Aggressive: Set to 100 to permit convergence using approximate\n                    factorizations or factorizations other than LU. If\n                    the factorization uses a technique other than\n                    Gaussian elimination, the guarantees in\n                    err_bnds_norm and err_bnds_comp may no longer be\n                    trustworthy.\n      PARAMS(LA_LINRX_CWISE_I = 3) : Flag determining if the code\n           will attempt to find a solution with small componentwise\n           relative error in the double-precision algorithm.  Positive\n           is true, 0.0 is false.\n        Default: 1.0 (attempt componentwise convergence)\n\\param[out] WORK\n         WORK is COMPLEX*16 array, dimension (2*N)\n\\param[out] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (2*N)\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit. The solution to every right-hand side is\n        guaranteed.\n      < 0:  If INFO = -i, the i-th argument had an illegal value\n      > 0 and <= N:  U(INFO,INFO) is exactly zero.  The factorization\n        has been completed, but the factor U is exactly singular, so\n        the solution and error bounds could not be computed. RCOND = 0\n        is returned.\n      = N+J: The solution corresponding to the Jth right-hand side is\n        not guaranteed. The solutions corresponding to other right-\n        hand sides K with K > J may not be guaranteed as well, but\n        only the first such right-hand side is reported. If a small\n        componentwise error is not requested (PARAMS(3) = 0.0) then\n        the Jth right-hand side is the first with a normwise error\n        bound that is not guaranteed (the smallest J such\n        that ERR_BNDS_NORM(J,1) = 0.0). By default (PARAMS(3) = 1.0)\n        the Jth right-hand side is the first with either a normwise or\n        componentwise error bound that is not guaranteed (the smallest\n        J such that either ERR_BNDS_NORM(J,1) = 0.0 or\n        ERR_BNDS_COMP(J,1) = 0.0). See the definition of\n        ERR_BNDS_NORM(:,1) and ERR_BNDS_COMP(:,1). To get information\n        about all of the right-hand sides check ERR_BNDS_NORM or\n        ERR_BNDS_COMP.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date April 2012\n\\ingroup complex16HEcomputational\n'),(429,'cla_gercond_c_429.txt','\n   CLA_GERCOND_C computes the infinity norm condition number of\n   op(A) * inv(diag(C)) where C is a REAL vector.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    On entry, the N-by-N matrix A\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The factors L and U from the factorization\n    A = P*L*U as computed by CGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by CGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] C\n         C is REAL array, dimension (N)\n    The vector C in the formula op(A) * inv(diag(C)).\n\\param[in] CAPPLY\n         CAPPLY is LOGICAL\n    If .TRUE. then access the vector C in the formula above.\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is REAL array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEcomputational\n'),(430,'zla_gercond_c_430.txt','   ZLA_GERCOND_C computes the infinity norm condition number of\n   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    On entry, the N-by-N matrix A\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The factors L and U from the factorization\n    A = P*L*U as computed by ZGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by ZGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The vector C in the formula op(A) * inv(diag(C)).\n\\param[in] CAPPLY\n         CAPPLY is LOGICAL\n    If .TRUE. then access the vector C in the formula above.\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX*16 array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEcomputational\n'),(431,'cla_gbrcond_c_431.txt','   CLA_GBRCOND_C Computes the infinity norm condition number of\n   op(A) * inv(diag(C)) where C is a REAL vector.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n    On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is COMPLEX array, dimension (LDAFB,N)\n    Details of the LU factorization of the band matrix A, as\n    computed by CGBTRF.  U is stored as an upper triangular\n    band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n    and the multipliers used during the factorization are stored\n    in rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by CGBTRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] C\n         C is REAL array, dimension (N)\n    The vector C in the formula op(A) * inv(diag(C)).\n\\param[in] CAPPLY\n         CAPPLY is LOGICAL\n    If .TRUE. then access the vector C in the formula above.\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is REAL array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGBcomputational\n'),(432,'zla_gbrcond_c_432.txt','   ZLA_GBRCOND_C Computes the infinity norm condition number of\n   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n    On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is COMPLEX*16 array, dimension (LDAFB,N)\n    Details of the LU factorization of the band matrix A, as\n    computed by ZGBTRF.  U is stored as an upper triangular\n    band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n    and the multipliers used during the factorization are stored\n    in rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by ZGBTRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The vector C in the formula op(A) * inv(diag(C)).\n\\param[in] CAPPLY\n         CAPPLY is LOGICAL\n    If .TRUE. then access the vector C in the formula above.\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX*16 array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GBcomputational\n'),(433,'cla_porcond_c_433.txt','   CLA_PORCOND_C Computes the infinity norm condition number of\n   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    On entry, the N-by-N matrix A\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The triangular factor U or L from the Cholesky factorization\n    A = U**H*U or A = L*L**H, as computed by CPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] C\n         C is REAL array, dimension (N)\n    The vector C in the formula op(A) * inv(diag(C)).\n\\param[in] CAPPLY\n         CAPPLY is LOGICAL\n    If .TRUE. then access the vector C in the formula above.\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is REAL array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexPOcomputational\n'),(434,'zla_porcond_c_434.txt','   ZLA_PORCOND_C Computes the infinity norm condition number of\n   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    On entry, the N-by-N matrix A\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The triangular factor U or L from the Cholesky factorization\n    A = U**H*U or A = L*L**H, as computed by ZPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The vector C in the formula op(A) * inv(diag(C)).\n\\param[in] CAPPLY\n         CAPPLY is LOGICAL\n    If .TRUE. then access the vector C in the formula above.\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX*16 array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POcomputational\n'),(435,'cla_syrcond_c_435.txt','   CLA_SYRCOND_C Computes the infinity norm condition number of\n   op(A) * inv(diag(C)) where C is a REAL vector.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    On entry, the N-by-N matrix A\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The block diagonal matrix D and the multipliers used to\n    obtain the factor U or L as computed by CSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by CSYTRF.\n\\param[in] C\n         C is REAL array, dimension (N)\n    The vector C in the formula op(A) * inv(diag(C)).\n\\param[in] CAPPLY\n         CAPPLY is LOGICAL\n    If .TRUE. then access the vector C in the formula above.\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is REAL array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n'),(436,'zla_syrcond_c_436.txt','   ZLA_SYRCOND_C Computes the infinity norm condition number of\n   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    On entry, the N-by-N matrix A\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The block diagonal matrix D and the multipliers used to\n    obtain the factor U or L as computed by ZSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by ZSYTRF.\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The vector C in the formula op(A) * inv(diag(C)).\n\\param[in] CAPPLY\n         CAPPLY is LOGICAL\n    If .TRUE. then access the vector C in the formula above.\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX*16 array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n'),(437,'cla_hercond_c_437.txt','   CLA_HERCOND_C computes the infinity norm condition number of\n   op(A) * inv(diag(C)) where C is a REAL vector.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    On entry, the N-by-N matrix A\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The block diagonal matrix D and the multipliers used to\n    obtain the factor U or L as computed by CHETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by CHETRF.\n\\param[in] C\n         C is REAL array, dimension (N)\n    The vector C in the formula op(A) * inv(diag(C)).\n\\param[in] CAPPLY\n         CAPPLY is LOGICAL\n    If .TRUE. then access the vector C in the formula above.\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is REAL array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEcomputational\n'),(438,'zla_hercond_c_438.txt','   ZLA_HERCOND_C computes the infinity norm condition number of\n   op(A) * inv(diag(C)) where C is a DOUBLE PRECISION vector.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    On entry, the N-by-N matrix A\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The block diagonal matrix D and the multipliers used to\n    obtain the factor U or L as computed by ZHETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by CHETRF.\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The vector C in the formula op(A) * inv(diag(C)).\n\\param[in] CAPPLY\n         CAPPLY is LOGICAL\n    If .TRUE. then access the vector C in the formula above.\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX*16 array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEcomputational\n'),(439,'cla_gercond_x_439.txt','\n   CLA_GERCOND_X computes the infinity norm condition number of\n   op(A) * diag(X) where X is a COMPLEX vector.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The factors L and U from the factorization\n    A = P*L*U as computed by CGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by CGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] X\n         X is COMPLEX array, dimension (N)\n    The vector X in the formula op(A) * diag(X).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is REAL array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGEcomputational\n'),(440,'zla_gercond_x_440.txt','   ZLA_GERCOND_X computes the infinity norm condition number of\n   op(A) * diag(X) where X is a COMPLEX*16 vector.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The factors L and U from the factorization\n    A = P*L*U as computed by ZGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by ZGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] X\n         X is COMPLEX*16 array, dimension (N)\n    The vector X in the formula op(A) * diag(X).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX*16 array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GEcomputational\n'),(441,'cla_gbrcond_x_441.txt','   CLA_GBRCOND_X Computes the infinity norm condition number of\n   op(A) * diag(X) where X is a COMPLEX vector.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is COMPLEX array, dimension (LDAB,N)\n    On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is COMPLEX array, dimension (LDAFB,N)\n    Details of the LU factorization of the band matrix A, as\n    computed by CGBTRF.  U is stored as an upper triangular\n    band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n    and the multipliers used during the factorization are stored\n    in rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by CGBTRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] X\n         X is COMPLEX array, dimension (N)\n    The vector X in the formula op(A) * diag(X).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is REAL array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexGBcomputational\n'),(442,'zla_gbrcond_x_442.txt','   ZLA_GBRCOND_X Computes the infinity norm condition number of\n   op(A) * diag(X) where X is a COMPLEX*16 vector.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is COMPLEX*16 array, dimension (LDAB,N)\n    On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is COMPLEX*16 array, dimension (LDAFB,N)\n    Details of the LU factorization of the band matrix A, as\n    computed by ZGBTRF.  U is stored as an upper triangular\n    band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n    and the multipliers used during the factorization are stored\n    in rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by ZGBTRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] X\n         X is COMPLEX*16 array, dimension (N)\n    The vector X in the formula op(A) * diag(X).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX*16 array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16GBcomputational\n'),(443,'cla_porcond_x_443.txt','   CLA_PORCOND_X Computes the infinity norm condition number of\n   op(A) * diag(X) where X is a COMPLEX vector.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The triangular factor U or L from the Cholesky factorization\n    A = U**H*U or A = L*L**H, as computed by CPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] X\n         X is COMPLEX array, dimension (N)\n    The vector X in the formula op(A) * diag(X).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is REAL array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexPOcomputational\n'),(444,'zla_porcond_x_444.txt','   ZLA_PORCOND_X Computes the infinity norm condition number of\n   op(A) * diag(X) where X is a COMPLEX*16 vector.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The triangular factor U or L from the Cholesky factorization\n    A = U**H*U or A = L*L**H, as computed by ZPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] X\n         X is COMPLEX*16 array, dimension (N)\n    The vector X in the formula op(A) * diag(X).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX*16 array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16POcomputational\n'),(445,'cla_syrcond_x_445.txt','   CLA_SYRCOND_X Computes the infinity norm condition number of\n   op(A) * diag(X) where X is a COMPLEX vector.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The block diagonal matrix D and the multipliers used to\n    obtain the factor U or L as computed by CSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by CSYTRF.\n\\param[in] X\n         X is COMPLEX array, dimension (N)\n    The vector X in the formula op(A) * diag(X).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is REAL array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexSYcomputational\n'),(446,'zla_syrcond_x_446.txt','   ZLA_SYRCOND_X Computes the infinity norm condition number of\n   op(A) * diag(X) where X is a COMPLEX*16 vector.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The block diagonal matrix D and the multipliers used to\n    obtain the factor U or L as computed by ZSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by ZSYTRF.\n\\param[in] X\n         X is COMPLEX*16 array, dimension (N)\n    The vector X in the formula op(A) * diag(X).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX*16 array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16SYcomputational\n'),(447,'cla_hercond_x_447.txt','   CLA_HERCOND_X computes the infinity norm condition number of\n   op(A) * diag(X) where X is a COMPLEX vector.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX array, dimension (LDAF,N)\n    The block diagonal matrix D and the multipliers used to\n    obtain the factor U or L as computed by CHETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by CHETRF.\n\\param[in] X\n         X is COMPLEX array, dimension (N)\n    The vector X in the formula op(A) * diag(X).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is REAL array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complexHEcomputational\n'),(448,'zla_hercond_x_448.txt','   ZLA_HERCOND_X computes the infinity norm condition number of\n   op(A) * diag(X) where X is a COMPLEX*16 vector.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is COMPLEX*16 array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is COMPLEX*16 array, dimension (LDAF,N)\n    The block diagonal matrix D and the multipliers used to\n    obtain the factor U or L as computed by ZHETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by CHETRF.\n\\param[in] X\n         X is COMPLEX*16 array, dimension (N)\n    The vector X in the formula op(A) * diag(X).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is COMPLEX*16 array, dimension (2*N).\n    Workspace.\n\\param[in] RWORK\n         RWORK is DOUBLE PRECISION array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup complex16HEcomputational\n'),(449,'sla_gercond_449.txt','   SLA_GERCOND estimates the Skeel condition number of op(A) * op2(C)\n   where op2 is determined by CMODE as follows\n   CMODE =  1    op2(C) = C\n   CMODE =  0    op2(C) = I\n   CMODE = -1    op2(C) = inv(C)\n   The Skeel condition number cond(A) = norminf( |inv(A)||A| )\n   is computed by computing scaling factors R such that\n   diag(R)*A*op2(C) is row equilibrated and computing the standard\n   infinity-norm condition number.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is REAL array, dimension (LDAF,N)\n    The factors L and U from the factorization\n    A = P*L*U as computed by SGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by SGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] CMODE\n         CMODE is INTEGER\n    Determines op2(C) in the formula op(A) * op2(C) as follows:\n    CMODE =  1    op2(C) = C\n    CMODE =  0    op2(C) = I\n    CMODE = -1    op2(C) = inv(C)\n\\param[in] C\n         C is REAL array, dimension (N)\n    The vector C in the formula op(A) * op2(C).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is REAL array, dimension (3*N).\n    Workspace.\n\\param[in] IWORK\n         IWORK is INTEGER array, dimension (N).\n    Workspace.2\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGEcomputational\n'),(450,'dla_gercond_450.txt','   DLA_GERCOND estimates the Skeel condition number of op(A) * op2(C)\n   where op2 is determined by CMODE as follows\n   CMODE =  1    op2(C) = C\n   CMODE =  0    op2(C) = I\n   CMODE = -1    op2(C) = inv(C)\n   The Skeel condition number cond(A) = norminf( |inv(A)||A| )\n   is computed by computing scaling factors R such that\n   diag(R)*A*op2(C) is row equilibrated and computing the standard\n   infinity-norm condition number.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n    The factors L and U from the factorization\n    A = P*L*U as computed by DGETRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by DGETRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] CMODE\n         CMODE is INTEGER\n    Determines op2(C) in the formula op(A) * op2(C) as follows:\n    CMODE =  1    op2(C) = C\n    CMODE =  0    op2(C) = I\n    CMODE = -1    op2(C) = inv(C)\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The vector C in the formula op(A) * op2(C).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N).\n    Workspace.\n\\param[in] IWORK\n         IWORK is INTEGER array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGEcomputational\n'),(451,'sla_gbrcond_451.txt','   SLA_GBRCOND Estimates the Skeel condition number of  op(A) * op2(C)\n   where op2 is determined by CMODE as follows\n   CMODE =  1    op2(C) = C\n   CMODE =  0    op2(C) = I\n   CMODE = -1    op2(C) = inv(C)\n   The Skeel condition number  cond(A) = norminf( |inv(A)||A| )\n   is computed by computing scaling factors R such that\n   diag(R)*A*op2(C) is row equilibrated and computing the standard\n   infinity-norm condition number.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is REAL array, dimension (LDAB,N)\n    On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is REAL array, dimension (LDAFB,N)\n    Details of the LU factorization of the band matrix A, as\n    computed by SGBTRF.  U is stored as an upper triangular\n    band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n    and the multipliers used during the factorization are stored\n    in rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by SGBTRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] CMODE\n         CMODE is INTEGER\n    Determines op2(C) in the formula op(A) * op2(C) as follows:\n    CMODE =  1    op2(C) = C\n    CMODE =  0    op2(C) = I\n    CMODE = -1    op2(C) = inv(C)\n\\param[in] C\n         C is REAL array, dimension (N)\n    The vector C in the formula op(A) * op2(C).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is REAL array, dimension (5*N).\n    Workspace.\n\\param[in] IWORK\n         IWORK is INTEGER array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realGBcomputational\n'),(452,'dla_gbrcond_452.txt','   DLA_GBRCOND Estimates the Skeel condition number of  op(A) * op2(C)\n   where op2 is determined by CMODE as follows\n   CMODE =  1    op2(C) = C\n   CMODE =  0    op2(C) = I\n   CMODE = -1    op2(C) = inv(C)\n   The Skeel condition number  cond(A) = norminf( |inv(A)||A| )\n   is computed by computing scaling factors R such that\n   diag(R)*A*op2(C) is row equilibrated and computing the standard\n   infinity-norm condition number.\nArguments:\n\\param[in] TRANS\n         TRANS is CHARACTER*1\n    Specifies the form of the system of equations:\n      = \'N\':  A * X = B     (No transpose)\n      = \'T\':  A**T * X = B  (Transpose)\n      = \'C\':  A**H * X = B  (Conjugate Transpose = Transpose)\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] KL\n         KL is INTEGER\n    The number of subdiagonals within the band of A.  KL >= 0.\n\\param[in] KU\n         KU is INTEGER\n    The number of superdiagonals within the band of A.  KU >= 0.\n\\param[in] AB\n         AB is DOUBLE PRECISION array, dimension (LDAB,N)\n    On entry, the matrix A in band storage, in rows 1 to KL+KU+1.\n    The j-th column of A is stored in the j-th column of the\n    array AB as follows:\n    AB(KU+1+i-j,j) = A(i,j) for max(1,j-KU)<=i<=min(N,j+kl)\n\\param[in] LDAB\n         LDAB is INTEGER\n    The leading dimension of the array AB.  LDAB >= KL+KU+1.\n\\param[in] AFB\n         AFB is DOUBLE PRECISION array, dimension (LDAFB,N)\n    Details of the LU factorization of the band matrix A, as\n    computed by DGBTRF.  U is stored as an upper triangular\n    band matrix with KL+KU superdiagonals in rows 1 to KL+KU+1,\n    and the multipliers used during the factorization are stored\n    in rows KL+KU+2 to 2*KL+KU+1.\n\\param[in] LDAFB\n         LDAFB is INTEGER\n    The leading dimension of the array AFB.  LDAFB >= 2*KL+KU+1.\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    The pivot indices from the factorization A = P*L*U\n    as computed by DGBTRF; row i of the matrix was interchanged\n    with row IPIV(i).\n\\param[in] CMODE\n         CMODE is INTEGER\n    Determines op2(C) in the formula op(A) * op2(C) as follows:\n    CMODE =  1    op2(C) = C\n    CMODE =  0    op2(C) = I\n    CMODE = -1    op2(C) = inv(C)\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The vector C in the formula op(A) * op2(C).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is DOUBLE PRECISION array, dimension (5*N).\n    Workspace.\n\\param[in] IWORK\n         IWORK is INTEGER array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleGBcomputational\n'),(453,'sla_porcond_453.txt','   SLA_PORCOND Estimates the Skeel condition number of  op(A) * op2(C)\n   where op2 is determined by CMODE as follows\n   CMODE =  1    op2(C) = C\n   CMODE =  0    op2(C) = I\n   CMODE = -1    op2(C) = inv(C)\n   The Skeel condition number  cond(A) = norminf( |inv(A)||A| )\n   is computed by computing scaling factors R such that\n   diag(R)*A*op2(C) is row equilibrated and computing the standard\n   infinity-norm condition number.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is REAL array, dimension (LDAF,N)\n    The triangular factor U or L from the Cholesky factorization\n    A = U**T*U or A = L*L**T, as computed by SPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] CMODE\n         CMODE is INTEGER\n    Determines op2(C) in the formula op(A) * op2(C) as follows:\n    CMODE =  1    op2(C) = C\n    CMODE =  0    op2(C) = I\n    CMODE = -1    op2(C) = inv(C)\n\\param[in] C\n         C is REAL array, dimension (N)\n    The vector C in the formula op(A) * op2(C).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is REAL array, dimension (3*N).\n    Workspace.\n\\param[in] IWORK\n         IWORK is INTEGER array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realPOcomputational\n'),(454,'dla_porcond_454.txt','   DLA_PORCOND Estimates the Skeel condition number of  op(A) * op2(C)\n   where op2 is determined by CMODE as follows\n   CMODE =  1    op2(C) = C\n   CMODE =  0    op2(C) = I\n   CMODE = -1    op2(C) = inv(C)\n   The Skeel condition number  cond(A) = norminf( |inv(A)||A| )\n   is computed by computing scaling factors R such that\n   diag(R)*A*op2(C) is row equilibrated and computing the standard\n   infinity-norm condition number.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n    The triangular factor U or L from the Cholesky factorization\n    A = U**T*U or A = L*L**T, as computed by DPOTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] CMODE\n         CMODE is INTEGER\n    Determines op2(C) in the formula op(A) * op2(C) as follows:\n    CMODE =  1    op2(C) = C\n    CMODE =  0    op2(C) = I\n    CMODE = -1    op2(C) = inv(C)\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The vector C in the formula op(A) * op2(C).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N).\n    Workspace.\n\\param[in] IWORK\n         IWORK is INTEGER array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doublePOcomputational\n'),(455,'sla_syrcond_455.txt','   SLA_SYRCOND estimates the Skeel condition number of  op(A) * op2(C)\n   where op2 is determined by CMODE as follows\n   CMODE =  1    op2(C) = C\n   CMODE =  0    op2(C) = I\n   CMODE = -1    op2(C) = inv(C)\n   The Skeel condition number cond(A) = norminf( |inv(A)||A| )\n   is computed by computing scaling factors R such that\n   diag(R)*A*op2(C) is row equilibrated and computing the standard\n   infinity-norm condition number.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is REAL array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is REAL array, dimension (LDAF,N)\n    The block diagonal matrix D and the multipliers used to\n    obtain the factor U or L as computed by SSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by SSYTRF.\n\\param[in] CMODE\n         CMODE is INTEGER\n    Determines op2(C) in the formula op(A) * op2(C) as follows:\n    CMODE =  1    op2(C) = C\n    CMODE =  0    op2(C) = I\n    CMODE = -1    op2(C) = inv(C)\n\\param[in] C\n         C is REAL array, dimension (N)\n    The vector C in the formula op(A) * op2(C).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is REAL array, dimension (3*N).\n    Workspace.\n\\param[in] IWORK\n         IWORK is INTEGER array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup realSYcomputational\n'),(456,'dla_syrcond_456.txt','   DLA_SYRCOND estimates the Skeel condition number of  op(A) * op2(C)\n   where op2 is determined by CMODE as follows\n   CMODE =  1    op2(C) = C\n   CMODE =  0    op2(C) = I\n   CMODE = -1    op2(C) = inv(C)\n   The Skeel condition number cond(A) = norminf( |inv(A)||A| )\n   is computed by computing scaling factors R such that\n   diag(R)*A*op2(C) is row equilibrated and computing the standard\n   infinity-norm condition number.\nArguments:\n\\param[in] UPLO\n         UPLO is CHARACTER*1\n      = \'U\':  Upper triangle of A is stored;\n      = \'L\':  Lower triangle of A is stored.\n\\param[in] N\n         N is INTEGER\n    The number of linear equations, i.e., the order of the\n    matrix A.  N >= 0.\n\\param[in] A\n         A is DOUBLE PRECISION array, dimension (LDA,N)\n    On entry, the N-by-N matrix A.\n\\param[in] LDA\n         LDA is INTEGER\n    The leading dimension of the array A.  LDA >= max(1,N).\n\\param[in] AF\n         AF is DOUBLE PRECISION array, dimension (LDAF,N)\n    The block diagonal matrix D and the multipliers used to\n    obtain the factor U or L as computed by DSYTRF.\n\\param[in] LDAF\n         LDAF is INTEGER\n    The leading dimension of the array AF.  LDAF >= max(1,N).\n\\param[in] IPIV\n         IPIV is INTEGER array, dimension (N)\n    Details of the interchanges and the block structure of D\n    as determined by DSYTRF.\n\\param[in] CMODE\n         CMODE is INTEGER\n    Determines op2(C) in the formula op(A) * op2(C) as follows:\n    CMODE =  1    op2(C) = C\n    CMODE =  0    op2(C) = I\n    CMODE = -1    op2(C) = inv(C)\n\\param[in] C\n         C is DOUBLE PRECISION array, dimension (N)\n    The vector C in the formula op(A) * op2(C).\n\\param[out] INFO\n         INFO is INTEGER\n      = 0:  Successful exit.\n    i > 0:  The ith argument is invalid.\n\\param[in] WORK\n         WORK is DOUBLE PRECISION array, dimension (3*N).\n    Workspace.\n\\param[in] IWORK\n         IWORK is INTEGER array, dimension (N).\n    Workspace.\nAuthors:\n\\author Univ. of Tennessee \n\\author Univ. of California Berkeley \n\\author Univ. of Colorado Denver \n\\author NAG Ltd. \n\\date November 2011\n\\ingroup doubleSYcomputational\n');
/*!40000 ALTER TABLE `Driver_routineinfo` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_group`
--

DROP TABLE IF EXISTS `auth_group`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_group` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(80) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `name` (`name`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_group`
--

LOCK TABLES `auth_group` WRITE;
/*!40000 ALTER TABLE `auth_group` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_group_permissions`
--

DROP TABLE IF EXISTS `auth_group_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_group_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `group_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `group_id` (`group_id`,`permission_id`),
  KEY `auth_group_permissions_425ae3c4` (`group_id`),
  KEY `auth_group_permissions_1e014c8f` (`permission_id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_group_permissions`
--

LOCK TABLES `auth_group_permissions` WRITE;
/*!40000 ALTER TABLE `auth_group_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_group_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_permission`
--

DROP TABLE IF EXISTS `auth_permission`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_permission` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(50) NOT NULL,
  `content_type_id` int(11) NOT NULL,
  `codename` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `content_type_id` (`content_type_id`,`codename`),
  KEY `auth_permission_1bb8f392` (`content_type_id`)
) ENGINE=MyISAM AUTO_INCREMENT=58 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_permission`
--

LOCK TABLES `auth_permission` WRITE;
/*!40000 ALTER TABLE `auth_permission` DISABLE KEYS */;
INSERT INTO `auth_permission` VALUES (1,'Can add permission',1,'add_permission'),(2,'Can change permission',1,'change_permission'),(3,'Can delete permission',1,'delete_permission'),(4,'Can add group',2,'add_group'),(5,'Can change group',2,'change_group'),(6,'Can delete group',2,'delete_group'),(7,'Can add user',3,'add_user'),(8,'Can change user',3,'change_user'),(9,'Can delete user',3,'delete_user'),(10,'Can add content type',4,'add_contenttype'),(11,'Can change content type',4,'change_contenttype'),(12,'Can delete content type',4,'delete_contenttype'),(13,'Can add session',5,'add_session'),(14,'Can change session',5,'change_session'),(15,'Can delete session',5,'delete_session'),(16,'Can add log entry',6,'add_logentry'),(17,'Can change log entry',6,'change_logentry'),(18,'Can delete log entry',6,'delete_logentry'),(19,'Can add routine info',7,'add_routineinfo'),(20,'Can change routine info',7,'change_routineinfo'),(21,'Can delete routine info',7,'delete_routineinfo'),(22,'Can add linear equation_driver',8,'add_linearequation_driver'),(23,'Can change linear equation_driver',8,'change_linearequation_driver'),(24,'Can delete linear equation_driver',8,'delete_linearequation_driver'),(25,'Can add linear equation_simple',9,'add_linearequation_simple'),(26,'Can change linear equation_simple',9,'change_linearequation_simple'),(27,'Can delete linear equation_simple',9,'delete_linearequation_simple'),(28,'Can add linear equation_expert',10,'add_linearequation_expert'),(29,'Can change linear equation_expert',10,'change_linearequation_expert'),(30,'Can delete linear equation_expert',10,'delete_linearequation_expert'),(31,'Can add linear equation_computational',11,'add_linearequation_computational'),(32,'Can change linear equation_computational',11,'change_linearequation_computational'),(33,'Can delete linear equation_computational',11,'delete_linearequation_computational'),(34,'Can add linear equation_factor',12,'add_linearequation_factor'),(35,'Can change linear equation_factor',12,'change_linearequation_factor'),(36,'Can delete linear equation_factor',12,'delete_linearequation_factor'),(37,'Can add linear equation_solve',13,'add_linearequation_solve'),(38,'Can change linear equation_solve',13,'change_linearequation_solve'),(39,'Can delete linear equation_solve',13,'delete_linearequation_solve'),(40,'Can add linear equation_condition_number',14,'add_linearequation_condition_number'),(41,'Can change linear equation_condition_number',14,'change_linearequation_condition_number'),(42,'Can delete linear equation_condition_number',14,'delete_linearequation_condition_number'),(43,'Can add linear equation_error_bound',15,'add_linearequation_error_bound'),(44,'Can change linear equation_error_bound',15,'change_linearequation_error_bound'),(45,'Can delete linear equation_error_bound',15,'delete_linearequation_error_bound'),(46,'Can add linear equation_invert',16,'add_linearequation_invert'),(47,'Can change linear equation_invert',16,'change_linearequation_invert'),(48,'Can delete linear equation_invert',16,'delete_linearequation_invert'),(49,'Can add linear equation_equilibrate',17,'add_linearequation_equilibrate'),(50,'Can change linear equation_equilibrate',17,'change_linearequation_equilibrate'),(51,'Can delete linear equation_equilibrate',17,'delete_linearequation_equilibrate'),(52,'Can add linear equation_only',18,'add_linearequation_only'),(53,'Can change linear equation_only',18,'change_linearequation_only'),(54,'Can delete linear equation_only',18,'delete_linearequation_only'),(55,'Can add registration profile',19,'add_registrationprofile'),(56,'Can change registration profile',19,'change_registrationprofile'),(57,'Can delete registration profile',19,'delete_registrationprofile');
/*!40000 ALTER TABLE `auth_permission` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_user`
--

DROP TABLE IF EXISTS `auth_user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(75) NOT NULL,
  `first_name` varchar(30) NOT NULL,
  `last_name` varchar(30) NOT NULL,
  `email` varchar(75) NOT NULL,
  `password` varchar(128) NOT NULL,
  `is_staff` tinyint(1) NOT NULL,
  `is_active` tinyint(1) NOT NULL,
  `is_superuser` tinyint(1) NOT NULL,
  `last_login` datetime NOT NULL,
  `date_joined` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `username` (`username`)
) ENGINE=MyISAM AUTO_INCREMENT=33 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_user`
--

LOCK TABLES `auth_user` WRITE;
/*!40000 ALTER TABLE `auth_user` DISABLE KEYS */;
INSERT INTO `auth_user` VALUES (1,'salin','','','salin@mcs.anl.gov','pbkdf2_sha256$10000$Ny3oQOOvTwsx$O84sQwbAoKWrFG74H19lt/fbnrWOA9AaZ1RnX/iKp1I=',1,1,1,'2012-09-21 14:52:40','2012-09-06 14:18:25'),(32,'sasa1688@gmail.com','','','sasa1688@gmail.com','pbkdf2_sha256$10000$IqqcSL8k9Kvg$vEJgzdMd8GTVcGPpSeYLH4hitzZ/lqE4vaUS5tYHhX4=',0,1,0,'2012-09-20 17:13:06','2012-09-20 17:13:06');
/*!40000 ALTER TABLE `auth_user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_user_groups`
--

DROP TABLE IF EXISTS `auth_user_groups`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_user_groups` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `group_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_id` (`user_id`,`group_id`),
  KEY `auth_user_groups_403f60f` (`user_id`),
  KEY `auth_user_groups_425ae3c4` (`group_id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_user_groups`
--

LOCK TABLES `auth_user_groups` WRITE;
/*!40000 ALTER TABLE `auth_user_groups` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user_groups` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `auth_user_user_permissions`
--

DROP TABLE IF EXISTS `auth_user_user_permissions`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `auth_user_user_permissions` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `permission_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_id` (`user_id`,`permission_id`),
  KEY `auth_user_user_permissions_403f60f` (`user_id`),
  KEY `auth_user_user_permissions_1e014c8f` (`permission_id`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `auth_user_user_permissions`
--

LOCK TABLES `auth_user_user_permissions` WRITE;
/*!40000 ALTER TABLE `auth_user_user_permissions` DISABLE KEYS */;
/*!40000 ALTER TABLE `auth_user_user_permissions` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `combine_linearequation_only`
--

DROP TABLE IF EXISTS `combine_linearequation_only`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `combine_linearequation_only` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Combine_linearequation_only_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=165 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `combine_linearequation_only`
--

LOCK TABLES `combine_linearequation_only` WRITE;
/*!40000 ALTER TABLE `combine_linearequation_only` DISABLE KEYS */;
INSERT INTO `combine_linearequation_only` VALUES (1,'s','gesv','general','full','Doxygen/docs/html/sgesv_8f.html','driver simple; solve A*X = B only',1),(2,'d','gesv','general','full','Doxygen/docs/html/dgesv_8f.html','driver simple; solve A*X = B only',2),(3,'c','gesv','general','full','Doxygen/docs/html/cgesv_8f.html','driver simple; solve A*X = B only',3),(4,'z','gesv','general','full','Doxygen/docs/html/zgesv_8f.html','driver simple; solve A*X = B only',4),(5,'s','gbsv','general','band','Doxygen/docs/html/sgbsv_8f.html','driver simple; solve A*X = B only',5),(6,'d','gbsv','general','band','Doxygen/docs/html/dgbsv_8f.html','driver simple; solve A*X = B only',6),(7,'c','gbsv','general','band','Doxygen/docs/html/cgbsv_8f.html','driver simple; solve A*X = B only',7),(8,'z','gbsv','general','band','Doxygen/docs/html/zgbsv_8f.html','driver simple; solve A*X = B only',8),(9,'s','gtsv','general','tridiagonal','Doxygen/docs/html/sgtsv_8f.html','driver simple; solve A*X = B only; Transpose',9),(10,'d','gtsv','general','tridiagonal','Doxygen/docs/html/dgtsv_8f.html','driver simple; solve A*X = B only; Transpose',10),(11,'c','gtsv','general','tridiagonal','Doxygen/docs/html/cgtsv_8f.html','driver simple; solve A*X = B only; Transpose',11),(12,'z','gtsv','general','tridiagonal','Doxygen/docs/html/zgtsv_8f.html','driver simple; solve A*X = B only; Transpose',12),(13,'c','hesv','Hermitian','full','Doxygen/docs/html/chesv_8f.html','driver simple; solve A*X = B only',13),(14,'z','hesv','Hermitian','full','Doxygen/docs/html/zhesv_8f.html','driver simple; solve A*X = B only',14),(15,'c','hpsv','Hermitian','packed','Doxygen/docs/html/chpsv_8f.html','driver simple; solve A*X = B only',15),(16,'z','hpsv','Hermitian','packed','Doxygen/docs/html/zhpsv_8f.html','driver simple; solve A*X = B only',16),(17,'s','posv','SPD','full','Doxygen/docs/html/sposv_8f.html','driver simple; solve A*X = B only',17),(18,'d','posv','SPD','full','Doxygen/docs/html/dposv_8f.html','driver simple; solve A*X = B only',18),(19,'c','posv','HPD','full','Doxygen/docs/html/cposv_8f.html','driver simple; solve A*X = B only',19),(20,'z','posv','HPD','full','Doxygen/docs/html/zposv_8f.html','driver simple; solve A*X = B only',20),(21,'s','pbsv','SPD','band','Doxygen/docs/html/spbsv_8f.html','driver simple; solve A*X = B only',21),(22,'d','pbsv','SPD','band','Doxygen/docs/html/dpbsv_8f.html','driver simple; solve A*X = B only',22),(23,'c','pbsv','HPD','band','Doxygen/docs/html/cpbsv_8f.html','driver simple; solve A*X = B only',23),(24,'z','pbsv','HPD','band','Doxygen/docs/html/zpbsv_8f.html','driver simple; solve A*X = B only',24),(25,'s','ppsv','SPD','packed','Doxygen/docs/html/sppsv_8f.html','driver simple; solve A*X = B only',25),(26,'d','ppsv','SPD','packed','Doxygen/docs/html/dppsv_8f.html','driver simple; solve A*X = B only',26),(27,'c','ppsv','HPD','packed','Doxygen/docs/html/cppsv_8f.html','driver simple; solve A*X = B only',27),(28,'z','ppsv','HPD','packed','Doxygen/docs/html/zppsv_8f.html','driver simple; solve A*X = B only',28),(29,'s','ptsv','SPD','tridiagonal','Doxygen/docs/html/sptsv_8f.html','driver simple; solve A*X = B only',29),(30,'d','ptsv','SPD','tridiagonal','Doxygen/docs/html/dptsv_8f.html','driver simple; solve A*X = B only',30),(31,'c','ptsv','HPD','tridiagonal','Doxygen/docs/html/cptsv_8f.html','driver simple; solve A*X = B only',31),(32,'z','ptsv','HPD','tridiagonal','Doxygen/docs/html/zptsv_8f.html','driver simple; solve A*X = B only',32),(33,'s','sysv','symmetric','full','Doxygen/docs/html/ssysv_8f.html','driver simple; solve A*X = B only',33),(34,'d','sysv','symmetric','full','Doxygen/docs/html/dsysv_8f.html','driver simple; solve A*X = B only',34),(35,'c','sysv','symmetric','full','Doxygen/docs/html/csysv_8f.html','driver simple; solve A*X = B only',35),(36,'z','sysv','symmetric','full','Doxygen/docs/html/zsysv_8f.html','driver simple; solve A*X = B only',36),(37,'s','spsv','symmetric','packed','Doxygen/docs/html/sspsv_8f.html','driver simple; solve A*X = B only',37),(38,'d','spsv','symmetric','packed','Doxygen/docs/html/dspsv_8f.html','driver simple; solve A*X = B only',38),(39,'c','spsv','symmetric','packed','Doxygen/docs/html/cspsv_8f.html','driver simple; solve A*X = B only',39),(40,'z','spsv','symmetric','packed','Doxygen/docs/html/zspsv_8f.html','driver simple; solve A*X = B only',40),(41,'d','sgesv','general','full','Doxygen/docs/html/dsgesv_8f.html','driver simple; solve A*X = B only; refinement',329),(42,'z','cgesv','general','full','Doxygen/docs/html/zcgesv_8f.html','driver simple; solve A*X = B only; refinement',330),(43,'d','sposv','SPD','full','Doxygen/docs/html/dsposv_8f.html','driver simple; solve A*X = B only; refinement',331),(44,'z','cposv','SPD','full','Doxygen/docs/html/zcposv_8f.html','driver simple; solve A*X = B only; refinement',332),(45,'s','gesvx','general','full','Doxygen/docs/html/sgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',41),(46,'d','gesvx','general','full','Doxygen/docs/html/dgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',42),(47,'c','gesvx','general','full','Doxygen/docs/html/cgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',43),(48,'z','gesvx','general','full','Doxygen/docs/html/zgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',44),(49,'s','gbsvx','general','band','Doxygen/docs/html/sgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',45),(50,'d','gbsvx','general','band','Doxygen/docs/html/dgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',46),(51,'c','gbsvx','general','band','Doxygen/docs/html/cgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',47),(52,'z','gbsvx','general','band','Doxygen/docs/html/zgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',48),(53,'s','gtsvx','general','tridiagonal','Doxygen/docs/html/sgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',49),(54,'d','gtsvx','general','tridiagonal','Doxygen/docs/html/dgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',50),(55,'c','gtsvx','general','tridiagonal','Doxygen/docs/html/cgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',51),(56,'z','gtsvx','general','tridiagonal','Doxygen/docs/html/zgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',52),(57,'c','hesvx','Hermitian','full','Doxygen/docs/html/chesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',53),(58,'z','hesvx','Hermitian','full','Doxygen/docs/html/zhesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',54),(59,'c','hpsvx','Hermitian','packed','Doxygen/docs/html/chpsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',55),(60,'z','hpsvx','Hermitian','packed','Doxygen/docs/html/zhpsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',56),(61,'s','posvx','SPD','full','Doxygen/docs/html/sposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',57),(62,'d','posvx','SPD','full','Doxygen/docs/html/dposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',58),(63,'c','posvx','HPD','full','Doxygen/docs/html/cposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',59),(64,'z','posvx','HPD','full','Doxygen/docs/html/zposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',60),(65,'s','pbsvx','SPD','band','Doxygen/docs/html/spbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',61),(66,'d','pbsvx','SPD','band','Doxygen/docs/html/dpbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',62),(67,'c','pbsvx','HPD','band','Doxygen/docs/html/cpbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',63),(68,'z','pbsvx','HPD','band','Doxygen/docs/html/zpbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',64),(69,'s','ppsvx','SPD','packed','Doxygen/docs/html/sppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',65),(70,'d','ppsvx','SPD','packed','Doxygen/docs/html/dppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',66),(71,'c','ppsvx','HPD','packed','Doxygen/docs/html/cppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',67),(72,'z','ppsvx','HPD','packed','Doxygen/docs/html/zppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',68),(73,'s','ptsvx','SPD','tridiagonal','Doxygen/docs/html/sptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',69),(74,'d','ptsvx','SPD','tridiagonal','Doxygen/docs/html/dptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',70),(75,'c','ptsvx','HPD','tridiagonal','Doxygen/docs/html/cptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',71),(76,'z','ptsvx','HPD','tridiagonal','Doxygen/docs/html/zptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',72),(77,'s','sysvx','symmetric','full','Doxygen/docs/html/ssysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',73),(78,'d','sysvx','symmetric','full','Doxygen/docs/html/dsysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',74),(79,'c','sysvx','symmetric','full','Doxygen/docs/html/csysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',75),(80,'z','sysvx','symmetric','full','Doxygen/docs/html/zsysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',76),(81,'s','spsvx','symmetric','packed','Doxygen/docs/html/sspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',77),(82,'d','spsvx','symmetric','packed','Doxygen/docs/html/dspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',78),(83,'c','spsvx','symmetric','packed','Doxygen/docs/html/cspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',79),(84,'z','spsvx','symmetric','packed','Doxygen/docs/html/zspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',80),(85,'s','gesvxx','general','full','Doxygen/docs/html/sgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',343),(86,'d','gesvxx','general','full','Doxygen/docs/html/dgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',344),(87,'c','gesvxx','general','full','Doxygen/docs/html/cgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',345),(88,'z','gesvxx','general','full','Doxygen/docs/html/zgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',346),(89,'s','gbsvxx','general','band','Doxygen/docs/html/sgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',347),(90,'d','gbsvxx','general','band','Doxygen/docs/html/dgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',348),(91,'c','gbsvxx','general','band','Doxygen/docs/html/cgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',349),(92,'z','gbsvxx','general','band','Doxygen/docs/html/zgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',350),(93,'s','posvxx','SPD','full','Doxygen/docs/html/sposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',351),(94,'d','posvxx','SPD','full','Doxygen/docs/html/dposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',352),(95,'c','posvxx','SPD','full','Doxygen/docs/html/cposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',353),(96,'z','posvxx','SPD','full','Doxygen/docs/html/zposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',354),(97,'s','sysvxx','symmetric','full','Doxygen/docs/html/ssysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',355),(98,'d','sysvxx','symmetric','full','Doxygen/docs/html/dsysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',356),(99,'c','sysvxx','symmetric','full','Doxygen/docs/html/csysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',357),(100,'z','sysvxx','symmetric','full','Doxygen/docs/html/zsysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',358),(101,'c','hesvxx','Hermitian','full','Doxygen/docs/html/chesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',359),(102,'z','hesvxx','Hermitian','full','Doxygen/docs/html/zhesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',360),(103,'s','getrs','general','full','Doxygen/docs/html/sgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by SGETRF',121),(104,'d','getrs','general','full','Doxygen/docs/html/dgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by DGETRF',122),(105,'c','getrs','general','full','Doxygen/docs/html/cgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by CGETRF',123),(106,'z','getrs','general','full','Doxygen/docs/html/zgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by ZGETRF',124),(107,'s','gbtrs','general','band','Doxygen/docs/html/sgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by SGBTRF',125),(108,'d','gbtrs','general','band','Doxygen/docs/html/dgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by DGBTRF',126),(109,'c','gbtrs','general','band','Doxygen/docs/html/cgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by CGBTRF',127),(110,'z','gbtrs','general','band','Doxygen/docs/html/zgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by ZGBTRF',128),(111,'s','gttrs','general','tridiagonal','Doxygen/docs/html/sgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by SGTTRF',129),(112,'d','gttrs','general','tridiagonal','Doxygen/docs/html/dgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by DGTTRF',130),(113,'c','gttrs','general','tridiagonal','Doxygen/docs/html/cgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by CGTTRF',131),(114,'z','gttrs','general','tridiagonal','Doxygen/docs/html/zgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by ZGTTRF',132),(115,'s','potrs','SPD','full','Doxygen/docs/html/spotrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPOTRF',133),(116,'d','potrs','SPD','full','Doxygen/docs/html/dpotrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPOTRF',134),(117,'c','potrs','HPD','full','Doxygen/docs/html/cpotrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPOTRF',135),(118,'z','potrs','HPD','full','Doxygen/docs/html/zpotrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPOTRF',136),(119,'s','pptrs','SPD','packed','Doxygen/docs/html/spptrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPPTRF',137),(120,'d','pptrs','SPD','packed','Doxygen/docs/html/dpptrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPPTRF',138),(121,'c','pptrs','HPD','packed','Doxygen/docs/html/cpptrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPPTRF',139),(122,'z','pptrs','HPD','packed','Doxygen/docs/html/zpptrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPPTRF',140),(123,'s','pbtrs','SPD','band','Doxygen/docs/html/spbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPBTRF',141),(124,'d','pbtrs','SPD','band','Doxygen/docs/html/dpbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPBTRF',142),(125,'c','pbtrs','HPD','band','Doxygen/docs/html/cpbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPBTRF',143),(126,'z','pbtrs','HPD','band','Doxygen/docs/html/zpbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPBTRF',144),(127,'s','pttrs','SPD','tridiagonal','Doxygen/docs/html/spttrs_8f.html','computational; solve A*X = B using the L*D*L**T; computed by SPTTRF',145),(128,'d','pttrs','SPD','tridiagonal','Doxygen/docs/html/dpttrs_8f.html','computational; solve A*X = B using the L*D*L**T; computed by DPTTRF ',146),(129,'c','pttrs','HPD','tridiagonal','Doxygen/docs/html/cpttrs_8f.html','computational; solve A*X = B using A = U**H*D*U or A = L*D*L**H; computed by CPTTRF',147),(130,'z','pttrs','HPD','tridiagonal','Doxygen/docs/html/zpttrs_8f.html','computational; solve A*X = B using A = U**H*D*U or A = L*D*L**H; computed by ZPTTRF',148),(131,'s','sytrs','symmetric','full','Doxygen/docs/html/ssytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by SSYTRF ',149),(132,'d','sytrs','symmetric','full','Doxygen/docs/html/dsytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by DSYTRF ',150),(133,'c','sytrs','symmetric','full','Doxygen/docs/html/csytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by CSYTRF',151),(134,'z','sytrs','symmetric','full','Doxygen/docs/html/zsytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by ZSYTRF',152),(135,'s','sptrs','symmetric','packed','Doxygen/docs/html/ssptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by SSPTRF',153),(136,'d','sptrs','symmetric','packed','Doxygen/docs/html/dsptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by DSPTRF',154),(137,'c','sptrs','symmetric','packed','Doxygen/docs/html/csptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by CSPTRF',155),(138,'z','sptrs','symmetric','packed','Doxygen/docs/html/zsptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by ZSPTRF ',156),(139,'c','hetrs','Hermitian','full','Doxygen/docs/html/chetrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by CHETRF',157),(140,'z','hetrs','Hermitian','full','Doxygen/docs/html/zhetrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by ZHETRF',158),(141,'c','hptrs','Hermitian','packed','Doxygen/docs/html/chptrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by CHPTRF',159),(142,'z','hptrs','Hermitian','packed','Doxygen/docs/html/zhptrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by ZHPTRF',160),(143,'s','trtrs','triangular','full','Doxygen/docs/html/strtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',161),(144,'d','trtrs','triangular','full','Doxygen/docs/html/dtrtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',162),(145,'c','trtrs','triangular','full','Doxygen/docs/html/ctrtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',163),(146,'z','trtrs','triangular','full','Doxygen/docs/html/ztrtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',164),(147,'s','tptrs','triangular','packed','Doxygen/docs/html/stptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',165),(148,'d','tptrs','triangular','packed','Doxygen/docs/html/dtptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',166),(149,'c','tptrs','triangular','packed','Doxygen/docs/html/ctptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',167),(150,'z','tptrs','triangular','packed','Doxygen/docs/html/ztptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',168),(151,'s','tbtrs','triangular','band','Doxygen/docs/html/stbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',169),(152,'d','tbtrs','triangular','band','Doxygen/docs/html/dtbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',170),(153,'c','tbtrs','triangular','band','Doxygen/docs/html/ctbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',171),(154,'z','tbtrs','triangular','band','Doxygen/docs/html/ztbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',172),(155,'s','pftrs','SPD','full','Doxygen/docs/html/spftrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPFTRF',333),(156,'d','pftrs','SPD','full','Doxygen/docs/html/dpftrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPFTRF',334),(157,'c','pftrs','HPD','full','Doxygen/docs/html/cpftrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPFTRF',335),(158,'z','pftrs','HPD','full','Doxygen/docs/html/zpftrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPFTRF',336),(159,'s','sytrs2','symmetric','full','Doxygen/docs/html/ssytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by SSYTRF and converted by SSYCONV',337),(160,'d','sytrs2','symmetric','full','Doxygen/docs/html/dsytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by DSYTRF and converted by DSYCONV',338),(161,'c','sytrs2','symmetric','full','Doxygen/docs/html/csytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by CSYTRF and converted by CSYCONV',339),(162,'z','sytrs2','symmetric','full','Doxygen/docs/html/zsytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by ZSYTRF and converted by ZSYCONV',340),(163,'c','hetrs2','Hermitian','full','Doxygen/docs/html/chetrs2_8f.html','computational; solve A*X = B using A = U*D*U**H or A = L*D*L**H; computed by CHETRF and converted by CSYCONV',341),(164,'z','hetrs2','Hermitian','full','Doxygen/docs/html/zhetrs2_8f.html','computational; solve A*X = B using A = U*D*U**H or A = L*D*L**H; computed by ZHETRF and converted by ZSYCONV',342);
/*!40000 ALTER TABLE `combine_linearequation_only` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `computational_linearequation_computational`
--

DROP TABLE IF EXISTS `computational_linearequation_computational`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `computational_linearequation_computational` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Computational_linearequation_computational_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=355 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `computational_linearequation_computational`
--

LOCK TABLES `computational_linearequation_computational` WRITE;
/*!40000 ALTER TABLE `computational_linearequation_computational` DISABLE KEYS */;
INSERT INTO `computational_linearequation_computational` VALUES (1,'s','getrf','general','full','Doxygen/docs/html/sgetrf_8f.html','Computes an LU factorization of an m-by-n matrix using partial pivoting with row interchanges',81),(2,'d','getrf','general','full','Doxygen/docs/html/dgetrf_8f.html','Computes an LU factorization of an m-by-n matrix using partial pivoting with row interchanges',82),(3,'c','getrf','general','full','Doxygen/docs/html/cgetrf_8f.html','Computes an LU factorization of an m-by-n matrix using partial pivoting with row interchanges',83),(4,'z','getrf','general','full','Doxygen/docs/html/zgetrf_8f.html','Computes an LU factorization of an m-by-n matrix using partial pivoting with row interchanges',84),(5,'s','gbtrf','general','band','Doxygen/docs/html/sgbtrf_8f.html','computes an LU factorization of an m-by-n band matrix using partial pivoting with row interchanges.',85),(6,'d','gbtrf','general','band','Doxygen/docs/html/dgbtrf_8f.html','computes an LU factorization of an m-by-n band matrix using partial pivoting with row interchanges.',86),(7,'c','gbtrf','general','band','Doxygen/docs/html/cgbtrf_8f.html','computes an LU factorization of an m-by-n band matrix using partial pivoting with row interchanges.',87),(8,'z','gbtrf','general','band','Doxygen/docs/html/zgbtrf_8f.html','computes an LU factorization of an m-by-n band matrix using partial pivoting with row interchanges.',88),(9,'s','gttrf','general','tridiagonal','Doxygen/docs/html/sgttrf_8f.html','computes an LU factorization of a tridiagonal matrix using elimination with partial pivoting and row interchanges',89),(10,'d','gttrf','general','tridiagonal','Doxygen/docs/html/dgttrf_8f.html','computes an LU factorization of a tridiagonal matrix using elimination with partial pivoting and row interchanges',90),(11,'c','gttrf','general','tridiagonal','Doxygen/docs/html/cgttrf_8f.html','computes an LU factorization of a tridiagonal matrix using elimination with partial pivoting and row interchanges',91),(12,'z','gttrf','general','tridiagonal','Doxygen/docs/html/zgttrf_8f.html','computes an LU factorization of a tridiagonal matrix using elimination with partial pivoting and row interchanges',92),(13,'s','potrf','SPD','full','Doxygen/docs/html/spotrf_8f.html','computes the Cholesky factorization of an SPD matrix',93),(14,'d','potrf','SPD','full','Doxygen/docs/html/dpotrf_8f.html','computes the Cholesky factorization of an SPD matrix',94),(15,'c','potrf','HPD','full','Doxygen/docs/html/cpotrf_8f.html','computes the Cholesky factorization of an HPD matrix',95),(16,'z','potrf','HPD','full','Doxygen/docs/html/zpotrf_8f.html','computes the Cholesky factorization of an HPD matrix',96),(17,'s','pptrf','SPD','packed','Doxygen/docs/html/spptrf_8f.html','computes the Cholesky factorization of an SPD matrix stored in packed format',97),(18,'d','pptrf','SPD','packed','Doxygen/docs/html/dpptrf_8f.html','computes the Cholesky factorization of an SPD matrix stored in packed format',98),(19,'c','pptrf','HPD','packed','Doxygen/docs/html/cpptrf_8f.html','computes the Cholesky factorization of an HPD matrix stored in packed format',99),(20,'z','pptrf','HPD','packed','Doxygen/docs/html/zpptrf_8f.html','computes the Cholesky factorization of an HPD matrix stored in packed format',100),(21,'s','pbtrf','SPD','band','Doxygen/docs/html/spbtrf_8f.html','computes the Cholesky factorization of an SPD band matrix',101),(22,'d','pbtrf','SPD','band','Doxygen/docs/html/dpbtrf_8f.html','computes the Cholesky factorization of an SPD band matrix',102),(23,'c','pbtrf','HPD','band','Doxygen/docs/html/cpbtrf_8f.html','computes the Cholesky factorization of an HPD band matrix',103),(24,'z','pbtrf','HPD','band','Doxygen/docs/html/zpbtrf_8f.html','computes the Cholesky factorization of an HPD band matrix',104),(25,'s','pttrf','SPD','tridiagonal','Doxygen/docs/html/spttrf_8f.html','computes the L*D*L**T factorization of an SPD tridiagonal matrix',105),(26,'d','pttrf','SPD','tridiagonal','Doxygen/docs/html/dpttrf_8f.html','computes the L*D*L**T factorization of an SPD tridiagonal matrix',106),(27,'c','pttrf','HPD','tridiagonal','Doxygen/docs/html/cpttrf_8f.html','computes the L*D*L**T factorization of an HPD tridiagonal matrix',107),(28,'z','pttrf','HPD','tridiagonal','Doxygen/docs/html/zpttrf_8f.html','computes the L*D*L**T factorization of an HPD tridiagonal matrix',108),(29,'s','sytrf','symmetric','full','Doxygen/docs/html/ssytrf_8f.html','computes the factorization of a real symmetric matrix using the Bunch-Kaufman diagonal pivoting method',109),(30,'d','sytrf','symmetric','full','Doxygen/docs/html/dsytrf_8f.html','computes the factorization of a real symmetric matrix using the Bunch-Kaufman diagonal pivoting method',110),(31,'c','hetrf','Hermitian','full','Doxygen/docs/html/chetrf_8f.html','computes the factorization of a complex Hermitian matrix using the Bunch-Kaufman diagonal pivoting method',111),(32,'z','hetrf','Hermitian','full','Doxygen/docs/html/zhetrf_8f.html','computes the factorization of a complex Hermitian matrix using the Bunch-Kaufman diagonal pivoting method',112),(33,'c','sytrf','symmetric','full','Doxygen/docs/html/csytrf_8f.html','computes the factorization of a complex symmetric matrix using the Bunch-Kaufman diagonal pivoting method',113),(34,'z','sytrf','symmetric','full','Doxygen/docs/html/zsytrf_8f.html','computes the factorization of a complex symmetric matrix using the Bunch-Kaufman diagonal pivoting method',114),(35,'s','sptrf','symmetric','packed','Doxygen/docs/html/ssptrf_8f.html','computes the factorization of a real symmetric matrix stored in packed format using the Bunch-Kaufman diagonal pivoting method',115),(36,'d','sptrf','symmetric','packed','Doxygen/docs/html/dsptrf_8f.html','computes the factorization of a real symmetric matrix stored in packed format using the Bunch-Kaufman diagonal pivoting method',116),(37,'c','hptrf','Hermitian','packed','Doxygen/docs/html/chptrf_8f.html','computes the factorization of a complex Hermitian packed matrix using the Bunch-Kaufman diagonal pivoting method',117),(38,'z','hptrf','Hermitian','packed','Doxygen/docs/html/zhptrf_8f.html','computes the factorization of a complex Hermitian packed matrix using the Bunch-Kaufman diagonal pivoting method',118),(39,'c','sptrf','symmetric','packed','Doxygen/docs/html/csptrf_8f.html','computes the factorization of a complex symmetric matrix stored in packed format using the Bunch-Kaufman diagonal pivoting method',119),(40,'z','sptrf','symmetric','packed','Doxygen/docs/html/zsptrf_8f.html','computes the factorization of a complex symmetric matrix stored in packed format using the Bunch-Kaufman diagonal pivoting method',120),(41,'s','pftrf','SPD','full','Doxygen/docs/html/spftrf_8f.html','computes the Cholesky factorization of a real Hermitian positive definite matrix; RFP format',361),(42,'d','pftrf','SPD','full','Doxygen/docs/html/dpftrf_8f.html','computes the Cholesky factorization of a real Hermitian positive definite matrix; RFP format',362),(43,'c','pftrf','HPD','full','Doxygen/docs/html/cpftrf_8f.html','computes the Cholesky factorization of a complex Hermitian positive definite matrix; RFP format',363),(44,'z','pftrf','HPD','full','Doxygen/docs/html/zpftrf_8f.html','computes the Cholesky factorization of a complex Hermitian positive definite matrix; RFP format',364),(45,'s','pstrf','semidefinite','full','Doxygen/docs/html/spstrf_8f.html','computes the Cholesky factorization with complete pivoting of a real Hermitian positive semidefinite matrix',365),(46,'d','pstrf','semidefinite','full','Doxygen/docs/html/dpstrf_8f.html','computes the Cholesky factorization with complete pivoting of a real Hermitian positive semidefinite matrix',366),(47,'c','pstrf','semidefinite','full','Doxygen/docs/html/cpstrf_8f.html','computes the Cholesky factorization with complete pivoting of a complex Hermitian positive semidefinite matrix',367),(48,'z','pstrf','semidefinite','full','Doxygen/docs/html/zpstrf_8f.html','computes the Cholesky factorization with complete pivoting of a complex Hermitian positive semidefinite matrix',368),(49,'s','getrs','general','full','Doxygen/docs/html/sgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by SGETRF',121),(50,'d','getrs','general','full','Doxygen/docs/html/dgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by DGETRF',122),(51,'c','getrs','general','full','Doxygen/docs/html/cgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by CGETRF',123),(52,'z','getrs','general','full','Doxygen/docs/html/zgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by ZGETRF',124),(53,'s','gbtrs','general','band','Doxygen/docs/html/sgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by SGBTRF',125),(54,'d','gbtrs','general','band','Doxygen/docs/html/dgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by DGBTRF',126),(55,'c','gbtrs','general','band','Doxygen/docs/html/cgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by CGBTRF',127),(56,'z','gbtrs','general','band','Doxygen/docs/html/zgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by ZGBTRF',128),(57,'s','gttrs','general','tridiagonal','Doxygen/docs/html/sgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by SGTTRF',129),(58,'d','gttrs','general','tridiagonal','Doxygen/docs/html/dgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by DGTTRF',130),(59,'c','gttrs','general','tridiagonal','Doxygen/docs/html/cgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by CGTTRF',131),(60,'z','gttrs','general','tridiagonal','Doxygen/docs/html/zgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by ZGTTRF',132),(61,'s','potrs','SPD','full','Doxygen/docs/html/spotrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPOTRF',133),(62,'d','potrs','SPD','full','Doxygen/docs/html/dpotrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPOTRF',134),(63,'c','potrs','HPD','full','Doxygen/docs/html/cpotrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPOTRF',135),(64,'z','potrs','HPD','full','Doxygen/docs/html/zpotrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPOTRF',136),(65,'s','pptrs','SPD','packed','Doxygen/docs/html/spptrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPPTRF',137),(66,'d','pptrs','SPD','packed','Doxygen/docs/html/dpptrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPPTRF',138),(67,'c','pptrs','HPD','packed','Doxygen/docs/html/cpptrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPPTRF',139),(68,'z','pptrs','HPD','packed','Doxygen/docs/html/zpptrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPPTRF',140),(69,'s','pbtrs','SPD','band','Doxygen/docs/html/spbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPBTRF',141),(70,'d','pbtrs','SPD','band','Doxygen/docs/html/dpbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPBTRF',142),(71,'c','pbtrs','HPD','band','Doxygen/docs/html/cpbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPBTRF',143),(72,'z','pbtrs','HPD','band','Doxygen/docs/html/zpbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPBTRF',144),(73,'s','pttrs','SPD','tridiagonal','Doxygen/docs/html/spttrs_8f.html','computational; solve A*X = B using the L*D*L**T; computed by SPTTRF',145),(74,'d','pttrs','SPD','tridiagonal','Doxygen/docs/html/dpttrs_8f.html','computational; solve A*X = B using the L*D*L**T; computed by DPTTRF ',146),(75,'c','pttrs','HPD','tridiagonal','Doxygen/docs/html/cpttrs_8f.html','computational; solve A*X = B using A = U**H*D*U or A = L*D*L**H; computed by CPTTRF',147),(76,'z','pttrs','HPD','tridiagonal','Doxygen/docs/html/zpttrs_8f.html','computational; solve A*X = B using A = U**H*D*U or A = L*D*L**H; computed by ZPTTRF',148),(77,'s','sytrs','symmetric','full','Doxygen/docs/html/ssytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by SSYTRF ',149),(78,'d','sytrs','symmetric','full','Doxygen/docs/html/dsytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by DSYTRF ',150),(79,'c','sytrs','symmetric','full','Doxygen/docs/html/csytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by CSYTRF',151),(80,'z','sytrs','symmetric','full','Doxygen/docs/html/zsytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by ZSYTRF',152),(81,'s','sptrs','symmetric','packed','Doxygen/docs/html/ssptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by SSPTRF',153),(82,'d','sptrs','symmetric','packed','Doxygen/docs/html/dsptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by DSPTRF',154),(83,'c','sptrs','symmetric','packed','Doxygen/docs/html/csptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by CSPTRF',155),(84,'z','sptrs','symmetric','packed','Doxygen/docs/html/zsptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by ZSPTRF ',156),(85,'c','hetrs','Hermitian','full','Doxygen/docs/html/chetrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by CHETRF',157),(86,'z','hetrs','Hermitian','full','Doxygen/docs/html/zhetrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by ZHETRF',158),(87,'c','hptrs','Hermitian','packed','Doxygen/docs/html/chptrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by CHPTRF',159),(88,'z','hptrs','Hermitian','packed','Doxygen/docs/html/zhptrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by ZHPTRF',160),(89,'s','trtrs','triangular','full','Doxygen/docs/html/strtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',161),(90,'d','trtrs','triangular','full','Doxygen/docs/html/dtrtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',162),(91,'c','trtrs','triangular','full','Doxygen/docs/html/ctrtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',163),(92,'z','trtrs','triangular','full','Doxygen/docs/html/ztrtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',164),(93,'s','tptrs','triangular','packed','Doxygen/docs/html/stptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',165),(94,'d','tptrs','triangular','packed','Doxygen/docs/html/dtptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',166),(95,'c','tptrs','triangular','packed','Doxygen/docs/html/ctptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',167),(96,'z','tptrs','triangular','packed','Doxygen/docs/html/ztptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',168),(97,'s','tbtrs','triangular','band','Doxygen/docs/html/stbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',169),(98,'d','tbtrs','triangular','band','Doxygen/docs/html/dtbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',170),(99,'c','tbtrs','triangular','band','Doxygen/docs/html/ctbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',171),(100,'z','tbtrs','triangular','band','Doxygen/docs/html/ztbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',172),(101,'s','pftrs','SPD','full','Doxygen/docs/html/spftrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPFTRF',333),(102,'d','pftrs','SPD','full','Doxygen/docs/html/dpftrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPFTRF',334),(103,'c','pftrs','HPD','full','Doxygen/docs/html/cpftrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPFTRF',335),(104,'z','pftrs','HPD','full','Doxygen/docs/html/zpftrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPFTRF',336),(105,'s','sytrs2','symmetric','full','Doxygen/docs/html/ssytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by SSYTRF and converted by SSYCONV',337),(106,'d','sytrs2','symmetric','full','Doxygen/docs/html/dsytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by DSYTRF and converted by DSYCONV',338),(107,'c','sytrs2','symmetric','full','Doxygen/docs/html/csytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by CSYTRF and converted by CSYCONV',339),(108,'z','sytrs2','symmetric','full','Doxygen/docs/html/zsytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by ZSYTRF and converted by ZSYCONV',340),(109,'c','hetrs2','Hermitian','full','Doxygen/docs/html/chetrs2_8f.html','computational; solve A*X = B using A = U*D*U**H or A = L*D*L**H; computed by CHETRF and converted by CSYCONV',341),(110,'z','hetrs2','Hermitian','full','Doxygen/docs/html/zhetrs2_8f.html','computational; solve A*X = B using A = U*D*U**H or A = L*D*L**H; computed by ZHETRF and converted by ZSYCONV',342),(111,'s','gecon','general','full','Doxygen/docs/html/sgecon_8f.html','estimates the reciprocal of the condition number of a general real matrix',173),(112,'d','gecon','general','full','Doxygen/docs/html/dgecon_8f.html','estimates the reciprocal of the condition number of a general real matrix',174),(113,'c','gecon','general','full','Doxygen/docs/html/cgecon_8f.html','estimates the reciprocal of the condition number of a general complex matrix',175),(114,'z','gecon','general','full','Doxygen/docs/html/zgecon_8f.html','estimates the reciprocal of the condition number of a general complex matrix',176),(115,'s','gbcon','general','band','Doxygen/docs/html/sgbcon_8f.html','estimates the reciprocal of the condition number of a real general band matrix',177),(116,'d','gbcon','general','band','Doxygen/docs/html/dgbcon_8f.html','estimates the reciprocal of the condition number of a real general band matrix',178),(117,'c','gbcon','general','band','Doxygen/docs/html/cgbcon_8f.html','estimates the reciprocal of the condition number of a complex general band matrix',179),(118,'z','gbcon','general','band','Doxygen/docs/html/zgbcon_8f.html','estimates the reciprocal of the condition number of a complex general band matrix',180),(119,'s','gtcon','general','tridiagonal','Doxygen/docs/html/sgtcon_8f.html','estimates the reciprocal of the condition number of a real tridiagonal matrix A using LU ',181),(120,'d','gtcon','general','tridiagonal','Doxygen/docs/html/dgtcon_8f.html','estimates the reciprocal of the condition number of a real tridiagonal matrix A using LU ',182),(121,'c','gtcon','general','tridiagonal','Doxygen/docs/html/cgtcon_8f.html','estimates the reciprocal of the condition number of a complex tridiagonal matrix A using LU',183),(122,'z','gtcon','general','tridiagonal','Doxygen/docs/html/zgtcon_8f.html','estimates the reciprocal of the condition number of a complex tridiagonal matrix A using LU ',184),(123,'s','pocon','SPD','full','Doxygen/docs/html/spocon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite matrix using Cholesky',185),(124,'d','pocon','SPD','full','Doxygen/docs/html/dpocon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite matrix using Cholesky',186),(125,'c','pocon','HPD','full','Doxygen/docs/html/cpocon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite matrix using Cholesky',187),(126,'z','pocon','HPD','full','Doxygen/docs/html/zpocon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite matrix using Cholesky',188),(127,'s','ppcon','SPD','packed','Doxygen/docs/html/sppcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite packed matrix using Cholesky',189),(128,'d','ppcon','SPD','packed','Doxygen/docs/html/dppcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite packed matrix using Cholesky ',190),(129,'c','ppcon','HPD','packed','Doxygen/docs/html/cppcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite packed matrix using Cholesky',191),(130,'z','ppcon','HPD','packed','Doxygen/docs/html/zppcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite packed matrix using Cholesky ',192),(131,'s','pbcon','SPD','band','Doxygen/docs/html/spbcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite banded matrix using Cholesky',193),(132,'d','pbcon','SPD','band','Doxygen/docs/html/dpbcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite banded matrix using Cholesky',194),(133,'c','pbcon','HPD','band','Doxygen/docs/html/cpbcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite banded matrix using Cholesky',195),(134,'z','pbcon','HPD','band','Doxygen/docs/html/zpbcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite banded matrix using Cholesky ',196),(135,'s','ptcon','SPD','tridiagonal','Doxygen/docs/html/sptcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite tridiagonal matrix using Cholesky',197),(136,'d','ptcon','SPD','tridiagonal','Doxygen/docs/html/dptcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite tridiagonal matrix using Cholesky',198),(137,'c','ptcon','HPD','tridiagonal','Doxygen/docs/html/cptcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite tridiagonal matrix using Cholesky',199),(138,'z','ptcon','HPD','tridiagonal','Doxygen/docs/html/zptcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite tridiagonal matrix using Cholesky',200),(139,'c','hecon','Hermitian','full','Doxygen/docs/html/checon_8f.html','estimates the reciprocal of the condition number of a complex Hermitian matrix A using A = U*D*U**H or A = L*D*L**H',201),(140,'z','hecon','Hermitian','full','Doxygen/docs/html/zhecon_8f.html','estimates the reciprocal of the condition number of a complex Hermitian matrix A using A = U*D*U**H or A = L*D*L**H',202),(141,'s','sycon','symmetric','full','Doxygen/docs/html/ssycon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric matrix A using A = U*D*U**T or A = L*D*L**T',203),(142,'d','sycon','symmetric','full','Doxygen/docs/html/dsycon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric matrix A using A = U*D*U**T or A = L*D*L**T',204),(143,'c','sycon','symmetric','full','Doxygen/docs/html/csycon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric matrix A using A = U*D*U**T or A = L*D*L**T',205),(144,'z','sycon','symmetric','full','Doxygen/docs/html/zsycon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric matrix A using A = U*D*U**T or A = L*D*L**T',206),(145,'s','spcon','symmetric','packed','Doxygen/docs/html/sspcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric packed matrix A using A = U*D*U**T or A = L*D*L**T ',207),(146,'d','spcon','symmetric','packed','Doxygen/docs/html/dspcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric packed matrix A using A = U*D*U**T or A = L*D*L**T ',208),(147,'c','spcon','symmetric','packed','Doxygen/docs/html/cspcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric packed matrix A using A = U*D*U**T or A = L*D*L**T',209),(148,'z','spcon','symmetric','packed','Doxygen/docs/html/zspcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric packed matrix A using A = U*D*U**T or A = L*D*L**T',210),(149,'c','hpcon','Hermitian','packed','Doxygen/docs/html/chpcon_8f.html','estimates the reciprocal of the condition number of a complex Hermitian packed matrix A using A = U*D*U**H or A = L*D*L**H',211),(150,'z','hpcon','Hermitian','packed','Doxygen/docs/html/zhpcon_8f.html','estimates the reciprocal of the condition number of a complex Hermitian packed matrix A using A = U*D*U**H or A = L*D*L**H',212),(151,'s','trcon','triangular','full','Doxygen/docs/html/strcon_8f.html','estimates the reciprocal of the condition number of a triangular matrix A; in either the 1-norm or the infinity-norm',213),(152,'d','trcon','triangular','full','Doxygen/docs/html/dtrcon_8f.html','estimates the reciprocal of the condition number of a triangular matrix A; in either the 1-norm or the infinity-norm',214),(153,'c','trcon','triangular','full','Doxygen/docs/html/ctrcon_8f.html','estimates the reciprocal of the condition number of a triangular matrix A; in either the 1-norm or the infinity-norm.',215),(154,'z','trcon','triangular','full','Doxygen/docs/html/ztrcon_8f.html','estimates the reciprocal of the condition number of a triangular matrix A; in either the 1-norm or the infinity-norm.',216),(155,'s','tbcon','triangular','band','Doxygen/docs/html/stbcon_8f.html','estimates the reciprocal of the condition number of a triangular band matrix A; in either the 1-norm or the infinity-norm',217),(156,'d','tbcon','triangular','band','Doxygen/docs/html/dtbcon_8f.html','estimates the reciprocal of the condition number of a triangular band matrix A; in either the 1-norm or the infinity-norm',218),(157,'c','tbcon','triangular','band','Doxygen/docs/html/ctbcon_8f.html','estimates the reciprocal of the condition number of a triangular band matrix A; in either the 1-norm or the infinity-norm',219),(158,'z','tbcon','triangular','band','Doxygen/docs/html/ztbcon_8f.html','estimates the reciprocal of the condition number of a triangular band matrix A; in either the 1-norm or the infinity-norm',220),(159,'s','tpcon','triangular','packed','Doxygen/docs/html/stpcon_8f.html','estimates the reciprocal of the condition number of a triangular packed matrix A; in either the 1-norm or the infinity-norm',221),(160,'d','tpcon','triangular','packed','Doxygen/docs/html/dtpcon_8f.html','estimates the reciprocal of the condition number of a triangular packed matrix A; in either the 1-norm or the infinity-norm',222),(161,'c','tpcon','triangular','packed','Doxygen/docs/html/ctpcon_8f.html','estimates the reciprocal of the condition number of a triangular packed matrix A; in either the 1-norm or the infinity-norm',223),(162,'z','tpcon','triangular','packed','Doxygen/docs/html/ztpcon_8f.html','estimates the reciprocal of the condition number of a triangular packed matrix A; in either the 1-norm or the infinity-norm',224),(163,'c','la_gercond_c','general','full','Doxygen/docs/html/cla__gercond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',429),(164,'z','la_gercond_c','general','full','Doxygen/docs/html/zla__gercond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',430),(165,'c','la_gbrcond_c','general','band','Doxygen/docs/html/cla__gbrcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',431),(166,'z','la_gbrcond_c','general','band','Doxygen/docs/html/zla__gbrcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',432),(167,'c','la_porcond_c','HPD','full','Doxygen/docs/html/cla__porcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',433),(168,'z','la_porcond_c','HPD','full','Doxygen/docs/html/zla__porcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',434),(169,'c','la_syrcond_c','symmetric','full','Doxygen/docs/html/cla__syrcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',435),(170,'z','la_syrcond_c','symmetric','full','Doxygen/docs/html/zla__syrcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',436),(171,'c','la_hercond_c','Hermitian','full','Doxygen/docs/html/cla__hercond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',437),(172,'z','la_hercond_c','Hermitian','full','Doxygen/docs/html/zla__hercond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',438),(173,'c','la_gercond_x','general','full','Doxygen/docs/html/cla__gercond__x_8f.html','computes the infinity norm condition number; X is a complex vector',439),(174,'z','la_gercond_x','general','full','Doxygen/docs/html/zla__gercond__x_8f.html','computes the infinity norm condition number; X is a complex vector',440),(175,'c','la_gbrcond_x','general','band','Doxygen/docs/html/cla__gbrcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',441),(176,'z','la_gbrcond_x','general','band','Doxygen/docs/html/zla__gbrcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',442),(177,'c','la_porcond_x','HPD','full','Doxygen/docs/html/cla__porcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',443),(178,'z','la_porcond_x','HPD','full','Doxygen/docs/html/zla__porcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',444),(179,'c','la_syrcond_x','symmetric','full','Doxygen/docs/html/cla__syrcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',445),(180,'z','la_syrcond_x','symmetric','full','Doxygen/docs/html/zla__syrcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',446),(181,'c','la_hercond_x','Hermitian','full','Doxygen/docs/html/cla__hercond__x_8f.html','computes the infinity norm condition number; X is a complex vector',447),(182,'z','la_hercond_x','Hermitian','full','Doxygen/docs/html/zla__hercond__x_8f.html','computes the infinity norm condition number; X is a complex vector',448),(183,'s','la_gercond','general','full','Doxygen/docs/html/sla__gercond_8f.html','estimates the Skeel condition number',449),(184,'d','la_gercond','general','full','Doxygen/docs/html/dla__gercond_8f.html','estimates the Skeel condition number',450),(185,'s','la_gbrcond','general','band','Doxygen/docs/html/sla__gbrcond_8f.html','estimates the Skeel condition number',451),(186,'d','la_gbrcond','general','band','Doxygen/docs/html/dla__gbrcond_8f.html','estimates the Skeel condition number',452),(187,'s','la_porcond','HPD','full','Doxygen/docs/html/sla__porcond_8f.html','estimates the Skeel condition number',453),(188,'d','la_porcond','HPD','full','Doxygen/docs/html/dla__porcond_8f.html','estimates the Skeel condition number',454),(189,'s','la_syrcond','symmetric','full','Doxygen/docs/html/sla__syrcond_8f.html','estimates the Skeel condition number',455),(190,'d','la_syrcond','symmetric','full','Doxygen/docs/html/dla__syrcond_8f.html','estimates the Skeel condition number',456),(191,'s','gerfs','general','full','Doxygen/docs/html/sgerfs_8f.html','error bounds and backward error estimates; iterative refinement',225),(192,'d','gerfs','general','full','Doxygen/docs/html/dgerfs_8f.html','error bounds and backward error estimates; iterative refinement',226),(193,'c','gerfs','general','full','Doxygen/docs/html/cgerfs_8f.html','error bounds and backward error estimates; iterative refinement',227),(194,'z','gerfs','general','full','Doxygen/docs/html/zgerfs_8f.html','error bounds and backward error estimates; iterative refinement',228),(195,'s','gbrfs','general','band','Doxygen/docs/html/sgbrfs_8f.html','error bounds and backward error estimates; iterative refinement',229),(196,'d','gbrfs','general','band','Doxygen/docs/html/dgbrfs_8f.html','error bounds and backward error estimates; iterative refinement',230),(197,'c','gbrfs','general','band','Doxygen/docs/html/cgbrfs_8f.html','error bounds and backward error estimates; iterative refinement',231),(198,'z','gbrfs','general','band','Doxygen/docs/html/zgbrfs_8f.html','error bounds and backward error estimates; iterative refinement',232),(199,'s','gtrfs','general','tridiagonal','Doxygen/docs/html/sgtrfs_8f.html','error bounds and backward error estimates; iterative refinement',233),(200,'d','gtrfs','general','tridiagonal','Doxygen/docs/html/dgtrfs_8f.html','error bounds and backward error estimates; iterative refinement',234),(201,'c','gtrfs','general','tridiagonal','Doxygen/docs/html/cgtrfs_8f.html','error bounds and backward error estimates; iterative refinement',235),(202,'z','gtrfs','general','tridiagonal','Doxygen/docs/html/zgtrfs_8f.html','error bounds and backward error estimates; iterative refinement',236),(203,'c','herfs','Hermitian','full','Doxygen/docs/html/cherfs_8f.html','error bounds and backward error estimates; iterative refinement',237),(204,'z','herfs','Hermitian','full','Doxygen/docs/html/zherfs_8f.html','error bounds and backward error estimates; iterative refinement',238),(205,'c','hprfs','Hermitian','packed','Doxygen/docs/html/chprfs_8f.html','error bounds and backward error estimates; iterative refinement',239),(206,'z','hprfs','Hermitian','packed','Doxygen/docs/html/zhprfs_8f.html','error bounds and backward error estimates; iterative refinement',240),(207,'s','porfs','SPD','full','Doxygen/docs/html/sporfs_8f.html','error bounds and backward error estimates; iterative refinement',241),(208,'d','porfs','SPD','full','Doxygen/docs/html/dporfs_8f.html','error bounds and backward error estimates; iterative refinement',242),(209,'c','porfs','HPD','full','Doxygen/docs/html/cporfs_8f.html','error bounds and backward error estimates; iterative refinement',243),(210,'z','porfs','HPD','full','Doxygen/docs/html/zporfs_8f.html','error bounds and backward error estimates; iterative refinement',244),(211,'s','pbrfs','SPD','band','Doxygen/docs/html/spbrfs_8f.html','error bounds and backward error estimates; iterative refinement',245),(212,'d','pbrfs','SPD','band','Doxygen/docs/html/dpbrfs_8f.html','error bounds and backward error estimates; iterative refinement',246),(213,'c','pbrfs','HPD','band','Doxygen/docs/html/cpbrfs_8f.html','error bounds and backward error estimates; iterative refinement',247),(214,'z','pbrfs','HPD','band','Doxygen/docs/html/zpbrfs_8f.html','error bounds and backward error estimates; iterative refinement',248),(215,'s','pprfs','SPD','packed','Doxygen/docs/html/spprfs_8f.html','error bounds and backward error estimates; iterative refinement',249),(216,'d','pprfs','SPD','packed','Doxygen/docs/html/dpprfs_8f.html','error bounds and backward error estimates; iterative refinement',250),(217,'c','pprfs','HPD','packed','Doxygen/docs/html/cpprfs_8f.html','error bounds and backward error estimates; iterative refinement',251),(218,'z','pprfs','HPD','packed','Doxygen/docs/html/zpprfs_8f.html','error bounds and backward error estimates; iterative refinement',252),(219,'s','ptrfs','SPD','tridiagonal','Doxygen/docs/html/sptrfs_8f.html','error bounds and backward error estimates; iterative refinement',253),(220,'d','ptrfs','SPD','tridiagonal','Doxygen/docs/html/dptrfs_8f.html','error bounds and backward error estimates; iterative refinement',254),(221,'c','ptrfs','HPD','tridiagonal','Doxygen/docs/html/cptrfs_8f.html','error bounds and backward error estimates; iterative refinement',255),(222,'z','ptrfs','HPD','tridiagonal','Doxygen/docs/html/zptrfs_8f.html','error bounds and backward error estimates; iterative refinement',256),(223,'s','syrfs','symmetric','full','Doxygen/docs/html/ssyrfs_8f.html','error bounds and backward error estimates; iterative refinement',257),(224,'d','syrfs','symmetric','full','Doxygen/docs/html/dsyrfs_8f.html','error bounds and backward error estimates; iterative refinement',258),(225,'c','syrfs','symmetric','full','Doxygen/docs/html/csyrfs_8f.html','error bounds and backward error estimates; iterative refinement',259),(226,'z','syrfs','symmetric','full','Doxygen/docs/html/zsyrfs_8f.html','error bounds and backward error estimates; iterative refinement',260),(227,'s','sprfs','symmetric','packed','Doxygen/docs/html/ssprfs_8f.html','error bounds and backward error estimates; iterative refinement',261),(228,'d','sprfs','symmetric','packed','Doxygen/docs/html/dsprfs_8f.html','error bounds and backward error estimates; iterative refinement',262),(229,'c','sprfs','symmetric','packed','Doxygen/docs/html/csprfs_8f.html','error bounds and backward error estimates; iterative refinement',263),(230,'z','sprfs','symmetric','packed','Doxygen/docs/html/zsprfs_8f.html','error bounds and backward error estimates; iterative refinement',264),(231,'s','trrfs','triangular','full','Doxygen/docs/html/strrfs_8f.html','error bounds and backward error estimates',265),(232,'d','trrfs','triangular','full','Doxygen/docs/html/dtrrfs_8f.html','error bounds and backward error estimates',266),(233,'c','trrfs','triangular','full','Doxygen/docs/html/ctrrfs_8f.html','error bounds and backward error estimates',267),(234,'z','trrfs','triangular','full','Doxygen/docs/html/ztrrfs_8f.html','error bounds and backward error estimates',268),(235,'s','tbrfs','triangular','band','Doxygen/docs/html/stbrfs_8f.html','error bounds and backward error estimates',269),(236,'d','tbrfs','triangular','band','Doxygen/docs/html/dtbrfs_8f.html','error bounds and backward error estimates',270),(237,'c','tbrfs','triangular','band','Doxygen/docs/html/ctbrfs_8f.html','error bounds and backward error estimates',271),(238,'z','tbrfs','triangular','band','Doxygen/docs/html/ztbrfs_8f.html','error bounds and backward error estimates',272),(239,'s','tprfs','triangular','packed','Doxygen/docs/html/stprfs_8f.html','error bounds and backward error estimates',273),(240,'d','tprfs','triangular','packed','Doxygen/docs/html/dtprfs_8f.html','error bounds and backward error estimates',274),(241,'c','tprfs','triangular','packed','Doxygen/docs/html/ctprfs_8f.html','error bounds and backward error estimates',275),(242,'z','tprfs','triangular','packed','Doxygen/docs/html/ztprfs_8f.html','error bounds and backward error estimates',276),(243,'s','gerfsx','general','full','Doxygen/docs/html/sgerfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',411),(244,'d','gerfsx','general','full','Doxygen/docs/html/dgerfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',412),(245,'c','gerfsx','general','full','Doxygen/docs/html/cgerfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',413),(246,'z','gerfsx','general','full','Doxygen/docs/html/zgerfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',414),(247,'s','gbrfsx','general','band','Doxygen/docs/html/sgbrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',415),(248,'d','gbrfsx','general','band','Doxygen/docs/html/dgbrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',416),(249,'c','gbrfsx','general','band','Doxygen/docs/html/cgbrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',417),(250,'z','gbrfsx','general','band','Doxygen/docs/html/zgbrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',418),(251,'s','porfsx','SPD','full','Doxygen/docs/html/sporfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',419),(252,'d','porfsx','SPD','full','Doxygen/docs/html/dporfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',420),(253,'c','porfsx','HPD','full','Doxygen/docs/html/cporfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',421),(254,'z','porfsx','HPD','full','Doxygen/docs/html/zporfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',422),(255,'s','syrfsx','symmetric','full','Doxygen/docs/html/ssyrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',423),(256,'d','syrfsx','symmetric','full','Doxygen/docs/html/dsyrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',424),(257,'c','syrfsx','symmetric','full','Doxygen/docs/html/csyrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',425),(258,'z','syrfsx','symmetric','full','Doxygen/docs/html/zsyrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',426),(259,'c','herfsx','Hermitian','full','Doxygen/docs/html/cherfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',427),(260,'z','herfsx','Hermitian','full','Doxygen/docs/html/zherfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',428),(261,'s','getri','general','full','Doxygen/docs/html/sgetri_8f.html','computes the inverse of a matrix',277),(262,'d','getri','general','full','Doxygen/docs/html/dgetri_8f.html','computes the inverse of a matrix',278),(263,'c','getri','general','full','Doxygen/docs/html/cgetri_8f.html','computes the inverse of a matrix',279),(264,'z','getri','general','full','Doxygen/docs/html/zgetri_8f.html','computes the inverse of a matrix',280),(265,'c','hetri','Hermitian','full','Doxygen/docs/html/chetri_8f.html','computes the inverse of a matrix',281),(266,'z','hetri','Hermitian','full','Doxygen/docs/html/zhetri_8f.html','computes the inverse of a matrix',282),(267,'c','hptri','Hermitian','packed','Doxygen/docs/html/chptri_8f.html','computes the inverse of a matrix',283),(268,'z','hptri','Hermitian','packed','Doxygen/docs/html/zhptri_8f.html','computes the inverse of a matrix',284),(269,'s','potri','SPD','full','Doxygen/docs/html/spotri_8f.html','computes the inverse of a matrix',285),(270,'d','potri','SPD','full','Doxygen/docs/html/dpotri_8f.html','computes the inverse of a matrix',286),(271,'c','potri','HPD','full','Doxygen/docs/html/cpotri_8f.html','computes the inverse of a matrix',287),(272,'z','potri','HPD','full','Doxygen/docs/html/zpotri_8f.html','computes the inverse of a matrix',288),(273,'s','pptri','SPD','packed','Doxygen/docs/html/spptri_8f.html','computes the inverse of a matrix',289),(274,'d','pptri','SPD','packed','Doxygen/docs/html/dpptri_8f.html','computes the inverse of a matrix',290),(275,'c','pptri','HPD','packed','Doxygen/docs/html/cpptri_8f.html','computes the inverse of a matrix',291),(276,'z','pptri','HPD','packed','Doxygen/docs/html/zpptri_8f.html','computes the inverse of a matrix',292),(277,'s','sytri','symmetric','full','Doxygen/docs/html/ssytri_8f.html','computes the inverse of a matrix',293),(278,'d','sytri','symmetric','full','Doxygen/docs/html/dsytri_8f.html','computes the inverse of a matrix',294),(279,'c','sytri','symmetric','full','Doxygen/docs/html/csytri_8f.html','computes the inverse of a matrix',295),(280,'z','sytri','symmetric','full','Doxygen/docs/html/zsytri_8f.html','computes the inverse of a matrix',296),(281,'s','sptri','symmetric','packed','Doxygen/docs/html/ssptri_8f.html','computes the inverse of a matrix',297),(282,'d','sptri','symmetric','packed','Doxygen/docs/html/dsptri_8f.html','computes the inverse of a matrix',298),(283,'c','sptri','symmetric','packed','Doxygen/docs/html/csptri_8f.html','computes the inverse of a matrix',299),(284,'z','sptri','symmetric','packed','Doxygen/docs/html/zsptri_8f.html','computes the inverse of a matrix',300),(285,'s','trtri','triangular','full','Doxygen/docs/html/strtri_8f.html','computes the inverse of a matrix',301),(286,'d','trtri','triangular','full','Doxygen/docs/html/dtrtri_8f.html','computes the inverse of a matrix',302),(287,'c','trtri','triangular','full','Doxygen/docs/html/ctrtri_8f.html','computes the inverse of a matrix',303),(288,'z','trtri','triangular','full','Doxygen/docs/html/ztrtri_8f.html','computes the inverse of a matrix',304),(289,'s','tptri','triangular','packed','Doxygen/docs/html/stptri_8f.html','computes the inverse of a matrix',305),(290,'d','tptri','triangular','packed','Doxygen/docs/html/dtptri_8f.html','computes the inverse of a matrix',306),(291,'c','tptri','triangular','packed','Doxygen/docs/html/ctptri_8f.html','computes the inverse of a matrix',307),(292,'z','tptri','triangular','packed','Doxygen/docs/html/ztptri_8f.html','computes the inverse of a matrix',308),(293,'s','pftri','SPD','full','Doxygen/docs/html/spftri_8f.html','computes the inverse using the Cholesky factorization; computed by SPFTRF',369),(294,'d','pftri','SPD','full','Doxygen/docs/html/dpftri_8f.html','computes the inverse using the Cholesky factorization; computed by DPFTRF',370),(295,'c','pftri','HPD','full','Doxygen/docs/html/cpftri_8f.html','computes the inverse using the Cholesky factorization; computed by CPFTRF',371),(296,'z','pftri','HPD','full','Doxygen/docs/html/zpftri_8f.html','computes the inverse using the Cholesky factorization; computed by ZPFTRF',372),(297,'s','tftri','triangular','full','Doxygen/docs/html/stftri_8f.html','computes the inverse of a matrix; stored in RFP format ',373),(298,'d','tftri','triangular','full','Doxygen/docs/html/dtftri_8f.html','computes the inverse of a matrix; stored in RFP format ',374),(299,'c','tftri','triangular','full','Doxygen/docs/html/ctftri_8f.html','computes the inverse of a matrix; stored in RFP format ',375),(300,'z','tftri','triangular','full','Doxygen/docs/html/ztftri_8f.html','computes the inverse of a matrix; stored in RFP format ',376),(301,'s','sytri2','symmetric','full','Doxygen/docs/html/ssytri2_8f.html','computes the inverse of a matrix; computed by SSYTRF; sets the LEADING DIMENSION of the workspace',377),(302,'d','sytri2','symmetric','full','Doxygen/docs/html/dsytri2_8f.html','computes the inverse of a matrix; computed by DSYTRF; sets the LEADING DIMENSION of the workspace',378),(303,'c','sytri2','symmetric','full','Doxygen/docs/html/csytri2_8f.html','computes the inverse of a matrix; computed by CSYTRF; sets the LEADING DIMENSION of the workspace',379),(304,'z','sytri2','symmetric','full','Doxygen/docs/html/zsytri2_8f.html','computes the inverse of a matrix; computed by ZSYTRF; sets the LEADING DIMENSION of the workspace',380),(305,'c','hetri2','Hermitian','full','Doxygen/docs/html/chetri2_8f.html','computes the inverse of a matrix; computed by CHETRF; sets the LEADING DIMENSION of the workspace',381),(306,'z','hetri2','Hermitian','full','Doxygen/docs/html/zhetri2_8f.html','computes the inverse of a matrix; computed by ZHETRF; sets the LEADING DIMENSION of the workspace',382),(307,'s','sytri2x','symmetric','full','Doxygen/docs/html/ssytri2x_8f.html','computes the inverse of a matrix; computed by SSYTRF',383),(308,'d','sytri2x','symmetric','full','Doxygen/docs/html/dsytri2x_8f.html','computes the inverse of a matrix; computed by DSYTRF',384),(309,'c','sytri2x','symmetric','full','Doxygen/docs/html/csytri2x_8f.html','computes the inverse of a matrix; computed by CSYTRF',385),(310,'z','sytri2x','symmetric','full','Doxygen/docs/html/zsytri2x_8f.html','computes the inverse of a matrix; computed by ZSYTRF',386),(311,'c','hetri2x','Hermitian','full','Doxygen/docs/html/chetri2x_8f.html','computes the inverse of a matrix; computed by CHETRF',387),(312,'z','hetri2x','Hermitian','full','Doxygen/docs/html/zhetri2x_8f.html','computes the inverse of a matrix; computed by ZHETRF',388),(313,'s','trti2','triangular','full','Doxygen/docs/html/strti2_8f.html','computes the inverse of a matrix; upper or lower triangular matrix; Level 2 BLA',389),(314,'d','trti2','triangular','full','Doxygen/docs/html/dtrti2_8f.html','computes the inverse of a matrix; upper or lower triangular matrix; Level 2 BLA',390),(315,'c','trti2','triangular','full','Doxygen/docs/html/ctrti2_8f.html','computes the inverse of a matrix; upper or lower triangular matrix; Level 2 BLA',391),(316,'z','trti2','triangular','full','Doxygen/docs/html/ztrti2_8f.html','computes the inverse of a matrix; upper or lower triangular matrix; Level 2 BLA',392),(317,'s','geequ','general','full','Doxygen/docs/html/sgeequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn',309),(318,'d','geequ','general','full','Doxygen/docs/html/dgeequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn',310),(319,'c','geequ','general','full','Doxygen/docs/html/cgeequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn',311),(320,'z','geequ','general','full','Doxygen/docs/html/zgeequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn',312),(321,'s','gbequ','general','band','Doxygen/docs/html/sgbequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn',313),(322,'d','gbequ','general','band','Doxygen/docs/html/dgbequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn',314),(323,'c','gbequ','general','band','Doxygen/docs/html/cgbequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn',315),(324,'z','gbequ','general','band','Doxygen/docs/html/zgbequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn',316),(325,'s','poequ','SPD','full','Doxygen/docs/html/spoequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite matrix A and reduce its cn (with respect to the two-norm)',317),(326,'d','poequ','SPD','full','Doxygen/docs/html/dpoequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite matrix A and reduce its cn (with respect to the two-norm)',318),(327,'c','poequ','HPD','full','Doxygen/docs/html/cpoequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A and reduce its cn (with respect to the two-norm)',319),(328,'z','poequ','HPD','full','Doxygen/docs/html/zpoequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A and reduce its cn (with respect to the two-norm)',320),(329,'s','pbequ','SPD','band','Doxygen/docs/html/spbequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite band matrix A and reduce its cn (with respect to the two-norm)',321),(330,'d','pbequ','SPD','band','Doxygen/docs/html/dpbequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite band matrix A and reduce its cn (with respect to the two-norm)',322),(331,'c','pbequ','HPD','band','Doxygen/docs/html/cpbequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite band matrix A and reduce its cn (with respect to the two-norm)',323),(332,'z','pbequ','HPD','band','Doxygen/docs/html/zpbequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite band matrix A and reduce its cn (with respect to the two-norm)',324),(333,'s','ppequ','SPD','packed','Doxygen/docs/html/sppequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite matrix A in packed storage and reduce its cn (with respect to the two-norm)',325),(334,'d','ppequ','SPD','packed','Doxygen/docs/html/dppequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite matrix A in packed storage and reduce its cn (with respect to the two-norm)',326),(335,'c','ppequ','HPD','packed','Doxygen/docs/html/cppequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A in packed storage and reduce its cn (with respect to the two-norm)',327),(336,'z','ppequ','HPD','packed','Doxygen/docs/html/zppequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A in packed storage and reduce its cn (with respect to the two-norm)',328),(337,'s','geequb','general','full','Doxygen/docs/html/sgeequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn; restricting the scaling factors to a power of the radix',393),(338,'d','geequb','general','full','Doxygen/docs/html/dgeequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn; restricting the scaling factors to a power of the radix',394),(339,'c','geequb','general','full','Doxygen/docs/html/cgeequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn; restricting the scaling factors to a power of the radix',395),(340,'z','geequb','general','full','Doxygen/docs/html/zgeequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn; restricting the scaling factors to a power of the radix',396),(341,'s','gbequb','general','band','Doxygen/docs/html/sgbequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn; restricting the scaling factors to a power of the radix',397),(342,'d','gbequb','general','band','Doxygen/docs/html/dgbequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn; restricting the scaling factors to a power of the radix',398),(343,'c','gbequb','general','band','Doxygen/docs/html/cgbequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn; restricting the scaling factors to a power of the radix',399),(344,'z','gbequb','general','band','Doxygen/docs/html/zgbequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn; restricting the scaling factors to a power of the radix',400),(345,'s','syequb','symmetric','full','Doxygen/docs/html/ssyequb_8f.html','computes row and column scalings intended to equilibrate a symmetric matrix A and reduce its cn; S contains the scale factors',401),(346,'d','syequb','symmetric','full','Doxygen/docs/html/dsyequb_8f.html','computes row and column scalings intended to equilibrate a symmetric matrix A and reduce its cn; S contains the scale factors',402),(347,'c','syequb','symmetric','full','Doxygen/docs/html/csyequb_8f.html','computes row and column scalings intended to equilibrate a symmetric matrix A and reduce its cn; S contains the scale factors',403),(348,'z','syequb','symmetric','full','Doxygen/docs/html/zsyequb_8f.html','computes row and column scalings intended to equilibrate a symmetric matrix A and reduce its cn; S contains the scale factors',404),(349,'s','poequb','SPD','full','Doxygen/docs/html/spoequb_8f.html','computes row and column scalings intended to equilibrate an SPD matrix A and reduce its cn; S contains the scale factors',405),(350,'d','poequb','SPD','full','Doxygen/docs/html/dpoequb_8f.html','computes row and column scalings intended to equilibrate an SPD matrix A and reduce its cn; S contains the scale factors',406),(351,'c','poequb','HPD','full','Doxygen/docs/html/cpoequb_8f.html','computes row and column scalings intended to equilibrate an HPD matrix A and reduce its cn; S contains the scale factors',407),(352,'z','poequb','HPD','full','Doxygen/docs/html/zpoequb_8f.html','computes row and column scalings intended to equilibrate an HPD matrix A and reduce its cn; S contains the scale factors',408),(353,'c','heequb','Hermitian','full','Doxygen/docs/html/cheequb_8f.html','computes row and column scalings intended to equilibrate a Hermitian matrix A and reduce its cn; S contains the scale factors',409),(354,'z','heequb','Hermitian','full','Doxygen/docs/html/zheequb_8f.html','computes row and column scalings intended to equilibrate a Hermitian matrix A and reduce its cn; S contains the scale factors',410);
/*!40000 ALTER TABLE `computational_linearequation_computational` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `computational_linearequation_condition_number`
--

DROP TABLE IF EXISTS `computational_linearequation_condition_number`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `computational_linearequation_condition_number` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Computational_linearequation_condition_number_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=81 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `computational_linearequation_condition_number`
--

LOCK TABLES `computational_linearequation_condition_number` WRITE;
/*!40000 ALTER TABLE `computational_linearequation_condition_number` DISABLE KEYS */;
INSERT INTO `computational_linearequation_condition_number` VALUES (1,'s','gecon','general','full','Doxygen/docs/html/sgecon_8f.html','estimates the reciprocal of the condition number of a general real matrix',173),(2,'d','gecon','general','full','Doxygen/docs/html/dgecon_8f.html','estimates the reciprocal of the condition number of a general real matrix',174),(3,'c','gecon','general','full','Doxygen/docs/html/cgecon_8f.html','estimates the reciprocal of the condition number of a general complex matrix',175),(4,'z','gecon','general','full','Doxygen/docs/html/zgecon_8f.html','estimates the reciprocal of the condition number of a general complex matrix',176),(5,'s','gbcon','general','band','Doxygen/docs/html/sgbcon_8f.html','estimates the reciprocal of the condition number of a real general band matrix',177),(6,'d','gbcon','general','band','Doxygen/docs/html/dgbcon_8f.html','estimates the reciprocal of the condition number of a real general band matrix',178),(7,'c','gbcon','general','band','Doxygen/docs/html/cgbcon_8f.html','estimates the reciprocal of the condition number of a complex general band matrix',179),(8,'z','gbcon','general','band','Doxygen/docs/html/zgbcon_8f.html','estimates the reciprocal of the condition number of a complex general band matrix',180),(9,'s','gtcon','general','tridiagonal','Doxygen/docs/html/sgtcon_8f.html','estimates the reciprocal of the condition number of a real tridiagonal matrix A using LU ',181),(10,'d','gtcon','general','tridiagonal','Doxygen/docs/html/dgtcon_8f.html','estimates the reciprocal of the condition number of a real tridiagonal matrix A using LU ',182),(11,'c','gtcon','general','tridiagonal','Doxygen/docs/html/cgtcon_8f.html','estimates the reciprocal of the condition number of a complex tridiagonal matrix A using LU',183),(12,'z','gtcon','general','tridiagonal','Doxygen/docs/html/zgtcon_8f.html','estimates the reciprocal of the condition number of a complex tridiagonal matrix A using LU ',184),(13,'s','pocon','SPD','full','Doxygen/docs/html/spocon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite matrix using Cholesky',185),(14,'d','pocon','SPD','full','Doxygen/docs/html/dpocon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite matrix using Cholesky',186),(15,'c','pocon','HPD','full','Doxygen/docs/html/cpocon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite matrix using Cholesky',187),(16,'z','pocon','HPD','full','Doxygen/docs/html/zpocon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite matrix using Cholesky',188),(17,'s','ppcon','SPD','packed','Doxygen/docs/html/sppcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite packed matrix using Cholesky',189),(18,'d','ppcon','SPD','packed','Doxygen/docs/html/dppcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite packed matrix using Cholesky ',190),(19,'c','ppcon','HPD','packed','Doxygen/docs/html/cppcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite packed matrix using Cholesky',191),(20,'z','ppcon','HPD','packed','Doxygen/docs/html/zppcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite packed matrix using Cholesky ',192),(21,'s','pbcon','SPD','band','Doxygen/docs/html/spbcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite banded matrix using Cholesky',193),(22,'d','pbcon','SPD','band','Doxygen/docs/html/dpbcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite banded matrix using Cholesky',194),(23,'c','pbcon','HPD','band','Doxygen/docs/html/cpbcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite banded matrix using Cholesky',195),(24,'z','pbcon','HPD','band','Doxygen/docs/html/zpbcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite banded matrix using Cholesky ',196),(25,'s','ptcon','SPD','tridiagonal','Doxygen/docs/html/sptcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite tridiagonal matrix using Cholesky',197),(26,'d','ptcon','SPD','tridiagonal','Doxygen/docs/html/dptcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric positive definite tridiagonal matrix using Cholesky',198),(27,'c','ptcon','HPD','tridiagonal','Doxygen/docs/html/cptcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite tridiagonal matrix using Cholesky',199),(28,'z','ptcon','HPD','tridiagonal','Doxygen/docs/html/zptcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex Hermitian positive definite tridiagonal matrix using Cholesky',200),(29,'c','hecon','Hermitian','full','Doxygen/docs/html/checon_8f.html','estimates the reciprocal of the condition number of a complex Hermitian matrix A using A = U*D*U**H or A = L*D*L**H',201),(30,'z','hecon','Hermitian','full','Doxygen/docs/html/zhecon_8f.html','estimates the reciprocal of the condition number of a complex Hermitian matrix A using A = U*D*U**H or A = L*D*L**H',202),(31,'s','sycon','symmetric','full','Doxygen/docs/html/ssycon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric matrix A using A = U*D*U**T or A = L*D*L**T',203),(32,'d','sycon','symmetric','full','Doxygen/docs/html/dsycon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric matrix A using A = U*D*U**T or A = L*D*L**T',204),(33,'c','sycon','symmetric','full','Doxygen/docs/html/csycon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric matrix A using A = U*D*U**T or A = L*D*L**T',205),(34,'z','sycon','symmetric','full','Doxygen/docs/html/zsycon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric matrix A using A = U*D*U**T or A = L*D*L**T',206),(35,'s','spcon','symmetric','packed','Doxygen/docs/html/sspcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric packed matrix A using A = U*D*U**T or A = L*D*L**T ',207),(36,'d','spcon','symmetric','packed','Doxygen/docs/html/dspcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a real symmetric packed matrix A using A = U*D*U**T or A = L*D*L**T ',208),(37,'c','spcon','symmetric','packed','Doxygen/docs/html/cspcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric packed matrix A using A = U*D*U**T or A = L*D*L**T',209),(38,'z','spcon','symmetric','packed','Doxygen/docs/html/zspcon_8f.html','estimates the reciprocal of the condition number (in the 1-norm) of a complex symmetric packed matrix A using A = U*D*U**T or A = L*D*L**T',210),(39,'c','hpcon','Hermitian','packed','Doxygen/docs/html/chpcon_8f.html','estimates the reciprocal of the condition number of a complex Hermitian packed matrix A using A = U*D*U**H or A = L*D*L**H',211),(40,'z','hpcon','Hermitian','packed','Doxygen/docs/html/zhpcon_8f.html','estimates the reciprocal of the condition number of a complex Hermitian packed matrix A using A = U*D*U**H or A = L*D*L**H',212),(41,'s','trcon','triangular','full','Doxygen/docs/html/strcon_8f.html','estimates the reciprocal of the condition number of a triangular matrix A; in either the 1-norm or the infinity-norm',213),(42,'d','trcon','triangular','full','Doxygen/docs/html/dtrcon_8f.html','estimates the reciprocal of the condition number of a triangular matrix A; in either the 1-norm or the infinity-norm',214),(43,'c','trcon','triangular','full','Doxygen/docs/html/ctrcon_8f.html','estimates the reciprocal of the condition number of a triangular matrix A; in either the 1-norm or the infinity-norm.',215),(44,'z','trcon','triangular','full','Doxygen/docs/html/ztrcon_8f.html','estimates the reciprocal of the condition number of a triangular matrix A; in either the 1-norm or the infinity-norm.',216),(45,'s','tbcon','triangular','band','Doxygen/docs/html/stbcon_8f.html','estimates the reciprocal of the condition number of a triangular band matrix A; in either the 1-norm or the infinity-norm',217),(46,'d','tbcon','triangular','band','Doxygen/docs/html/dtbcon_8f.html','estimates the reciprocal of the condition number of a triangular band matrix A; in either the 1-norm or the infinity-norm',218),(47,'c','tbcon','triangular','band','Doxygen/docs/html/ctbcon_8f.html','estimates the reciprocal of the condition number of a triangular band matrix A; in either the 1-norm or the infinity-norm',219),(48,'z','tbcon','triangular','band','Doxygen/docs/html/ztbcon_8f.html','estimates the reciprocal of the condition number of a triangular band matrix A; in either the 1-norm or the infinity-norm',220),(49,'s','tpcon','triangular','packed','Doxygen/docs/html/stpcon_8f.html','estimates the reciprocal of the condition number of a triangular packed matrix A; in either the 1-norm or the infinity-norm',221),(50,'d','tpcon','triangular','packed','Doxygen/docs/html/dtpcon_8f.html','estimates the reciprocal of the condition number of a triangular packed matrix A; in either the 1-norm or the infinity-norm',222),(51,'c','tpcon','triangular','packed','Doxygen/docs/html/ctpcon_8f.html','estimates the reciprocal of the condition number of a triangular packed matrix A; in either the 1-norm or the infinity-norm',223),(52,'z','tpcon','triangular','packed','Doxygen/docs/html/ztpcon_8f.html','estimates the reciprocal of the condition number of a triangular packed matrix A; in either the 1-norm or the infinity-norm',224),(53,'c','la_gercond_c','general','full','Doxygen/docs/html/cla__gercond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',429),(54,'z','la_gercond_c','general','full','Doxygen/docs/html/zla__gercond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',430),(55,'c','la_gbrcond_c','general','band','Doxygen/docs/html/cla__gbrcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',431),(56,'z','la_gbrcond_c','general','band','Doxygen/docs/html/zla__gbrcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',432),(57,'c','la_porcond_c','HPD','full','Doxygen/docs/html/cla__porcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',433),(58,'z','la_porcond_c','HPD','full','Doxygen/docs/html/zla__porcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',434),(59,'c','la_syrcond_c','symmetric','full','Doxygen/docs/html/cla__syrcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',435),(60,'z','la_syrcond_c','symmetric','full','Doxygen/docs/html/zla__syrcond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',436),(61,'c','la_hercond_c','Hermitian','full','Doxygen/docs/html/cla__hercond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',437),(62,'z','la_hercond_c','Hermitian','full','Doxygen/docs/html/zla__hercond__c_8f.html','computes the infinity norm condition number; C is a double precision vector',438),(63,'c','la_gercond_x','general','full','Doxygen/docs/html/cla__gercond__x_8f.html','computes the infinity norm condition number; X is a complex vector',439),(64,'z','la_gercond_x','general','full','Doxygen/docs/html/zla__gercond__x_8f.html','computes the infinity norm condition number; X is a complex vector',440),(65,'c','la_gbrcond_x','general','band','Doxygen/docs/html/cla__gbrcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',441),(66,'z','la_gbrcond_x','general','band','Doxygen/docs/html/zla__gbrcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',442),(67,'c','la_porcond_x','HPD','full','Doxygen/docs/html/cla__porcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',443),(68,'z','la_porcond_x','HPD','full','Doxygen/docs/html/zla__porcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',444),(69,'c','la_syrcond_x','symmetric','full','Doxygen/docs/html/cla__syrcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',445),(70,'z','la_syrcond_x','symmetric','full','Doxygen/docs/html/zla__syrcond__x_8f.html','computes the infinity norm condition number; X is a complex vector',446),(71,'c','la_hercond_x','Hermitian','full','Doxygen/docs/html/cla__hercond__x_8f.html','computes the infinity norm condition number; X is a complex vector',447),(72,'z','la_hercond_x','Hermitian','full','Doxygen/docs/html/zla__hercond__x_8f.html','computes the infinity norm condition number; X is a complex vector',448),(73,'s','la_gercond','general','full','Doxygen/docs/html/sla__gercond_8f.html','estimates the Skeel condition number',449),(74,'d','la_gercond','general','full','Doxygen/docs/html/dla__gercond_8f.html','estimates the Skeel condition number',450),(75,'s','la_gbrcond','general','band','Doxygen/docs/html/sla__gbrcond_8f.html','estimates the Skeel condition number',451),(76,'d','la_gbrcond','general','band','Doxygen/docs/html/dla__gbrcond_8f.html','estimates the Skeel condition number',452),(77,'s','la_porcond','HPD','full','Doxygen/docs/html/sla__porcond_8f.html','estimates the Skeel condition number',453),(78,'d','la_porcond','HPD','full','Doxygen/docs/html/dla__porcond_8f.html','estimates the Skeel condition number',454),(79,'s','la_syrcond','symmetric','full','Doxygen/docs/html/sla__syrcond_8f.html','estimates the Skeel condition number',455),(80,'d','la_syrcond','symmetric','full','Doxygen/docs/html/dla__syrcond_8f.html','estimates the Skeel condition number',456);
/*!40000 ALTER TABLE `computational_linearequation_condition_number` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `computational_linearequation_equilibrate`
--

DROP TABLE IF EXISTS `computational_linearequation_equilibrate`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `computational_linearequation_equilibrate` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Computational_linearequation_equilibrate_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=39 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `computational_linearequation_equilibrate`
--

LOCK TABLES `computational_linearequation_equilibrate` WRITE;
/*!40000 ALTER TABLE `computational_linearequation_equilibrate` DISABLE KEYS */;
INSERT INTO `computational_linearequation_equilibrate` VALUES (1,'s','geequ','general','full','Doxygen/docs/html/sgeequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn',309),(2,'d','geequ','general','full','Doxygen/docs/html/dgeequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn',310),(3,'c','geequ','general','full','Doxygen/docs/html/cgeequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn',311),(4,'z','geequ','general','full','Doxygen/docs/html/zgeequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn',312),(5,'s','gbequ','general','band','Doxygen/docs/html/sgbequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn',313),(6,'d','gbequ','general','band','Doxygen/docs/html/dgbequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn',314),(7,'c','gbequ','general','band','Doxygen/docs/html/cgbequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn',315),(8,'z','gbequ','general','band','Doxygen/docs/html/zgbequ_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn',316),(9,'s','poequ','SPD','full','Doxygen/docs/html/spoequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite matrix A and reduce its cn (with respect to the two-norm)',317),(10,'d','poequ','SPD','full','Doxygen/docs/html/dpoequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite matrix A and reduce its cn (with respect to the two-norm)',318),(11,'c','poequ','HPD','full','Doxygen/docs/html/cpoequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A and reduce its cn (with respect to the two-norm)',319),(12,'z','poequ','HPD','full','Doxygen/docs/html/zpoequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A and reduce its cn (with respect to the two-norm)',320),(13,'s','pbequ','SPD','band','Doxygen/docs/html/spbequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite band matrix A and reduce its cn (with respect to the two-norm)',321),(14,'d','pbequ','SPD','band','Doxygen/docs/html/dpbequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite band matrix A and reduce its cn (with respect to the two-norm)',322),(15,'c','pbequ','HPD','band','Doxygen/docs/html/cpbequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite band matrix A and reduce its cn (with respect to the two-norm)',323),(16,'z','pbequ','HPD','band','Doxygen/docs/html/zpbequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite band matrix A and reduce its cn (with respect to the two-norm)',324),(17,'s','ppequ','SPD','packed','Doxygen/docs/html/sppequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite matrix A in packed storage and reduce its cn (with respect to the two-norm)',325),(18,'d','ppequ','SPD','packed','Doxygen/docs/html/dppequ_8f.html','computes row and column scalings intended to equilibrate a symmetric positive definite matrix A in packed storage and reduce its cn (with respect to the two-norm)',326),(19,'c','ppequ','HPD','packed','Doxygen/docs/html/cppequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A in packed storage and reduce its cn (with respect to the two-norm)',327),(20,'z','ppequ','HPD','packed','Doxygen/docs/html/zppequ_8f.html','computes row and column scalings intended to equilibrate a Hermitian positive definite matrix A in packed storage and reduce its cn (with respect to the two-norm)',328),(21,'s','geequb','general','full','Doxygen/docs/html/sgeequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn; restricting the scaling factors to a power of the radix',393),(22,'d','geequb','general','full','Doxygen/docs/html/dgeequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn; restricting the scaling factors to a power of the radix',394),(23,'c','geequb','general','full','Doxygen/docs/html/cgeequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn; restricting the scaling factors to a power of the radix',395),(24,'z','geequb','general','full','Doxygen/docs/html/zgeequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N matrix A and reduce its cn; restricting the scaling factors to a power of the radix',396),(25,'s','gbequb','general','band','Doxygen/docs/html/sgbequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn; restricting the scaling factors to a power of the radix',397),(26,'d','gbequb','general','band','Doxygen/docs/html/dgbequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn; restricting the scaling factors to a power of the radix',398),(27,'c','gbequb','general','band','Doxygen/docs/html/cgbequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn; restricting the scaling factors to a power of the radix',399),(28,'z','gbequb','general','band','Doxygen/docs/html/zgbequb_8f.html','computes row and column scalings intended to equilibrate an M-by-N band matrix A and reduce its cn; restricting the scaling factors to a power of the radix',400),(29,'s','syequb','symmetric','full','Doxygen/docs/html/ssyequb_8f.html','computes row and column scalings intended to equilibrate a symmetric matrix A and reduce its cn; S contains the scale factors',401),(30,'d','syequb','symmetric','full','Doxygen/docs/html/dsyequb_8f.html','computes row and column scalings intended to equilibrate a symmetric matrix A and reduce its cn; S contains the scale factors',402),(31,'c','syequb','symmetric','full','Doxygen/docs/html/csyequb_8f.html','computes row and column scalings intended to equilibrate a symmetric matrix A and reduce its cn; S contains the scale factors',403),(32,'z','syequb','symmetric','full','Doxygen/docs/html/zsyequb_8f.html','computes row and column scalings intended to equilibrate a symmetric matrix A and reduce its cn; S contains the scale factors',404),(33,'s','poequb','SPD','full','Doxygen/docs/html/spoequb_8f.html','computes row and column scalings intended to equilibrate an SPD matrix A and reduce its cn; S contains the scale factors',405),(34,'d','poequb','SPD','full','Doxygen/docs/html/dpoequb_8f.html','computes row and column scalings intended to equilibrate an SPD matrix A and reduce its cn; S contains the scale factors',406),(35,'c','poequb','HPD','full','Doxygen/docs/html/cpoequb_8f.html','computes row and column scalings intended to equilibrate an HPD matrix A and reduce its cn; S contains the scale factors',407),(36,'z','poequb','HPD','full','Doxygen/docs/html/zpoequb_8f.html','computes row and column scalings intended to equilibrate an HPD matrix A and reduce its cn; S contains the scale factors',408),(37,'c','heequb','Hermitian','full','Doxygen/docs/html/cheequb_8f.html','computes row and column scalings intended to equilibrate a Hermitian matrix A and reduce its cn; S contains the scale factors',409),(38,'z','heequb','Hermitian','full','Doxygen/docs/html/zheequb_8f.html','computes row and column scalings intended to equilibrate a Hermitian matrix A and reduce its cn; S contains the scale factors',410);
/*!40000 ALTER TABLE `computational_linearequation_equilibrate` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `computational_linearequation_error_bound`
--

DROP TABLE IF EXISTS `computational_linearequation_error_bound`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `computational_linearequation_error_bound` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Computational_linearequation_error_bound_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=71 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `computational_linearequation_error_bound`
--

LOCK TABLES `computational_linearequation_error_bound` WRITE;
/*!40000 ALTER TABLE `computational_linearequation_error_bound` DISABLE KEYS */;
INSERT INTO `computational_linearequation_error_bound` VALUES (1,'s','gerfs','general','full','Doxygen/docs/html/sgerfs_8f.html','error bounds and backward error estimates; iterative refinement',225),(2,'d','gerfs','general','full','Doxygen/docs/html/dgerfs_8f.html','error bounds and backward error estimates; iterative refinement',226),(3,'c','gerfs','general','full','Doxygen/docs/html/cgerfs_8f.html','error bounds and backward error estimates; iterative refinement',227),(4,'z','gerfs','general','full','Doxygen/docs/html/zgerfs_8f.html','error bounds and backward error estimates; iterative refinement',228),(5,'s','gbrfs','general','band','Doxygen/docs/html/sgbrfs_8f.html','error bounds and backward error estimates; iterative refinement',229),(6,'d','gbrfs','general','band','Doxygen/docs/html/dgbrfs_8f.html','error bounds and backward error estimates; iterative refinement',230),(7,'c','gbrfs','general','band','Doxygen/docs/html/cgbrfs_8f.html','error bounds and backward error estimates; iterative refinement',231),(8,'z','gbrfs','general','band','Doxygen/docs/html/zgbrfs_8f.html','error bounds and backward error estimates; iterative refinement',232),(9,'s','gtrfs','general','tridiagonal','Doxygen/docs/html/sgtrfs_8f.html','error bounds and backward error estimates; iterative refinement',233),(10,'d','gtrfs','general','tridiagonal','Doxygen/docs/html/dgtrfs_8f.html','error bounds and backward error estimates; iterative refinement',234),(11,'c','gtrfs','general','tridiagonal','Doxygen/docs/html/cgtrfs_8f.html','error bounds and backward error estimates; iterative refinement',235),(12,'z','gtrfs','general','tridiagonal','Doxygen/docs/html/zgtrfs_8f.html','error bounds and backward error estimates; iterative refinement',236),(13,'c','herfs','Hermitian','full','Doxygen/docs/html/cherfs_8f.html','error bounds and backward error estimates; iterative refinement',237),(14,'z','herfs','Hermitian','full','Doxygen/docs/html/zherfs_8f.html','error bounds and backward error estimates; iterative refinement',238),(15,'c','hprfs','Hermitian','packed','Doxygen/docs/html/chprfs_8f.html','error bounds and backward error estimates; iterative refinement',239),(16,'z','hprfs','Hermitian','packed','Doxygen/docs/html/zhprfs_8f.html','error bounds and backward error estimates; iterative refinement',240),(17,'s','porfs','SPD','full','Doxygen/docs/html/sporfs_8f.html','error bounds and backward error estimates; iterative refinement',241),(18,'d','porfs','SPD','full','Doxygen/docs/html/dporfs_8f.html','error bounds and backward error estimates; iterative refinement',242),(19,'c','porfs','HPD','full','Doxygen/docs/html/cporfs_8f.html','error bounds and backward error estimates; iterative refinement',243),(20,'z','porfs','HPD','full','Doxygen/docs/html/zporfs_8f.html','error bounds and backward error estimates; iterative refinement',244),(21,'s','pbrfs','SPD','band','Doxygen/docs/html/spbrfs_8f.html','error bounds and backward error estimates; iterative refinement',245),(22,'d','pbrfs','SPD','band','Doxygen/docs/html/dpbrfs_8f.html','error bounds and backward error estimates; iterative refinement',246),(23,'c','pbrfs','HPD','band','Doxygen/docs/html/cpbrfs_8f.html','error bounds and backward error estimates; iterative refinement',247),(24,'z','pbrfs','HPD','band','Doxygen/docs/html/zpbrfs_8f.html','error bounds and backward error estimates; iterative refinement',248),(25,'s','pprfs','SPD','packed','Doxygen/docs/html/spprfs_8f.html','error bounds and backward error estimates; iterative refinement',249),(26,'d','pprfs','SPD','packed','Doxygen/docs/html/dpprfs_8f.html','error bounds and backward error estimates; iterative refinement',250),(27,'c','pprfs','HPD','packed','Doxygen/docs/html/cpprfs_8f.html','error bounds and backward error estimates; iterative refinement',251),(28,'z','pprfs','HPD','packed','Doxygen/docs/html/zpprfs_8f.html','error bounds and backward error estimates; iterative refinement',252),(29,'s','ptrfs','SPD','tridiagonal','Doxygen/docs/html/sptrfs_8f.html','error bounds and backward error estimates; iterative refinement',253),(30,'d','ptrfs','SPD','tridiagonal','Doxygen/docs/html/dptrfs_8f.html','error bounds and backward error estimates; iterative refinement',254),(31,'c','ptrfs','HPD','tridiagonal','Doxygen/docs/html/cptrfs_8f.html','error bounds and backward error estimates; iterative refinement',255),(32,'z','ptrfs','HPD','tridiagonal','Doxygen/docs/html/zptrfs_8f.html','error bounds and backward error estimates; iterative refinement',256),(33,'s','syrfs','symmetric','full','Doxygen/docs/html/ssyrfs_8f.html','error bounds and backward error estimates; iterative refinement',257),(34,'d','syrfs','symmetric','full','Doxygen/docs/html/dsyrfs_8f.html','error bounds and backward error estimates; iterative refinement',258),(35,'c','syrfs','symmetric','full','Doxygen/docs/html/csyrfs_8f.html','error bounds and backward error estimates; iterative refinement',259),(36,'z','syrfs','symmetric','full','Doxygen/docs/html/zsyrfs_8f.html','error bounds and backward error estimates; iterative refinement',260),(37,'s','sprfs','symmetric','packed','Doxygen/docs/html/ssprfs_8f.html','error bounds and backward error estimates; iterative refinement',261),(38,'d','sprfs','symmetric','packed','Doxygen/docs/html/dsprfs_8f.html','error bounds and backward error estimates; iterative refinement',262),(39,'c','sprfs','symmetric','packed','Doxygen/docs/html/csprfs_8f.html','error bounds and backward error estimates; iterative refinement',263),(40,'z','sprfs','symmetric','packed','Doxygen/docs/html/zsprfs_8f.html','error bounds and backward error estimates; iterative refinement',264),(41,'s','trrfs','triangular','full','Doxygen/docs/html/strrfs_8f.html','error bounds and backward error estimates',265),(42,'d','trrfs','triangular','full','Doxygen/docs/html/dtrrfs_8f.html','error bounds and backward error estimates',266),(43,'c','trrfs','triangular','full','Doxygen/docs/html/ctrrfs_8f.html','error bounds and backward error estimates',267),(44,'z','trrfs','triangular','full','Doxygen/docs/html/ztrrfs_8f.html','error bounds and backward error estimates',268),(45,'s','tbrfs','triangular','band','Doxygen/docs/html/stbrfs_8f.html','error bounds and backward error estimates',269),(46,'d','tbrfs','triangular','band','Doxygen/docs/html/dtbrfs_8f.html','error bounds and backward error estimates',270),(47,'c','tbrfs','triangular','band','Doxygen/docs/html/ctbrfs_8f.html','error bounds and backward error estimates',271),(48,'z','tbrfs','triangular','band','Doxygen/docs/html/ztbrfs_8f.html','error bounds and backward error estimates',272),(49,'s','tprfs','triangular','packed','Doxygen/docs/html/stprfs_8f.html','error bounds and backward error estimates',273),(50,'d','tprfs','triangular','packed','Doxygen/docs/html/dtprfs_8f.html','error bounds and backward error estimates',274),(51,'c','tprfs','triangular','packed','Doxygen/docs/html/ctprfs_8f.html','error bounds and backward error estimates',275),(52,'z','tprfs','triangular','packed','Doxygen/docs/html/ztprfs_8f.html','error bounds and backward error estimates',276),(53,'s','gerfsx','general','full','Doxygen/docs/html/sgerfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',411),(54,'d','gerfsx','general','full','Doxygen/docs/html/dgerfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',412),(55,'c','gerfsx','general','full','Doxygen/docs/html/cgerfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',413),(56,'z','gerfsx','general','full','Doxygen/docs/html/zgerfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',414),(57,'s','gbrfsx','general','band','Doxygen/docs/html/sgbrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',415),(58,'d','gbrfsx','general','band','Doxygen/docs/html/dgbrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',416),(59,'c','gbrfsx','general','band','Doxygen/docs/html/cgbrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',417),(60,'z','gbrfsx','general','band','Doxygen/docs/html/zgbrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',418),(61,'s','porfsx','SPD','full','Doxygen/docs/html/sporfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',419),(62,'d','porfsx','SPD','full','Doxygen/docs/html/dporfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',420),(63,'c','porfsx','HPD','full','Doxygen/docs/html/cporfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',421),(64,'z','porfsx','HPD','full','Doxygen/docs/html/zporfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',422),(65,'s','syrfsx','symmetric','full','Doxygen/docs/html/ssyrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',423),(66,'d','syrfsx','symmetric','full','Doxygen/docs/html/dsyrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',424),(67,'c','syrfsx','symmetric','full','Doxygen/docs/html/csyrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',425),(68,'z','syrfsx','symmetric','full','Doxygen/docs/html/zsyrfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',426),(69,'c','herfsx','Hermitian','full','Doxygen/docs/html/cherfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',427),(70,'z','herfsx','Hermitian','full','Doxygen/docs/html/zherfsx_8f.html','error bounds and backward error estimates; iterative refinement; EQUED',428);
/*!40000 ALTER TABLE `computational_linearequation_error_bound` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `computational_linearequation_factor`
--

DROP TABLE IF EXISTS `computational_linearequation_factor`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `computational_linearequation_factor` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Computational_linearequation_factor_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=49 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `computational_linearequation_factor`
--

LOCK TABLES `computational_linearequation_factor` WRITE;
/*!40000 ALTER TABLE `computational_linearequation_factor` DISABLE KEYS */;
INSERT INTO `computational_linearequation_factor` VALUES (1,'s','getrf','general','full','Doxygen/docs/html/sgetrf_8f.html','Computes an LU factorization of an m-by-n matrix using partial pivoting with row interchanges',81),(2,'d','getrf','general','full','Doxygen/docs/html/dgetrf_8f.html','Computes an LU factorization of an m-by-n matrix using partial pivoting with row interchanges',82),(3,'c','getrf','general','full','Doxygen/docs/html/cgetrf_8f.html','Computes an LU factorization of an m-by-n matrix using partial pivoting with row interchanges',83),(4,'z','getrf','general','full','Doxygen/docs/html/zgetrf_8f.html','Computes an LU factorization of an m-by-n matrix using partial pivoting with row interchanges',84),(5,'s','gbtrf','general','band','Doxygen/docs/html/sgbtrf_8f.html','computes an LU factorization of an m-by-n band matrix using partial pivoting with row interchanges.',85),(6,'d','gbtrf','general','band','Doxygen/docs/html/dgbtrf_8f.html','computes an LU factorization of an m-by-n band matrix using partial pivoting with row interchanges.',86),(7,'c','gbtrf','general','band','Doxygen/docs/html/cgbtrf_8f.html','computes an LU factorization of an m-by-n band matrix using partial pivoting with row interchanges.',87),(8,'z','gbtrf','general','band','Doxygen/docs/html/zgbtrf_8f.html','computes an LU factorization of an m-by-n band matrix using partial pivoting with row interchanges.',88),(9,'s','gttrf','general','tridiagonal','Doxygen/docs/html/sgttrf_8f.html','computes an LU factorization of a tridiagonal matrix using elimination with partial pivoting and row interchanges',89),(10,'d','gttrf','general','tridiagonal','Doxygen/docs/html/dgttrf_8f.html','computes an LU factorization of a tridiagonal matrix using elimination with partial pivoting and row interchanges',90),(11,'c','gttrf','general','tridiagonal','Doxygen/docs/html/cgttrf_8f.html','computes an LU factorization of a tridiagonal matrix using elimination with partial pivoting and row interchanges',91),(12,'z','gttrf','general','tridiagonal','Doxygen/docs/html/zgttrf_8f.html','computes an LU factorization of a tridiagonal matrix using elimination with partial pivoting and row interchanges',92),(13,'s','potrf','SPD','full','Doxygen/docs/html/spotrf_8f.html','computes the Cholesky factorization of an SPD matrix',93),(14,'d','potrf','SPD','full','Doxygen/docs/html/dpotrf_8f.html','computes the Cholesky factorization of an SPD matrix',94),(15,'c','potrf','HPD','full','Doxygen/docs/html/cpotrf_8f.html','computes the Cholesky factorization of an HPD matrix',95),(16,'z','potrf','HPD','full','Doxygen/docs/html/zpotrf_8f.html','computes the Cholesky factorization of an HPD matrix',96),(17,'s','pptrf','SPD','packed','Doxygen/docs/html/spptrf_8f.html','computes the Cholesky factorization of an SPD matrix stored in packed format',97),(18,'d','pptrf','SPD','packed','Doxygen/docs/html/dpptrf_8f.html','computes the Cholesky factorization of an SPD matrix stored in packed format',98),(19,'c','pptrf','HPD','packed','Doxygen/docs/html/cpptrf_8f.html','computes the Cholesky factorization of an HPD matrix stored in packed format',99),(20,'z','pptrf','HPD','packed','Doxygen/docs/html/zpptrf_8f.html','computes the Cholesky factorization of an HPD matrix stored in packed format',100),(21,'s','pbtrf','SPD','band','Doxygen/docs/html/spbtrf_8f.html','computes the Cholesky factorization of an SPD band matrix',101),(22,'d','pbtrf','SPD','band','Doxygen/docs/html/dpbtrf_8f.html','computes the Cholesky factorization of an SPD band matrix',102),(23,'c','pbtrf','HPD','band','Doxygen/docs/html/cpbtrf_8f.html','computes the Cholesky factorization of an HPD band matrix',103),(24,'z','pbtrf','HPD','band','Doxygen/docs/html/zpbtrf_8f.html','computes the Cholesky factorization of an HPD band matrix',104),(25,'s','pttrf','SPD','tridiagonal','Doxygen/docs/html/spttrf_8f.html','computes the L*D*L**T factorization of an SPD tridiagonal matrix',105),(26,'d','pttrf','SPD','tridiagonal','Doxygen/docs/html/dpttrf_8f.html','computes the L*D*L**T factorization of an SPD tridiagonal matrix',106),(27,'c','pttrf','HPD','tridiagonal','Doxygen/docs/html/cpttrf_8f.html','computes the L*D*L**T factorization of an HPD tridiagonal matrix',107),(28,'z','pttrf','HPD','tridiagonal','Doxygen/docs/html/zpttrf_8f.html','computes the L*D*L**T factorization of an HPD tridiagonal matrix',108),(29,'s','sytrf','symmetric','full','Doxygen/docs/html/ssytrf_8f.html','computes the factorization of a real symmetric matrix using the Bunch-Kaufman diagonal pivoting method',109),(30,'d','sytrf','symmetric','full','Doxygen/docs/html/dsytrf_8f.html','computes the factorization of a real symmetric matrix using the Bunch-Kaufman diagonal pivoting method',110),(31,'c','hetrf','Hermitian','full','Doxygen/docs/html/chetrf_8f.html','computes the factorization of a complex Hermitian matrix using the Bunch-Kaufman diagonal pivoting method',111),(32,'z','hetrf','Hermitian','full','Doxygen/docs/html/zhetrf_8f.html','computes the factorization of a complex Hermitian matrix using the Bunch-Kaufman diagonal pivoting method',112),(33,'c','sytrf','symmetric','full','Doxygen/docs/html/csytrf_8f.html','computes the factorization of a complex symmetric matrix using the Bunch-Kaufman diagonal pivoting method',113),(34,'z','sytrf','symmetric','full','Doxygen/docs/html/zsytrf_8f.html','computes the factorization of a complex symmetric matrix using the Bunch-Kaufman diagonal pivoting method',114),(35,'s','sptrf','symmetric','packed','Doxygen/docs/html/ssptrf_8f.html','computes the factorization of a real symmetric matrix stored in packed format using the Bunch-Kaufman diagonal pivoting method',115),(36,'d','sptrf','symmetric','packed','Doxygen/docs/html/dsptrf_8f.html','computes the factorization of a real symmetric matrix stored in packed format using the Bunch-Kaufman diagonal pivoting method',116),(37,'c','hptrf','Hermitian','packed','Doxygen/docs/html/chptrf_8f.html','computes the factorization of a complex Hermitian packed matrix using the Bunch-Kaufman diagonal pivoting method',117),(38,'z','hptrf','Hermitian','packed','Doxygen/docs/html/zhptrf_8f.html','computes the factorization of a complex Hermitian packed matrix using the Bunch-Kaufman diagonal pivoting method',118),(39,'c','sptrf','symmetric','packed','Doxygen/docs/html/csptrf_8f.html','computes the factorization of a complex symmetric matrix stored in packed format using the Bunch-Kaufman diagonal pivoting method',119),(40,'z','sptrf','symmetric','packed','Doxygen/docs/html/zsptrf_8f.html','computes the factorization of a complex symmetric matrix stored in packed format using the Bunch-Kaufman diagonal pivoting method',120),(41,'s','pftrf','SPD','full','Doxygen/docs/html/spftrf_8f.html','computes the Cholesky factorization of a real Hermitian positive definite matrix; RFP format',361),(42,'d','pftrf','SPD','full','Doxygen/docs/html/dpftrf_8f.html','computes the Cholesky factorization of a real Hermitian positive definite matrix; RFP format',362),(43,'c','pftrf','HPD','full','Doxygen/docs/html/cpftrf_8f.html','computes the Cholesky factorization of a complex Hermitian positive definite matrix; RFP format',363),(44,'z','pftrf','HPD','full','Doxygen/docs/html/zpftrf_8f.html','computes the Cholesky factorization of a complex Hermitian positive definite matrix; RFP format',364),(45,'s','pstrf','semidefinite','full','Doxygen/docs/html/spstrf_8f.html','computes the Cholesky factorization with complete pivoting of a real Hermitian positive semidefinite matrix',365),(46,'d','pstrf','semidefinite','full','Doxygen/docs/html/dpstrf_8f.html','computes the Cholesky factorization with complete pivoting of a real Hermitian positive semidefinite matrix',366),(47,'c','pstrf','semidefinite','full','Doxygen/docs/html/cpstrf_8f.html','computes the Cholesky factorization with complete pivoting of a complex Hermitian positive semidefinite matrix',367),(48,'z','pstrf','semidefinite','full','Doxygen/docs/html/zpstrf_8f.html','computes the Cholesky factorization with complete pivoting of a complex Hermitian positive semidefinite matrix',368);
/*!40000 ALTER TABLE `computational_linearequation_factor` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `computational_linearequation_invert`
--

DROP TABLE IF EXISTS `computational_linearequation_invert`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `computational_linearequation_invert` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Computational_linearequation_invert_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=57 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `computational_linearequation_invert`
--

LOCK TABLES `computational_linearequation_invert` WRITE;
/*!40000 ALTER TABLE `computational_linearequation_invert` DISABLE KEYS */;
INSERT INTO `computational_linearequation_invert` VALUES (1,'s','getri','general','full','Doxygen/docs/html/sgetri_8f.html','computes the inverse of a matrix',277),(2,'d','getri','general','full','Doxygen/docs/html/dgetri_8f.html','computes the inverse of a matrix',278),(3,'c','getri','general','full','Doxygen/docs/html/cgetri_8f.html','computes the inverse of a matrix',279),(4,'z','getri','general','full','Doxygen/docs/html/zgetri_8f.html','computes the inverse of a matrix',280),(5,'c','hetri','Hermitian','full','Doxygen/docs/html/chetri_8f.html','computes the inverse of a matrix',281),(6,'z','hetri','Hermitian','full','Doxygen/docs/html/zhetri_8f.html','computes the inverse of a matrix',282),(7,'c','hptri','Hermitian','packed','Doxygen/docs/html/chptri_8f.html','computes the inverse of a matrix',283),(8,'z','hptri','Hermitian','packed','Doxygen/docs/html/zhptri_8f.html','computes the inverse of a matrix',284),(9,'s','potri','SPD','full','Doxygen/docs/html/spotri_8f.html','computes the inverse of a matrix',285),(10,'d','potri','SPD','full','Doxygen/docs/html/dpotri_8f.html','computes the inverse of a matrix',286),(11,'c','potri','HPD','full','Doxygen/docs/html/cpotri_8f.html','computes the inverse of a matrix',287),(12,'z','potri','HPD','full','Doxygen/docs/html/zpotri_8f.html','computes the inverse of a matrix',288),(13,'s','pptri','SPD','packed','Doxygen/docs/html/spptri_8f.html','computes the inverse of a matrix',289),(14,'d','pptri','SPD','packed','Doxygen/docs/html/dpptri_8f.html','computes the inverse of a matrix',290),(15,'c','pptri','HPD','packed','Doxygen/docs/html/cpptri_8f.html','computes the inverse of a matrix',291),(16,'z','pptri','HPD','packed','Doxygen/docs/html/zpptri_8f.html','computes the inverse of a matrix',292),(17,'s','sytri','symmetric','full','Doxygen/docs/html/ssytri_8f.html','computes the inverse of a matrix',293),(18,'d','sytri','symmetric','full','Doxygen/docs/html/dsytri_8f.html','computes the inverse of a matrix',294),(19,'c','sytri','symmetric','full','Doxygen/docs/html/csytri_8f.html','computes the inverse of a matrix',295),(20,'z','sytri','symmetric','full','Doxygen/docs/html/zsytri_8f.html','computes the inverse of a matrix',296),(21,'s','sptri','symmetric','packed','Doxygen/docs/html/ssptri_8f.html','computes the inverse of a matrix',297),(22,'d','sptri','symmetric','packed','Doxygen/docs/html/dsptri_8f.html','computes the inverse of a matrix',298),(23,'c','sptri','symmetric','packed','Doxygen/docs/html/csptri_8f.html','computes the inverse of a matrix',299),(24,'z','sptri','symmetric','packed','Doxygen/docs/html/zsptri_8f.html','computes the inverse of a matrix',300),(25,'s','trtri','triangular','full','Doxygen/docs/html/strtri_8f.html','computes the inverse of a matrix',301),(26,'d','trtri','triangular','full','Doxygen/docs/html/dtrtri_8f.html','computes the inverse of a matrix',302),(27,'c','trtri','triangular','full','Doxygen/docs/html/ctrtri_8f.html','computes the inverse of a matrix',303),(28,'z','trtri','triangular','full','Doxygen/docs/html/ztrtri_8f.html','computes the inverse of a matrix',304),(29,'s','tptri','triangular','packed','Doxygen/docs/html/stptri_8f.html','computes the inverse of a matrix',305),(30,'d','tptri','triangular','packed','Doxygen/docs/html/dtptri_8f.html','computes the inverse of a matrix',306),(31,'c','tptri','triangular','packed','Doxygen/docs/html/ctptri_8f.html','computes the inverse of a matrix',307),(32,'z','tptri','triangular','packed','Doxygen/docs/html/ztptri_8f.html','computes the inverse of a matrix',308),(33,'s','pftri','SPD','full','Doxygen/docs/html/spftri_8f.html','computes the inverse using the Cholesky factorization; computed by SPFTRF',369),(34,'d','pftri','SPD','full','Doxygen/docs/html/dpftri_8f.html','computes the inverse using the Cholesky factorization; computed by DPFTRF',370),(35,'c','pftri','HPD','full','Doxygen/docs/html/cpftri_8f.html','computes the inverse using the Cholesky factorization; computed by CPFTRF',371),(36,'z','pftri','HPD','full','Doxygen/docs/html/zpftri_8f.html','computes the inverse using the Cholesky factorization; computed by ZPFTRF',372),(37,'s','tftri','triangular','full','Doxygen/docs/html/stftri_8f.html','computes the inverse of a matrix; stored in RFP format ',373),(38,'d','tftri','triangular','full','Doxygen/docs/html/dtftri_8f.html','computes the inverse of a matrix; stored in RFP format ',374),(39,'c','tftri','triangular','full','Doxygen/docs/html/ctftri_8f.html','computes the inverse of a matrix; stored in RFP format ',375),(40,'z','tftri','triangular','full','Doxygen/docs/html/ztftri_8f.html','computes the inverse of a matrix; stored in RFP format ',376),(41,'s','sytri2','symmetric','full','Doxygen/docs/html/ssytri2_8f.html','computes the inverse of a matrix; computed by SSYTRF; sets the LEADING DIMENSION of the workspace',377),(42,'d','sytri2','symmetric','full','Doxygen/docs/html/dsytri2_8f.html','computes the inverse of a matrix; computed by DSYTRF; sets the LEADING DIMENSION of the workspace',378),(43,'c','sytri2','symmetric','full','Doxygen/docs/html/csytri2_8f.html','computes the inverse of a matrix; computed by CSYTRF; sets the LEADING DIMENSION of the workspace',379),(44,'z','sytri2','symmetric','full','Doxygen/docs/html/zsytri2_8f.html','computes the inverse of a matrix; computed by ZSYTRF; sets the LEADING DIMENSION of the workspace',380),(45,'c','hetri2','Hermitian','full','Doxygen/docs/html/chetri2_8f.html','computes the inverse of a matrix; computed by CHETRF; sets the LEADING DIMENSION of the workspace',381),(46,'z','hetri2','Hermitian','full','Doxygen/docs/html/zhetri2_8f.html','computes the inverse of a matrix; computed by ZHETRF; sets the LEADING DIMENSION of the workspace',382),(47,'s','sytri2x','symmetric','full','Doxygen/docs/html/ssytri2x_8f.html','computes the inverse of a matrix; computed by SSYTRF',383),(48,'d','sytri2x','symmetric','full','Doxygen/docs/html/dsytri2x_8f.html','computes the inverse of a matrix; computed by DSYTRF',384),(49,'c','sytri2x','symmetric','full','Doxygen/docs/html/csytri2x_8f.html','computes the inverse of a matrix; computed by CSYTRF',385),(50,'z','sytri2x','symmetric','full','Doxygen/docs/html/zsytri2x_8f.html','computes the inverse of a matrix; computed by ZSYTRF',386),(51,'c','hetri2x','Hermitian','full','Doxygen/docs/html/chetri2x_8f.html','computes the inverse of a matrix; computed by CHETRF',387),(52,'z','hetri2x','Hermitian','full','Doxygen/docs/html/zhetri2x_8f.html','computes the inverse of a matrix; computed by ZHETRF',388),(53,'s','trti2','triangular','full','Doxygen/docs/html/strti2_8f.html','computes the inverse of a matrix; upper or lower triangular matrix; Level 2 BLA',389),(54,'d','trti2','triangular','full','Doxygen/docs/html/dtrti2_8f.html','computes the inverse of a matrix; upper or lower triangular matrix; Level 2 BLA',390),(55,'c','trti2','triangular','full','Doxygen/docs/html/ctrti2_8f.html','computes the inverse of a matrix; upper or lower triangular matrix; Level 2 BLA',391),(56,'z','trti2','triangular','full','Doxygen/docs/html/ztrti2_8f.html','computes the inverse of a matrix; upper or lower triangular matrix; Level 2 BLA',392);
/*!40000 ALTER TABLE `computational_linearequation_invert` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `computational_linearequation_solve`
--

DROP TABLE IF EXISTS `computational_linearequation_solve`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `computational_linearequation_solve` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Computational_linearequation_solve_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=63 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `computational_linearequation_solve`
--

LOCK TABLES `computational_linearequation_solve` WRITE;
/*!40000 ALTER TABLE `computational_linearequation_solve` DISABLE KEYS */;
INSERT INTO `computational_linearequation_solve` VALUES (1,'s','getrs','general','full','Doxygen/docs/html/sgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by SGETRF',121),(2,'d','getrs','general','full','Doxygen/docs/html/dgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by DGETRF',122),(3,'c','getrs','general','full','Doxygen/docs/html/cgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by CGETRF',123),(4,'z','getrs','general','full','Doxygen/docs/html/zgetrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by ZGETRF',124),(5,'s','gbtrs','general','band','Doxygen/docs/html/sgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by SGBTRF',125),(6,'d','gbtrs','general','band','Doxygen/docs/html/dgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by DGBTRF',126),(7,'c','gbtrs','general','band','Doxygen/docs/html/cgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by CGBTRF',127),(8,'z','gbtrs','general','band','Doxygen/docs/html/zgbtrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by ZGBTRF',128),(9,'s','gttrs','general','tridiagonal','Doxygen/docs/html/sgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by SGTTRF',129),(10,'d','gttrs','general','tridiagonal','Doxygen/docs/html/dgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by DGTTRF',130),(11,'c','gttrs','general','tridiagonal','Doxygen/docs/html/cgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by CGTTRF',131),(12,'z','gttrs','general','tridiagonal','Doxygen/docs/html/zgttrs_8f.html','computational; solve A*X = B using LU; Transpose; computed by ZGTTRF',132),(13,'s','potrs','SPD','full','Doxygen/docs/html/spotrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPOTRF',133),(14,'d','potrs','SPD','full','Doxygen/docs/html/dpotrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPOTRF',134),(15,'c','potrs','HPD','full','Doxygen/docs/html/cpotrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPOTRF',135),(16,'z','potrs','HPD','full','Doxygen/docs/html/zpotrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPOTRF',136),(17,'s','pptrs','SPD','packed','Doxygen/docs/html/spptrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPPTRF',137),(18,'d','pptrs','SPD','packed','Doxygen/docs/html/dpptrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPPTRF',138),(19,'c','pptrs','HPD','packed','Doxygen/docs/html/cpptrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPPTRF',139),(20,'z','pptrs','HPD','packed','Doxygen/docs/html/zpptrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPPTRF',140),(21,'s','pbtrs','SPD','band','Doxygen/docs/html/spbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPBTRF',141),(22,'d','pbtrs','SPD','band','Doxygen/docs/html/dpbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPBTRF',142),(23,'c','pbtrs','HPD','band','Doxygen/docs/html/cpbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPBTRF',143),(24,'z','pbtrs','HPD','band','Doxygen/docs/html/zpbtrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPBTRF',144),(25,'s','pttrs','SPD','tridiagonal','Doxygen/docs/html/spttrs_8f.html','computational; solve A*X = B using the L*D*L**T; computed by SPTTRF',145),(26,'d','pttrs','SPD','tridiagonal','Doxygen/docs/html/dpttrs_8f.html','computational; solve A*X = B using the L*D*L**T; computed by DPTTRF ',146),(27,'c','pttrs','HPD','tridiagonal','Doxygen/docs/html/cpttrs_8f.html','computational; solve A*X = B using A = U**H*D*U or A = L*D*L**H; computed by CPTTRF',147),(28,'z','pttrs','HPD','tridiagonal','Doxygen/docs/html/zpttrs_8f.html','computational; solve A*X = B using A = U**H*D*U or A = L*D*L**H; computed by ZPTTRF',148),(29,'s','sytrs','symmetric','full','Doxygen/docs/html/ssytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by SSYTRF ',149),(30,'d','sytrs','symmetric','full','Doxygen/docs/html/dsytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by DSYTRF ',150),(31,'c','sytrs','symmetric','full','Doxygen/docs/html/csytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by CSYTRF',151),(32,'z','sytrs','symmetric','full','Doxygen/docs/html/zsytrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by ZSYTRF',152),(33,'s','sptrs','symmetric','packed','Doxygen/docs/html/ssptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by SSPTRF',153),(34,'d','sptrs','symmetric','packed','Doxygen/docs/html/dsptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by DSPTRF',154),(35,'c','sptrs','symmetric','packed','Doxygen/docs/html/csptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by CSPTRF',155),(36,'z','sptrs','symmetric','packed','Doxygen/docs/html/zsptrs_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by ZSPTRF ',156),(37,'c','hetrs','Hermitian','full','Doxygen/docs/html/chetrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by CHETRF',157),(38,'z','hetrs','Hermitian','full','Doxygen/docs/html/zhetrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by ZHETRF',158),(39,'c','hptrs','Hermitian','packed','Doxygen/docs/html/chptrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by CHPTRF',159),(40,'z','hptrs','Hermitian','packed','Doxygen/docs/html/zhptrs_8f.html','computational; solve A*X = B using U*D*U*H or L*D*L*H; computed by ZHPTRF',160),(41,'s','trtrs','triangular','full','Doxygen/docs/html/strtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',161),(42,'d','trtrs','triangular','full','Doxygen/docs/html/dtrtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',162),(43,'c','trtrs','triangular','full','Doxygen/docs/html/ctrtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',163),(44,'z','trtrs','triangular','full','Doxygen/docs/html/ztrtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',164),(45,'s','tptrs','triangular','packed','Doxygen/docs/html/stptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',165),(46,'d','tptrs','triangular','packed','Doxygen/docs/html/dtptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',166),(47,'c','tptrs','triangular','packed','Doxygen/docs/html/ctptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',167),(48,'z','tptrs','triangular','packed','Doxygen/docs/html/ztptrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',168),(49,'s','tbtrs','triangular','band','Doxygen/docs/html/stbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',169),(50,'d','tbtrs','triangular','band','Doxygen/docs/html/dtbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',170),(51,'c','tbtrs','triangular','band','Doxygen/docs/html/ctbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',171),(52,'z','tbtrs','triangular','band','Doxygen/docs/html/ztbtrs_8f.html','computational; solve A*X = B; B is an N-by-NRHS matrix; Transpose',172),(53,'s','pftrs','SPD','full','Doxygen/docs/html/spftrs_8f.html','computational; solve A*X = B using Cholesky; computed by SPFTRF',333),(54,'d','pftrs','SPD','full','Doxygen/docs/html/dpftrs_8f.html','computational; solve A*X = B using Cholesky; computed by DPFTRF',334),(55,'c','pftrs','HPD','full','Doxygen/docs/html/cpftrs_8f.html','computational; solve A*X = B using Cholesky; computed by CPFTRF',335),(56,'z','pftrs','HPD','full','Doxygen/docs/html/zpftrs_8f.html','computational; solve A*X = B using Cholesky; computed by ZPFTRF',336),(57,'s','sytrs2','symmetric','full','Doxygen/docs/html/ssytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by SSYTRF and converted by SSYCONV',337),(58,'d','sytrs2','symmetric','full','Doxygen/docs/html/dsytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by DSYTRF and converted by DSYCONV',338),(59,'c','sytrs2','symmetric','full','Doxygen/docs/html/csytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by CSYTRF and converted by CSYCONV',339),(60,'z','sytrs2','symmetric','full','Doxygen/docs/html/zsytrs2_8f.html','computational; solve A*X = B using A = U*D*U**T or A = L*D*L**T; computed by ZSYTRF and converted by ZSYCONV',340),(61,'c','hetrs2','Hermitian','full','Doxygen/docs/html/chetrs2_8f.html','computational; solve A*X = B using A = U*D*U**H or A = L*D*L**H; computed by CHETRF and converted by CSYCONV',341),(62,'z','hetrs2','Hermitian','full','Doxygen/docs/html/zhetrs2_8f.html','computational; solve A*X = B using A = U*D*U**H or A = L*D*L**H; computed by ZHETRF and converted by ZSYCONV',342);
/*!40000 ALTER TABLE `computational_linearequation_solve` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_admin_log`
--

DROP TABLE IF EXISTS `django_admin_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_admin_log` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `action_time` datetime NOT NULL,
  `user_id` int(11) NOT NULL,
  `content_type_id` int(11) DEFAULT NULL,
  `object_id` longtext,
  `object_repr` varchar(200) NOT NULL,
  `action_flag` smallint(5) unsigned NOT NULL,
  `change_message` longtext NOT NULL,
  PRIMARY KEY (`id`),
  KEY `django_admin_log_403f60f` (`user_id`),
  KEY `django_admin_log_1bb8f392` (`content_type_id`)
) ENGINE=MyISAM AUTO_INCREMENT=59 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_admin_log`
--

LOCK TABLES `django_admin_log` WRITE;
/*!40000 ALTER TABLE `django_admin_log` DISABLE KEYS */;
INSERT INTO `django_admin_log` VALUES (1,'2012-09-13 15:15:08',1,19,'1','Registration information for albert',3,''),(2,'2012-09-13 17:10:01',1,19,'4','Registration information for hello',3,''),(3,'2012-09-13 17:10:01',1,19,'3','Registration information for Albert3',3,''),(4,'2012-09-13 17:10:01',1,19,'2','Registration information for Albert4',3,''),(5,'2012-09-13 17:10:10',1,19,'5','Registration information for batman',3,''),(6,'2012-09-13 17:32:56',1,19,'10','Registration information for qqw',3,''),(7,'2012-09-13 17:32:56',1,19,'9','Registration information for dda',3,''),(8,'2012-09-13 17:32:56',1,19,'8','Registration information for cc',3,''),(9,'2012-09-13 17:32:56',1,19,'7','Registration information for as',3,''),(10,'2012-09-13 17:32:56',1,19,'6','Registration information for anna',3,''),(11,'2012-09-13 18:05:27',1,19,'12','Registration information for junk',3,''),(12,'2012-09-13 18:05:27',1,19,'11','Registration information for jb',3,''),(13,'2012-09-17 16:02:46',1,19,'18','Registration information for joe88',3,''),(14,'2012-09-17 16:02:46',1,19,'17','Registration information for joe888',3,''),(15,'2012-09-17 16:02:46',1,19,'16','Registration information for awan',3,''),(16,'2012-09-17 16:02:46',1,19,'15','Registration information for ccb',3,''),(17,'2012-09-17 16:02:46',1,19,'14','Registration information for anna6',3,''),(18,'2012-09-17 16:02:46',1,19,'13','Registration information for dfg',3,''),(19,'2012-09-20 13:45:45',1,19,'24','Registration information for junk2@ustw.info',3,''),(20,'2012-09-20 13:45:45',1,19,'23','Registration information for cat666',3,''),(21,'2012-09-20 13:45:45',1,19,'22','Registration information for cat123',3,''),(22,'2012-09-20 13:45:45',1,19,'21','Registration information for norris',3,''),(23,'2012-09-20 13:45:45',1,19,'20','Registration information for cat',3,''),(24,'2012-09-20 13:45:45',1,19,'19','Registration information for dudu',3,''),(25,'2012-09-20 13:48:27',1,19,'25','Registration information for joe@gmail.com',3,''),(26,'2012-09-20 13:49:20',1,3,'2','albert',3,''),(27,'2012-09-20 13:49:20',1,3,'4','Albert3',3,''),(28,'2012-09-20 13:49:20',1,3,'3','Albert4',3,''),(29,'2012-09-20 13:49:20',1,3,'7','anna',3,''),(30,'2012-09-20 13:49:20',1,3,'15','anna6',3,''),(31,'2012-09-20 13:49:20',1,3,'8','as',3,''),(32,'2012-09-20 13:49:20',1,3,'17','awan',3,''),(33,'2012-09-20 13:49:20',1,3,'6','batman',3,''),(34,'2012-09-20 13:49:20',1,3,'22','cat',3,''),(35,'2012-09-20 13:49:20',1,3,'24','cat123',3,''),(36,'2012-09-20 13:49:20',1,3,'25','cat666',3,''),(37,'2012-09-20 13:49:20',1,3,'9','cc',3,''),(38,'2012-09-20 13:49:20',1,3,'16','ccb',3,''),(39,'2012-09-20 13:49:20',1,3,'10','dda',3,''),(40,'2012-09-20 13:49:20',1,3,'14','dfg',3,''),(41,'2012-09-20 13:49:20',1,3,'21','dog',3,''),(42,'2012-09-20 13:49:20',1,3,'20','dudu',3,''),(43,'2012-09-20 13:49:20',1,3,'5','hello',3,''),(44,'2012-09-20 13:49:20',1,3,'12','jb',3,''),(45,'2012-09-20 13:49:20',1,3,'19','joe88',3,''),(46,'2012-09-20 13:49:20',1,3,'18','joe888',3,''),(47,'2012-09-20 13:49:20',1,3,'27','joe@gmail.com',3,''),(48,'2012-09-20 13:49:20',1,3,'13','junk',3,''),(49,'2012-09-20 13:49:20',1,3,'26','junk2@ustw.info',3,''),(50,'2012-09-20 13:49:20',1,3,'23','norris',3,''),(51,'2012-09-20 13:49:20',1,3,'11','qqw',3,''),(52,'2012-09-20 15:34:33',1,3,'28','sasa1688@gmail.com',3,''),(53,'2012-09-20 16:50:39',1,19,'29','Registration information for salinbernst@gmail.com',3,''),(54,'2012-09-20 16:50:39',1,19,'28','Registration information for junk2@ustw.info',3,''),(55,'2012-09-20 16:50:39',1,19,'27','Registration information for sasa1688@gmail.com',3,''),(56,'2012-09-20 16:50:52',1,3,'30','junk2@ustw.info',3,''),(57,'2012-09-20 16:50:52',1,3,'31','salinbernst@gmail.com',3,''),(58,'2012-09-20 16:50:52',1,3,'29','sasa1688@gmail.com',3,'');
/*!40000 ALTER TABLE `django_admin_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_content_type`
--

DROP TABLE IF EXISTS `django_content_type`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_content_type` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `name` varchar(100) NOT NULL,
  `app_label` varchar(100) NOT NULL,
  `model` varchar(100) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `app_label` (`app_label`,`model`)
) ENGINE=MyISAM AUTO_INCREMENT=20 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_content_type`
--

LOCK TABLES `django_content_type` WRITE;
/*!40000 ALTER TABLE `django_content_type` DISABLE KEYS */;
INSERT INTO `django_content_type` VALUES (1,'permission','auth','permission'),(2,'group','auth','group'),(3,'user','auth','user'),(4,'content type','contenttypes','contenttype'),(5,'session','sessions','session'),(6,'log entry','admin','logentry'),(7,'routine info','Driver','routineinfo'),(8,'linear equation_driver','Driver','linearequation_driver'),(9,'linear equation_simple','Driver','linearequation_simple'),(10,'linear equation_expert','Driver','linearequation_expert'),(11,'linear equation_computational','Computational','linearequation_computational'),(12,'linear equation_factor','Computational','linearequation_factor'),(13,'linear equation_solve','Computational','linearequation_solve'),(14,'linear equation_condition_number','Computational','linearequation_condition_number'),(15,'linear equation_error_bound','Computational','linearequation_error_bound'),(16,'linear equation_invert','Computational','linearequation_invert'),(17,'linear equation_equilibrate','Computational','linearequation_equilibrate'),(18,'linear equation_only','Combine','linearequation_only'),(19,'registration profile','registration','registrationprofile');
/*!40000 ALTER TABLE `django_content_type` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `django_session`
--

DROP TABLE IF EXISTS `django_session`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `django_session` (
  `session_key` varchar(40) NOT NULL,
  `session_data` longtext NOT NULL,
  `expire_date` datetime NOT NULL,
  PRIMARY KEY (`session_key`),
  KEY `django_session_3da3d3d8` (`expire_date`)
) ENGINE=MyISAM DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `django_session`
--

LOCK TABLES `django_session` WRITE;
/*!40000 ALTER TABLE `django_session` DISABLE KEYS */;
INSERT INTO `django_session` VALUES ('14518d7310379b525bdfdb8539e9f754','NGIyZjkyYTYyN2I3ZWY4ODI3NjIwOGJjZTM2YzA1NWUwZmM5ZmFkMzqAAn1xAShVEFF1ZXN0aW9u\nX2NvbXBsZXhdcQIoVQFuVQJub3EDZVUUUXVlc3Rpb25fc3RvcmFnZXR5cGVdcQQoWAQAAABmdWxs\ncQVYBAAAAGZ1bGxxBmVVEVF1ZXN0aW9uX2VxdWF0aW9uXXEHKEsASwBlVQxzY3JpcHRPdXRwdXRV\nAFUNX2F1dGhfdXNlcl9pZIoBAVUQUXVlc3Rpb25fcHJvYmxlbV1xCFguAAAAQ29tcHV0YXRpb25h\nbCBMaW5lYXJFcXVhdGlvbl9lcnJvcl9ib3VuZCBlcnJvcnEJVUtDb21wdXRlIGZvcndhcmQgb3Ig\nYmFja3dhcmQgZXJyb3IgYm91bmQgZm9yIHRoZSBzb2x1dGlvbiB0byBhIGxpbmVhciBzeXN0ZW1x\nCoZxC2FVD1F1ZXN0aW9uX2ZhY3Rvcl1xDChLAEsAZVUIUm91dGluZXNjZGphbmdvLmRiLm1vZGVs\ncy5xdWVyeQpRdWVyeVNldApxDSmBcQ59cQ8oVQVfaXRlcnEQTlUOX3N0aWNreV9maWx0ZXJxEYlV\nA19kYnESTlUNX3Jlc3VsdF9jYWNoZXETXXEUKGNkamFuZ28uZGIubW9kZWxzLmJhc2UKbW9kZWxf\ndW5waWNrbGUKcRVjQ29tcHV0YXRpb25hbC5tb2RlbHMKTGluZWFyRXF1YXRpb25fZXJyb3JfYm91\nbmQKcRZdY2RqYW5nby5kYi5tb2RlbHMuYmFzZQpzaW1wbGVfY2xhc3NfZmFjdG9yeQpxF4dScRh9\ncRkoVQptYXRyaXhUeXBlcRpYBwAAAGdlbmVyYWxVC3N0b3JhZ2VUeXBlcRtYBAAAAGZ1bGxVBW5v\ndGVzcRxYPwAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVy\nYXRpdmUgcmVmaW5lbWVudFUGX3N0YXRlcR1jZGphbmdvLmRiLm1vZGVscy5iYXNlCk1vZGVsU3Rh\ndGUKcR4pgXEffXEgKFUGYWRkaW5ncSGJVQJkYnEiVQdkZWZhdWx0cSN1YlUDdXJscSRYIAAAAERv\neHlnZW4vZG9jcy9odG1sL3NnZXJmc184Zi5odG1sVQx0aGVQcmVjaXNpb25xJVgBAAAAc1ULX2lu\nZm9fY2FjaGVxJmgVY0RyaXZlci5tb2RlbHMKUm91dGluZUluZm8KcSddaBeHUnEofXEpKFUEaW5m\nb3EqWDsMAABTR0VSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVt\nIG9mIGxpbmVhcgplcXVhdGlvbnMgYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dh\ncmQgZXJyb3IgZXN0aW1hdGVzIGZvcgp0aGUgc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2lu\nXSBUUkFOUwogICAgICAgICBUUkFOUyBpcyBDSEFSQUNURVIqMQogICAgICAgICBTcGVjaWZpZXMg\ndGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnM6CiAgICAgICAgID0gJ04nOiAgQSAq\nIFggPSBCICAgICAoTm8gdHJhbnNwb3NlKQogICAgICAgICA9ICdUJzogIEEqKlQgKiBYID0gQiAg\nKFRyYW5zcG9zZSkKICAgICAgICAgPSAnQyc6ICBBKipIICogWCA9IEIgIChDb25qdWdhdGUgdHJh\nbnNwb3NlID0gVHJhbnNwb3NlKQpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAg\nICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJI\nUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBo\nYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1h\ndHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQQogICAgICAgICBBIGlzIFJF\nQUwgYXJyYXksIGRpbWVuc2lvbiAoTERBLE4pCiAgICAgICAgIFRoZSBvcmlnaW5hbCBOLWJ5LU4g\nbWF0cml4IEEuClxwYXJhbVtpbl0gTERBCiAgICAgICAgIExEQSBpcyBJTlRFR0VSCiAgICAgICAg\nIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQS4gIExEQSA+PSBtYXgoMSxOKS4K\nXHBhcmFtW2luXSBBRgogICAgICAgICBBRiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKExEQUYs\nTikKICAgICAgICAgVGhlIGZhY3RvcnMgTCBhbmQgVSBmcm9tIHRoZSBmYWN0b3JpemF0aW9uIEEg\nPSBQKkwqVQogICAgICAgICBhcyBjb21wdXRlZCBieSBTR0VUUkYuClxwYXJhbVtpbl0gTERBRgog\nICAgICAgICBMREFGIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9m\nIHRoZSBhcnJheSBBRi4gIExEQUYgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gSVBJVgogICAgICAg\nICBJUElWIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgICAgICAgVGhlIHBpdm90\nIGluZGljZXMgZnJvbSBTR0VUUkY7IGZvciAxPD1pPD1OLCByb3cgaSBvZiB0aGUKICAgICAgICAg\nbWF0cml4IHdhcyBpbnRlcmNoYW5nZWQgd2l0aCByb3cgSVBJVihpKS4KXHBhcmFtW2luXSBCCiAg\nICAgICAgIEIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhl\nIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlz\nIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAg\nTERCID49IG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgUkVBTCBhcnJh\neSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBt\nYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgU0dFVFJTLgogICAgICAgICBPbiBleGl0LCB0aGUgaW1w\ncm92ZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJ\nTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExE\nWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIFJFQUwgYXJy\nYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9y\nIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGopICh0aGUgai10aCBj\nb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRSVUUgaXMgdGhl\nIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAgICAgICAgIGlz\nIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2Vz\ndAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25p\ndHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBUaGUgZXN0aW1h\ndGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBSQ09ORCwgYW5k\nIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRlIG9mIHRoZSB0\ncnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgUkVBTCBhcnJheSwg\nZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBiYWNr\nd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBYKGopIChpLmUuLCB0\naGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBlbGVtZW50IG9mIEEg\nb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1bb3V0XSBXT1JL\nCiAgICAgICAgIFdPUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uICgzKk4pClxwYXJhbVtvdXRd\nIElXT1JLCiAgICAgICAgIElXT1JLIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKXHBh\ncmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgICAgPSAwOiAgc3Vj\nY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1l\nbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRNQVgg\naXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50LgpB\ndXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxp\nZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhv\nciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCByZWFsR0Vjb21wdXRhdGlv\nbmFsCmgdaB4pgXErfXEsKGghiWgiaCN1YlUCaWRxLYoC4QBVB3JvdXRpbmVxLlgOAAAAc2dlcmZz\nXzIyNS50eHR1YlUHaW5mb19pZHEvigLhAFULcm91dGluZU5hbWVxMFgFAAAAZ2VyZnNoLYoBAXVi\naBVoFl1oF4dScTF9cTIoaBpYBwAAAGdlbmVyYWxoG1gEAAAAZnVsbGgcWD8AAABlcnJvciBib3Vu\nZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlczsgaXRlcmF0aXZlIHJlZmluZW1lbnRoHWge\nKYFxM31xNChoIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwvZGdlcmZzXzhmLmh0bWxo\nJVgBAAAAZGgmaBVoJ11oF4dScTV9cTYoaCpYkQwAAERHRVJGUyBpbXByb3ZlcyB0aGUgY29tcHV0\nZWQgc29sdXRpb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyCmVxdWF0aW9ucyBhbmQgcHJvdmlkZXMg\nZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMgZm9yCnRoZSBzb2x1dGlv\nbi4KQXJndW1lbnRzOgpccGFyYW1baW5dIFRSQU5TCiAgICAgICAgIFRSQU5TIGlzIENIQVJBQ1RF\nUioxCiAgICAgICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiB0aGUgc3lzdGVtIG9mIGVxdWF0aW9u\nczoKICAgICAgICAgPSAnTic6ICBBICogWCA9IEIgICAgIChObyB0cmFuc3Bvc2UpCiAgICAgICAg\nID0gJ1QnOiAgQSoqVCAqIFggPSBCICAoVHJhbnNwb3NlKQogICAgICAgICA9ICdDJzogIEEqKkgg\nKiBYID0gQiAgKENvbmp1Z2F0ZSB0cmFuc3Bvc2UgPSBUcmFuc3Bvc2UpClxwYXJhbVtpbl0gTgog\nICAgICAgICBOIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4g\nIE4gPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAg\nICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29s\ndW1ucwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFt\nW2luXSBBCiAgICAgICAgIEEgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChM\nREEsTikKICAgICAgICAgVGhlIG9yaWdpbmFsIE4tYnktTiBtYXRyaXggQS4KXHBhcmFtW2luXSBM\nREEKICAgICAgICAgTERBIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9u\nIG9mIHRoZSBhcnJheSBBLiAgTERBID49IG1heCgxLE4pLgpccGFyYW1baW5dIEFGCiAgICAgICAg\nIEFGIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTERBRixOKQogICAgICAg\nICBUaGUgZmFjdG9ycyBMIGFuZCBVIGZyb20gdGhlIGZhY3Rvcml6YXRpb24gQSA9IFAqTCpVCiAg\nICAgICAgIGFzIGNvbXB1dGVkIGJ5IERHRVRSRi4KXHBhcmFtW2luXSBMREFGCiAgICAgICAgIExE\nQUYgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5\nIEFGLiAgTERBRiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBJUElWCiAgICAgICAgIElQSVYgaXMg\nSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgICAgICBUaGUgcGl2b3QgaW5kaWNlcyBm\ncm9tIERHRVRSRjsgZm9yIDE8PWk8PU4sIHJvdyBpIG9mIHRoZQogICAgICAgICBtYXRyaXggd2Fz\nIGludGVyY2hhbmdlZCB3aXRoIHJvdyBJUElWKGkpLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBp\ncyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBU\naGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIg\naXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIu\nICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBET1VCTEUg\nUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgICAgICBPbiBlbnRyeSwg\ndGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBieSBER0VUUlMuCiAgICAgICAgIE9u\nIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAg\nICAgICAgTERYIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRo\nZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZF\nUlIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBU\naGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24gdmVjdG9y\nCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0cml4IFgp\nLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRv\nIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0\naGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgoaikgLSBY\nVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJnZXN0IGVs\nZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAgICAgICB0\naGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdodAogICAg\nICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJFUlIKICAg\nICAgICAgQkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAg\nICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2gg\nc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2\nZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMgWChq\nKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBE\nT1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKDMqTikKXHBhcmFtW291dF0gSVdPUksK\nICAgICAgICAgSVdPUksgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0\nXSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVs\nIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQg\nYW4gaWxsZWdhbCB2YWx1ZQpccGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUg\nbWF4aW11bSBudW1iZXIgb2Ygc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6\nClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEg\nQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBM\ndGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIGRvdWJsZUdFY29tcHV0YXRpb25hbApo\nHWgeKYFxN31xOChoIYloImgjdWJoLYoC4gBoLlgOAAAAZGdlcmZzXzIyNi50eHR1YmgvigLiAGgw\nWAUAAABnZXJmc2gtigECdWJoFWgWXWgXh1JxOX1xOihoGlgHAAAAZ2VuZXJhbGgbWAQAAABmdWxs\naBxYPwAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRp\ndmUgcmVmaW5lbWVudGgdaB4pgXE7fXE8KGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRt\nbC9jZ2VyZnNfOGYuaHRtbGglWAEAAABjaCZoFWgnXWgXh1JxPX1xPihoKlg+DAAAQ0dFUkZTIGlt\ncHJvdmVzIHRoZSBjb21wdXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKZXF1YXRp\nb25zIGFuZCBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRl\ncyBmb3IKdGhlIHNvbHV0aW9uLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVFJBTlMKICAgICAgICAg\nVFJBTlMgaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgU3BlY2lmaWVzIHRoZSBmb3JtIG9mIHRoZSBz\neXN0ZW0gb2YgZXF1YXRpb25zOgogICAgICAgICA9ICdOJzogIEEgKiBYID0gQiAgICAgKE5vIHRy\nYW5zcG9zZSkKICAgICAgICAgPSAnVCc6ICBBKipUICogWCA9IEIgIChUcmFuc3Bvc2UpCiAgICAg\nICAgID0gJ0MnOiAgQSoqSCAqIFggPSBCICAoQ29uanVnYXRlIHRyYW5zcG9zZSkKXHBhcmFtW2lu\nXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJp\neCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAg\nICAgICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBv\nZiBjb2x1bW5zCiAgICAgICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpc\ncGFyYW1baW5dIEEKICAgICAgICAgQSBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKExEQSxO\nKQogICAgICAgICBUaGUgb3JpZ2luYWwgTi1ieS1OIG1hdHJpeCBBLgpccGFyYW1baW5dIExEQQog\nICAgICAgICBMREEgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2Yg\ndGhlIGFycmF5IEEuICBMREEgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gQUYKICAgICAgICAgQUYg\naXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREFGLE4pCiAgICAgICAgIFRoZSBmYWN0b3Jz\nIEwgYW5kIFUgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBBID0gUCpMKlUKICAgICAgICAgYXMgY29t\ncHV0ZWQgYnkgQ0dFVFJGLgpccGFyYW1baW5dIExEQUYKICAgICAgICAgTERBRiBpcyBJTlRFR0VS\nCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUYuICBMREFGID49\nIG1heCgxLE4pLgpccGFyYW1baW5dIElQSVYKICAgICAgICAgSVBJViBpcyBJTlRFR0VSIGFycmF5\nLCBkaW1lbnNpb24gKE4pCiAgICAgICAgIFRoZSBwaXZvdCBpbmRpY2VzIGZyb20gQ0dFVFJGOyBm\nb3IgMTw9aTw9Tiwgcm93IGkgb2YgdGhlCiAgICAgICAgIG1hdHJpeCB3YXMgaW50ZXJjaGFuZ2Vk\nIHdpdGggcm93IElQSVYoaSkuClxwYXJhbVtpbl0gQgogICAgICAgICBCIGlzIENPTVBMRVggYXJy\nYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0\ncml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VSCiAgICAgICAgIFRo\nZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBh\ncmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERY\nLE5SSFMpCiAgICAgICAgIE9uIGVudHJ5LCB0aGUgc29sdXRpb24gbWF0cml4IFgsIGFzIGNvbXB1\ndGVkIGJ5IENHRVRSUy4KICAgICAgICAgT24gZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0aW9uIG1h\ndHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgogICAgICAgICBU\naGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4KDEsTikuClxw\nYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5S\nSFMpCiAgICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciBib3VuZCBmb3IgZWFjaCBz\nb2x1dGlvbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhlIGotdGggY29sdW1uIG9mIHRoZSBzb2x1\ndGlvbiBtYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVFIGlzIHRoZSB0cnVlIHNvbHV0aW9uIGNv\ncnJlc3BvbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAgICAgICBpcyBhbiBlc3RpbWF0ZWQgdXBw\nZXIgYm91bmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGxhcmdlc3QKICAgICAgICAgZWxlbWVu\ndCBpbiAoWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRoZSBtYWduaXR1ZGUgb2YgdGhlCiAgICAg\nICAgIGxhcmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhlIGVzdGltYXRlIGlzIGFzIHJlbGlhYmxl\nIGFzCiAgICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNPTkQsIGFuZCBpcyBhbG1vc3QgYWx3YXlz\nIGEgc2xpZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBvZiB0aGUgdHJ1ZSBlcnJvci4KXHBhcmFt\nW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUykK\nICAgICAgICAgVGhlIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFj\naCBzb2x1dGlvbgogICAgICAgICB2ZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0\naXZlIGNoYW5nZSBpbgogICAgICAgICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBY\nKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlz\nIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBSV09SSwogICAgICAg\nICBSV09SSyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRdIElORk8KICAg\nICAgICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3NmdWwgZXhpdAogICAg\nICAgICA8IDA6ICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2Fs\nIHZhbHVlClxwYXIgSW50ZXJuYWwgUGFyYW1ldGVyczoKIElUTUFYIGlzIHRoZSBtYXhpbXVtIG51\nbWJlciBvZiBzdGVwcyBvZiBpdGVyYXRpdmUgcmVmaW5lbWVudC4KQXV0aG9yczoKXGF1dGhvciBV\nbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBCZXJrZWxleSAK\nXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0ZC4gClxkYXRl\nIE5vdmVtYmVyIDIwMTEKXGluZ3JvdXAgY29tcGxleEdFY29tcHV0YXRpb25hbApoHWgeKYFxP31x\nQChoIYloImgjdWJoLYoC4wBoLlgOAAAAY2dlcmZzXzIyNy50eHR1YmgvigLjAGgwWAUAAABnZXJm\nc2gtigEDdWJoFWgWXWgXh1JxQX1xQihoGlgHAAAAZ2VuZXJhbGgbWAQAAABmdWxsaBxYPwAAAGVy\ncm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5l\nbWVudGgdaB4pgXFDfXFEKGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC96Z2VyZnNf\nOGYuaHRtbGglWAEAAAB6aCZoFWgnXWgXh1JxRX1xRihoKlhzDAAAWkdFUkZTIGltcHJvdmVzIHRo\nZSBjb21wdXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKZXF1YXRpb25zIGFuZCBw\ncm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcyBmb3IKdGhl\nIHNvbHV0aW9uLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVFJBTlMKICAgICAgICAgVFJBTlMgaXMg\nQ0hBUkFDVEVSKjEKICAgICAgICAgU3BlY2lmaWVzIHRoZSBmb3JtIG9mIHRoZSBzeXN0ZW0gb2Yg\nZXF1YXRpb25zOgogICAgICAgICA9ICdOJzogIEEgKiBYID0gQiAgICAgKE5vIHRyYW5zcG9zZSkK\nICAgICAgICAgPSAnVCc6ICBBKipUICogWCA9IEIgIChUcmFuc3Bvc2UpCiAgICAgICAgID0gJ0Mn\nOiAgQSoqSCAqIFggPSBCICAoQ29uanVnYXRlIHRyYW5zcG9zZSkKXHBhcmFtW2luXSBOCiAgICAg\nICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+\nPSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICAgICAgIFRo\nZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5z\nCiAgICAgICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFyYW1baW5d\nIEEKICAgICAgICAgQSBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQSxOKQogICAg\nICAgICBUaGUgb3JpZ2luYWwgTi1ieS1OIG1hdHJpeCBBLgpccGFyYW1baW5dIExEQQogICAgICAg\nICBMREEgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFy\ncmF5IEEuICBMREEgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gQUYKICAgICAgICAgQUYgaXMgQ09N\nUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChMREFGLE4pCiAgICAgICAgIFRoZSBmYWN0b3JzIEwg\nYW5kIFUgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBBID0gUCpMKlUKICAgICAgICAgYXMgY29tcHV0\nZWQgYnkgWkdFVFJGLgpccGFyYW1baW5dIExEQUYKICAgICAgICAgTERBRiBpcyBJTlRFR0VSCiAg\nICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUYuICBMREFGID49IG1h\neCgxLE4pLgpccGFyYW1baW5dIElQSVYKICAgICAgICAgSVBJViBpcyBJTlRFR0VSIGFycmF5LCBk\naW1lbnNpb24gKE4pCiAgICAgICAgIFRoZSBwaXZvdCBpbmRpY2VzIGZyb20gWkdFVFJGOyBmb3Ig\nMTw9aTw9Tiwgcm93IGkgb2YgdGhlCiAgICAgICAgIG1hdHJpeCB3YXMgaW50ZXJjaGFuZ2VkIHdp\ndGggcm93IElQSVYoaSkuClxwYXJhbVtpbl0gQgogICAgICAgICBCIGlzIENPTVBMRVgqMTYgYXJy\nYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0\ncml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VSCiAgICAgICAgIFRo\nZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBh\ncmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAo\nTERYLE5SSFMpCiAgICAgICAgIE9uIGVudHJ5LCB0aGUgc29sdXRpb24gbWF0cml4IFgsIGFzIGNv\nbXB1dGVkIGJ5IFpHRVRSUy4KICAgICAgICAgT24gZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0aW9u\nIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgogICAgICAg\nICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4KDEsTiku\nClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5\nLCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciBi\nb3VuZCBmb3IgZWFjaCBzb2x1dGlvbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhlIGotdGggY29s\ndW1uIG9mIHRoZSBzb2x1dGlvbiBtYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVFIGlzIHRoZSB0\ncnVlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAgICAgICBpcyBh\nbiBlc3RpbWF0ZWQgdXBwZXIgYm91bmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGxhcmdlc3QK\nICAgICAgICAgZWxlbWVudCBpbiAoWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRoZSBtYWduaXR1\nZGUgb2YgdGhlCiAgICAgICAgIGxhcmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhlIGVzdGltYXRl\nIGlzIGFzIHJlbGlhYmxlIGFzCiAgICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNPTkQsIGFuZCBp\ncyBhbG1vc3QgYWx3YXlzIGEgc2xpZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBvZiB0aGUgdHJ1\nZSBlcnJvci4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIERPVUJMRSBQUkVDSVNJ\nT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGNvbXBvbmVudHdpc2UgcmVs\nYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1dGlvbgogICAgICAgICB2ZWN0b3IgWChq\nKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbgogICAgICAgICBhbnkgZWxl\nbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFt\nW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAo\nMipOKQpccGFyYW1bb3V0XSBSV09SSwogICAgICAgICBSV09SSyBpcyBET1VCTEUgUFJFQ0lTSU9O\nIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRdIElORk8KICAgICAgICAgSU5GTyBpcyBJ\nTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3NmdWwgZXhpdAogICAgICAgICA8IDA6ICBpZiBJ\nTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVlClxwYXIgSW50\nZXJuYWwgUGFyYW1ldGVyczoKIElUTUFYIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzdGVwcyBv\nZiBpdGVyYXRpdmUgcmVmaW5lbWVudC4KQXV0aG9yczoKXGF1dGhvciBVbml2LiBvZiBUZW5uZXNz\nZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBCZXJrZWxleSAKXGF1dGhvciBVbml2LiBv\nZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0ZC4gClxkYXRlIE5vdmVtYmVyIDIwMTEK\nXGluZ3JvdXAgY29tcGxleDE2R0Vjb21wdXRhdGlvbmFsCmgdaB4pgXFHfXFIKGghiWgiaCN1Ymgt\nigLkAGguWA4AAAB6Z2VyZnNfMjI4LnR4dHViaC+KAuQAaDBYBQAAAGdlcmZzaC2KAQR1YmgVaBZd\naBeHUnFJfXFKKGgaWAcAAABnZW5lcmFsaBtYBAAAAGJhbmRoHFg/AAAAZXJyb3IgYm91bmRzIGFu\nZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZpbmVtZW50aB1oHimBcUt9\ncUwoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4vZG9jcy9odG1sL3NnYnJmc184Zi5odG1saCVYAQAA\nAHNoJmgVaCddaBeHUnFNfXFOKGgqWNgOAABTR0JSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNv\nbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2ll\nbnQgbWF0cml4IGlzIGJhbmRlZCwgYW5kIHByb3ZpZGVzCmVycm9yIGJvdW5kcyBhbmQgYmFja3dh\ncmQgZXJyb3IgZXN0aW1hdGVzIGZvciB0aGUgc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2lu\nXSBUUkFOUwogICAgICAgICBUUkFOUyBpcyBDSEFSQUNURVIqMQogICAgICAgICBTcGVjaWZpZXMg\ndGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnM6CiAgICAgICAgID0gJ04nOiAgQSAq\nIFggPSBCICAgICAoTm8gdHJhbnNwb3NlKQogICAgICAgICA9ICdUJzogIEEqKlQgKiBYID0gQiAg\nKFRyYW5zcG9zZSkKICAgICAgICAgPSAnQyc6ICBBKipIICogWCA9IEIgIChDb25qdWdhdGUgdHJh\nbnNwb3NlID0gVHJhbnNwb3NlKQpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAg\nICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gS0wK\nICAgICAgICAgS0wgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHN1YmRpYWdvbmFs\ncyB3aXRoaW4gdGhlIGJhbmQgb2YgQS4gIEtMID49IDAuClxwYXJhbVtpbl0gS1UKICAgICAgICAg\nS1UgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHN1cGVyZGlhZ29uYWxzIHdpdGhp\nbiB0aGUgYmFuZCBvZiBBLiAgS1UgPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMg\naXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4s\nIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4g\nIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBBQgogICAgICAgICBBQiBpcyBSRUFMIGFycmF5LCBkaW1l\nbnNpb24gKExEQUIsTikKICAgICAgICAgVGhlIG9yaWdpbmFsIGJhbmQgbWF0cml4IEEsIHN0b3Jl\nZCBpbiByb3dzIDEgdG8gS0wrS1UrMS4KICAgICAgICAgVGhlIGotdGggY29sdW1uIG9mIEEgaXMg\nc3RvcmVkIGluIHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUKICAgICAgICAgYXJyYXkgQUIgYXMgZm9s\nbG93czoKICAgICAgICAgQUIoa3UrMStpLWosaikgPSBBKGksaikgZm9yIG1heCgxLGota3UpPD1p\nPD1taW4obixqK2tsKS4KXHBhcmFtW2luXSBMREFCCiAgICAgICAgIExEQUIgaXMgSU5URUdFUgog\nICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFCLiAgTERBQiA+PSBL\nTCtLVSsxLgpccGFyYW1baW5dIEFGQgogICAgICAgICBBRkIgaXMgUkVBTCBhcnJheSwgZGltZW5z\naW9uIChMREFGQixOKQogICAgICAgICBEZXRhaWxzIG9mIHRoZSBMVSBmYWN0b3JpemF0aW9uIG9m\nIHRoZSBiYW5kIG1hdHJpeCBBLCBhcwogICAgICAgICBjb21wdXRlZCBieSBTR0JUUkYuICBVIGlz\nIHN0b3JlZCBhcyBhbiB1cHBlciB0cmlhbmd1bGFyIGJhbmQKICAgICAgICAgbWF0cml4IHdpdGgg\nS0wrS1Ugc3VwZXJkaWFnb25hbHMgaW4gcm93cyAxIHRvIEtMK0tVKzEsIGFuZAogICAgICAgICB0\naGUgbXVsdGlwbGllcnMgdXNlZCBkdXJpbmcgdGhlIGZhY3Rvcml6YXRpb24gYXJlIHN0b3JlZCBp\nbgogICAgICAgICByb3dzIEtMK0tVKzIgdG8gMipLTCtLVSsxLgpccGFyYW1baW5dIExEQUZCCiAg\nICAgICAgIExEQUZCIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9m\nIHRoZSBhcnJheSBBRkIuICBMREFGQiA+PSAyKktMKktVKzEuClxwYXJhbVtpbl0gSVBJVgogICAg\nICAgICBJUElWIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgICAgICAgVGhlIHBp\ndm90IGluZGljZXMgZnJvbSBTR0JUUkY7IGZvciAxPD1pPD1OLCByb3cgaSBvZiB0aGUKICAgICAg\nICAgbWF0cml4IHdhcyBpbnRlcmNoYW5nZWQgd2l0aCByb3cgSVBJVihpKS4KXHBhcmFtW2luXSBC\nCiAgICAgICAgIEIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAg\nVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERC\nIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBC\nLiAgTERCID49IG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgUkVBTCBh\ncnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBzb2x1dGlv\nbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgU0dCVFJTLgogICAgICAgICBPbiBleGl0LCB0aGUg\naW1wcm92ZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBp\ncyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4g\nIExEWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIFJFQUwg\nYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVy\ncm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGopICh0aGUgai10\naCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRSVUUgaXMg\ndGhlIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAgICAgICAg\nIGlzIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0aGUgbGFy\nZ2VzdAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkgdGhlIG1h\nZ25pdHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBUaGUgZXN0\naW1hdGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBSQ09ORCwg\nYW5kIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRlIG9mIHRo\nZSB0cnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgUkVBTCBhcnJh\neSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBi\nYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBYKGopIChpLmUu\nLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBlbGVtZW50IG9m\nIEEgb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1bb3V0XSBX\nT1JLCiAgICAgICAgIFdPUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uICgzKk4pClxwYXJhbVtv\ndXRdIElXT1JLCiAgICAgICAgIElXT1JLIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikK\nXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgICAgPSAwOiAg\nc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAtaSwgdGhlIGktdGggYXJn\ndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRN\nQVggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50\nLgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBD\nYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1\ndGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCByZWFsR0Jjb21wdXRh\ndGlvbmFsCmgdaB4pgXFPfXFQKGghiWgiaCN1YmgtigLlAGguWA4AAABzZ2JyZnNfMjI5LnR4dHVi\naC+KAuUAaDBYBQAAAGdicmZzaC2KAQV1YmgVaBZdaBeHUnFRfXFSKGgaWAcAAABnZW5lcmFsaBtY\nBAAAAGJhbmRoHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7\nIGl0ZXJhdGl2ZSByZWZpbmVtZW50aB1oHimBcVN9cVQoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4v\nZG9jcy9odG1sL2RnYnJmc184Zi5odG1saCVYAQAAAGRoJmgVaCddaBeHUnFVfXFWKGgqWC4PAABE\nR0JSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVh\ncgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIGJhbmRlZCwgYW5kIHBy\nb3ZpZGVzCmVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzIGZvciB0aGUg\nc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2luXSBUUkFOUwogICAgICAgICBUUkFOUyBpcyBD\nSEFSQUNURVIqMQogICAgICAgICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBvZiBl\ncXVhdGlvbnM6CiAgICAgICAgID0gJ04nOiAgQSAqIFggPSBCICAgICAoTm8gdHJhbnNwb3NlKQog\nICAgICAgICA9ICdUJzogIEEqKlQgKiBYID0gQiAgKFRyYW5zcG9zZSkKICAgICAgICAgPSAnQyc6\nICBBKipIICogWCA9IEIgIChDb25qdWdhdGUgdHJhbnNwb3NlID0gVHJhbnNwb3NlKQpccGFyYW1b\naW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0\ncml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gS0wKICAgICAgICAgS0wgaXMgSU5URUdFUgogICAg\nICAgICBUaGUgbnVtYmVyIG9mIHN1YmRpYWdvbmFscyB3aXRoaW4gdGhlIGJhbmQgb2YgQS4gIEtM\nID49IDAuClxwYXJhbVtpbl0gS1UKICAgICAgICAgS1UgaXMgSU5URUdFUgogICAgICAgICBUaGUg\nbnVtYmVyIG9mIHN1cGVyZGlhZ29uYWxzIHdpdGhpbiB0aGUgYmFuZCBvZiBBLiAgS1UgPj0gMC4K\nXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVt\nYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAg\nICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBBQgog\nICAgICAgICBBQiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKExEQUIsTikK\nICAgICAgICAgVGhlIG9yaWdpbmFsIGJhbmQgbWF0cml4IEEsIHN0b3JlZCBpbiByb3dzIDEgdG8g\nS0wrS1UrMS4KICAgICAgICAgVGhlIGotdGggY29sdW1uIG9mIEEgaXMgc3RvcmVkIGluIHRoZSBq\nLXRoIGNvbHVtbiBvZiB0aGUKICAgICAgICAgYXJyYXkgQUIgYXMgZm9sbG93czoKICAgICAgICAg\nQUIoa3UrMStpLWosaikgPSBBKGksaikgZm9yIG1heCgxLGota3UpPD1pPD1taW4obixqK2tsKS4K\nXHBhcmFtW2luXSBMREFCCiAgICAgICAgIExEQUIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVh\nZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFCLiAgTERBQiA+PSBLTCtLVSsxLgpccGFyYW1b\naW5dIEFGQgogICAgICAgICBBRkIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9u\nIChMREFGQixOKQogICAgICAgICBEZXRhaWxzIG9mIHRoZSBMVSBmYWN0b3JpemF0aW9uIG9mIHRo\nZSBiYW5kIG1hdHJpeCBBLCBhcwogICAgICAgICBjb21wdXRlZCBieSBER0JUUkYuICBVIGlzIHN0\nb3JlZCBhcyBhbiB1cHBlciB0cmlhbmd1bGFyIGJhbmQKICAgICAgICAgbWF0cml4IHdpdGggS0wr\nS1Ugc3VwZXJkaWFnb25hbHMgaW4gcm93cyAxIHRvIEtMK0tVKzEsIGFuZAogICAgICAgICB0aGUg\nbXVsdGlwbGllcnMgdXNlZCBkdXJpbmcgdGhlIGZhY3Rvcml6YXRpb24gYXJlIHN0b3JlZCBpbgog\nICAgICAgICByb3dzIEtMK0tVKzIgdG8gMipLTCtLVSsxLgpccGFyYW1baW5dIExEQUZCCiAgICAg\nICAgIExEQUZCIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRo\nZSBhcnJheSBBRkIuICBMREFGQiA+PSAyKktMKktVKzEuClxwYXJhbVtpbl0gSVBJVgogICAgICAg\nICBJUElWIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgICAgICAgVGhlIHBpdm90\nIGluZGljZXMgZnJvbSBER0JUUkY7IGZvciAxPD1pPD1OLCByb3cgaSBvZiB0aGUKICAgICAgICAg\nbWF0cml4IHdhcyBpbnRlcmNoYW5nZWQgd2l0aCByb3cgSVBJVihpKS4KXHBhcmFtW2luXSBCCiAg\nICAgICAgIEIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykK\nICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAg\nICAgICAgTERCIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRo\nZSBhcnJheSBCLiAgTERCID49IG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFgg\naXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAg\nT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgREdCVFJTLgog\nICAgICAgICBPbiBleGl0LCB0aGUgaW1wcm92ZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtp\nbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVu\nc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgog\nICAgICAgICBGRVJSIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykK\nICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0\naW9uIHZlY3RvcgogICAgICAgICBYKGopICh0aGUgai10aCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9u\nIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRSVUUgaXMgdGhlIHRydWUgc29sdXRpb24gY29ycmVz\ncG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAgICAgICAgIGlzIGFuIGVzdGltYXRlZCB1cHBlciBi\nb3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2VzdAogICAgICAgICBlbGVtZW50IGlu\nIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25pdHVkZSBvZiB0aGUKICAgICAgICAg\nbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBUaGUgZXN0aW1hdGUgaXMgYXMgcmVsaWFibGUgYXMK\nICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBSQ09ORCwgYW5kIGlzIGFsbW9zdCBhbHdheXMgYSBz\nbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRlIG9mIHRoZSB0cnVlIGVycm9yLgpccGFyYW1bb3V0\nXSBCRVJSCiAgICAgICAgIEJFUlIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9u\nIChOUkhTKQogICAgICAgICBUaGUgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJv\nciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBYKGopIChpLmUuLCB0aGUgc21hbGxl\nc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0\nIG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAg\nIFdPUksgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uICgzKk4pClxwYXJhbVtv\ndXRdIElXT1JLCiAgICAgICAgIElXT1JLIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikK\nXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgICAgPSAwOiAg\nc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAtaSwgdGhlIGktdGggYXJn\ndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRN\nQVggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50\nLgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBD\nYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1\ndGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCBkb3VibGVHQmNvbXB1\ndGF0aW9uYWwKaB1oHimBcVd9cVgoaCGJaCJoI3ViaC2KAuYAaC5YDgAAAGRnYnJmc18yMzAudHh0\ndWJoL4oC5gBoMFgFAAAAZ2JyZnNoLYoBBnViaBVoFl1oF4dScVl9cVooaBpYBwAAAGdlbmVyYWxo\nG1gEAAAAYmFuZGgcWD8AAABlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRl\nczsgaXRlcmF0aXZlIHJlZmluZW1lbnRoHWgeKYFxW31xXChoIYloImgjdWJoJFggAAAARG94eWdl\nbi9kb2NzL2h0bWwvY2dicmZzXzhmLmh0bWxoJVgBAAAAY2gmaBVoJ11oF4dScV19cV4oaCpY2w4A\nAENHQlJGUyBpbXByb3ZlcyB0aGUgY29tcHV0ZWQgc29sdXRpb24gdG8gYSBzeXN0ZW0gb2YgbGlu\nZWFyCmVxdWF0aW9ucyB3aGVuIHRoZSBjb2VmZmljaWVudCBtYXRyaXggaXMgYmFuZGVkLCBhbmQg\ncHJvdmlkZXMKZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMgZm9yIHRo\nZSBzb2x1dGlvbi4KQXJndW1lbnRzOgpccGFyYW1baW5dIFRSQU5TCiAgICAgICAgIFRSQU5TIGlz\nIENIQVJBQ1RFUioxCiAgICAgICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiB0aGUgc3lzdGVtIG9m\nIGVxdWF0aW9uczoKICAgICAgICAgPSAnTic6ICBBICogWCA9IEIgICAgIChObyB0cmFuc3Bvc2Up\nCiAgICAgICAgID0gJ1QnOiAgQSoqVCAqIFggPSBCICAoVHJhbnNwb3NlKQogICAgICAgICA9ICdD\nJzogIEEqKkggKiBYID0gQiAgKENvbmp1Z2F0ZSB0cmFuc3Bvc2UpClxwYXJhbVtpbl0gTgogICAg\nICAgICBOIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4g\nPj0gMC4KXHBhcmFtW2luXSBLTAogICAgICAgICBLTCBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBu\ndW1iZXIgb2Ygc3ViZGlhZ29uYWxzIHdpdGhpbiB0aGUgYmFuZCBvZiBBLiAgS0wgPj0gMC4KXHBh\ncmFtW2luXSBLVQogICAgICAgICBLVSBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2Yg\nc3VwZXJkaWFnb25hbHMgd2l0aGluIHRoZSBiYW5kIG9mIEEuICBLVSA+PSAwLgpccGFyYW1baW5d\nIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2Ygcmln\naHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5zCiAgICAgICAgIG9mIHRo\nZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEFCCiAgICAgICAgIEFC\nIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERBQixOKQogICAgICAgICBUaGUgb3JpZ2lu\nYWwgYmFuZCBtYXRyaXggQSwgc3RvcmVkIGluIHJvd3MgMSB0byBLTCtLVSsxLgogICAgICAgICBU\naGUgai10aCBjb2x1bW4gb2YgQSBpcyBzdG9yZWQgaW4gdGhlIGotdGggY29sdW1uIG9mIHRoZQog\nICAgICAgICBhcnJheSBBQiBhcyBmb2xsb3dzOgogICAgICAgICBBQihrdSsxK2ktaixqKSA9IEEo\naSxqKSBmb3IgbWF4KDEsai1rdSk8PWk8PW1pbihuLGora2wpLgpccGFyYW1baW5dIExEQUIKICAg\nICAgICAgTERBQiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0\naGUgYXJyYXkgQUIuICBMREFCID49IEtMK0tVKzEuClxwYXJhbVtpbl0gQUZCCiAgICAgICAgIEFG\nQiBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKExEQUZCLE4pCiAgICAgICAgIERldGFpbHMg\nb2YgdGhlIExVIGZhY3Rvcml6YXRpb24gb2YgdGhlIGJhbmQgbWF0cml4IEEsIGFzCiAgICAgICAg\nIGNvbXB1dGVkIGJ5IENHQlRSRi4gIFUgaXMgc3RvcmVkIGFzIGFuIHVwcGVyIHRyaWFuZ3VsYXIg\nYmFuZAogICAgICAgICBtYXRyaXggd2l0aCBLTCtLVSBzdXBlcmRpYWdvbmFscyBpbiByb3dzIDEg\ndG8gS0wrS1UrMSwgYW5kCiAgICAgICAgIHRoZSBtdWx0aXBsaWVycyB1c2VkIGR1cmluZyB0aGUg\nZmFjdG9yaXphdGlvbiBhcmUgc3RvcmVkIGluCiAgICAgICAgIHJvd3MgS0wrS1UrMiB0byAyKktM\nK0tVKzEuClxwYXJhbVtpbl0gTERBRkIKICAgICAgICAgTERBRkIgaXMgSU5URUdFUgogICAgICAg\nICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFGQi4gIExEQUZCID49IDIqS0wq\nS1UrMS4KXHBhcmFtW2luXSBJUElWCiAgICAgICAgIElQSVYgaXMgSU5URUdFUiBhcnJheSwgZGlt\nZW5zaW9uIChOKQogICAgICAgICBUaGUgcGl2b3QgaW5kaWNlcyBmcm9tIENHQlRSRjsgZm9yIDE8\nPWk8PU4sIHJvdyBpIG9mIHRoZQogICAgICAgICBtYXRyaXggd2FzIGludGVyY2hhbmdlZCB3aXRo\nIHJvdyBJUElWKGkpLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBDT01QTEVYIGFycmF5LCBk\naW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBC\nLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVh\nZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtp\nbixvdXRdIFgKICAgICAgICAgWCBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhT\nKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBi\neSBDR0JUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXgg\nWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxl\nYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1b\nb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQog\nICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRp\nb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24g\nbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNw\nb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJv\ndW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4g\nKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBs\nYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwog\nICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNs\naWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRd\nIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAg\nICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29s\ndXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBj\naGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMgWChqKSBh\nbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBDT01Q\nTEVYIGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0gUldPUksKICAgICAgICAgUldP\nUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAg\nIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAg\nPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1\nZQpccGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11bSBudW1iZXIg\nb2Ygc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4g\nb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRo\nb3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBOb3Zl\nbWJlciAyMDExClxpbmdyb3VwIGNvbXBsZXhHQmNvbXB1dGF0aW9uYWwKaB1oHimBcV99cWAoaCGJ\naCJoI3ViaC2KAucAaC5YDgAAAGNnYnJmc18yMzEudHh0dWJoL4oC5wBoMFgFAAAAZ2JyZnNoLYoB\nB3ViaBVoFl1oF4dScWF9cWIoaBpYBwAAAGdlbmVyYWxoG1gEAAAAYmFuZGgcWD8AAABlcnJvciBi\nb3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlczsgaXRlcmF0aXZlIHJlZmluZW1lbnRo\nHWgeKYFxY31xZChoIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwvemdicmZzXzhmLmh0\nbWxoJVgBAAAAemgmaBVoJ11oF4dScWV9cWYoaCpYEA8AAFpHQlJGUyBpbXByb3ZlcyB0aGUgY29t\ncHV0ZWQgc29sdXRpb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyCmVxdWF0aW9ucyB3aGVuIHRoZSBj\nb2VmZmljaWVudCBtYXRyaXggaXMgYmFuZGVkLCBhbmQgcHJvdmlkZXMKZXJyb3IgYm91bmRzIGFu\nZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMgZm9yIHRoZSBzb2x1dGlvbi4KQXJndW1lbnRzOgpc\ncGFyYW1baW5dIFRSQU5TCiAgICAgICAgIFRSQU5TIGlzIENIQVJBQ1RFUioxCiAgICAgICAgIFNw\nZWNpZmllcyB0aGUgZm9ybSBvZiB0aGUgc3lzdGVtIG9mIGVxdWF0aW9uczoKICAgICAgICAgPSAn\nTic6ICBBICogWCA9IEIgICAgIChObyB0cmFuc3Bvc2UpCiAgICAgICAgID0gJ1QnOiAgQSoqVCAq\nIFggPSBCICAoVHJhbnNwb3NlKQogICAgICAgICA9ICdDJzogIEEqKkggKiBYID0gQiAgKENvbmp1\nZ2F0ZSB0cmFuc3Bvc2UpClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAgICAg\nICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBLTAogICAg\nICAgICBLTCBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2Ygc3ViZGlhZ29uYWxzIHdp\ndGhpbiB0aGUgYmFuZCBvZiBBLiAgS0wgPj0gMC4KXHBhcmFtW2luXSBLVQogICAgICAgICBLVSBp\ncyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2Ygc3VwZXJkaWFnb25hbHMgd2l0aGluIHRo\nZSBiYW5kIG9mIEEuICBLVSA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJ\nTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhl\nIG51bWJlciBvZiBjb2x1bW5zCiAgICAgICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJI\nUyA+PSAwLgpccGFyYW1baW5dIEFCCiAgICAgICAgIEFCIGlzIENPTVBMRVgqMTYgYXJyYXksIGRp\nbWVuc2lvbiAoTERBQixOKQogICAgICAgICBUaGUgb3JpZ2luYWwgYmFuZCBtYXRyaXggQSwgc3Rv\ncmVkIGluIHJvd3MgMSB0byBLTCtLVSsxLgogICAgICAgICBUaGUgai10aCBjb2x1bW4gb2YgQSBp\ncyBzdG9yZWQgaW4gdGhlIGotdGggY29sdW1uIG9mIHRoZQogICAgICAgICBhcnJheSBBQiBhcyBm\nb2xsb3dzOgogICAgICAgICBBQihrdSsxK2ktaixqKSA9IEEoaSxqKSBmb3IgbWF4KDEsai1rdSk8\nPWk8PW1pbihuLGora2wpLgpccGFyYW1baW5dIExEQUIKICAgICAgICAgTERBQiBpcyBJTlRFR0VS\nCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUIuICBMREFCID49\nIEtMK0tVKzEuClxwYXJhbVtpbl0gQUZCCiAgICAgICAgIEFGQiBpcyBDT01QTEVYKjE2IGFycmF5\nLCBkaW1lbnNpb24gKExEQUZCLE4pCiAgICAgICAgIERldGFpbHMgb2YgdGhlIExVIGZhY3Rvcml6\nYXRpb24gb2YgdGhlIGJhbmQgbWF0cml4IEEsIGFzCiAgICAgICAgIGNvbXB1dGVkIGJ5IFpHQlRS\nRi4gIFUgaXMgc3RvcmVkIGFzIGFuIHVwcGVyIHRyaWFuZ3VsYXIgYmFuZAogICAgICAgICBtYXRy\naXggd2l0aCBLTCtLVSBzdXBlcmRpYWdvbmFscyBpbiByb3dzIDEgdG8gS0wrS1UrMSwgYW5kCiAg\nICAgICAgIHRoZSBtdWx0aXBsaWVycyB1c2VkIGR1cmluZyB0aGUgZmFjdG9yaXphdGlvbiBhcmUg\nc3RvcmVkIGluCiAgICAgICAgIHJvd3MgS0wrS1UrMiB0byAyKktMK0tVKzEuClxwYXJhbVtpbl0g\nTERBRkIKICAgICAgICAgTERBRkIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1l\nbnNpb24gb2YgdGhlIGFycmF5IEFGQi4gIExEQUZCID49IDIqS0wqS1UrMS4KXHBhcmFtW2luXSBJ\nUElWCiAgICAgICAgIElQSVYgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgICAg\nICBUaGUgcGl2b3QgaW5kaWNlcyBmcm9tIFpHQlRSRjsgZm9yIDE8PWk8PU4sIHJvdyBpIG9mIHRo\nZQogICAgICAgICBtYXRyaXggd2FzIGludGVyY2hhbmdlZCB3aXRoIHJvdyBJUElWKGkpLgpccGFy\nYW1baW5dIEIKICAgICAgICAgQiBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQixO\nUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpccGFyYW1baW5dIExE\nQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24g\nb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAg\nICAgWCBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgICAgICBP\nbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBieSBaR0JUUlMuCiAg\nICAgICAgIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2lu\nXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5z\naW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAg\nICAgICAgIEZFUlIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQog\nICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRp\nb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24g\nbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNw\nb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJv\ndW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4g\nKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBs\nYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwog\nICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNs\naWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRd\nIEJFUlIKICAgICAgICAgQkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24g\nKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9y\nIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVz\ndCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQg\nbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAg\nV09SSyBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0gUldP\nUksKICAgICAgICAgUldPUksgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChO\nKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6\nICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBh\ncmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpccGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJ\nVE1BWCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1l\nbnQuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9m\nIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApc\nYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIGNvbXBsZXgxNkdC\nY29tcHV0YXRpb25hbApoHWgeKYFxZ31xaChoIYloImgjdWJoLYoC6ABoLlgOAAAAemdicmZzXzIz\nMi50eHR1YmgvigLoAGgwWAUAAABnYnJmc2gtigEIdWJoFWgWXWgXh1JxaX1xaihoGlgHAAAAZ2Vu\nZXJhbGgbWAsAAAB0cmlkaWFnb25hbGgcWD8AAABlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVy\ncm9yIGVzdGltYXRlczsgaXRlcmF0aXZlIHJlZmluZW1lbnRoHWgeKYFxa31xbChoIYloImgjdWJo\nJFggAAAARG94eWdlbi9kb2NzL2h0bWwvc2d0cmZzXzhmLmh0bWxoJVgBAAAAc2gmaBVoJ11oF4dS\ncW19cW4oaCpYcA4AAFNHVFJGUyBpbXByb3ZlcyB0aGUgY29tcHV0ZWQgc29sdXRpb24gdG8gYSBz\neXN0ZW0gb2YgbGluZWFyCmVxdWF0aW9ucyB3aGVuIHRoZSBjb2VmZmljaWVudCBtYXRyaXggaXMg\ndHJpZGlhZ29uYWwsIGFuZCBwcm92aWRlcwplcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9y\nIGVzdGltYXRlcyBmb3IgdGhlIHNvbHV0aW9uLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVFJBTlMK\nICAgICAgICAgVFJBTlMgaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgU3BlY2lmaWVzIHRoZSBmb3Jt\nIG9mIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zOgogICAgICAgICA9ICdOJzogIEEgKiBYID0gQiAg\nICAgKE5vIHRyYW5zcG9zZSkKICAgICAgICAgPSAnVCc6ICBBKipUICogWCA9IEIgIChUcmFuc3Bv\nc2UpCiAgICAgICAgID0gJ0MnOiAgQSoqSCAqIFggPSBCICAoQ29uanVnYXRlIHRyYW5zcG9zZSA9\nIFRyYW5zcG9zZSkKXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBU\naGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAg\nICAgTlJIUyBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRl\ncywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5zCiAgICAgICAgIG9mIHRoZSBtYXRyaXggQi4g\nIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBETAogICAgICAgICBETCBpcyBSRUFMIGFycmF5LCBkaW1l\nbnNpb24gKE4tMSkKICAgICAgICAgVGhlIChuLTEpIHN1YmRpYWdvbmFsIGVsZW1lbnRzIG9mIEEu\nClxwYXJhbVtpbl0gRAogICAgICAgICBEIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTikKICAg\nICAgICAgVGhlIGRpYWdvbmFsIGVsZW1lbnRzIG9mIEEuClxwYXJhbVtpbl0gRFUKICAgICAgICAg\nRFUgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOLTEpCiAgICAgICAgIFRoZSAobi0xKSBzdXBl\ncmRpYWdvbmFsIGVsZW1lbnRzIG9mIEEuClxwYXJhbVtpbl0gRExGCiAgICAgICAgIERMRiBpcyBS\nRUFMIGFycmF5LCBkaW1lbnNpb24gKE4tMSkKICAgICAgICAgVGhlIChuLTEpIG11bHRpcGxpZXJz\nIHRoYXQgZGVmaW5lIHRoZSBtYXRyaXggTCBmcm9tIHRoZQogICAgICAgICBMVSBmYWN0b3JpemF0\naW9uIG9mIEEgYXMgY29tcHV0ZWQgYnkgU0dUVFJGLgpccGFyYW1baW5dIERGCiAgICAgICAgIERG\nIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgICAgICAgVGhlIG4gZGlhZ29uYWwgZWxl\nbWVudHMgb2YgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IFUgZnJvbQogICAgICAgICB0aGUg\nTFUgZmFjdG9yaXphdGlvbiBvZiBBLgpccGFyYW1baW5dIERVRgogICAgICAgICBEVUYgaXMgUkVB\nTCBhcnJheSwgZGltZW5zaW9uIChOLTEpCiAgICAgICAgIFRoZSAobi0xKSBlbGVtZW50cyBvZiB0\naGUgZmlyc3Qgc3VwZXJkaWFnb25hbCBvZiBVLgpccGFyYW1baW5dIERVMgogICAgICAgICBEVTIg\naXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOLTIpCiAgICAgICAgIFRoZSAobi0yKSBlbGVtZW50\ncyBvZiB0aGUgc2Vjb25kIHN1cGVyZGlhZ29uYWwgb2YgVS4KXHBhcmFtW2luXSBJUElWCiAgICAg\nICAgIElQSVYgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgICAgICBUaGUgcGl2\nb3QgaW5kaWNlczsgZm9yIDEgPD0gaSA8PSBuLCByb3cgaSBvZiB0aGUgbWF0cml4IHdhcwogICAg\nICAgICBpbnRlcmNoYW5nZWQgd2l0aCByb3cgSVBJVihpKS4gIElQSVYoaSkgd2lsbCBhbHdheXMg\nYmUgZWl0aGVyCiAgICAgICAgIGkgb3IgaSsxOyBJUElWKGkpID0gaSBpbmRpY2F0ZXMgYSByb3cg\naW50ZXJjaGFuZ2Ugd2FzIG5vdAogICAgICAgICByZXF1aXJlZC4KXHBhcmFtW2luXSBCCiAgICAg\nICAgIEIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhlIHJp\nZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElO\nVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERC\nID49IG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgUkVBTCBhcnJheSwg\nZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRy\naXggWCwgYXMgY29tcHV0ZWQgYnkgU0dUVFJTLgogICAgICAgICBPbiBleGl0LCB0aGUgaW1wcm92\nZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRF\nR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+\nPSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIFJFQUwgYXJyYXks\nIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9yIGJv\ndW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGopICh0aGUgai10aCBjb2x1\nbW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRSVUUgaXMgdGhlIHRy\ndWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAgICAgICAgIGlzIGFu\nIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2VzdAog\nICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25pdHVk\nZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBUaGUgZXN0aW1hdGUg\naXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBSQ09ORCwgYW5kIGlz\nIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRlIG9mIHRoZSB0cnVl\nIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgUkVBTCBhcnJheSwgZGlt\nZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBiYWNrd2Fy\nZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBYKGopIChpLmUuLCB0aGUg\nc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBlbGVtZW50IG9mIEEgb3Ig\nQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1bb3V0XSBXT1JLCiAg\nICAgICAgIFdPUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uICgzKk4pClxwYXJhbVtvdXRdIElX\nT1JLCiAgICAgICAgIElXT1JLIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKXHBhcmFt\nW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgICAgPSAwOiAgc3VjY2Vz\nc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQg\naGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRNQVggaXMg\ndGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50LgpBdXRo\nb3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9y\nbmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBO\nQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCByZWFsT1RIRVJjb21wdXRhdGlv\nbmFsCmgdaB4pgXFvfXFwKGghiWgiaCN1YmgtigLpAGguWA4AAABzZ3RyZnNfMjMzLnR4dHViaC+K\nAukAaDBYBQAAAGd0cmZzaC2KAQl1YmgVaBZdaBeHUnFxfXFyKGgaWAcAAABnZW5lcmFsaBtYCwAA\nAHRyaWRpYWdvbmFsaBxYPwAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1h\ndGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudGgdaB4pgXFzfXF0KGghiWgiaCN1YmgkWCAAAABEb3h5\nZ2VuL2RvY3MvaHRtbC9kZ3RyZnNfOGYuaHRtbGglWAEAAABkaCZoFWgnXWgXh1JxdX1xdihoKlgC\nDwAAREdUUkZTIGltcHJvdmVzIHRoZSBjb21wdXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBs\naW5lYXIKZXF1YXRpb25zIHdoZW4gdGhlIGNvZWZmaWNpZW50IG1hdHJpeCBpcyB0cmlkaWFnb25h\nbCwgYW5kIHByb3ZpZGVzCmVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVz\nIGZvciB0aGUgc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2luXSBUUkFOUwogICAgICAgICBU\nUkFOUyBpcyBDSEFSQUNURVIqMQogICAgICAgICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5\nc3RlbSBvZiBlcXVhdGlvbnM6CiAgICAgICAgID0gJ04nOiAgQSAqIFggPSBCICAgICAoTm8gdHJh\nbnNwb3NlKQogICAgICAgICA9ICdUJzogIEEqKlQgKiBYID0gQiAgKFRyYW5zcG9zZSkKICAgICAg\nICAgPSAnQyc6ICBBKipIICogWCA9IEIgIChDb25qdWdhdGUgdHJhbnNwb3NlID0gVHJhbnNwb3Nl\nKQpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBvcmRlciBv\nZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlz\nIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0\naGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1hdHJpeCBCLiAgTlJIUyA+PSAw\nLgpccGFyYW1baW5dIERMCiAgICAgICAgIERMIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRp\nbWVuc2lvbiAoTi0xKQogICAgICAgICBUaGUgKG4tMSkgc3ViZGlhZ29uYWwgZWxlbWVudHMgb2Yg\nQS4KXHBhcmFtW2luXSBECiAgICAgICAgIEQgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGlt\nZW5zaW9uIChOKQogICAgICAgICBUaGUgZGlhZ29uYWwgZWxlbWVudHMgb2YgQS4KXHBhcmFtW2lu\nXSBEVQogICAgICAgICBEVSBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4t\nMSkKICAgICAgICAgVGhlIChuLTEpIHN1cGVyZGlhZ29uYWwgZWxlbWVudHMgb2YgQS4KXHBhcmFt\nW2luXSBETEYKICAgICAgICAgRExGIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lv\nbiAoTi0xKQogICAgICAgICBUaGUgKG4tMSkgbXVsdGlwbGllcnMgdGhhdCBkZWZpbmUgdGhlIG1h\ndHJpeCBMIGZyb20gdGhlCiAgICAgICAgIExVIGZhY3Rvcml6YXRpb24gb2YgQSBhcyBjb21wdXRl\nZCBieSBER1RUUkYuClxwYXJhbVtpbl0gREYKICAgICAgICAgREYgaXMgRE9VQkxFIFBSRUNJU0lP\nTiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgICAgICBUaGUgbiBkaWFnb25hbCBlbGVtZW50cyBv\nZiB0aGUgdXBwZXIgdHJpYW5ndWxhciBtYXRyaXggVSBmcm9tCiAgICAgICAgIHRoZSBMVSBmYWN0\nb3JpemF0aW9uIG9mIEEuClxwYXJhbVtpbl0gRFVGCiAgICAgICAgIERVRiBpcyBET1VCTEUgUFJF\nQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4tMSkKICAgICAgICAgVGhlIChuLTEpIGVsZW1lbnRz\nIG9mIHRoZSBmaXJzdCBzdXBlcmRpYWdvbmFsIG9mIFUuClxwYXJhbVtpbl0gRFUyCiAgICAgICAg\nIERVMiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4tMikKICAgICAgICAg\nVGhlIChuLTIpIGVsZW1lbnRzIG9mIHRoZSBzZWNvbmQgc3VwZXJkaWFnb25hbCBvZiBVLgpccGFy\nYW1baW5dIElQSVYKICAgICAgICAgSVBJViBpcyBJTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4p\nCiAgICAgICAgIFRoZSBwaXZvdCBpbmRpY2VzOyBmb3IgMSA8PSBpIDw9IG4sIHJvdyBpIG9mIHRo\nZSBtYXRyaXggd2FzCiAgICAgICAgIGludGVyY2hhbmdlZCB3aXRoIHJvdyBJUElWKGkpLiAgSVBJ\nVihpKSB3aWxsIGFsd2F5cyBiZSBlaXRoZXIKICAgICAgICAgaSBvciBpKzE7IElQSVYoaSkgPSBp\nIGluZGljYXRlcyBhIHJvdyBpbnRlcmNoYW5nZSB3YXMgbm90CiAgICAgICAgIHJlcXVpcmVkLgpc\ncGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNp\nb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpccGFy\nYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBk\naW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRd\nIFgKICAgICAgICAgWCBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKExEWCxO\nUkhTKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21wdXRl\nZCBieSBER1RUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1dGlvbiBtYXRy\naXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgICAgICAgVGhl\nIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFy\nYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGlt\nZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91bmQg\nZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBv\nZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBz\nb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0\naW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAg\nICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9m\nIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBh\ncyByZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMgYWxt\nb3N0IGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJy\nb3IuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFy\ncmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZl\nIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGku\nZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQg\nb2YgQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRd\nIFdPUksKICAgICAgICAgV09SSyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24g\nKDMqTikKXHBhcmFtW291dF0gSVdPUksKICAgICAgICAgSVdPUksgaXMgSU5URUdFUiBhcnJheSwg\nZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgog\nICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1p\nLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpccGFyIEludGVybmFsIFBh\ncmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3RlcHMgb2YgaXRlcmF0\naXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0\naG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3Jh\nZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3Vw\nIGRvdWJsZU9USEVSY29tcHV0YXRpb25hbApoHWgeKYFxd31xeChoIYloImgjdWJoLYoC6gBoLlgO\nAAAAZGd0cmZzXzIzNC50eHR1YmgvigLqAGgwWAUAAABndHJmc2gtigEKdWJoFWgWXWgXh1JxeX1x\neihoGlgHAAAAZ2VuZXJhbGgbWAsAAAB0cmlkaWFnb25hbGgcWD8AAABlcnJvciBib3VuZHMgYW5k\nIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlczsgaXRlcmF0aXZlIHJlZmluZW1lbnRoHWgeKYFxe31x\nfChoIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwvY2d0cmZzXzhmLmh0bWxoJVgBAAAA\nY2gmaBVoJ11oF4dScX19cX4oaCpYgg4AAENHVFJGUyBpbXByb3ZlcyB0aGUgY29tcHV0ZWQgc29s\ndXRpb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyCmVxdWF0aW9ucyB3aGVuIHRoZSBjb2VmZmljaWVu\ndCBtYXRyaXggaXMgdHJpZGlhZ29uYWwsIGFuZCBwcm92aWRlcwplcnJvciBib3VuZHMgYW5kIGJh\nY2t3YXJkIGVycm9yIGVzdGltYXRlcyBmb3IgdGhlIHNvbHV0aW9uLgpBcmd1bWVudHM6ClxwYXJh\nbVtpbl0gVFJBTlMKICAgICAgICAgVFJBTlMgaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgU3BlY2lm\naWVzIHRoZSBmb3JtIG9mIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zOgogICAgICAgICA9ICdOJzog\nIEEgKiBYID0gQiAgICAgKE5vIHRyYW5zcG9zZSkKICAgICAgICAgPSAnVCc6ICBBKipUICogWCA9\nIEIgIChUcmFuc3Bvc2UpCiAgICAgICAgID0gJ0MnOiAgQSoqSCAqIFggPSBCICAoQ29uanVnYXRl\nIHRyYW5zcG9zZSkKXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBU\naGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAg\nICAgTlJIUyBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRl\ncywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5zCiAgICAgICAgIG9mIHRoZSBtYXRyaXggQi4g\nIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBETAogICAgICAgICBETCBpcyBDT01QTEVYIGFycmF5LCBk\naW1lbnNpb24gKE4tMSkKICAgICAgICAgVGhlIChuLTEpIHN1YmRpYWdvbmFsIGVsZW1lbnRzIG9m\nIEEuClxwYXJhbVtpbl0gRAogICAgICAgICBEIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAo\nTikKICAgICAgICAgVGhlIGRpYWdvbmFsIGVsZW1lbnRzIG9mIEEuClxwYXJhbVtpbl0gRFUKICAg\nICAgICAgRFUgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChOLTEpCiAgICAgICAgIFRoZSAo\nbi0xKSBzdXBlcmRpYWdvbmFsIGVsZW1lbnRzIG9mIEEuClxwYXJhbVtpbl0gRExGCiAgICAgICAg\nIERMRiBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKE4tMSkKICAgICAgICAgVGhlIChuLTEp\nIG11bHRpcGxpZXJzIHRoYXQgZGVmaW5lIHRoZSBtYXRyaXggTCBmcm9tIHRoZQogICAgICAgICBM\nVSBmYWN0b3JpemF0aW9uIG9mIEEgYXMgY29tcHV0ZWQgYnkgQ0dUVFJGLgpccGFyYW1baW5dIERG\nCiAgICAgICAgIERGIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTikKICAgICAgICAgVGhl\nIG4gZGlhZ29uYWwgZWxlbWVudHMgb2YgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgbWF0cml4IFUgZnJv\nbQogICAgICAgICB0aGUgTFUgZmFjdG9yaXphdGlvbiBvZiBBLgpccGFyYW1baW5dIERVRgogICAg\nICAgICBEVUYgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChOLTEpCiAgICAgICAgIFRoZSAo\nbi0xKSBlbGVtZW50cyBvZiB0aGUgZmlyc3Qgc3VwZXJkaWFnb25hbCBvZiBVLgpccGFyYW1baW5d\nIERVMgogICAgICAgICBEVTIgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChOLTIpCiAgICAg\nICAgIFRoZSAobi0yKSBlbGVtZW50cyBvZiB0aGUgc2Vjb25kIHN1cGVyZGlhZ29uYWwgb2YgVS4K\nXHBhcmFtW2luXSBJUElWCiAgICAgICAgIElQSVYgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9u\nIChOKQogICAgICAgICBUaGUgcGl2b3QgaW5kaWNlczsgZm9yIDEgPD0gaSA8PSBuLCByb3cgaSBv\nZiB0aGUgbWF0cml4IHdhcwogICAgICAgICBpbnRlcmNoYW5nZWQgd2l0aCByb3cgSVBJVihpKS4g\nIElQSVYoaSkgd2lsbCBhbHdheXMgYmUgZWl0aGVyCiAgICAgICAgIGkgb3IgaSsxOyBJUElWKGkp\nID0gaSBpbmRpY2F0ZXMgYSByb3cgaW50ZXJjaGFuZ2Ugd2FzIG5vdAogICAgICAgICByZXF1aXJl\nZC4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChM\nREIsTlJIUykKICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2lu\nXSBMREIKICAgICAgICAgTERCIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5z\naW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49IG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAg\nICAgICAgIFggaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAg\nT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgQ0dUVFJTLgog\nICAgICAgICBPbiBleGl0LCB0aGUgaW1wcm92ZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtp\nbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVu\nc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgog\nICAgICAgICBGRVJSIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhl\nIGVzdGltYXRlZCBmb3J3YXJkIGVycm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3Rvcgog\nICAgICAgICBYKGopICh0aGUgai10aCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4K\nICAgICAgICAgSWYgWFRSVUUgaXMgdGhlIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBY\nKGopLCBGRVJSKGopCiAgICAgICAgIGlzIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhl\nIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2VzdAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRS\nVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25pdHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVt\nZW50IGluIFgoaikuICBUaGUgZXN0aW1hdGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhl\nIGVzdGltYXRlIGZvciBSQ09ORCwgYW5kIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAg\nICAgb3ZlcmVzdGltYXRlIG9mIHRoZSB0cnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAg\nICAgIEJFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29t\ncG9uZW50d2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAg\nICAgIHZlY3RvciBYKGopIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAg\nICAgICAgIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29s\ndXRpb24pLgpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgQ09NUExFWCBhcnJheSwg\nZGltZW5zaW9uICgyKk4pClxwYXJhbVtvdXRdIFJXT1JLCiAgICAgICAgIFJXT1JLIGlzIFJFQUwg\nYXJyYXksIGRpbWVuc2lvbiAoTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElO\nVEVHRVIKICAgICAgICAgPSAwOiAgc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElO\nRk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRl\ncm5hbCBQYXJhbWV0ZXJzOgogSVRNQVggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9m\nIGl0ZXJhdGl2ZSByZWZpbmVtZW50LgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3Nl\nZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9m\nIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpc\naW5ncm91cCBjb21wbGV4T1RIRVJjb21wdXRhdGlvbmFsCmgdaB4pgXF/fXGAKGghiWgiaCN1Ymgt\nigLrAGguWA4AAABjZ3RyZnNfMjM1LnR4dHViaC+KAusAaDBYBQAAAGd0cmZzaC2KAQt1YmgVaBZd\naBeHUnGBfXGCKGgaWAcAAABnZW5lcmFsaBtYCwAAAHRyaWRpYWdvbmFsaBxYPwAAAGVycm9yIGJv\ndW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudGgd\naB4pgXGDfXGEKGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC96Z3RyZnNfOGYuaHRt\nbGglWAEAAAB6aCZoFWgnXWgXh1JxhX1xhihoKljGDgAAWkdUUkZTIGltcHJvdmVzIHRoZSBjb21w\ndXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKZXF1YXRpb25zIHdoZW4gdGhlIGNv\nZWZmaWNpZW50IG1hdHJpeCBpcyB0cmlkaWFnb25hbCwgYW5kIHByb3ZpZGVzCmVycm9yIGJvdW5k\ncyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzIGZvciB0aGUgc29sdXRpb24uCkFyZ3VtZW50\nczoKXHBhcmFtW2luXSBUUkFOUwogICAgICAgICBUUkFOUyBpcyBDSEFSQUNURVIqMQogICAgICAg\nICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnM6CiAgICAgICAg\nID0gJ04nOiAgQSAqIFggPSBCICAgICAoTm8gdHJhbnNwb3NlKQogICAgICAgICA9ICdUJzogIEEq\nKlQgKiBYID0gQiAgKFRyYW5zcG9zZSkKICAgICAgICAgPSAnQyc6ICBBKipIICogWCA9IEIgIChD\nb25qdWdhdGUgdHJhbnNwb3NlKQpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAg\nICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJI\nUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBo\nYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1h\ndHJpeCBCLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIERMCiAgICAgICAgIERMIGlzIENPTVBMRVgq\nMTYgYXJyYXksIGRpbWVuc2lvbiAoTi0xKQogICAgICAgICBUaGUgKG4tMSkgc3ViZGlhZ29uYWwg\nZWxlbWVudHMgb2YgQS4KXHBhcmFtW2luXSBECiAgICAgICAgIEQgaXMgQ09NUExFWCoxNiBhcnJh\neSwgZGltZW5zaW9uIChOKQogICAgICAgICBUaGUgZGlhZ29uYWwgZWxlbWVudHMgb2YgQS4KXHBh\ncmFtW2luXSBEVQogICAgICAgICBEVSBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKE4t\nMSkKICAgICAgICAgVGhlIChuLTEpIHN1cGVyZGlhZ29uYWwgZWxlbWVudHMgb2YgQS4KXHBhcmFt\nW2luXSBETEYKICAgICAgICAgRExGIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTi0x\nKQogICAgICAgICBUaGUgKG4tMSkgbXVsdGlwbGllcnMgdGhhdCBkZWZpbmUgdGhlIG1hdHJpeCBM\nIGZyb20gdGhlCiAgICAgICAgIExVIGZhY3Rvcml6YXRpb24gb2YgQSBhcyBjb21wdXRlZCBieSBa\nR1RUUkYuClxwYXJhbVtpbl0gREYKICAgICAgICAgREYgaXMgQ09NUExFWCoxNiBhcnJheSwgZGlt\nZW5zaW9uIChOKQogICAgICAgICBUaGUgbiBkaWFnb25hbCBlbGVtZW50cyBvZiB0aGUgdXBwZXIg\ndHJpYW5ndWxhciBtYXRyaXggVSBmcm9tCiAgICAgICAgIHRoZSBMVSBmYWN0b3JpemF0aW9uIG9m\nIEEuClxwYXJhbVtpbl0gRFVGCiAgICAgICAgIERVRiBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1l\nbnNpb24gKE4tMSkKICAgICAgICAgVGhlIChuLTEpIGVsZW1lbnRzIG9mIHRoZSBmaXJzdCBzdXBl\ncmRpYWdvbmFsIG9mIFUuClxwYXJhbVtpbl0gRFUyCiAgICAgICAgIERVMiBpcyBDT01QTEVYKjE2\nIGFycmF5LCBkaW1lbnNpb24gKE4tMikKICAgICAgICAgVGhlIChuLTIpIGVsZW1lbnRzIG9mIHRo\nZSBzZWNvbmQgc3VwZXJkaWFnb25hbCBvZiBVLgpccGFyYW1baW5dIElQSVYKICAgICAgICAgSVBJ\nViBpcyBJTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICAgICAgIFRoZSBwaXZvdCBpbmRp\nY2VzOyBmb3IgMSA8PSBpIDw9IG4sIHJvdyBpIG9mIHRoZSBtYXRyaXggd2FzCiAgICAgICAgIGlu\ndGVyY2hhbmdlZCB3aXRoIHJvdyBJUElWKGkpLiAgSVBJVihpKSB3aWxsIGFsd2F5cyBiZSBlaXRo\nZXIKICAgICAgICAgaSBvciBpKzE7IElQSVYoaSkgPSBpIGluZGljYXRlcyBhIHJvdyBpbnRlcmNo\nYW5nZSB3YXMgbm90CiAgICAgICAgIHJlcXVpcmVkLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBp\ncyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmln\naHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5U\nRUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIg\nPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBDT01QTEVYKjE2IGFy\ncmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9u\nIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBieSBaR1RUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBp\nbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlz\nIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAg\nTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgRE9VQkxF\nIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVk\nIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgo\naikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJ\nZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIo\naikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRl\nIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRl\nZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChq\nKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUg\nZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0\naW1hdGUgb2YgdGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBp\ncyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBj\nb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAg\nICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4K\nICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBz\nb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBDT01QTEVYKjE2IGFy\ncmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0gUldPUksKICAgICAgICAgUldPUksgaXMg\nRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAg\nICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQKICAg\nICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxsZWdh\nbCB2YWx1ZQpccGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11bSBu\ndW1iZXIgb2Ygc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRob3Ig\nVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkg\nClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0\nZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIGNvbXBsZXgxNk9USEVSY29tcHV0YXRpb25hbApoHWge\nKYFxh31xiChoIYloImgjdWJoLYoC7ABoLlgOAAAAemd0cmZzXzIzNi50eHR1YmgvigLsAGgwWAUA\nAABndHJmc2gtigEMdWJoFWgWXWgXh1JxiX1xiihoGlgJAAAASGVybWl0aWFuaBtYBAAAAGZ1bGxo\nHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2\nZSByZWZpbmVtZW50aB1oHimBcYt9cYwoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4vZG9jcy9odG1s\nL2NoZXJmc184Zi5odG1saCVYAQAAAGNoJmgVaCddaBeHUnGNfXGOKGgqWB4OAABDSEVSRlMgaW1w\ncm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgplcXVhdGlv\nbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIEhlcm1pdGlhbiBpbmRlZmluaXRlLCBh\nbmQKcHJvdmlkZXMgZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMgZm9y\nIHRoZSBzb2x1dGlvbi4KQXJndW1lbnRzOgpccGFyYW1baW5dIFVQTE8KICAgICAgICAgVVBMTyBp\ncyBDSEFSQUNURVIqMQogICAgICAgICA9ICdVJzogIFVwcGVyIHRyaWFuZ2xlIG9mIEEgaXMgc3Rv\ncmVkOwogICAgICAgICA9ICdMJzogIExvd2VyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkLgpccGFy\nYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBvcmRlciBvZiB0aGUg\nbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlzIElOVEVH\nRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVt\nYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49\nIDAuClxwYXJhbVtpbl0gQQogICAgICAgICBBIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAo\nTERBLE4pCiAgICAgICAgIFRoZSBIZXJtaXRpYW4gbWF0cml4IEEuICBJZiBVUExPID0gJ1UnLCB0\naGUgbGVhZGluZyBOLWJ5LU4KICAgICAgICAgdXBwZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEgY29u\ndGFpbnMgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgcGFydAogICAgICAgICBvZiB0aGUgbWF0cml4IEEs\nIGFuZCB0aGUgc3RyaWN0bHkgbG93ZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEKICAgICAgICAgaXMg\nbm90IHJlZmVyZW5jZWQuICBJZiBVUExPID0gJ0wnLCB0aGUgbGVhZGluZyBOLWJ5LU4gbG93ZXIK\nICAgICAgICAgdHJpYW5ndWxhciBwYXJ0IG9mIEEgY29udGFpbnMgdGhlIGxvd2VyIHRyaWFuZ3Vs\nYXIgcGFydCBvZgogICAgICAgICB0aGUgbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkgdXBwZXIg\ndHJpYW5ndWxhciBwYXJ0IG9mIEEgaXMKICAgICAgICAgbm90IHJlZmVyZW5jZWQuClxwYXJhbVtp\nbl0gTERBCiAgICAgICAgIExEQSBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVu\nc2lvbiBvZiB0aGUgYXJyYXkgQS4gIExEQSA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBBRgogICAg\nICAgICBBRiBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKExEQUYsTikKICAgICAgICAgVGhl\nIGZhY3RvcmVkIGZvcm0gb2YgdGhlIG1hdHJpeCBBLiAgQUYgY29udGFpbnMgdGhlIGJsb2NrCiAg\nICAgICAgIGRpYWdvbmFsIG1hdHJpeCBEIGFuZCB0aGUgbXVsdGlwbGllcnMgdXNlZCB0byBvYnRh\naW4gdGhlCiAgICAgICAgIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBBID0g\nVSpEKlUqKkggb3IKICAgICAgICAgQSA9IEwqRCpMKipIIGFzIGNvbXB1dGVkIGJ5IENIRVRSRi4K\nXHBhcmFtW2luXSBMREFGCiAgICAgICAgIExEQUYgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVh\nZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFGLiAgTERBRiA+PSBtYXgoMSxOKS4KXHBhcmFt\nW2luXSBJUElWCiAgICAgICAgIElQSVYgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQog\nICAgICAgICBEZXRhaWxzIG9mIHRoZSBpbnRlcmNoYW5nZXMgYW5kIHRoZSBibG9jayBzdHJ1Y3R1\ncmUgb2YgRAogICAgICAgICBhcyBkZXRlcm1pbmVkIGJ5IENIRVRSRi4KXHBhcmFtW2luXSBCCiAg\nICAgICAgIEIgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAg\nVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERC\nIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBC\nLiAgTERCID49IG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgQ09NUExF\nWCBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBzb2x1\ndGlvbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgQ0hFVFJTLgogICAgICAgICBPbiBleGl0LCB0\naGUgaW1wcm92ZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExE\nWCBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkg\nWC4gIExEWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIFJF\nQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3YXJk\nIGVycm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGopICh0aGUg\nai10aCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRSVUUg\naXMgdGhlIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAgICAg\nICAgIGlzIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0aGUg\nbGFyZ2VzdAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkgdGhl\nIG1hZ25pdHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBUaGUg\nZXN0aW1hdGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBSQ09O\nRCwgYW5kIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRlIG9m\nIHRoZSB0cnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgUkVBTCBh\ncnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9uZW50d2lzZSByZWxhdGl2\nZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBYKGopIChp\nLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBlbGVtZW50\nIG9mIEEgb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1bb3V0\nXSBXT1JLCiAgICAgICAgIFdPUksgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uICgyKk4pClxw\nYXJhbVtvdXRdIFJXT1JLCiAgICAgICAgIFJXT1JLIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAo\nTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgICAgPSAw\nOiAgc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAtaSwgdGhlIGktdGgg\nYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgog\nSVRNQVggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVt\nZW50LgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBv\nZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAK\nXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCBjb21wbGV4SEVj\nb21wdXRhdGlvbmFsCmgdaB4pgXGPfXGQKGghiWgiaCN1YmgtigLtAGguWA4AAABjaGVyZnNfMjM3\nLnR4dHViaC+KAu0AaDBYBQAAAGhlcmZzaC2KAQ11YmgVaBZdaBeHUnGRfXGSKGgaWAkAAABIZXJt\naXRpYW5oG1gEAAAAZnVsbGgcWD8AAABlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVz\ndGltYXRlczsgaXRlcmF0aXZlIHJlZmluZW1lbnRoHWgeKYFxk31xlChoIYloImgjdWJoJFggAAAA\nRG94eWdlbi9kb2NzL2h0bWwvemhlcmZzXzhmLmh0bWxoJVgBAAAAemgmaBVoJ11oF4dScZV9cZYo\naCpYUw4AAFpIRVJGUyBpbXByb3ZlcyB0aGUgY29tcHV0ZWQgc29sdXRpb24gdG8gYSBzeXN0ZW0g\nb2YgbGluZWFyCmVxdWF0aW9ucyB3aGVuIHRoZSBjb2VmZmljaWVudCBtYXRyaXggaXMgSGVybWl0\naWFuIGluZGVmaW5pdGUsIGFuZApwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVy\ncm9yIGVzdGltYXRlcyBmb3IgdGhlIHNvbHV0aW9uLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVVBM\nTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUioxCiAgICAgICAgID0gJ1UnOiAgVXBwZXIgdHJp\nYW5nbGUgb2YgQSBpcyBzdG9yZWQ7CiAgICAgICAgID0gJ0wnOiAgTG93ZXIgdHJpYW5nbGUgb2Yg\nQSBpcyBzdG9yZWQuClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAgICAgICAg\nVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAg\nICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lk\nZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUgbWF0cmljZXMg\nQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBBCiAgICAgICAgIEEgaXMgQ09NUExFWCox\nNiBhcnJheSwgZGltZW5zaW9uIChMREEsTikKICAgICAgICAgVGhlIEhlcm1pdGlhbiBtYXRyaXgg\nQS4gIElmIFVQTE8gPSAnVScsIHRoZSBsZWFkaW5nIE4tYnktTgogICAgICAgICB1cHBlciB0cmlh\nbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgdXBwZXIgdHJpYW5ndWxhciBwYXJ0CiAgICAg\nICAgIG9mIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBzdHJpY3RseSBsb3dlciB0cmlhbmd1bGFyIHBh\ncnQgb2YgQQogICAgICAgICBpcyBub3QgcmVmZXJlbmNlZC4gIElmIFVQTE8gPSAnTCcsIHRoZSBs\nZWFkaW5nIE4tYnktTiBsb3dlcgogICAgICAgICB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlu\ncyB0aGUgbG93ZXIgdHJpYW5ndWxhciBwYXJ0IG9mCiAgICAgICAgIHRoZSBtYXRyaXggQSwgYW5k\nIHRoZSBzdHJpY3RseSB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2YgQSBpcwogICAgICAgICBub3Qg\ncmVmZXJlbmNlZC4KXHBhcmFtW2luXSBMREEKICAgICAgICAgTERBIGlzIElOVEVHRVIKICAgICAg\nICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBLiAgTERBID49IG1heCgxLE4p\nLgpccGFyYW1baW5dIEFGCiAgICAgICAgIEFGIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lv\nbiAoTERBRixOKQogICAgICAgICBUaGUgZmFjdG9yZWQgZm9ybSBvZiB0aGUgbWF0cml4IEEuICBB\nRiBjb250YWlucyB0aGUgYmxvY2sKICAgICAgICAgZGlhZ29uYWwgbWF0cml4IEQgYW5kIHRoZSBt\ndWx0aXBsaWVycyB1c2VkIHRvIG9idGFpbiB0aGUKICAgICAgICAgZmFjdG9yIFUgb3IgTCBmcm9t\nIHRoZSBmYWN0b3JpemF0aW9uIEEgPSBVKkQqVSoqSCBvcgogICAgICAgICBBID0gTCpEKkwqKkgg\nYXMgY29tcHV0ZWQgYnkgWkhFVFJGLgpccGFyYW1baW5dIExEQUYKICAgICAgICAgTERBRiBpcyBJ\nTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUYuICBM\nREFGID49IG1heCgxLE4pLgpccGFyYW1baW5dIElQSVYKICAgICAgICAgSVBJViBpcyBJTlRFR0VS\nIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICAgICAgIERldGFpbHMgb2YgdGhlIGludGVyY2hhbmdl\ncyBhbmQgdGhlIGJsb2NrIHN0cnVjdHVyZSBvZiBECiAgICAgICAgIGFzIGRldGVybWluZWQgYnkg\nWkhFVFJGLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1l\nbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpc\ncGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGlu\nZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixv\ndXRdIFgKICAgICAgICAgWCBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhT\nKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBi\neSBaSEVUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXgg\nWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxl\nYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1b\nb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5z\naW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91bmQgZm9y\nIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0\naGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1\ndGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1h\ndGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAg\nIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRo\nZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyBy\nZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0\nIGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJyb3Iu\nClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5\nLCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJh\nY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4s\nIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2Yg\nQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdP\nUksKICAgICAgICAgV09SSyBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBh\ncmFtW291dF0gUldPUksKICAgICAgICAgUldPUksgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwg\nZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgog\nICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1p\nLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpccGFyIEludGVybmFsIFBh\ncmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3RlcHMgb2YgaXRlcmF0\naXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0\naG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3Jh\nZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3Vw\nIGNvbXBsZXgxNkhFY29tcHV0YXRpb25hbApoHWgeKYFxl31xmChoIYloImgjdWJoLYoC7gBoLlgO\nAAAAemhlcmZzXzIzOC50eHR1YmgvigLuAGgwWAUAAABoZXJmc2gtigEOdWJoFWgWXWgXh1JxmX1x\nmihoGlgJAAAASGVybWl0aWFuaBtYBgAAAHBhY2tlZGgcWD8AAABlcnJvciBib3VuZHMgYW5kIGJh\nY2t3YXJkIGVycm9yIGVzdGltYXRlczsgaXRlcmF0aXZlIHJlZmluZW1lbnRoHWgeKYFxm31xnCho\nIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwvY2hwcmZzXzhmLmh0bWxoJVgBAAAAY2gm\naBVoJ11oF4dScZ19cZ4oaCpYEw0AAENIUFJGUyBpbXByb3ZlcyB0aGUgY29tcHV0ZWQgc29sdXRp\nb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyCmVxdWF0aW9ucyB3aGVuIHRoZSBjb2VmZmljaWVudCBt\nYXRyaXggaXMgSGVybWl0aWFuIGluZGVmaW5pdGUKYW5kIHBhY2tlZCwgYW5kIHByb3ZpZGVzIGVy\ncm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzCmZvciB0aGUgc29sdXRpb24u\nCkFyZ3VtZW50czoKXHBhcmFtW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEK\nICAgICAgICAgPSAnVSc6ICBVcHBlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZDsKICAgICAgICAg\nPSAnTCc6ICBMb3dlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZC4KXHBhcmFtW2luXSBOCiAgICAg\nICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+\nPSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICAgICAgIFRo\nZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5z\nCiAgICAgICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFyYW1baW5d\nIEFQCiAgICAgICAgIEFQIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTiooTisxKS8yKQog\nICAgICAgICBUaGUgdXBwZXIgb3IgbG93ZXIgdHJpYW5nbGUgb2YgdGhlIEhlcm1pdGlhbiBtYXRy\naXggQSwgcGFja2VkCiAgICAgICAgIGNvbHVtbndpc2UgaW4gYSBsaW5lYXIgYXJyYXkuICBUaGUg\nai10aCBjb2x1bW4gb2YgQSBpcyBzdG9yZWQKICAgICAgICAgaW4gdGhlIGFycmF5IEFQIGFzIGZv\nbGxvd3M6CiAgICAgICAgIGlmIFVQTE8gPSAnVScsIEFQKGkgKyAoai0xKSpqLzIpID0gQShpLGop\nIGZvciAxPD1pPD1qOwogICAgICAgICBpZiBVUExPID0gJ0wnLCBBUChpICsgKGotMSkqKDIqbi1q\nKS8yKSA9IEEoaSxqKSBmb3Igajw9aTw9bi4KXHBhcmFtW2luXSBBRlAKICAgICAgICAgQUZQIGlz\nIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTiooTisxKS8yKQogICAgICAgICBUaGUgZmFjdG9y\nZWQgZm9ybSBvZiB0aGUgbWF0cml4IEEuICBBRlAgY29udGFpbnMgdGhlIGJsb2NrCiAgICAgICAg\nIGRpYWdvbmFsIG1hdHJpeCBEIGFuZCB0aGUgbXVsdGlwbGllcnMgdXNlZCB0byBvYnRhaW4gdGhl\nCiAgICAgICAgIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBBID0gVSpEKlUq\nKkggb3IKICAgICAgICAgQSA9IEwqRCpMKipIIGFzIGNvbXB1dGVkIGJ5IENIUFRSRiwgc3RvcmVk\nIGFzIGEgcGFja2VkCiAgICAgICAgIHRyaWFuZ3VsYXIgbWF0cml4LgpccGFyYW1baW5dIElQSVYK\nICAgICAgICAgSVBJViBpcyBJTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICAgICAgIERl\ndGFpbHMgb2YgdGhlIGludGVyY2hhbmdlcyBhbmQgdGhlIGJsb2NrIHN0cnVjdHVyZSBvZiBECiAg\nICAgICAgIGFzIGRldGVybWluZWQgYnkgQ0hQVFJGLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBp\ncyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQg\naGFuZCBzaWRlIG1hdHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdF\nUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0g\nbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBDT01QTEVYIGFycmF5LCBk\naW1lbnNpb24gKExEWCxOUkhTKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJp\neCBYLCBhcyBjb21wdXRlZCBieSBDSFBUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBpbXByb3Zl\nZCBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVH\nRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49\nIG1heCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgUkVBTCBhcnJheSwg\nZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91\nbmQgZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVt\nbiBvZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1\nZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4g\nZXN0aW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAg\nICAgICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRl\nIG9mIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBp\ncyBhcyByZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMg\nYWxtb3N0IGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUg\nZXJyb3IuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFycmF5LCBkaW1l\nbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJk\nIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBz\nbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBC\nIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAg\nICAgICAgV09SSyBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0g\nUldPUksKICAgICAgICAgUldPUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1b\nb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNz\nZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBo\nYWQgYW4gaWxsZWdhbCB2YWx1ZQpccGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0\naGUgbWF4aW11bSBudW1iZXIgb2Ygc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhv\ncnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3Ju\naWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5B\nRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIGNvbXBsZXhPVEhFUmNvbXB1dGF0\naW9uYWwKaB1oHimBcZ99caAoaCGJaCJoI3ViaC2KAu8AaC5YDgAAAGNocHJmc18yMzkudHh0dWJo\nL4oC7wBoMFgFAAAAaHByZnNoLYoBD3ViaBVoFl1oF4dScaF9caIoaBpYCQAAAEhlcm1pdGlhbmgb\nWAYAAABwYWNrZWRoHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0\nZXM7IGl0ZXJhdGl2ZSByZWZpbmVtZW50aB1oHimBcaN9caQoaCGJaCJoI3ViaCRYIAAAAERveHln\nZW4vZG9jcy9odG1sL3pocHJmc184Zi5odG1saCVYAQAAAHpoJmgVaCddaBeHUnGlfXGmKGgqWEgN\nAABaSFBSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxp\nbmVhcgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIEhlcm1pdGlhbiBp\nbmRlZmluaXRlCmFuZCBwYWNrZWQsIGFuZCBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3\nYXJkIGVycm9yIGVzdGltYXRlcwpmb3IgdGhlIHNvbHV0aW9uLgpBcmd1bWVudHM6ClxwYXJhbVtp\nbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUioxCiAgICAgICAgID0gJ1UnOiAgVXBw\nZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQ7CiAgICAgICAgID0gJ0wnOiAgTG93ZXIgdHJpYW5n\nbGUgb2YgQSBpcyBzdG9yZWQuClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAg\nICAgICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBOUkhT\nCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhh\nbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUgbWF0\ncmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBBUAogICAgICAgICBBUCBpcyBD\nT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKE4qKE4rMSkvMikKICAgICAgICAgVGhlIHVwcGVy\nIG9yIGxvd2VyIHRyaWFuZ2xlIG9mIHRoZSBIZXJtaXRpYW4gbWF0cml4IEEsIHBhY2tlZAogICAg\nICAgICBjb2x1bW53aXNlIGluIGEgbGluZWFyIGFycmF5LiAgVGhlIGotdGggY29sdW1uIG9mIEEg\naXMgc3RvcmVkCiAgICAgICAgIGluIHRoZSBhcnJheSBBUCBhcyBmb2xsb3dzOgogICAgICAgICBp\nZiBVUExPID0gJ1UnLCBBUChpICsgKGotMSkqai8yKSA9IEEoaSxqKSBmb3IgMTw9aTw9ajsKICAg\nICAgICAgaWYgVVBMTyA9ICdMJywgQVAoaSArIChqLTEpKigyKm4taikvMikgPSBBKGksaikgZm9y\nIGo8PWk8PW4uClxwYXJhbVtpbl0gQUZQCiAgICAgICAgIEFGUCBpcyBDT01QTEVYKjE2IGFycmF5\nLCBkaW1lbnNpb24gKE4qKE4rMSkvMikKICAgICAgICAgVGhlIGZhY3RvcmVkIGZvcm0gb2YgdGhl\nIG1hdHJpeCBBLiAgQUZQIGNvbnRhaW5zIHRoZSBibG9jawogICAgICAgICBkaWFnb25hbCBtYXRy\naXggRCBhbmQgdGhlIG11bHRpcGxpZXJzIHVzZWQgdG8gb2J0YWluIHRoZQogICAgICAgICBmYWN0\nb3IgVSBvciBMIGZyb20gdGhlIGZhY3Rvcml6YXRpb24gQSA9IFUqRCpVKipIIG9yCiAgICAgICAg\nIEEgPSBMKkQqTCoqSCBhcyBjb21wdXRlZCBieSBaSFBUUkYsIHN0b3JlZCBhcyBhIHBhY2tlZAog\nICAgICAgICB0cmlhbmd1bGFyIG1hdHJpeC4KXHBhcmFtW2luXSBJUElWCiAgICAgICAgIElQSVYg\naXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgICAgICBEZXRhaWxzIG9mIHRoZSBp\nbnRlcmNoYW5nZXMgYW5kIHRoZSBibG9jayBzdHJ1Y3R1cmUgb2YgRAogICAgICAgICBhcyBkZXRl\ncm1pbmVkIGJ5IFpIUFRSRi4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIgaXMgQ09NUExFWCoxNiBh\ncnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBt\nYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVHRVIKICAgICAgICAg\nVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49IG1heCgxLE4pLgpc\ncGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9u\nIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwgYXMg\nY29tcHV0ZWQgYnkgWkhQVFJTLgogICAgICAgICBPbiBleGl0LCB0aGUgaW1wcm92ZWQgc29sdXRp\nb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICAg\nICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+PSBtYXgoMSxO\nKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIERPVUJMRSBQUkVDSVNJT04gYXJy\nYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9y\nIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGopICh0aGUgai10aCBj\nb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRSVUUgaXMgdGhl\nIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAgICAgICAgIGlz\nIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2Vz\ndAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25p\ndHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBUaGUgZXN0aW1h\ndGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBSQ09ORCwgYW5k\nIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRlIG9mIHRoZSB0\ncnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgRE9VQkxFIFBSRUNJ\nU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9uZW50d2lzZSBy\nZWxhdGl2ZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBY\nKGopIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBl\nbGVtZW50IG9mIEEgb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFy\nYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9u\nICgyKk4pClxwYXJhbVtvdXRdIFJXT1JLCiAgICAgICAgIFJXT1JLIGlzIERPVUJMRSBQUkVDSVNJ\nT04gYXJyYXksIGRpbWVuc2lvbiAoTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlz\nIElOVEVHRVIKICAgICAgICAgPSAwOiAgc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlm\nIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJ\nbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRNQVggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBz\nIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50LgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5l\nc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYu\nIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAx\nMQpcaW5ncm91cCBjb21wbGV4MTZPVEhFUmNvbXB1dGF0aW9uYWwKaB1oHimBcad9cagoaCGJaCJo\nI3ViaC2KAvAAaC5YDgAAAHpocHJmc18yNDAudHh0dWJoL4oC8ABoMFgFAAAAaHByZnNoLYoBEHVi\naBVoFl1oF4dScal9caooaBpYAwAAAFNQRGgbWAQAAABmdWxsaBxYPwAAAGVycm9yIGJvdW5kcyBh\nbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudGgdaB4pgXGr\nfXGsKGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC9zcG9yZnNfOGYuaHRtbGglWAEA\nAABzaCZoFWgnXWgXh1JxrX1xrihoKlgEDQAAU1BPUkZTIGltcHJvdmVzIHRoZSBjb21wdXRlZCBz\nb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKZXF1YXRpb25zIHdoZW4gdGhlIGNvZWZmaWNp\nZW50IG1hdHJpeCBpcyBzeW1tZXRyaWMgcG9zaXRpdmUgZGVmaW5pdGUsCmFuZCBwcm92aWRlcyBl\ncnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcyBmb3IgdGhlCnNvbHV0aW9u\nLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUiox\nCiAgICAgICAgID0gJ1UnOiAgVXBwZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQ7CiAgICAgICAg\nID0gJ0wnOiAgTG93ZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQuClxwYXJhbVtpbl0gTgogICAg\nICAgICBOIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4g\nPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBU\naGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1u\ncwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2lu\nXSBBCiAgICAgICAgIEEgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMREEsTikKICAgICAgICAg\nVGhlIHN5bW1ldHJpYyBtYXRyaXggQS4gIElmIFVQTE8gPSAnVScsIHRoZSBsZWFkaW5nIE4tYnkt\nTgogICAgICAgICB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgdXBwZXIg\ndHJpYW5ndWxhciBwYXJ0CiAgICAgICAgIG9mIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBzdHJpY3Rs\neSBsb3dlciB0cmlhbmd1bGFyIHBhcnQgb2YgQQogICAgICAgICBpcyBub3QgcmVmZXJlbmNlZC4g\nIElmIFVQTE8gPSAnTCcsIHRoZSBsZWFkaW5nIE4tYnktTiBsb3dlcgogICAgICAgICB0cmlhbmd1\nbGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgbG93ZXIgdHJpYW5ndWxhciBwYXJ0IG9mCiAgICAg\nICAgIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBzdHJpY3RseSB1cHBlciB0cmlhbmd1bGFyIHBhcnQg\nb2YgQSBpcwogICAgICAgICBub3QgcmVmZXJlbmNlZC4KXHBhcmFtW2luXSBMREEKICAgICAgICAg\nTERBIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJh\neSBBLiAgTERBID49IG1heCgxLE4pLgpccGFyYW1baW5dIEFGCiAgICAgICAgIEFGIGlzIFJFQUwg\nYXJyYXksIGRpbWVuc2lvbiAoTERBRixOKQogICAgICAgICBUaGUgdHJpYW5ndWxhciBmYWN0b3Ig\nVSBvciBMIGZyb20gdGhlIENob2xlc2t5IGZhY3Rvcml6YXRpb24KICAgICAgICAgQSA9IFUqKlQq\nVSBvciBBID0gTCpMKipULCBhcyBjb21wdXRlZCBieSBTUE9UUkYuClxwYXJhbVtpbl0gTERBRgog\nICAgICAgICBMREFGIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9m\nIHRoZSBhcnJheSBBRi4gIExEQUYgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gQgogICAgICAgICBC\nIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRoZSByaWdodCBo\nYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VS\nCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBt\nYXgoMSxOKS4KXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIFJFQUwgYXJyYXksIGRpbWVu\nc2lvbiAoTERYLE5SSFMpCiAgICAgICAgIE9uIGVudHJ5LCB0aGUgc29sdXRpb24gbWF0cml4IFgs\nIGFzIGNvbXB1dGVkIGJ5IFNQT1RSUy4KICAgICAgICAgT24gZXhpdCwgdGhlIGltcHJvdmVkIHNv\nbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgog\nICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4\nKDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBSRUFMIGFycmF5LCBkaW1l\nbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciBib3VuZCBm\nb3IgZWFjaCBzb2x1dGlvbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhlIGotdGggY29sdW1uIG9m\nIHRoZSBzb2x1dGlvbiBtYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVFIGlzIHRoZSB0cnVlIHNv\nbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAgICAgICBpcyBhbiBlc3Rp\nbWF0ZWQgdXBwZXIgYm91bmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGxhcmdlc3QKICAgICAg\nICAgZWxlbWVudCBpbiAoWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRoZSBtYWduaXR1ZGUgb2Yg\ndGhlCiAgICAgICAgIGxhcmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhlIGVzdGltYXRlIGlzIGFz\nIHJlbGlhYmxlIGFzCiAgICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNPTkQsIGFuZCBpcyBhbG1v\nc3QgYWx3YXlzIGEgc2xpZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBvZiB0aGUgdHJ1ZSBlcnJv\nci4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lv\nbiAoTlJIUykKICAgICAgICAgVGhlIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJy\nb3Igb2YgZWFjaCBzb2x1dGlvbgogICAgICAgICB2ZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxs\nZXN0IHJlbGF0aXZlIGNoYW5nZSBpbgogICAgICAgICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhh\ndCBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW291dF0gV09SSwogICAgICAg\nICBXT1JLIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoMypOKQpccGFyYW1bb3V0XSBJV09SSwog\nICAgICAgICBJV09SSyBpcyBJTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRd\nIElORk8KICAgICAgICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3NmdWwg\nZXhpdAogICAgICAgICA8IDA6ICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBh\nbiBpbGxlZ2FsIHZhbHVlClxwYXIgSW50ZXJuYWwgUGFyYW1ldGVyczoKIElUTUFYIGlzIHRoZSBt\nYXhpbXVtIG51bWJlciBvZiBzdGVwcyBvZiBpdGVyYXRpdmUgcmVmaW5lbWVudC4KQXV0aG9yczoK\nXGF1dGhvciBVbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBC\nZXJrZWxleSAKXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0\nZC4gClxkYXRlIE5vdmVtYmVyIDIwMTEKXGluZ3JvdXAgcmVhbFBPY29tcHV0YXRpb25hbApoHWge\nKYFxr31xsChoIYloImgjdWJoLYoC8QBoLlgOAAAAc3BvcmZzXzI0MS50eHR1YmgvigLxAGgwWAUA\nAABwb3Jmc2gtigERdWJoFWgWXWgXh1JxsX1xsihoGlgDAAAAU1BEaBtYBAAAAGZ1bGxoHFg/AAAA\nZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZp\nbmVtZW50aB1oHimBcbN9cbQoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4vZG9jcy9odG1sL2Rwb3Jm\nc184Zi5odG1saCVYAQAAAGRoJmgVaCddaBeHUnG1fXG2KGgqWFoNAABEUE9SRlMgaW1wcm92ZXMg\ndGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgplcXVhdGlvbnMgd2hl\nbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIHN5bW1ldHJpYyBwb3NpdGl2ZSBkZWZpbml0ZSwK\nYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzIGZv\nciB0aGUKc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2luXSBVUExPCiAgICAgICAgIFVQTE8g\naXMgQ0hBUkFDVEVSKjEKICAgICAgICAgPSAnVSc6ICBVcHBlciB0cmlhbmdsZSBvZiBBIGlzIHN0\nb3JlZDsKICAgICAgICAgPSAnTCc6ICBMb3dlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZC4KXHBh\ncmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2YgdGhl\nIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRF\nR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51\nbWJlciBvZiBjb2x1bW5zCiAgICAgICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+\nPSAwLgpccGFyYW1baW5dIEEKICAgICAgICAgQSBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBk\naW1lbnNpb24gKExEQSxOKQogICAgICAgICBUaGUgc3ltbWV0cmljIG1hdHJpeCBBLiAgSWYgVVBM\nTyA9ICdVJywgdGhlIGxlYWRpbmcgTi1ieS1OCiAgICAgICAgIHVwcGVyIHRyaWFuZ3VsYXIgcGFy\ndCBvZiBBIGNvbnRhaW5zIHRoZSB1cHBlciB0cmlhbmd1bGFyIHBhcnQKICAgICAgICAgb2YgdGhl\nIG1hdHJpeCBBLCBhbmQgdGhlIHN0cmljdGx5IGxvd2VyIHRyaWFuZ3VsYXIgcGFydCBvZiBBCiAg\nICAgICAgIGlzIG5vdCByZWZlcmVuY2VkLiAgSWYgVVBMTyA9ICdMJywgdGhlIGxlYWRpbmcgTi1i\neS1OIGxvd2VyCiAgICAgICAgIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGNvbnRhaW5zIHRoZSBsb3dl\nciB0cmlhbmd1bGFyIHBhcnQgb2YKICAgICAgICAgdGhlIG1hdHJpeCBBLCBhbmQgdGhlIHN0cmlj\ndGx5IHVwcGVyIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGlzCiAgICAgICAgIG5vdCByZWZlcmVuY2Vk\nLgpccGFyYW1baW5dIExEQQogICAgICAgICBMREEgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVh\nZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEEuICBMREEgPj0gbWF4KDEsTikuClxwYXJhbVtp\nbl0gQUYKICAgICAgICAgQUYgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChM\nREFGLE4pCiAgICAgICAgIFRoZSB0cmlhbmd1bGFyIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgQ2hv\nbGVza3kgZmFjdG9yaXphdGlvbgogICAgICAgICBBID0gVSoqVCpVIG9yIEEgPSBMKkwqKlQsIGFz\nIGNvbXB1dGVkIGJ5IERQT1RSRi4KXHBhcmFtW2luXSBMREFGCiAgICAgICAgIExEQUYgaXMgSU5U\nRUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFGLiAgTERB\nRiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIgaXMgRE9VQkxFIFBSRUNJU0lP\nTiBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lk\nZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVHRVIKICAgICAg\nICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49IG1heCgxLE4p\nLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwg\nZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRy\naXggWCwgYXMgY29tcHV0ZWQgYnkgRFBPVFJTLgogICAgICAgICBPbiBleGl0LCB0aGUgaW1wcm92\nZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRF\nR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+\nPSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIERPVUJMRSBQUkVD\nSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3\nYXJkIGVycm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGopICh0\naGUgai10aCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRS\nVUUgaXMgdGhlIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAg\nICAgICAgIGlzIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0\naGUgbGFyZ2VzdAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkg\ndGhlIG1hZ25pdHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBU\naGUgZXN0aW1hdGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBS\nQ09ORCwgYW5kIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRl\nIG9mIHRoZSB0cnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgRE9V\nQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9u\nZW50d2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAg\nIHZlY3RvciBYKGopIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAg\nICAgIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRp\nb24pLgpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgRE9VQkxFIFBSRUNJU0lPTiBh\ncnJheSwgZGltZW5zaW9uICgzKk4pClxwYXJhbVtvdXRdIElXT1JLCiAgICAgICAgIElXT1JLIGlz\nIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJ\nTkZPIGlzIElOVEVHRVIKICAgICAgICAgPSAwOiAgc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwg\nMDogIGlmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUK\nXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRNQVggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9m\nIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50LgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9m\nIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9y\nIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1i\nZXIgMjAxMQpcaW5ncm91cCBkb3VibGVQT2NvbXB1dGF0aW9uYWwKaB1oHimBcbd9cbgoaCGJaCJo\nI3ViaC2KAvIAaC5YDgAAAGRwb3Jmc18yNDIudHh0dWJoL4oC8gBoMFgFAAAAcG9yZnNoLYoBEnVi\naBVoFl1oF4dScbl9cbooaBpYAwAAAEhQRGgbWAQAAABmdWxsaBxYPwAAAGVycm9yIGJvdW5kcyBh\nbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudGgdaB4pgXG7\nfXG8KGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC9jcG9yZnNfOGYuaHRtbGglWAEA\nAABjaCZoFWgnXWgXh1JxvX1xvihoKlgTDQAAQ1BPUkZTIGltcHJvdmVzIHRoZSBjb21wdXRlZCBz\nb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKZXF1YXRpb25zIHdoZW4gdGhlIGNvZWZmaWNp\nZW50IG1hdHJpeCBpcyBIZXJtaXRpYW4gcG9zaXRpdmUgZGVmaW5pdGUsCmFuZCBwcm92aWRlcyBl\ncnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcyBmb3IgdGhlCnNvbHV0aW9u\nLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUiox\nCiAgICAgICAgID0gJ1UnOiAgVXBwZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQ7CiAgICAgICAg\nID0gJ0wnOiAgTG93ZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQuClxwYXJhbVtpbl0gTgogICAg\nICAgICBOIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4g\nPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBU\naGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1u\ncwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2lu\nXSBBCiAgICAgICAgIEEgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREEsTikKICAgICAg\nICAgVGhlIEhlcm1pdGlhbiBtYXRyaXggQS4gIElmIFVQTE8gPSAnVScsIHRoZSBsZWFkaW5nIE4t\nYnktTgogICAgICAgICB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgdXBw\nZXIgdHJpYW5ndWxhciBwYXJ0CiAgICAgICAgIG9mIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBzdHJp\nY3RseSBsb3dlciB0cmlhbmd1bGFyIHBhcnQgb2YgQQogICAgICAgICBpcyBub3QgcmVmZXJlbmNl\nZC4gIElmIFVQTE8gPSAnTCcsIHRoZSBsZWFkaW5nIE4tYnktTiBsb3dlcgogICAgICAgICB0cmlh\nbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgbG93ZXIgdHJpYW5ndWxhciBwYXJ0IG9mCiAg\nICAgICAgIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBzdHJpY3RseSB1cHBlciB0cmlhbmd1bGFyIHBh\ncnQgb2YgQSBpcwogICAgICAgICBub3QgcmVmZXJlbmNlZC4KXHBhcmFtW2luXSBMREEKICAgICAg\nICAgTERBIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBh\ncnJheSBBLiAgTERBID49IG1heCgxLE4pLgpccGFyYW1baW5dIEFGCiAgICAgICAgIEFGIGlzIENP\nTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERBRixOKQogICAgICAgICBUaGUgdHJpYW5ndWxhciBm\nYWN0b3IgVSBvciBMIGZyb20gdGhlIENob2xlc2t5IGZhY3Rvcml6YXRpb24KICAgICAgICAgQSA9\nIFUqKkgqVSBvciBBID0gTCpMKipILCBhcyBjb21wdXRlZCBieSBDUE9UUkYuClxwYXJhbVtpbl0g\nTERBRgogICAgICAgICBMREFGIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5z\naW9uIG9mIHRoZSBhcnJheSBBRi4gIExEQUYgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gQgogICAg\nICAgICBCIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRo\nZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBp\ncyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4g\nIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIENPTVBMRVgg\nYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICAgICAgIE9uIGVudHJ5LCB0aGUgc29sdXRp\nb24gbWF0cml4IFgsIGFzIGNvbXB1dGVkIGJ5IENQT1RSUy4KICAgICAgICAgT24gZXhpdCwgdGhl\nIGltcHJvdmVkIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFgg\naXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFgu\nICBMRFggPj0gbWF4KDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBSRUFM\nIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBl\ncnJvciBib3VuZCBmb3IgZWFjaCBzb2x1dGlvbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhlIGot\ndGggY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBtYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVFIGlz\nIHRoZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAgICAg\nICBpcyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91bmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGxh\ncmdlc3QKICAgICAgICAgZWxlbWVudCBpbiAoWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRoZSBt\nYWduaXR1ZGUgb2YgdGhlCiAgICAgICAgIGxhcmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhlIGVz\ndGltYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAgICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNPTkQs\nIGFuZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xpZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBvZiB0\naGUgdHJ1ZSBlcnJvci4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIFJFQUwgYXJy\nYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUg\nYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1dGlvbgogICAgICAgICB2ZWN0b3IgWChqKSAoaS5l\nLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbgogICAgICAgICBhbnkgZWxlbWVudCBv\nZiBBIG9yIEIgdGhhdCBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW291dF0g\nV09SSwogICAgICAgICBXT1JLIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFy\nYW1bb3V0XSBSV09SSwogICAgICAgICBSV09SSyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE4p\nClxwYXJhbVtvdXRdIElORk8KICAgICAgICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDog\nIHN1Y2Nlc3NmdWwgZXhpdAogICAgICAgICA8IDA6ICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFy\nZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVlClxwYXIgSW50ZXJuYWwgUGFyYW1ldGVyczoKIElU\nTUFYIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzdGVwcyBvZiBpdGVyYXRpdmUgcmVmaW5lbWVu\ndC4KQXV0aG9yczoKXGF1dGhvciBVbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2Yg\nQ2FsaWZvcm5pYSBCZXJrZWxleSAKXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxh\ndXRob3IgTkFHIEx0ZC4gClxkYXRlIE5vdmVtYmVyIDIwMTEKXGluZ3JvdXAgY29tcGxleFBPY29t\ncHV0YXRpb25hbApoHWgeKYFxv31xwChoIYloImgjdWJoLYoC8wBoLlgOAAAAY3BvcmZzXzI0My50\neHR1YmgvigLzAGgwWAUAAABwb3Jmc2gtigETdWJoFWgWXWgXh1JxwX1xwihoGlgDAAAASFBEaBtY\nBAAAAGZ1bGxoHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7\nIGl0ZXJhdGl2ZSByZWZpbmVtZW50aB1oHimBccN9ccQoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4v\nZG9jcy9odG1sL3pwb3Jmc184Zi5odG1saCVYAQAAAHpoJmgVaCddaBeHUnHFfXHGKGgqWEgNAABa\nUE9SRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVh\ncgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIEhlcm1pdGlhbiBwb3Np\ndGl2ZSBkZWZpbml0ZSwKYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJy\nb3IgZXN0aW1hdGVzIGZvciB0aGUKc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2luXSBVUExP\nCiAgICAgICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgPSAnVSc6ICBVcHBlciB0cmlh\nbmdsZSBvZiBBIGlzIHN0b3JlZDsKICAgICAgICAgPSAnTCc6ICBMb3dlciB0cmlhbmdsZSBvZiBB\nIGlzIHN0b3JlZC4KXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBU\naGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAg\nICAgTlJIUyBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRl\ncywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5zCiAgICAgICAgIG9mIHRoZSBtYXRyaWNlcyBC\nIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEEKICAgICAgICAgQSBpcyBDT01QTEVYKjE2\nIGFycmF5LCBkaW1lbnNpb24gKExEQSxOKQogICAgICAgICBUaGUgSGVybWl0aWFuIG1hdHJpeCBB\nLiAgSWYgVVBMTyA9ICdVJywgdGhlIGxlYWRpbmcgTi1ieS1OCiAgICAgICAgIHVwcGVyIHRyaWFu\nZ3VsYXIgcGFydCBvZiBBIGNvbnRhaW5zIHRoZSB1cHBlciB0cmlhbmd1bGFyIHBhcnQKICAgICAg\nICAgb2YgdGhlIG1hdHJpeCBBLCBhbmQgdGhlIHN0cmljdGx5IGxvd2VyIHRyaWFuZ3VsYXIgcGFy\ndCBvZiBBCiAgICAgICAgIGlzIG5vdCByZWZlcmVuY2VkLiAgSWYgVVBMTyA9ICdMJywgdGhlIGxl\nYWRpbmcgTi1ieS1OIGxvd2VyCiAgICAgICAgIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGNvbnRhaW5z\nIHRoZSBsb3dlciB0cmlhbmd1bGFyIHBhcnQgb2YKICAgICAgICAgdGhlIG1hdHJpeCBBLCBhbmQg\ndGhlIHN0cmljdGx5IHVwcGVyIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGlzCiAgICAgICAgIG5vdCBy\nZWZlcmVuY2VkLgpccGFyYW1baW5dIExEQQogICAgICAgICBMREEgaXMgSU5URUdFUgogICAgICAg\nICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEEuICBMREEgPj0gbWF4KDEsTiku\nClxwYXJhbVtpbl0gQUYKICAgICAgICAgQUYgaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9u\nIChMREFGLE4pCiAgICAgICAgIFRoZSB0cmlhbmd1bGFyIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUg\nQ2hvbGVza3kgZmFjdG9yaXphdGlvbgogICAgICAgICBBID0gVSoqSCpVIG9yIEEgPSBMKkwqKkgs\nIGFzIGNvbXB1dGVkIGJ5IFpQT1RSRi4KXHBhcmFtW2luXSBMREFGCiAgICAgICAgIExEQUYgaXMg\nSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFGLiAg\nTERBRiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIgaXMgQ09NUExFWCoxNiBh\ncnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBt\nYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVHRVIKICAgICAgICAg\nVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49IG1heCgxLE4pLgpc\ncGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9u\nIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwgYXMg\nY29tcHV0ZWQgYnkgWlBPVFJTLgogICAgICAgICBPbiBleGl0LCB0aGUgaW1wcm92ZWQgc29sdXRp\nb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICAg\nICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+PSBtYXgoMSxO\nKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIERPVUJMRSBQUkVDSVNJT04gYXJy\nYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9y\nIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGopICh0aGUgai10aCBj\nb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRSVUUgaXMgdGhl\nIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAgICAgICAgIGlz\nIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2Vz\ndAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25p\ndHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBUaGUgZXN0aW1h\ndGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBSQ09ORCwgYW5k\nIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRlIG9mIHRoZSB0\ncnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgRE9VQkxFIFBSRUNJ\nU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9uZW50d2lzZSBy\nZWxhdGl2ZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBY\nKGopIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBl\nbGVtZW50IG9mIEEgb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFy\nYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9u\nICgyKk4pClxwYXJhbVtvdXRdIFJXT1JLCiAgICAgICAgIFJXT1JLIGlzIERPVUJMRSBQUkVDSVNJ\nT04gYXJyYXksIGRpbWVuc2lvbiAoTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlz\nIElOVEVHRVIKICAgICAgICAgPSAwOiAgc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlm\nIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJ\nbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRNQVggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBz\nIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50LgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5l\nc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYu\nIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAx\nMQpcaW5ncm91cCBjb21wbGV4MTZQT2NvbXB1dGF0aW9uYWwKaB1oHimBccd9ccgoaCGJaCJoI3Vi\naC2KAvQAaC5YDgAAAHpwb3Jmc18yNDQudHh0dWJoL4oC9ABoMFgFAAAAcG9yZnNoLYoBFHViaBVo\nFl1oF4dSccl9ccooaBpYAwAAAFNQRGgbWAQAAABiYW5kaBxYPwAAAGVycm9yIGJvdW5kcyBhbmQg\nYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudGgdaB4pgXHLfXHM\nKGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC9zcGJyZnNfOGYuaHRtbGglWAEAAABz\naCZoFWgnXWgXh1JxzX1xzihoKliwDQAAU1BCUkZTIGltcHJvdmVzIHRoZSBjb21wdXRlZCBzb2x1\ndGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKZXF1YXRpb25zIHdoZW4gdGhlIGNvZWZmaWNpZW50\nIG1hdHJpeCBpcyBzeW1tZXRyaWMgcG9zaXRpdmUgZGVmaW5pdGUKYW5kIGJhbmRlZCwgYW5kIHBy\nb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzCmZvciB0aGUg\nc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hB\nUkFDVEVSKjEKICAgICAgICAgPSAnVSc6ICBVcHBlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZDsK\nICAgICAgICAgPSAnTCc6ICBMb3dlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZC4KXHBhcmFtW2lu\nXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJp\neCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIEtECiAgICAgICAgIEtEIGlzIElOVEVHRVIKICAgICAg\nICAgVGhlIG51bWJlciBvZiBzdXBlcmRpYWdvbmFscyBvZiB0aGUgbWF0cml4IEEgaWYgVVBMTyA9\nICdVJywKICAgICAgICAgb3IgdGhlIG51bWJlciBvZiBzdWJkaWFnb25hbHMgaWYgVVBMTyA9ICdM\nJy4gIEtEID49IDAuClxwYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAg\nICAgICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9m\nIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxw\nYXJhbVtpbl0gQUIKICAgICAgICAgQUIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMREFCLE4p\nCiAgICAgICAgIFRoZSB1cHBlciBvciBsb3dlciB0cmlhbmdsZSBvZiB0aGUgc3ltbWV0cmljIGJh\nbmQgbWF0cml4IEEsCiAgICAgICAgIHN0b3JlZCBpbiB0aGUgZmlyc3QgS0QrMSByb3dzIG9mIHRo\nZSBhcnJheS4gIFRoZSBqLXRoIGNvbHVtbgogICAgICAgICBvZiBBIGlzIHN0b3JlZCBpbiB0aGUg\nai10aCBjb2x1bW4gb2YgdGhlIGFycmF5IEFCIGFzIGZvbGxvd3M6CiAgICAgICAgIGlmIFVQTE8g\nPSAnVScsIEFCKGtkKzEraS1qLGopID0gQShpLGopIGZvciBtYXgoMSxqLWtkKTw9aTw9ajsKICAg\nICAgICAgaWYgVVBMTyA9ICdMJywgQUIoMStpLWosaikgICAgPSBBKGksaikgZm9yIGo8PWk8PW1p\nbihuLGora2QpLgpccGFyYW1baW5dIExEQUIKICAgICAgICAgTERBQiBpcyBJTlRFR0VSCiAgICAg\nICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUIuICBMREFCID49IEtEKzEu\nClxwYXJhbVtpbl0gQUZCCiAgICAgICAgIEFGQiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKExE\nQUZCLE4pCiAgICAgICAgIFRoZSB0cmlhbmd1bGFyIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgQ2hv\nbGVza3kgZmFjdG9yaXphdGlvbgogICAgICAgICBBID0gVSoqVCpVIG9yIEEgPSBMKkwqKlQgb2Yg\ndGhlIGJhbmQgbWF0cml4IEEgYXMgY29tcHV0ZWQgYnkKICAgICAgICAgU1BCVFJGLCBpbiB0aGUg\nc2FtZSBzdG9yYWdlIGZvcm1hdCBhcyBBIChzZWUgQUIpLgpccGFyYW1baW5dIExEQUZCCiAgICAg\nICAgIExEQUZCIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRo\nZSBhcnJheSBBRkIuICBMREFGQiA+PSBLRCsxLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBS\nRUFMIGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBz\naWRlIG1hdHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAg\nICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEs\nTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24g\nKExEWCxOUkhTKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBj\nb21wdXRlZCBieSBTUEJUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1dGlv\nbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgICAg\nICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4p\nLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9u\nIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVh\nY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUg\nc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlv\nbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVk\nIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVs\nZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQog\nICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyByZWxp\nYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0IGFs\nd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJyb3IuClxw\nYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5S\nSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9m\nIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCBy\nZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFr\nZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09S\nSyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKDMqTikKXHBhcmFtW291dF0gSVdPUksKICAgICAg\nICAgSVdPUksgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZP\nCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQK\nICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxs\nZWdhbCB2YWx1ZQpccGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11\nbSBudW1iZXIgb2Ygc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRo\nb3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2Vs\nZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApc\nZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIHJlYWxPVEhFUmNvbXB1dGF0aW9uYWwKaB1oHimB\ncc99cdAoaCGJaCJoI3ViaC2KAvUAaC5YDgAAAHNwYnJmc18yNDUudHh0dWJoL4oC9QBoMFgFAAAA\ncGJyZnNoLYoBFXViaBVoFl1oF4dScdF9cdIoaBpYAwAAAFNQRGgbWAQAAABiYW5kaBxYPwAAAGVy\ncm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5l\nbWVudGgdaB4pgXHTfXHUKGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC9kcGJyZnNf\nOGYuaHRtbGglWAEAAABkaCZoFWgnXWgXh1Jx1X1x1ihoKlgGDgAARFBCUkZTIGltcHJvdmVzIHRo\nZSBjb21wdXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKZXF1YXRpb25zIHdoZW4g\ndGhlIGNvZWZmaWNpZW50IG1hdHJpeCBpcyBzeW1tZXRyaWMgcG9zaXRpdmUgZGVmaW5pdGUKYW5k\nIGJhbmRlZCwgYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0\naW1hdGVzCmZvciB0aGUgc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2luXSBVUExPCiAgICAg\nICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgPSAnVSc6ICBVcHBlciB0cmlhbmdsZSBv\nZiBBIGlzIHN0b3JlZDsKICAgICAgICAgPSAnTCc6ICBMb3dlciB0cmlhbmdsZSBvZiBBIGlzIHN0\nb3JlZC4KXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3Jk\nZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIEtECiAgICAgICAgIEtEIGlz\nIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiBzdXBlcmRpYWdvbmFscyBvZiB0aGUgbWF0\ncml4IEEgaWYgVVBMTyA9ICdVJywKICAgICAgICAgb3IgdGhlIG51bWJlciBvZiBzdWJkaWFnb25h\nbHMgaWYgVVBMTyA9ICdMJy4gIEtEID49IDAuClxwYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhT\nIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUu\nLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFgu\nICBOUkhTID49IDAuClxwYXJhbVtpbl0gQUIKICAgICAgICAgQUIgaXMgRE9VQkxFIFBSRUNJU0lP\nTiBhcnJheSwgZGltZW5zaW9uIChMREFCLE4pCiAgICAgICAgIFRoZSB1cHBlciBvciBsb3dlciB0\ncmlhbmdsZSBvZiB0aGUgc3ltbWV0cmljIGJhbmQgbWF0cml4IEEsCiAgICAgICAgIHN0b3JlZCBp\nbiB0aGUgZmlyc3QgS0QrMSByb3dzIG9mIHRoZSBhcnJheS4gIFRoZSBqLXRoIGNvbHVtbgogICAg\nICAgICBvZiBBIGlzIHN0b3JlZCBpbiB0aGUgai10aCBjb2x1bW4gb2YgdGhlIGFycmF5IEFCIGFz\nIGZvbGxvd3M6CiAgICAgICAgIGlmIFVQTE8gPSAnVScsIEFCKGtkKzEraS1qLGopID0gQShpLGop\nIGZvciBtYXgoMSxqLWtkKTw9aTw9ajsKICAgICAgICAgaWYgVVBMTyA9ICdMJywgQUIoMStpLWos\naikgICAgPSBBKGksaikgZm9yIGo8PWk8PW1pbihuLGora2QpLgpccGFyYW1baW5dIExEQUIKICAg\nICAgICAgTERBQiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0\naGUgYXJyYXkgQUIuICBMREFCID49IEtEKzEuClxwYXJhbVtpbl0gQUZCCiAgICAgICAgIEFGQiBp\ncyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKExEQUZCLE4pCiAgICAgICAgIFRo\nZSB0cmlhbmd1bGFyIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgQ2hvbGVza3kgZmFjdG9yaXphdGlv\nbgogICAgICAgICBBID0gVSoqVCpVIG9yIEEgPSBMKkwqKlQgb2YgdGhlIGJhbmQgbWF0cml4IEEg\nYXMgY29tcHV0ZWQgYnkKICAgICAgICAgRFBCVFJGLCBpbiB0aGUgc2FtZSBzdG9yYWdlIGZvcm1h\ndCBhcyBBIChzZWUgQUIpLgpccGFyYW1baW5dIExEQUZCCiAgICAgICAgIExEQUZCIGlzIElOVEVH\nRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBRkIuICBMREFG\nQiA+PSBLRCsxLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFy\ncmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1h\ndHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBU\naGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxw\nYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1l\nbnNpb24gKExEWCxOUkhTKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBY\nLCBhcyBjb21wdXRlZCBieSBEUEJUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBz\nb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIK\nICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1h\neCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgRE9VQkxFIFBSRUNJU0lP\nTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQg\nZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBq\nLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBp\ncyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAg\nICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBs\nYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUg\nbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBl\nc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05E\nLCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2Yg\ndGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBET1VCTEUg\nUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3\naXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVj\ndG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAg\nYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbiku\nClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5\nLCBkaW1lbnNpb24gKDMqTikKXHBhcmFtW291dF0gSVdPUksKICAgICAgICAgSVdPUksgaXMgSU5U\nRUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8g\naXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAg\naWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpccGFy\nIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3Rl\ncHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVu\nbmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5p\ndi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAy\nMDExClxpbmdyb3VwIGRvdWJsZU9USEVSY29tcHV0YXRpb25hbApoHWgeKYFx131x2ChoIYloImgj\ndWJoLYoC9gBoLlgOAAAAZHBicmZzXzI0Ni50eHR1YmgvigL2AGgwWAUAAABwYnJmc2gtigEWdWJo\nFWgWXWgXh1Jx2X1x2ihoGlgDAAAASFBEaBtYBAAAAGJhbmRoHFg/AAAAZXJyb3IgYm91bmRzIGFu\nZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZpbmVtZW50aB1oHimBcdt9\ncdwoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4vZG9jcy9odG1sL2NwYnJmc184Zi5odG1saCVYAQAA\nAGNoJmgVaCddaBeHUnHdfXHeKGgqWL8NAABDUEJSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNv\nbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2ll\nbnQgbWF0cml4IGlzIEhlcm1pdGlhbiBwb3NpdGl2ZSBkZWZpbml0ZQphbmQgYmFuZGVkLCBhbmQg\ncHJvdmlkZXMgZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMKZm9yIHRo\nZSBzb2x1dGlvbi4KQXJndW1lbnRzOgpccGFyYW1baW5dIFVQTE8KICAgICAgICAgVVBMTyBpcyBD\nSEFSQUNURVIqMQogICAgICAgICA9ICdVJzogIFVwcGVyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVk\nOwogICAgICAgICA9ICdMJzogIExvd2VyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkLgpccGFyYW1b\naW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0\ncml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gS0QKICAgICAgICAgS0QgaXMgSU5URUdFUgogICAg\nICAgICBUaGUgbnVtYmVyIG9mIHN1cGVyZGlhZ29uYWxzIG9mIHRoZSBtYXRyaXggQSBpZiBVUExP\nID0gJ1UnLAogICAgICAgICBvciB0aGUgbnVtYmVyIG9mIHN1YmRpYWdvbmFscyBpZiBVUExPID0g\nJ0wnLiAgS0QgPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgog\nICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIg\nb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4K\nXHBhcmFtW2luXSBBQgogICAgICAgICBBQiBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKExE\nQUIsTikKICAgICAgICAgVGhlIHVwcGVyIG9yIGxvd2VyIHRyaWFuZ2xlIG9mIHRoZSBIZXJtaXRp\nYW4gYmFuZCBtYXRyaXggQSwKICAgICAgICAgc3RvcmVkIGluIHRoZSBmaXJzdCBLRCsxIHJvd3Mg\nb2YgdGhlIGFycmF5LiAgVGhlIGotdGggY29sdW1uCiAgICAgICAgIG9mIEEgaXMgc3RvcmVkIGlu\nIHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgYXJyYXkgQUIgYXMgZm9sbG93czoKICAgICAgICAgaWYg\nVVBMTyA9ICdVJywgQUIoa2QrMStpLWosaikgPSBBKGksaikgZm9yIG1heCgxLGota2QpPD1pPD1q\nOwogICAgICAgICBpZiBVUExPID0gJ0wnLCBBQigxK2ktaixqKSAgICA9IEEoaSxqKSBmb3Igajw9\naTw9bWluKG4saitrZCkuClxwYXJhbVtpbl0gTERBQgogICAgICAgICBMREFCIGlzIElOVEVHRVIK\nICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBQi4gIExEQUIgPj0g\nS0QrMS4KXHBhcmFtW2luXSBBRkIKICAgICAgICAgQUZCIGlzIENPTVBMRVggYXJyYXksIGRpbWVu\nc2lvbiAoTERBRkIsTikKICAgICAgICAgVGhlIHRyaWFuZ3VsYXIgZmFjdG9yIFUgb3IgTCBmcm9t\nIHRoZSBDaG9sZXNreSBmYWN0b3JpemF0aW9uCiAgICAgICAgIEEgPSBVKipIKlUgb3IgQSA9IEwq\nTCoqSCBvZiB0aGUgYmFuZCBtYXRyaXggQSBhcyBjb21wdXRlZCBieQogICAgICAgICBDUEJUUkYs\nIGluIHRoZSBzYW1lIHN0b3JhZ2UgZm9ybWF0IGFzIEEgKHNlZSBBQikuClxwYXJhbVtpbl0gTERB\nRkIKICAgICAgICAgTERBRkIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNp\nb24gb2YgdGhlIGFycmF5IEFGQi4gIExEQUZCID49IEtEKzEuClxwYXJhbVtpbl0gQgogICAgICAg\nICBCIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRoZSBy\naWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJ\nTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExE\nQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIENPTVBMRVggYXJy\nYXksIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICAgICAgIE9uIGVudHJ5LCB0aGUgc29sdXRpb24g\nbWF0cml4IFgsIGFzIGNvbXB1dGVkIGJ5IENQQlRSUy4KICAgICAgICAgT24gZXhpdCwgdGhlIGlt\ncHJvdmVkIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMg\nSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBM\nRFggPj0gbWF4KDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBSRUFMIGFy\ncmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJv\nciBib3VuZCBmb3IgZWFjaCBzb2x1dGlvbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhlIGotdGgg\nY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBtYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVFIGlzIHRo\nZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAgICAgICBp\ncyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91bmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGxhcmdl\nc3QKICAgICAgICAgZWxlbWVudCBpbiAoWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRoZSBtYWdu\naXR1ZGUgb2YgdGhlCiAgICAgICAgIGxhcmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhlIGVzdGlt\nYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAgICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNPTkQsIGFu\nZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xpZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBvZiB0aGUg\ndHJ1ZSBlcnJvci4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIFJFQUwgYXJyYXks\nIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFj\na3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1dGlvbgogICAgICAgICB2ZWN0b3IgWChqKSAoaS5lLiwg\ndGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbgogICAgICAgICBhbnkgZWxlbWVudCBvZiBB\nIG9yIEIgdGhhdCBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW291dF0gV09S\nSwogICAgICAgICBXT1JLIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1b\nb3V0XSBSV09SSwogICAgICAgICBSV09SSyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE4pClxw\nYXJhbVtvdXRdIElORk8KICAgICAgICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1\nY2Nlc3NmdWwgZXhpdAogICAgICAgICA8IDA6ICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3Vt\nZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVlClxwYXIgSW50ZXJuYWwgUGFyYW1ldGVyczoKIElUTUFY\nIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzdGVwcyBvZiBpdGVyYXRpdmUgcmVmaW5lbWVudC4K\nQXV0aG9yczoKXGF1dGhvciBVbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2Fs\naWZvcm5pYSBCZXJrZWxleSAKXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRo\nb3IgTkFHIEx0ZC4gClxkYXRlIE5vdmVtYmVyIDIwMTEKXGluZ3JvdXAgY29tcGxleE9USEVSY29t\ncHV0YXRpb25hbApoHWgeKYFx331x4ChoIYloImgjdWJoLYoC9wBoLlgOAAAAY3BicmZzXzI0Ny50\neHR1YmgvigL3AGgwWAUAAABwYnJmc2gtigEXdWJoFWgWXWgXh1Jx4X1x4ihoGlgDAAAASFBEaBtY\nBAAAAGJhbmRoHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7\nIGl0ZXJhdGl2ZSByZWZpbmVtZW50aB1oHimBceN9ceQoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4v\nZG9jcy9odG1sL3pwYnJmc184Zi5odG1saCVYAQAAAHpoJmgVaCddaBeHUnHlfXHmKGgqWPoNAABa\nUEJSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVh\ncgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIEhlcm1pdGlhbiBwb3Np\ndGl2ZSBkZWZpbml0ZQphbmQgYmFuZGVkLCBhbmQgcHJvdmlkZXMgZXJyb3IgYm91bmRzIGFuZCBi\nYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMKZm9yIHRoZSBzb2x1dGlvbi4KQXJndW1lbnRzOgpccGFy\nYW1baW5dIFVQTE8KICAgICAgICAgVVBMTyBpcyBDSEFSQUNURVIqMQogICAgICAgICA9ICdVJzog\nIFVwcGVyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkOwogICAgICAgICA9ICdMJzogIExvd2VyIHRy\naWFuZ2xlIG9mIEEgaXMgc3RvcmVkLgpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VS\nCiAgICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0g\nS0QKICAgICAgICAgS0QgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHN1cGVyZGlh\nZ29uYWxzIG9mIHRoZSBtYXRyaXggQSBpZiBVUExPID0gJ1UnLAogICAgICAgICBvciB0aGUgbnVt\nYmVyIG9mIHN1YmRpYWdvbmFscyBpZiBVUExPID0gJ0wnLiAgS0QgPj0gMC4KXHBhcmFtW2luXSBO\nUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0\nIGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUg\nbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBBQgogICAgICAgICBBQiBp\ncyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKExEQUIsTikKICAgICAgICAgVGhl\nIHVwcGVyIG9yIGxvd2VyIHRyaWFuZ2xlIG9mIHRoZSBIZXJtaXRpYW4gYmFuZCBtYXRyaXggQSwK\nICAgICAgICAgc3RvcmVkIGluIHRoZSBmaXJzdCBLRCsxIHJvd3Mgb2YgdGhlIGFycmF5LiAgVGhl\nIGotdGggY29sdW1uCiAgICAgICAgIG9mIEEgaXMgc3RvcmVkIGluIHRoZSBqLXRoIGNvbHVtbiBv\nZiB0aGUgYXJyYXkgQUIgYXMgZm9sbG93czoKICAgICAgICAgaWYgVVBMTyA9ICdVJywgQUIoa2Qr\nMStpLWosaikgPSBBKGksaikgZm9yIG1heCgxLGota2QpPD1pPD1qOwogICAgICAgICBpZiBVUExP\nID0gJ0wnLCBBQigxK2ktaixqKSAgICA9IEEoaSxqKSBmb3Igajw9aTw9bWluKG4saitrZCkuClxw\nYXJhbVtpbl0gTERBQgogICAgICAgICBMREFCIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRp\nbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBQi4gIExEQUIgPj0gS0QrMS4KXHBhcmFtW2luXSBB\nRkIKICAgICAgICAgQUZCIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTERBRkIsTikK\nICAgICAgICAgVGhlIHRyaWFuZ3VsYXIgZmFjdG9yIFUgb3IgTCBmcm9tIHRoZSBDaG9sZXNreSBm\nYWN0b3JpemF0aW9uCiAgICAgICAgIEEgPSBVKipIKlUgb3IgQSA9IEwqTCoqSCBvZiB0aGUgYmFu\nZCBtYXRyaXggQSBhcyBjb21wdXRlZCBieQogICAgICAgICBaUEJUUkYsIGluIHRoZSBzYW1lIHN0\nb3JhZ2UgZm9ybWF0IGFzIEEgKHNlZSBBQikuClxwYXJhbVtpbl0gTERBRkIKICAgICAgICAgTERB\nRkIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5\nIEFGQi4gIExEQUZCID49IEtEKzEuClxwYXJhbVtpbl0gQgogICAgICAgICBCIGlzIENPTVBMRVgq\nMTYgYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRoZSByaWdodCBoYW5kIHNp\nZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VSCiAgICAg\nICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxO\nKS4KXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVu\nc2lvbiAoTERYLE5SSFMpCiAgICAgICAgIE9uIGVudHJ5LCB0aGUgc29sdXRpb24gbWF0cml4IFgs\nIGFzIGNvbXB1dGVkIGJ5IFpQQlRSUy4KICAgICAgICAgT24gZXhpdCwgdGhlIGltcHJvdmVkIHNv\nbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgog\nICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4\nKDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9O\nIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBl\ncnJvciBib3VuZCBmb3IgZWFjaCBzb2x1dGlvbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhlIGot\ndGggY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBtYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVFIGlz\nIHRoZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAgICAg\nICBpcyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91bmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGxh\ncmdlc3QKICAgICAgICAgZWxlbWVudCBpbiAoWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRoZSBt\nYWduaXR1ZGUgb2YgdGhlCiAgICAgICAgIGxhcmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhlIGVz\ndGltYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAgICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNPTkQs\nIGFuZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xpZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBvZiB0\naGUgdHJ1ZSBlcnJvci4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIERPVUJMRSBQ\nUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGNvbXBvbmVudHdp\nc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1dGlvbgogICAgICAgICB2ZWN0\nb3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbgogICAgICAgICBh\nbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4K\nXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVu\nc2lvbiAoMipOKQpccGFyYW1bb3V0XSBSV09SSwogICAgICAgICBSV09SSyBpcyBET1VCTEUgUFJF\nQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRdIElORk8KICAgICAgICAgSU5G\nTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3NmdWwgZXhpdAogICAgICAgICA8IDA6\nICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVlClxw\nYXIgSW50ZXJuYWwgUGFyYW1ldGVyczoKIElUTUFYIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBz\ndGVwcyBvZiBpdGVyYXRpdmUgcmVmaW5lbWVudC4KQXV0aG9yczoKXGF1dGhvciBVbml2LiBvZiBU\nZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBCZXJrZWxleSAKXGF1dGhvciBV\nbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0ZC4gClxkYXRlIE5vdmVtYmVy\nIDIwMTEKXGluZ3JvdXAgY29tcGxleDE2T1RIRVJjb21wdXRhdGlvbmFsCmgdaB4pgXHnfXHoKGgh\niWgiaCN1YmgtigL4AGguWA4AAAB6cGJyZnNfMjQ4LnR4dHViaC+KAvgAaDBYBQAAAHBicmZzaC2K\nARh1YmgVaBZdaBeHUnHpfXHqKGgaWAMAAABTUERoG1gGAAAAcGFja2VkaBxYPwAAAGVycm9yIGJv\ndW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudGgd\naB4pgXHrfXHsKGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC9zcHByZnNfOGYuaHRt\nbGglWAEAAABzaCZoFWgnXWgXh1Jx7X1x7ihoKlgnDAAAU1BQUkZTIGltcHJvdmVzIHRoZSBjb21w\ndXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKZXF1YXRpb25zIHdoZW4gdGhlIGNv\nZWZmaWNpZW50IG1hdHJpeCBpcyBzeW1tZXRyaWMgcG9zaXRpdmUgZGVmaW5pdGUKYW5kIHBhY2tl\nZCwgYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVz\nCmZvciB0aGUgc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2luXSBVUExPCiAgICAgICAgIFVQ\nTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgPSAnVSc6ICBVcHBlciB0cmlhbmdsZSBvZiBBIGlz\nIHN0b3JlZDsKICAgICAgICAgPSAnTCc6ICBMb3dlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZC4K\nXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2Yg\ndGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJ\nTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhl\nIG51bWJlciBvZiBjb2x1bW5zCiAgICAgICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJI\nUyA+PSAwLgpccGFyYW1baW5dIEFQCiAgICAgICAgIEFQIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lv\nbiAoTiooTisxKS8yKQogICAgICAgICBUaGUgdXBwZXIgb3IgbG93ZXIgdHJpYW5nbGUgb2YgdGhl\nIHN5bW1ldHJpYyBtYXRyaXggQSwgcGFja2VkCiAgICAgICAgIGNvbHVtbndpc2UgaW4gYSBsaW5l\nYXIgYXJyYXkuICBUaGUgai10aCBjb2x1bW4gb2YgQSBpcyBzdG9yZWQKICAgICAgICAgaW4gdGhl\nIGFycmF5IEFQIGFzIGZvbGxvd3M6CiAgICAgICAgIGlmIFVQTE8gPSAnVScsIEFQKGkgKyAoai0x\nKSpqLzIpID0gQShpLGopIGZvciAxPD1pPD1qOwogICAgICAgICBpZiBVUExPID0gJ0wnLCBBUChp\nICsgKGotMSkqKDJuLWopLzIpID0gQShpLGopIGZvciBqPD1pPD1uLgpccGFyYW1baW5dIEFGUAog\nICAgICAgICBBRlAgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOKihOKzEpLzIpCiAgICAgICAg\nIFRoZSB0cmlhbmd1bGFyIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgQ2hvbGVza3kgZmFjdG9yaXph\ndGlvbgogICAgICAgICBBID0gVSoqVCpVIG9yIEEgPSBMKkwqKlQsIGFzIGNvbXB1dGVkIGJ5IFNQ\nUFRSRi9DUFBUUkYsCiAgICAgICAgIHBhY2tlZCBjb2x1bW53aXNlIGluIGEgbGluZWFyIGFycmF5\nIGluIHRoZSBzYW1lIGZvcm1hdCBhcyBBCiAgICAgICAgIChzZWUgQVApLgpccGFyYW1baW5dIEIK\nICAgICAgICAgQiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBU\naGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIg\naXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIu\nICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBSRUFMIGFy\ncmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9u\nIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBieSBTUFBUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBp\nbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlz\nIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAg\nTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgUkVBTCBh\ncnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJy\nb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRo\nIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0\naGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAg\naXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJn\nZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFn\nbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3Rp\nbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBh\nbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhl\nIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFycmF5\nLCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJh\nY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4s\nIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2Yg\nQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdP\nUksKICAgICAgICAgV09SSyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKDMqTikKXHBhcmFtW291\ndF0gSVdPUksKICAgICAgICAgSVdPUksgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQpc\ncGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBz\ndWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1\nbWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpccGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1B\nWCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQu\nCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENh\nbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0\naG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIHJlYWxPVEhFUmNvbXB1\ndGF0aW9uYWwKaB1oHimBce99cfAoaCGJaCJoI3ViaC2KAvkAaC5YDgAAAHNwcHJmc18yNDkudHh0\ndWJoL4oC+QBoMFgFAAAAcHByZnNoLYoBGXViaBVoFl1oF4dScfF9cfIoaBpYAwAAAFNQRGgbWAYA\nAABwYWNrZWRoHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7\nIGl0ZXJhdGl2ZSByZWZpbmVtZW50aB1oHimBcfN9cfQoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4v\nZG9jcy9odG1sL2RwcHJmc184Zi5odG1saCVYAQAAAGRoJmgVaCddaBeHUnH1fXH2KGgqWH0MAABE\nUFBSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVh\ncgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIHN5bW1ldHJpYyBwb3Np\ndGl2ZSBkZWZpbml0ZQphbmQgcGFja2VkLCBhbmQgcHJvdmlkZXMgZXJyb3IgYm91bmRzIGFuZCBi\nYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMKZm9yIHRoZSBzb2x1dGlvbi4KQXJndW1lbnRzOgpccGFy\nYW1baW5dIFVQTE8KICAgICAgICAgVVBMTyBpcyBDSEFSQUNURVIqMQogICAgICAgICA9ICdVJzog\nIFVwcGVyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkOwogICAgICAgICA9ICdMJzogIExvd2VyIHRy\naWFuZ2xlIG9mIEEgaXMgc3RvcmVkLgpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VS\nCiAgICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0g\nTlJIUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdo\ndCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhl\nIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQVAKICAgICAgICAgQVAg\naXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOKihOKzEpLzIpCiAgICAgICAg\nIFRoZSB1cHBlciBvciBsb3dlciB0cmlhbmdsZSBvZiB0aGUgc3ltbWV0cmljIG1hdHJpeCBBLCBw\nYWNrZWQKICAgICAgICAgY29sdW1ud2lzZSBpbiBhIGxpbmVhciBhcnJheS4gIFRoZSBqLXRoIGNv\nbHVtbiBvZiBBIGlzIHN0b3JlZAogICAgICAgICBpbiB0aGUgYXJyYXkgQVAgYXMgZm9sbG93czoK\nICAgICAgICAgaWYgVVBMTyA9ICdVJywgQVAoaSArIChqLTEpKmovMikgPSBBKGksaikgZm9yIDE8\nPWk8PWo7CiAgICAgICAgIGlmIFVQTE8gPSAnTCcsIEFQKGkgKyAoai0xKSooMm4taikvMikgPSBB\nKGksaikgZm9yIGo8PWk8PW4uClxwYXJhbVtpbl0gQUZQCiAgICAgICAgIEFGUCBpcyBET1VCTEUg\nUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4qKE4rMSkvMikKICAgICAgICAgVGhlIHRyaWFu\nZ3VsYXIgZmFjdG9yIFUgb3IgTCBmcm9tIHRoZSBDaG9sZXNreSBmYWN0b3JpemF0aW9uCiAgICAg\nICAgIEEgPSBVKipUKlUgb3IgQSA9IEwqTCoqVCwgYXMgY29tcHV0ZWQgYnkgRFBQVFJGL1pQUFRS\nRiwKICAgICAgICAgcGFja2VkIGNvbHVtbndpc2UgaW4gYSBsaW5lYXIgYXJyYXkgaW4gdGhlIHNh\nbWUgZm9ybWF0IGFzIEEKICAgICAgICAgKHNlZSBBUCkuClxwYXJhbVtpbl0gQgogICAgICAgICBC\nIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAg\nIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExE\nQiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkg\nQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIERPVUJM\nRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICAgICAgIE9uIGVudHJ5\nLCB0aGUgc29sdXRpb24gbWF0cml4IFgsIGFzIGNvbXB1dGVkIGJ5IERQUFRSUy4KICAgICAgICAg\nT24gZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAog\nICAgICAgICBMRFggaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2Yg\ndGhlIGFycmF5IFguICBMRFggPj0gbWF4KDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAg\nRkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAg\nIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciBib3VuZCBmb3IgZWFjaCBzb2x1dGlvbiB2ZWN0\nb3IKICAgICAgICAgWChqKSAodGhlIGotdGggY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBtYXRyaXgg\nWCkuCiAgICAgICAgIElmIFhUUlVFIGlzIHRoZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcg\ndG8gWChqKSwgRkVSUihqKQogICAgICAgICBpcyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91bmQgZm9y\nIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGxhcmdlc3QKICAgICAgICAgZWxlbWVudCBpbiAoWChqKSAt\nIFhUUlVFKSBkaXZpZGVkIGJ5IHRoZSBtYWduaXR1ZGUgb2YgdGhlCiAgICAgICAgIGxhcmdlc3Qg\nZWxlbWVudCBpbiBYKGopLiAgVGhlIGVzdGltYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAgICAgICAg\nIHRoZSBlc3RpbWF0ZSBmb3IgUkNPTkQsIGFuZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xpZ2h0CiAg\nICAgICAgIG92ZXJlc3RpbWF0ZSBvZiB0aGUgdHJ1ZSBlcnJvci4KXHBhcmFtW291dF0gQkVSUgog\nICAgICAgICBCRVJSIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykK\nICAgICAgICAgVGhlIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFj\naCBzb2x1dGlvbgogICAgICAgICB2ZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0\naXZlIGNoYW5nZSBpbgogICAgICAgICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBY\nKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlz\nIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoMypOKQpccGFyYW1bb3V0XSBJV09S\nSwogICAgICAgICBJV09SSyBpcyBJTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtv\ndXRdIElORk8KICAgICAgICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3Nm\ndWwgZXhpdAogICAgICAgICA8IDA6ICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhh\nZCBhbiBpbGxlZ2FsIHZhbHVlClxwYXIgSW50ZXJuYWwgUGFyYW1ldGVyczoKIElUTUFYIGlzIHRo\nZSBtYXhpbXVtIG51bWJlciBvZiBzdGVwcyBvZiBpdGVyYXRpdmUgcmVmaW5lbWVudC4KQXV0aG9y\nczoKXGF1dGhvciBVbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5p\nYSBCZXJrZWxleSAKXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFH\nIEx0ZC4gClxkYXRlIE5vdmVtYmVyIDIwMTEKXGluZ3JvdXAgZG91YmxlT1RIRVJjb21wdXRhdGlv\nbmFsCmgdaB4pgXH3fXH4KGghiWgiaCN1YmgtigL6AGguWA4AAABkcHByZnNfMjUwLnR4dHViaC+K\nAvoAaDBYBQAAAHBwcmZzaC2KARp1YmgVaBZdaBeHUnH5fXH6KGgaWAMAAABIUERoG1gGAAAAcGFj\na2VkaBxYPwAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVy\nYXRpdmUgcmVmaW5lbWVudGgdaB4pgXH7fXH8KGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3Mv\naHRtbC9jcHByZnNfOGYuaHRtbGglWAEAAABjaCZoFWgnXWgXh1Jx/X1x/ihoKlg2DAAAQ1BQUkZT\nIGltcHJvdmVzIHRoZSBjb21wdXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKZXF1\nYXRpb25zIHdoZW4gdGhlIGNvZWZmaWNpZW50IG1hdHJpeCBpcyBIZXJtaXRpYW4gcG9zaXRpdmUg\nZGVmaW5pdGUKYW5kIHBhY2tlZCwgYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dh\ncmQgZXJyb3IgZXN0aW1hdGVzCmZvciB0aGUgc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2lu\nXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgPSAnVSc6ICBVcHBl\nciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZDsKICAgICAgICAgPSAnTCc6ICBMb3dlciB0cmlhbmds\nZSBvZiBBIGlzIHN0b3JlZC4KXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAg\nICAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMK\nICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFu\nZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5zCiAgICAgICAgIG9mIHRoZSBtYXRy\naWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEFQCiAgICAgICAgIEFQIGlzIENP\nTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTiooTisxKS8yKQogICAgICAgICBUaGUgdXBwZXIgb3Ig\nbG93ZXIgdHJpYW5nbGUgb2YgdGhlIEhlcm1pdGlhbiBtYXRyaXggQSwgcGFja2VkCiAgICAgICAg\nIGNvbHVtbndpc2UgaW4gYSBsaW5lYXIgYXJyYXkuICBUaGUgai10aCBjb2x1bW4gb2YgQSBpcyBz\ndG9yZWQKICAgICAgICAgaW4gdGhlIGFycmF5IEFQIGFzIGZvbGxvd3M6CiAgICAgICAgIGlmIFVQ\nTE8gPSAnVScsIEFQKGkgKyAoai0xKSpqLzIpID0gQShpLGopIGZvciAxPD1pPD1qOwogICAgICAg\nICBpZiBVUExPID0gJ0wnLCBBUChpICsgKGotMSkqKDJuLWopLzIpID0gQShpLGopIGZvciBqPD1p\nPD1uLgpccGFyYW1baW5dIEFGUAogICAgICAgICBBRlAgaXMgQ09NUExFWCBhcnJheSwgZGltZW5z\naW9uIChOKihOKzEpLzIpCiAgICAgICAgIFRoZSB0cmlhbmd1bGFyIGZhY3RvciBVIG9yIEwgZnJv\nbSB0aGUgQ2hvbGVza3kgZmFjdG9yaXphdGlvbgogICAgICAgICBBID0gVSoqSCpVIG9yIEEgPSBM\nKkwqKkgsIGFzIGNvbXB1dGVkIGJ5IFNQUFRSRi9DUFBUUkYsCiAgICAgICAgIHBhY2tlZCBjb2x1\nbW53aXNlIGluIGEgbGluZWFyIGFycmF5IGluIHRoZSBzYW1lIGZvcm1hdCBhcyBBCiAgICAgICAg\nIChzZWUgQVApLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBDT01QTEVYIGFycmF5LCBkaW1l\nbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpc\ncGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGlu\nZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixv\ndXRdIFgKICAgICAgICAgWCBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQog\nICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBieSBD\nUFBUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXggWC4K\nXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRp\nbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0\nXSBGRVJSCiAgICAgICAgIEZFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAg\nICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24g\ndmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0\ncml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25k\naW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5k\nIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgo\naikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJn\nZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAg\nICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdo\ndAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJF\nUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAg\nIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRp\nb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFu\nZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBl\neGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBDT01QTEVY\nIGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0gUldPUksKICAgICAgICAgUldPUksg\naXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElO\nRk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAw\nOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpc\ncGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2Yg\nc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2Yg\nVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3Ig\nVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJl\nciAyMDExClxpbmdyb3VwIGNvbXBsZXhPVEhFUmNvbXB1dGF0aW9uYWwKaB1oHimBcf99cgABAAAo\naCGJaCJoI3ViaC2KAvsAaC5YDgAAAGNwcHJmc18yNTEudHh0dWJoL4oC+wBoMFgFAAAAcHByZnNo\nLYoBG3ViaBVoFl1oF4dScgEBAAB9cgIBAAAoaBpYAwAAAEhQRGgbWAYAAABwYWNrZWRoHFg/AAAA\nZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZp\nbmVtZW50aB1oHimBcgMBAAB9cgQBAAAoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4vZG9jcy9odG1s\nL3pwcHJmc184Zi5odG1saCVYAQAAAHpoJmgVaCddaBeHUnIFAQAAfXIGAQAAKGgqWGsMAABaUFBS\nRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgpl\ncXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIEhlcm1pdGlhbiBwb3NpdGl2\nZSBkZWZpbml0ZQphbmQgcGFja2VkLCBhbmQgcHJvdmlkZXMgZXJyb3IgYm91bmRzIGFuZCBiYWNr\nd2FyZCBlcnJvciBlc3RpbWF0ZXMKZm9yIHRoZSBzb2x1dGlvbi4KQXJndW1lbnRzOgpccGFyYW1b\naW5dIFVQTE8KICAgICAgICAgVVBMTyBpcyBDSEFSQUNURVIqMQogICAgICAgICA9ICdVJzogIFVw\ncGVyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkOwogICAgICAgICA9ICdMJzogIExvd2VyIHRyaWFu\nZ2xlIG9mIEEgaXMgc3RvcmVkLgpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAg\nICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJI\nUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBo\nYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1h\ndHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQVAKICAgICAgICAgQVAgaXMg\nQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChOKihOKzEpLzIpCiAgICAgICAgIFRoZSB1cHBl\nciBvciBsb3dlciB0cmlhbmdsZSBvZiB0aGUgSGVybWl0aWFuIG1hdHJpeCBBLCBwYWNrZWQKICAg\nICAgICAgY29sdW1ud2lzZSBpbiBhIGxpbmVhciBhcnJheS4gIFRoZSBqLXRoIGNvbHVtbiBvZiBB\nIGlzIHN0b3JlZAogICAgICAgICBpbiB0aGUgYXJyYXkgQVAgYXMgZm9sbG93czoKICAgICAgICAg\naWYgVVBMTyA9ICdVJywgQVAoaSArIChqLTEpKmovMikgPSBBKGksaikgZm9yIDE8PWk8PWo7CiAg\nICAgICAgIGlmIFVQTE8gPSAnTCcsIEFQKGkgKyAoai0xKSooMm4taikvMikgPSBBKGksaikgZm9y\nIGo8PWk8PW4uClxwYXJhbVtpbl0gQUZQCiAgICAgICAgIEFGUCBpcyBDT01QTEVYKjE2IGFycmF5\nLCBkaW1lbnNpb24gKE4qKE4rMSkvMikKICAgICAgICAgVGhlIHRyaWFuZ3VsYXIgZmFjdG9yIFUg\nb3IgTCBmcm9tIHRoZSBDaG9sZXNreSBmYWN0b3JpemF0aW9uCiAgICAgICAgIEEgPSBVKipIKlUg\nb3IgQSA9IEwqTCoqSCwgYXMgY29tcHV0ZWQgYnkgRFBQVFJGL1pQUFRSRiwKICAgICAgICAgcGFj\na2VkIGNvbHVtbndpc2UgaW4gYSBsaW5lYXIgYXJyYXkgaW4gdGhlIHNhbWUgZm9ybWF0IGFzIEEK\nICAgICAgICAgKHNlZSBBUCkuClxwYXJhbVtpbl0gQgogICAgICAgICBCIGlzIENPTVBMRVgqMTYg\nYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUg\nbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VSCiAgICAgICAg\nIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4K\nXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lv\nbiAoTERYLE5SSFMpCiAgICAgICAgIE9uIGVudHJ5LCB0aGUgc29sdXRpb24gbWF0cml4IFgsIGFz\nIGNvbXB1dGVkIGJ5IFpQUFRSUy4KICAgICAgICAgT24gZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0\naW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgogICAg\nICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4KDEs\nTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFy\ncmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJv\nciBib3VuZCBmb3IgZWFjaCBzb2x1dGlvbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhlIGotdGgg\nY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBtYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVFIGlzIHRo\nZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAgICAgICBp\ncyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91bmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGxhcmdl\nc3QKICAgICAgICAgZWxlbWVudCBpbiAoWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRoZSBtYWdu\naXR1ZGUgb2YgdGhlCiAgICAgICAgIGxhcmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhlIGVzdGlt\nYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAgICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNPTkQsIGFu\nZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xpZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBvZiB0aGUg\ndHJ1ZSBlcnJvci4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIERPVUJMRSBQUkVD\nSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGNvbXBvbmVudHdpc2Ug\ncmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1dGlvbgogICAgICAgICB2ZWN0b3Ig\nWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbgogICAgICAgICBhbnkg\nZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBh\ncmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lv\nbiAoMipOKQpccGFyYW1bb3V0XSBSV09SSwogICAgICAgICBSV09SSyBpcyBET1VCTEUgUFJFQ0lT\nSU9OIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRdIElORk8KICAgICAgICAgSU5GTyBp\ncyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3NmdWwgZXhpdAogICAgICAgICA8IDA6ICBp\nZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVlClxwYXIg\nSW50ZXJuYWwgUGFyYW1ldGVyczoKIElUTUFYIGlzIHRoZSBtYXhpbXVtIG51bWJlciBvZiBzdGVw\ncyBvZiBpdGVyYXRpdmUgcmVmaW5lbWVudC4KQXV0aG9yczoKXGF1dGhvciBVbml2LiBvZiBUZW5u\nZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBCZXJrZWxleSAKXGF1dGhvciBVbml2\nLiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0ZC4gClxkYXRlIE5vdmVtYmVyIDIw\nMTEKXGluZ3JvdXAgY29tcGxleDE2T1RIRVJjb21wdXRhdGlvbmFsCmgdaB4pgXIHAQAAfXIIAQAA\nKGghiWgiaCN1YmgtigL8AGguWA4AAAB6cHByZnNfMjUyLnR4dHViaC+KAvwAaDBYBQAAAHBwcmZz\naC2KARx1YmgVaBZdaBeHUnIJAQAAfXIKAQAAKGgaWAMAAABTUERoG1gLAAAAdHJpZGlhZ29uYWxo\nHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2\nZSByZWZpbmVtZW50aB1oHimBcgsBAAB9cgwBAAAoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4vZG9j\ncy9odG1sL3NwdHJmc184Zi5odG1saCVYAQAAAHNoJmgVaCddaBeHUnINAQAAfXIOAQAAKGgqWHYK\nAABTUFRSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxp\nbmVhcgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIHN5bW1ldHJpYyBw\nb3NpdGl2ZSBkZWZpbml0ZQphbmQgdHJpZGlhZ29uYWwsIGFuZCBwcm92aWRlcyBlcnJvciBib3Vu\nZHMgYW5kIGJhY2t3YXJkIGVycm9yCmVzdGltYXRlcyBmb3IgdGhlIHNvbHV0aW9uLgpBcmd1bWVu\ndHM6ClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG9yZGVy\nIG9mIHRoZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMg\naXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4s\nIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUgbWF0cml4IEIuICBOUkhTID49\nIDAuClxwYXJhbVtpbl0gRAogICAgICAgICBEIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTikK\nICAgICAgICAgVGhlIG4gZGlhZ29uYWwgZWxlbWVudHMgb2YgdGhlIHRyaWRpYWdvbmFsIG1hdHJp\neCBBLgpccGFyYW1baW5dIEUKICAgICAgICAgRSBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE4t\nMSkKICAgICAgICAgVGhlIChuLTEpIHN1YmRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoZSB0cmlkaWFn\nb25hbCBtYXRyaXggQS4KXHBhcmFtW2luXSBERgogICAgICAgICBERiBpcyBSRUFMIGFycmF5LCBk\naW1lbnNpb24gKE4pCiAgICAgICAgIFRoZSBuIGRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoZSBkaWFn\nb25hbCBtYXRyaXggRCBmcm9tIHRoZQogICAgICAgICBmYWN0b3JpemF0aW9uIGNvbXB1dGVkIGJ5\nIFNQVFRSRi4KXHBhcmFtW2luXSBFRgogICAgICAgICBFRiBpcyBSRUFMIGFycmF5LCBkaW1lbnNp\nb24gKE4tMSkKICAgICAgICAgVGhlIChuLTEpIHN1YmRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoZSB1\nbml0IGJpZGlhZ29uYWwgZmFjdG9yCiAgICAgICAgIEwgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBj\nb21wdXRlZCBieSBTUFRUUkYuClxwYXJhbVtpbl0gQgogICAgICAgICBCIGlzIFJFQUwgYXJyYXks\nIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4\nIEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBs\nZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFt\nW2luLG91dF0gWAogICAgICAgICBYIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMp\nCiAgICAgICAgIE9uIGVudHJ5LCB0aGUgc29sdXRpb24gbWF0cml4IFgsIGFzIGNvbXB1dGVkIGJ5\nIFNQVFRSUy4KICAgICAgICAgT24gZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0aW9uIG1hdHJpeCBY\nLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVh\nZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4KDEsTikuClxwYXJhbVtv\ndXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAg\nICAgICAgIFRoZSBmb3J3YXJkIGVycm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3Rvcgog\nICAgICAgICBYKGopICh0aGUgai10aCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4K\nICAgICAgICAgSWYgWFRSVUUgaXMgdGhlIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBY\nKGopLCBGRVJSKGopCiAgICAgICAgIGlzIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhl\nIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2VzdAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRS\nVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25pdHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVt\nZW50IGluIFgoaikuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFycmF5\nLCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJh\nY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4s\nIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2Yg\nQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdP\nUksKICAgICAgICAgV09SSyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFtW291\ndF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgICAgPSAwOiAgc3VjY2Vzc2Z1\nbCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFk\nIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRNQVggaXMgdGhl\nIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50LgpBdXRob3Jz\nOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlh\nIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcg\nTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCByZWFsT1RIRVJjb21wdXRhdGlvbmFs\nCmgdaB4pgXIPAQAAfXIQAQAAKGghiWgiaCN1YmgtigL9AGguWA4AAABzcHRyZnNfMjUzLnR4dHVi\naC+KAv0AaDBYBQAAAHB0cmZzaC2KAR11YmgVaBZdaBeHUnIRAQAAfXISAQAAKGgaWAMAAABTUERo\nG1gLAAAAdHJpZGlhZ29uYWxoHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBl\nc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZpbmVtZW50aB1oHimBchMBAAB9chQBAAAoaCGJaCJoI3Vi\naCRYIAAAAERveHlnZW4vZG9jcy9odG1sL2RwdHJmc184Zi5odG1saCVYAQAAAGRoJmgVaCddaBeH\nUnIVAQAAfXIWAQAAKGgqWOQKAABEUFRSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9u\nIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0\ncml4IGlzIHN5bW1ldHJpYyBwb3NpdGl2ZSBkZWZpbml0ZQphbmQgdHJpZGlhZ29uYWwsIGFuZCBw\ncm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yCmVzdGltYXRlcyBmb3IgdGhl\nIHNvbHV0aW9uLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIK\nICAgICAgICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBO\nUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0\nIGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUg\nbWF0cml4IEIuICBOUkhTID49IDAuClxwYXJhbVtpbl0gRAogICAgICAgICBEIGlzIERPVUJMRSBQ\nUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTikKICAgICAgICAgVGhlIG4gZGlhZ29uYWwgZWxl\nbWVudHMgb2YgdGhlIHRyaWRpYWdvbmFsIG1hdHJpeCBBLgpccGFyYW1baW5dIEUKICAgICAgICAg\nRSBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4tMSkKICAgICAgICAgVGhl\nIChuLTEpIHN1YmRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoZSB0cmlkaWFnb25hbCBtYXRyaXggQS4K\nXHBhcmFtW2luXSBERgogICAgICAgICBERiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1l\nbnNpb24gKE4pCiAgICAgICAgIFRoZSBuIGRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoZSBkaWFnb25h\nbCBtYXRyaXggRCBmcm9tIHRoZQogICAgICAgICBmYWN0b3JpemF0aW9uIGNvbXB1dGVkIGJ5IERQ\nVFRSRi4KXHBhcmFtW2luXSBFRgogICAgICAgICBFRiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5\nLCBkaW1lbnNpb24gKE4tMSkKICAgICAgICAgVGhlIChuLTEpIHN1YmRpYWdvbmFsIGVsZW1lbnRz\nIG9mIHRoZSB1bml0IGJpZGlhZ29uYWwgZmFjdG9yCiAgICAgICAgIEwgZnJvbSB0aGUgZmFjdG9y\naXphdGlvbiBjb21wdXRlZCBieSBEUFRUUkYuClxwYXJhbVtpbl0gQgogICAgICAgICBCIGlzIERP\nVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRoZSBy\naWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJ\nTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExE\nQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIERPVUJMRSBQUkVD\nSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICAgICAgIE9uIGVudHJ5LCB0aGUg\nc29sdXRpb24gbWF0cml4IFgsIGFzIGNvbXB1dGVkIGJ5IERQVFRSUy4KICAgICAgICAgT24gZXhp\ndCwgdGhlIGltcHJvdmVkIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAg\nICBMRFggaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFy\ncmF5IFguICBMRFggPj0gbWF4KDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBp\ncyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBm\nb3J3YXJkIGVycm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGop\nICh0aGUgai10aCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYg\nWFRSVUUgaXMgdGhlIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGop\nCiAgICAgICAgIGlzIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBv\nZiB0aGUgbGFyZ2VzdAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQg\nYnkgdGhlIG1hZ25pdHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaiku\nClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5\nLCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJh\nY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4s\nIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2Yg\nQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdP\nUksKICAgICAgICAgV09SSyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKDIq\nTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgICAgPSAw\nOiAgc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAtaSwgdGhlIGktdGgg\nYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgog\nSVRNQVggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVt\nZW50LgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBv\nZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAK\nXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCBkb3VibGVPVEhF\nUmNvbXB1dGF0aW9uYWwKaB1oHimBchcBAAB9chgBAAAoaCGJaCJoI3ViaC2KAv4AaC5YDgAAAGRw\ndHJmc18yNTQudHh0dWJoL4oC/gBoMFgFAAAAcHRyZnNoLYoBHnViaBVoFl1oF4dSchkBAAB9choB\nAAAoaBpYAwAAAEhQRGgbWAsAAAB0cmlkaWFnb25hbGgcWD8AAABlcnJvciBib3VuZHMgYW5kIGJh\nY2t3YXJkIGVycm9yIGVzdGltYXRlczsgaXRlcmF0aXZlIHJlZmluZW1lbnRoHWgeKYFyGwEAAH1y\nHAEAAChoIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwvY3B0cmZzXzhmLmh0bWxoJVgB\nAAAAY2gmaBVoJ11oF4dSch0BAAB9ch4BAAAoaCpYdAwAAENQVFJGUyBpbXByb3ZlcyB0aGUgY29t\ncHV0ZWQgc29sdXRpb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyCmVxdWF0aW9ucyB3aGVuIHRoZSBj\nb2VmZmljaWVudCBtYXRyaXggaXMgSGVybWl0aWFuIHBvc2l0aXZlIGRlZmluaXRlCmFuZCB0cmlk\naWFnb25hbCwgYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IKZXN0\naW1hdGVzIGZvciB0aGUgc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFtW2luXSBVUExPCiAgICAg\nICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgU3BlY2lmaWVzIHdoZXRoZXIgdGhlIHN1\ncGVyZGlhZ29uYWwgb3IgdGhlIHN1YmRpYWdvbmFsIG9mIHRoZQogICAgICAgICB0cmlkaWFnb25h\nbCBtYXRyaXggQSBpcyBzdG9yZWQgYW5kIHRoZSBmb3JtIG9mIHRoZQogICAgICAgICBmYWN0b3Jp\nemF0aW9uOgogICAgICAgICA9ICdVJzogIEUgaXMgdGhlIHN1cGVyZGlhZ29uYWwgb2YgQSwgYW5k\nIEEgPSBVKipIKkQqVTsKICAgICAgICAgPSAnTCc6ICBFIGlzIHRoZSBzdWJkaWFnb25hbCBvZiBB\nLCBhbmQgQSA9IEwqRCpMKipILgogICAgICAgICAoVGhlIHR3byBmb3JtcyBhcmUgZXF1aXZhbGVu\ndCBpZiBBIGlzIHJlYWwuKQpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICAg\nICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJIUwog\nICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5k\nIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1hdHJp\neCBCLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEQKICAgICAgICAgRCBpcyBSRUFMIGFycmF5LCBk\naW1lbnNpb24gKE4pCiAgICAgICAgIFRoZSBuIHJlYWwgZGlhZ29uYWwgZWxlbWVudHMgb2YgdGhl\nIHRyaWRpYWdvbmFsIG1hdHJpeCBBLgpccGFyYW1baW5dIEUKICAgICAgICAgRSBpcyBDT01QTEVY\nIGFycmF5LCBkaW1lbnNpb24gKE4tMSkKICAgICAgICAgVGhlIChuLTEpIG9mZi1kaWFnb25hbCBl\nbGVtZW50cyBvZiB0aGUgdHJpZGlhZ29uYWwgbWF0cml4IEEKICAgICAgICAgKHNlZSBVUExPKS4K\nXHBhcmFtW2luXSBERgogICAgICAgICBERiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE4pCiAg\nICAgICAgIFRoZSBuIGRpYWdvbmFsIGVsZW1lbnRzIG9mIHRoZSBkaWFnb25hbCBtYXRyaXggRCBm\ncm9tCiAgICAgICAgIHRoZSBmYWN0b3JpemF0aW9uIGNvbXB1dGVkIGJ5IENQVFRSRi4KXHBhcmFt\nW2luXSBFRgogICAgICAgICBFRiBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKE4tMSkKICAg\nICAgICAgVGhlIChuLTEpIG9mZi1kaWFnb25hbCBlbGVtZW50cyBvZiB0aGUgdW5pdCBiaWRpYWdv\nbmFsCiAgICAgICAgIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBjb21wdXRl\nZCBieSBDUFRUUkYKICAgICAgICAgKHNlZSBVUExPKS4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIg\naXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhlIHJpZ2h0\nIGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVH\nRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49\nIG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgQ09NUExFWCBhcnJheSwg\nZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRy\naXggWCwgYXMgY29tcHV0ZWQgYnkgQ1BUVFJTLgogICAgICAgICBPbiBleGl0LCB0aGUgaW1wcm92\nZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRF\nR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+\nPSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIFJFQUwgYXJyYXks\nIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVh\nY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUg\nc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlv\nbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVk\nIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVs\nZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQog\nICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4KXHBhcmFtW291dF0gQkVSUgogICAgICAg\nICBCRVJSIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGNvbXBv\nbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1dGlvbgogICAgICAg\nICB2ZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbgogICAg\nICAgICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0\naW9uKS4KXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIENPTVBMRVggYXJyYXksIGRp\nbWVuc2lvbiAoTikKXHBhcmFtW291dF0gUldPUksKICAgICAgICAgUldPUksgaXMgUkVBTCBhcnJh\neSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdF\nUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9\nIC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpccGFyIEludGVybmFs\nIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3RlcHMgb2YgaXRl\ncmF0aXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApc\nYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29s\nb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdy\nb3VwIGNvbXBsZXhPVEhFUmNvbXB1dGF0aW9uYWwKaB1oHimBch8BAAB9ciABAAAoaCGJaCJoI3Vi\naC2KAv8AaC5YDgAAAGNwdHJmc18yNTUudHh0dWJoL4oC/wBoMFgFAAAAcHRyZnNoLYoBH3ViaBVo\nFl1oF4dSciEBAAB9ciIBAAAoaBpYAwAAAEhQRGgbWAsAAAB0cmlkaWFnb25hbGgcWD8AAABlcnJv\nciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlczsgaXRlcmF0aXZlIHJlZmluZW1l\nbnRoHWgeKYFyIwEAAH1yJAEAAChoIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwvenB0\ncmZzXzhmLmh0bWxoJVgBAAAAemgmaBVoJ11oF4dSciUBAAB9ciYBAAAoaCpYwQwAAFpQVFJGUyBp\nbXByb3ZlcyB0aGUgY29tcHV0ZWQgc29sdXRpb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyCmVxdWF0\naW9ucyB3aGVuIHRoZSBjb2VmZmljaWVudCBtYXRyaXggaXMgSGVybWl0aWFuIHBvc2l0aXZlIGRl\nZmluaXRlCmFuZCB0cmlkaWFnb25hbCwgYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFj\na3dhcmQgZXJyb3IKZXN0aW1hdGVzIGZvciB0aGUgc29sdXRpb24uCkFyZ3VtZW50czoKXHBhcmFt\nW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgU3BlY2lmaWVz\nIHdoZXRoZXIgdGhlIHN1cGVyZGlhZ29uYWwgb3IgdGhlIHN1YmRpYWdvbmFsIG9mIHRoZQogICAg\nICAgICB0cmlkaWFnb25hbCBtYXRyaXggQSBpcyBzdG9yZWQgYW5kIHRoZSBmb3JtIG9mIHRoZQog\nICAgICAgICBmYWN0b3JpemF0aW9uOgogICAgICAgICA9ICdVJzogIEUgaXMgdGhlIHN1cGVyZGlh\nZ29uYWwgb2YgQSwgYW5kIEEgPSBVKipIKkQqVTsKICAgICAgICAgPSAnTCc6ICBFIGlzIHRoZSBz\ndWJkaWFnb25hbCBvZiBBLCBhbmQgQSA9IEwqRCpMKipILgogICAgICAgICAoVGhlIHR3byBmb3Jt\ncyBhcmUgZXF1aXZhbGVudCBpZiBBIGlzIHJlYWwuKQpccGFyYW1baW5dIE4KICAgICAgICAgTiBp\ncyBJTlRFR0VSCiAgICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxw\nYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJl\nciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAg\nICAgb2YgdGhlIG1hdHJpeCBCLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEQKICAgICAgICAgRCBp\ncyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICAgICAgIFRoZSBuIHJl\nYWwgZGlhZ29uYWwgZWxlbWVudHMgb2YgdGhlIHRyaWRpYWdvbmFsIG1hdHJpeCBBLgpccGFyYW1b\naW5dIEUKICAgICAgICAgRSBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKE4tMSkKICAg\nICAgICAgVGhlIChuLTEpIG9mZi1kaWFnb25hbCBlbGVtZW50cyBvZiB0aGUgdHJpZGlhZ29uYWwg\nbWF0cml4IEEKICAgICAgICAgKHNlZSBVUExPKS4KXHBhcmFtW2luXSBERgogICAgICAgICBERiBp\ncyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICAgICAgIFRoZSBuIGRp\nYWdvbmFsIGVsZW1lbnRzIG9mIHRoZSBkaWFnb25hbCBtYXRyaXggRCBmcm9tCiAgICAgICAgIHRo\nZSBmYWN0b3JpemF0aW9uIGNvbXB1dGVkIGJ5IFpQVFRSRi4KXHBhcmFtW2luXSBFRgogICAgICAg\nICBFRiBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKE4tMSkKICAgICAgICAgVGhlIChu\nLTEpIG9mZi1kaWFnb25hbCBlbGVtZW50cyBvZiB0aGUgdW5pdCBiaWRpYWdvbmFsCiAgICAgICAg\nIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBjb21wdXRlZCBieSBaUFRUUkYK\nICAgICAgICAgKHNlZSBVUExPKS4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIgaXMgQ09NUExFWCox\nNiBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lk\nZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVHRVIKICAgICAg\nICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49IG1heCgxLE4p\nLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5z\naW9uIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwg\nYXMgY29tcHV0ZWQgYnkgWlBUVFJTLgogICAgICAgICBPbiBleGl0LCB0aGUgaW1wcm92ZWQgc29s\ndXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAg\nICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+PSBtYXgo\nMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIERPVUJMRSBQUkVDSVNJT04g\nYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGZvcndhcmQgZXJyb3IgYm91bmQg\nZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBv\nZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBz\nb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0\naW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAg\nICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9m\nIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4KXHBhcmFtW291dF0gQkVSUgog\nICAgICAgICBCRVJSIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykK\nICAgICAgICAgVGhlIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFj\naCBzb2x1dGlvbgogICAgICAgICB2ZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0\naXZlIGNoYW5nZSBpbgogICAgICAgICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBY\nKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlz\nIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTikKXHBhcmFtW291dF0gUldPUksKICAgICAg\nICAgUldPUksgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1b\nb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNz\nZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBo\nYWQgYW4gaWxsZWdhbCB2YWx1ZQpccGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0\naGUgbWF4aW11bSBudW1iZXIgb2Ygc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhv\ncnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3Ju\naWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5B\nRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIGNvbXBsZXgxNk9USEVSY29tcHV0\nYXRpb25hbApoHWgeKYFyJwEAAH1yKAEAAChoIYloImgjdWJoLYoCAAFoLlgOAAAAenB0cmZzXzI1\nNi50eHR1YmgvigIAAWgwWAUAAABwdHJmc2gtigEgdWJoFWgWXWgXh1JyKQEAAH1yKgEAAChoGlgJ\nAAAAc3ltbWV0cmljaBtYBAAAAGZ1bGxoHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBl\ncnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZpbmVtZW50aB1oHimBcisBAAB9ciwBAAAoaCGJ\naCJoI3ViaCRYIAAAAERveHlnZW4vZG9jcy9odG1sL3NzeXJmc184Zi5odG1saCVYAQAAAHNoJmgV\naCddaBeHUnItAQAAfXIuAQAAKGgqWA8OAABTU1lSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNv\nbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2ll\nbnQgbWF0cml4IGlzIHN5bW1ldHJpYyBpbmRlZmluaXRlLCBhbmQKcHJvdmlkZXMgZXJyb3IgYm91\nbmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMgZm9yIHRoZSBzb2x1dGlvbi4KQXJndW1l\nbnRzOgpccGFyYW1baW5dIFVQTE8KICAgICAgICAgVVBMTyBpcyBDSEFSQUNURVIqMQogICAgICAg\nICA9ICdVJzogIFVwcGVyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkOwogICAgICAgICA9ICdMJzog\nIExvd2VyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkLgpccGFyYW1baW5dIE4KICAgICAgICAgTiBp\ncyBJTlRFR0VSCiAgICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxw\nYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJl\nciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAg\nICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQQogICAg\nICAgICBBIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTERBLE4pCiAgICAgICAgIFRoZSBzeW1t\nZXRyaWMgbWF0cml4IEEuICBJZiBVUExPID0gJ1UnLCB0aGUgbGVhZGluZyBOLWJ5LU4KICAgICAg\nICAgdXBwZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEgY29udGFpbnMgdGhlIHVwcGVyIHRyaWFuZ3Vs\nYXIgcGFydAogICAgICAgICBvZiB0aGUgbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkgbG93ZXIg\ndHJpYW5ndWxhciBwYXJ0IG9mIEEKICAgICAgICAgaXMgbm90IHJlZmVyZW5jZWQuICBJZiBVUExP\nID0gJ0wnLCB0aGUgbGVhZGluZyBOLWJ5LU4gbG93ZXIKICAgICAgICAgdHJpYW5ndWxhciBwYXJ0\nIG9mIEEgY29udGFpbnMgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgcGFydCBvZgogICAgICAgICB0aGUg\nbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkgdXBwZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEgaXMK\nICAgICAgICAgbm90IHJlZmVyZW5jZWQuClxwYXJhbVtpbl0gTERBCiAgICAgICAgIExEQSBpcyBJ\nTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQS4gIExE\nQSA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBBRgogICAgICAgICBBRiBpcyBSRUFMIGFycmF5LCBk\naW1lbnNpb24gKExEQUYsTikKICAgICAgICAgVGhlIGZhY3RvcmVkIGZvcm0gb2YgdGhlIG1hdHJp\neCBBLiAgQUYgY29udGFpbnMgdGhlIGJsb2NrCiAgICAgICAgIGRpYWdvbmFsIG1hdHJpeCBEIGFu\nZCB0aGUgbXVsdGlwbGllcnMgdXNlZCB0byBvYnRhaW4gdGhlCiAgICAgICAgIGZhY3RvciBVIG9y\nIEwgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBBID0gVSpEKlUqKlQgb3IKICAgICAgICAgQSA9IEwq\nRCpMKipUIGFzIGNvbXB1dGVkIGJ5IFNTWVRSRi4KXHBhcmFtW2luXSBMREFGCiAgICAgICAgIExE\nQUYgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5\nIEFGLiAgTERBRiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBJUElWCiAgICAgICAgIElQSVYgaXMg\nSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgICAgICBEZXRhaWxzIG9mIHRoZSBpbnRl\ncmNoYW5nZXMgYW5kIHRoZSBibG9jayBzdHJ1Y3R1cmUgb2YgRAogICAgICAgICBhcyBkZXRlcm1p\nbmVkIGJ5IFNTWVRSRi4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIgaXMgUkVBTCBhcnJheSwgZGlt\nZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4K\nXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRp\nbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49IG1heCgxLE4pLgpccGFyYW1baW4s\nb3V0XSBYCiAgICAgICAgIFggaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAg\nICAgICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgU1NZ\nVFJTLgogICAgICAgICBPbiBleGl0LCB0aGUgaW1wcm92ZWQgc29sdXRpb24gbWF0cml4IFguClxw\nYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5n\nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0g\nRkVSUgogICAgICAgICBGRVJSIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAg\nICAgVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZl\nY3RvcgogICAgICAgICBYKGopICh0aGUgai10aCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJp\neCBYKS4KICAgICAgICAgSWYgWFRSVUUgaXMgdGhlIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGlu\nZyB0byBYKGopLCBGRVJSKGopCiAgICAgICAgIGlzIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBm\nb3IgdGhlIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2VzdAogICAgICAgICBlbGVtZW50IGluIChYKGop\nIC0gWFRSVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25pdHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2Vz\ndCBlbGVtZW50IGluIFgoaikuICBUaGUgZXN0aW1hdGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAg\nICAgdGhlIGVzdGltYXRlIGZvciBSQ09ORCwgYW5kIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQK\nICAgICAgICAgb3ZlcmVzdGltYXRlIG9mIHRoZSB0cnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJS\nCiAgICAgICAgIEJFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBU\naGUgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9u\nCiAgICAgICAgIHZlY3RvciBYKGopIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdl\nIGluCiAgICAgICAgIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhh\nY3Qgc29sdXRpb24pLgpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgUkVBTCBhcnJh\neSwgZGltZW5zaW9uICgzKk4pClxwYXJhbVtvdXRdIElXT1JLCiAgICAgICAgIElXT1JLIGlzIElO\nVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZP\nIGlzIElOVEVHRVIKICAgICAgICAgPSAwOiAgc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDog\nIGlmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBh\nciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRNQVggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0\nZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50LgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRl\nbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVu\naXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIg\nMjAxMQpcaW5ncm91cCByZWFsU1ljb21wdXRhdGlvbmFsCmgdaB4pgXIvAQAAfXIwAQAAKGghiWgi\naCN1YmgtigIBAWguWA4AAABzc3lyZnNfMjU3LnR4dHViaC+KAgEBaDBYBQAAAHN5cmZzaC2KASF1\nYmgVaBZdaBeHUnIxAQAAfXIyAQAAKGgaWAkAAABzeW1tZXRyaWNoG1gEAAAAZnVsbGgcWD8AAABl\ncnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlczsgaXRlcmF0aXZlIHJlZmlu\nZW1lbnRoHWgeKYFyMwEAAH1yNAEAAChoIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwv\nZHN5cmZzXzhmLmh0bWxoJVgBAAAAZGgmaBVoJ11oF4dScjUBAAB9cjYBAAAoaCpYZQ4AAERTWVJG\nUyBpbXByb3ZlcyB0aGUgY29tcHV0ZWQgc29sdXRpb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyCmVx\ndWF0aW9ucyB3aGVuIHRoZSBjb2VmZmljaWVudCBtYXRyaXggaXMgc3ltbWV0cmljIGluZGVmaW5p\ndGUsIGFuZApwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRl\ncyBmb3IgdGhlIHNvbHV0aW9uLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVVBMTwogICAgICAgICBV\nUExPIGlzIENIQVJBQ1RFUioxCiAgICAgICAgID0gJ1UnOiAgVXBwZXIgdHJpYW5nbGUgb2YgQSBp\ncyBzdG9yZWQ7CiAgICAgICAgID0gJ0wnOiAgTG93ZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQu\nClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG9yZGVyIG9m\nIHRoZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMg\nSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRo\nZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5S\nSFMgPj0gMC4KXHBhcmFtW2luXSBBCiAgICAgICAgIEEgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJh\neSwgZGltZW5zaW9uIChMREEsTikKICAgICAgICAgVGhlIHN5bW1ldHJpYyBtYXRyaXggQS4gIElm\nIFVQTE8gPSAnVScsIHRoZSBsZWFkaW5nIE4tYnktTgogICAgICAgICB1cHBlciB0cmlhbmd1bGFy\nIHBhcnQgb2YgQSBjb250YWlucyB0aGUgdXBwZXIgdHJpYW5ndWxhciBwYXJ0CiAgICAgICAgIG9m\nIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBzdHJpY3RseSBsb3dlciB0cmlhbmd1bGFyIHBhcnQgb2Yg\nQQogICAgICAgICBpcyBub3QgcmVmZXJlbmNlZC4gIElmIFVQTE8gPSAnTCcsIHRoZSBsZWFkaW5n\nIE4tYnktTiBsb3dlcgogICAgICAgICB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUg\nbG93ZXIgdHJpYW5ndWxhciBwYXJ0IG9mCiAgICAgICAgIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBz\ndHJpY3RseSB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2YgQSBpcwogICAgICAgICBub3QgcmVmZXJl\nbmNlZC4KXHBhcmFtW2luXSBMREEKICAgICAgICAgTERBIGlzIElOVEVHRVIKICAgICAgICAgVGhl\nIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBLiAgTERBID49IG1heCgxLE4pLgpccGFy\nYW1baW5dIEFGCiAgICAgICAgIEFGIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lv\nbiAoTERBRixOKQogICAgICAgICBUaGUgZmFjdG9yZWQgZm9ybSBvZiB0aGUgbWF0cml4IEEuICBB\nRiBjb250YWlucyB0aGUgYmxvY2sKICAgICAgICAgZGlhZ29uYWwgbWF0cml4IEQgYW5kIHRoZSBt\ndWx0aXBsaWVycyB1c2VkIHRvIG9idGFpbiB0aGUKICAgICAgICAgZmFjdG9yIFUgb3IgTCBmcm9t\nIHRoZSBmYWN0b3JpemF0aW9uIEEgPSBVKkQqVSoqVCBvcgogICAgICAgICBBID0gTCpEKkwqKlQg\nYXMgY29tcHV0ZWQgYnkgRFNZVFJGLgpccGFyYW1baW5dIExEQUYKICAgICAgICAgTERBRiBpcyBJ\nTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUYuICBM\nREFGID49IG1heCgxLE4pLgpccGFyYW1baW5dIElQSVYKICAgICAgICAgSVBJViBpcyBJTlRFR0VS\nIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICAgICAgIERldGFpbHMgb2YgdGhlIGludGVyY2hhbmdl\ncyBhbmQgdGhlIGJsb2NrIHN0cnVjdHVyZSBvZiBECiAgICAgICAgIGFzIGRldGVybWluZWQgYnkg\nRFNZVFJGLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5\nLCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJp\neCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBUaGUg\nbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJh\nbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNp\nb24gKExEWCxOUkhTKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBh\ncyBjb21wdXRlZCBieSBEU1lUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1\ndGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAg\nICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgx\nLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgRE9VQkxFIFBSRUNJU0lPTiBh\ncnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJy\nb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRo\nIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0\naGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAg\naXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJn\nZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFn\nbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3Rp\nbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBh\nbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhl\nIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBET1VCTEUgUFJF\nQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNl\nIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9y\nIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55\nIGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxw\nYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBk\naW1lbnNpb24gKDMqTikKXHBhcmFtW291dF0gSVdPUksKICAgICAgICAgSVdPUksgaXMgSU5URUdF\nUiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMg\nSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYg\nSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpccGFyIElu\ndGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11bSBudW1iZXIgb2Ygc3RlcHMg\nb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVz\nc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4g\nb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDEx\nClxpbmdyb3VwIGRvdWJsZVNZY29tcHV0YXRpb25hbApoHWgeKYFyNwEAAH1yOAEAAChoIYloImgj\ndWJoLYoCAgFoLlgOAAAAZHN5cmZzXzI1OC50eHR1YmgvigICAWgwWAUAAABzeXJmc2gtigEidWJo\nFWgWXWgXh1JyOQEAAH1yOgEAAChoGlgJAAAAc3ltbWV0cmljaBtYBAAAAGZ1bGxoHFg/AAAAZXJy\nb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZpbmVt\nZW50aB1oHimBcjsBAAB9cjwBAAAoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4vZG9jcy9odG1sL2Nz\neXJmc184Zi5odG1saCVYAQAAAGNoJmgVaCddaBeHUnI9AQAAfXI+AQAAKGgqWB4OAABDU1lSRlMg\naW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgplcXVh\ndGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIHN5bW1ldHJpYyBpbmRlZmluaXRl\nLCBhbmQKcHJvdmlkZXMgZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMg\nZm9yIHRoZSBzb2x1dGlvbi4KQXJndW1lbnRzOgpccGFyYW1baW5dIFVQTE8KICAgICAgICAgVVBM\nTyBpcyBDSEFSQUNURVIqMQogICAgICAgICA9ICdVJzogIFVwcGVyIHRyaWFuZ2xlIG9mIEEgaXMg\nc3RvcmVkOwogICAgICAgICA9ICdMJzogIExvd2VyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkLgpc\ncGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBvcmRlciBvZiB0\naGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlzIElO\nVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUg\nbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhT\nID49IDAuClxwYXJhbVtpbl0gQQogICAgICAgICBBIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lv\nbiAoTERBLE4pCiAgICAgICAgIFRoZSBzeW1tZXRyaWMgbWF0cml4IEEuICBJZiBVUExPID0gJ1Un\nLCB0aGUgbGVhZGluZyBOLWJ5LU4KICAgICAgICAgdXBwZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEg\nY29udGFpbnMgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgcGFydAogICAgICAgICBvZiB0aGUgbWF0cml4\nIEEsIGFuZCB0aGUgc3RyaWN0bHkgbG93ZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEKICAgICAgICAg\naXMgbm90IHJlZmVyZW5jZWQuICBJZiBVUExPID0gJ0wnLCB0aGUgbGVhZGluZyBOLWJ5LU4gbG93\nZXIKICAgICAgICAgdHJpYW5ndWxhciBwYXJ0IG9mIEEgY29udGFpbnMgdGhlIGxvd2VyIHRyaWFu\nZ3VsYXIgcGFydCBvZgogICAgICAgICB0aGUgbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkgdXBw\nZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEgaXMKICAgICAgICAgbm90IHJlZmVyZW5jZWQuClxwYXJh\nbVtpbl0gTERBCiAgICAgICAgIExEQSBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRp\nbWVuc2lvbiBvZiB0aGUgYXJyYXkgQS4gIExEQSA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBBRgog\nICAgICAgICBBRiBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKExEQUYsTikKICAgICAgICAg\nVGhlIGZhY3RvcmVkIGZvcm0gb2YgdGhlIG1hdHJpeCBBLiAgQUYgY29udGFpbnMgdGhlIGJsb2Nr\nCiAgICAgICAgIGRpYWdvbmFsIG1hdHJpeCBEIGFuZCB0aGUgbXVsdGlwbGllcnMgdXNlZCB0byBv\nYnRhaW4gdGhlCiAgICAgICAgIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBB\nID0gVSpEKlUqKlQgb3IKICAgICAgICAgQSA9IEwqRCpMKipUIGFzIGNvbXB1dGVkIGJ5IENTWVRS\nRi4KXHBhcmFtW2luXSBMREFGCiAgICAgICAgIExEQUYgaXMgSU5URUdFUgogICAgICAgICBUaGUg\nbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFGLiAgTERBRiA+PSBtYXgoMSxOKS4KXHBh\ncmFtW2luXSBJUElWCiAgICAgICAgIElQSVYgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChO\nKQogICAgICAgICBEZXRhaWxzIG9mIHRoZSBpbnRlcmNoYW5nZXMgYW5kIHRoZSBibG9jayBzdHJ1\nY3R1cmUgb2YgRAogICAgICAgICBhcyBkZXRlcm1pbmVkIGJ5IENTWVRSRi4KXHBhcmFtW2luXSBC\nCiAgICAgICAgIEIgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAg\nICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAg\nTERCIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJh\neSBCLiAgTERCID49IG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgQ09N\nUExFWCBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBz\nb2x1dGlvbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgQ1NZVFJTLgogICAgICAgICBPbiBleGl0\nLCB0aGUgaW1wcm92ZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAg\nIExEWCBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJy\nYXkgWC4gIExEWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlz\nIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3\nYXJkIGVycm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGopICh0\naGUgai10aCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRS\nVUUgaXMgdGhlIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAg\nICAgICAgIGlzIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0\naGUgbGFyZ2VzdAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkg\ndGhlIG1hZ25pdHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBU\naGUgZXN0aW1hdGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBS\nQ09ORCwgYW5kIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRl\nIG9mIHRoZSB0cnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgUkVB\nTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9uZW50d2lzZSByZWxh\ndGl2ZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBYKGop\nIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBlbGVt\nZW50IG9mIEEgb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1b\nb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uICgyKk4p\nClxwYXJhbVtvdXRdIFJXT1JLCiAgICAgICAgIFJXT1JLIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lv\nbiAoTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgICAg\nPSAwOiAgc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAtaSwgdGhlIGkt\ndGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJz\nOgogSVRNQVggaXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZp\nbmVtZW50LgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2\nLiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZl\nciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCBjb21wbGV4\nU1ljb21wdXRhdGlvbmFsCmgdaB4pgXI/AQAAfXJAAQAAKGghiWgiaCN1YmgtigIDAWguWA4AAABj\nc3lyZnNfMjU5LnR4dHViaC+KAgMBaDBYBQAAAHN5cmZzaC2KASN1YmgVaBZdaBeHUnJBAQAAfXJC\nAQAAKGgaWAkAAABzeW1tZXRyaWNoG1gEAAAAZnVsbGgcWD8AAABlcnJvciBib3VuZHMgYW5kIGJh\nY2t3YXJkIGVycm9yIGVzdGltYXRlczsgaXRlcmF0aXZlIHJlZmluZW1lbnRoHWgeKYFyQwEAAH1y\nRAEAAChoIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwvenN5cmZzXzhmLmh0bWxoJVgB\nAAAAemgmaBVoJ11oF4dSckUBAAB9ckYBAAAoaCpYUw4AAFpTWVJGUyBpbXByb3ZlcyB0aGUgY29t\ncHV0ZWQgc29sdXRpb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyCmVxdWF0aW9ucyB3aGVuIHRoZSBj\nb2VmZmljaWVudCBtYXRyaXggaXMgc3ltbWV0cmljIGluZGVmaW5pdGUsIGFuZApwcm92aWRlcyBl\ncnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcyBmb3IgdGhlIHNvbHV0aW9u\nLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUiox\nCiAgICAgICAgID0gJ1UnOiAgVXBwZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQ7CiAgICAgICAg\nID0gJ0wnOiAgTG93ZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQuClxwYXJhbVtpbl0gTgogICAg\nICAgICBOIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4g\nPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBU\naGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1u\ncwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2lu\nXSBBCiAgICAgICAgIEEgaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChMREEsTikKICAg\nICAgICAgVGhlIHN5bW1ldHJpYyBtYXRyaXggQS4gIElmIFVQTE8gPSAnVScsIHRoZSBsZWFkaW5n\nIE4tYnktTgogICAgICAgICB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUg\ndXBwZXIgdHJpYW5ndWxhciBwYXJ0CiAgICAgICAgIG9mIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBz\ndHJpY3RseSBsb3dlciB0cmlhbmd1bGFyIHBhcnQgb2YgQQogICAgICAgICBpcyBub3QgcmVmZXJl\nbmNlZC4gIElmIFVQTE8gPSAnTCcsIHRoZSBsZWFkaW5nIE4tYnktTiBsb3dlcgogICAgICAgICB0\ncmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgbG93ZXIgdHJpYW5ndWxhciBwYXJ0IG9m\nCiAgICAgICAgIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBzdHJpY3RseSB1cHBlciB0cmlhbmd1bGFy\nIHBhcnQgb2YgQSBpcwogICAgICAgICBub3QgcmVmZXJlbmNlZC4KXHBhcmFtW2luXSBMREEKICAg\nICAgICAgTERBIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRo\nZSBhcnJheSBBLiAgTERBID49IG1heCgxLE4pLgpccGFyYW1baW5dIEFGCiAgICAgICAgIEFGIGlz\nIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTERBRixOKQogICAgICAgICBUaGUgZmFjdG9y\nZWQgZm9ybSBvZiB0aGUgbWF0cml4IEEuICBBRiBjb250YWlucyB0aGUgYmxvY2sKICAgICAgICAg\nZGlhZ29uYWwgbWF0cml4IEQgYW5kIHRoZSBtdWx0aXBsaWVycyB1c2VkIHRvIG9idGFpbiB0aGUK\nICAgICAgICAgZmFjdG9yIFUgb3IgTCBmcm9tIHRoZSBmYWN0b3JpemF0aW9uIEEgPSBVKkQqVSoq\nVCBvcgogICAgICAgICBBID0gTCpEKkwqKlQgYXMgY29tcHV0ZWQgYnkgWlNZVFJGLgpccGFyYW1b\naW5dIExEQUYKICAgICAgICAgTERBRiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRp\nbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUYuICBMREFGID49IG1heCgxLE4pLgpccGFyYW1baW5dIElQ\nSVYKICAgICAgICAgSVBJViBpcyBJTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICAgICAg\nIERldGFpbHMgb2YgdGhlIGludGVyY2hhbmdlcyBhbmQgdGhlIGJsb2NrIHN0cnVjdHVyZSBvZiBE\nCiAgICAgICAgIGFzIGRldGVybWluZWQgYnkgWlNZVFJGLgpccGFyYW1baW5dIEIKICAgICAgICAg\nQiBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUg\ncmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMg\nSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBM\nREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBDT01QTEVYKjE2\nIGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0\naW9uIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBieSBaU1lUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRo\nZSBpbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERY\nIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBY\nLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgRE9V\nQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1h\ndGVkIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAg\nIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAg\nICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZF\nUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0\ndWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2\naWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4g\nWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1h\ndGUgZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVy\nZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVS\nUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRo\nZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24K\nICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2Ug\naW4KICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFj\ndCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBDT01QTEVYKjE2\nIGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0gUldPUksKICAgICAgICAgUldPUksg\naXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZP\nCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQK\nICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxs\nZWdhbCB2YWx1ZQpccGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11\nbSBudW1iZXIgb2Ygc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRo\nb3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2Vs\nZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApc\nZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIGNvbXBsZXgxNlNZY29tcHV0YXRpb25hbApoHWge\nKYFyRwEAAH1ySAEAAChoIYloImgjdWJoLYoCBAFoLlgOAAAAenN5cmZzXzI2MC50eHR1YmgvigIE\nAWgwWAUAAABzeXJmc2gtigEkdWJoFWgWXWgXh1JySQEAAH1ySgEAAChoGlgJAAAAc3ltbWV0cmlj\naBtYBgAAAHBhY2tlZGgcWD8AAABlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGlt\nYXRlczsgaXRlcmF0aXZlIHJlZmluZW1lbnRoHWgeKYFySwEAAH1yTAEAAChoIYloImgjdWJoJFgg\nAAAARG94eWdlbi9kb2NzL2h0bWwvc3NwcmZzXzhmLmh0bWxoJVgBAAAAc2gmaBVoJ11oF4dSck0B\nAAB9ck4BAAAoaCpYBA0AAFNTUFJGUyBpbXByb3ZlcyB0aGUgY29tcHV0ZWQgc29sdXRpb24gdG8g\nYSBzeXN0ZW0gb2YgbGluZWFyCmVxdWF0aW9ucyB3aGVuIHRoZSBjb2VmZmljaWVudCBtYXRyaXgg\naXMgc3ltbWV0cmljIGluZGVmaW5pdGUKYW5kIHBhY2tlZCwgYW5kIHByb3ZpZGVzIGVycm9yIGJv\ndW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzCmZvciB0aGUgc29sdXRpb24uCkFyZ3Vt\nZW50czoKXHBhcmFtW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAg\nICAgPSAnVSc6ICBVcHBlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZDsKICAgICAgICAgPSAnTCc6\nICBMb3dlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZC4KXHBhcmFtW2luXSBOCiAgICAgICAgIE4g\naXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpc\ncGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1i\nZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5zCiAgICAg\nICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEFQCiAg\nICAgICAgIEFQIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTiooTisxKS8yKQogICAgICAgICBU\naGUgdXBwZXIgb3IgbG93ZXIgdHJpYW5nbGUgb2YgdGhlIHN5bW1ldHJpYyBtYXRyaXggQSwgcGFj\na2VkCiAgICAgICAgIGNvbHVtbndpc2UgaW4gYSBsaW5lYXIgYXJyYXkuICBUaGUgai10aCBjb2x1\nbW4gb2YgQSBpcyBzdG9yZWQKICAgICAgICAgaW4gdGhlIGFycmF5IEFQIGFzIGZvbGxvd3M6CiAg\nICAgICAgIGlmIFVQTE8gPSAnVScsIEFQKGkgKyAoai0xKSpqLzIpID0gQShpLGopIGZvciAxPD1p\nPD1qOwogICAgICAgICBpZiBVUExPID0gJ0wnLCBBUChpICsgKGotMSkqKDIqbi1qKS8yKSA9IEEo\naSxqKSBmb3Igajw9aTw9bi4KXHBhcmFtW2luXSBBRlAKICAgICAgICAgQUZQIGlzIFJFQUwgYXJy\nYXksIGRpbWVuc2lvbiAoTiooTisxKS8yKQogICAgICAgICBUaGUgZmFjdG9yZWQgZm9ybSBvZiB0\naGUgbWF0cml4IEEuICBBRlAgY29udGFpbnMgdGhlIGJsb2NrCiAgICAgICAgIGRpYWdvbmFsIG1h\ndHJpeCBEIGFuZCB0aGUgbXVsdGlwbGllcnMgdXNlZCB0byBvYnRhaW4gdGhlCiAgICAgICAgIGZh\nY3RvciBVIG9yIEwgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBBID0gVSpEKlUqKlQgb3IKICAgICAg\nICAgQSA9IEwqRCpMKipUIGFzIGNvbXB1dGVkIGJ5IFNTUFRSRiwgc3RvcmVkIGFzIGEgcGFja2Vk\nCiAgICAgICAgIHRyaWFuZ3VsYXIgbWF0cml4LgpccGFyYW1baW5dIElQSVYKICAgICAgICAgSVBJ\nViBpcyBJTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICAgICAgIERldGFpbHMgb2YgdGhl\nIGludGVyY2hhbmdlcyBhbmQgdGhlIGJsb2NrIHN0cnVjdHVyZSBvZiBECiAgICAgICAgIGFzIGRl\ndGVybWluZWQgYnkgU1NQVFJGLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBSRUFMIGFycmF5\nLCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJp\neCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBUaGUg\nbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJh\nbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhT\nKQogICAgICAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBi\neSBTU1BUUlMuCiAgICAgICAgIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXgg\nWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxl\nYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1b\nb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQog\nICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRp\nb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24g\nbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNw\nb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJv\ndW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4g\nKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBs\nYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwog\nICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNs\naWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRd\nIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAg\nICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29s\ndXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBj\naGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMgWChqKSBh\nbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBSRUFM\nIGFycmF5LCBkaW1lbnNpb24gKDMqTikKXHBhcmFtW291dF0gSVdPUksKICAgICAgICAgSVdPUksg\naXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAg\nIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAg\nPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1\nZQpccGFyIEludGVybmFsIFBhcmFtZXRlcnM6CiBJVE1BWCBpcyB0aGUgbWF4aW11bSBudW1iZXIg\nb2Ygc3RlcHMgb2YgaXRlcmF0aXZlIHJlZmluZW1lbnQuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4g\nb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRo\nb3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBOb3Zl\nbWJlciAyMDExClxpbmdyb3VwIHJlYWxPVEhFUmNvbXB1dGF0aW9uYWwKaB1oHimBck8BAAB9clAB\nAAAoaCGJaCJoI3ViaC2KAgUBaC5YDgAAAHNzcHJmc18yNjEudHh0dWJoL4oCBQFoMFgFAAAAc3By\nZnNoLYoBJXViaBVoFl1oF4dSclEBAAB9clIBAAAoaBpYCQAAAHN5bW1ldHJpY2gbWAYAAABwYWNr\nZWRoHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJh\ndGl2ZSByZWZpbmVtZW50aB1oHimBclMBAAB9clQBAAAoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4v\nZG9jcy9odG1sL2RzcHJmc184Zi5odG1saCVYAQAAAGRoJmgVaCddaBeHUnJVAQAAfXJWAQAAKGgq\nWFoNAABEU1BSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9m\nIGxpbmVhcgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIHN5bW1ldHJp\nYyBpbmRlZmluaXRlCmFuZCBwYWNrZWQsIGFuZCBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJh\nY2t3YXJkIGVycm9yIGVzdGltYXRlcwpmb3IgdGhlIHNvbHV0aW9uLgpBcmd1bWVudHM6ClxwYXJh\nbVtpbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUioxCiAgICAgICAgID0gJ1UnOiAg\nVXBwZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQ7CiAgICAgICAgID0gJ0wnOiAgTG93ZXIgdHJp\nYW5nbGUgb2YgQSBpcyBzdG9yZWQuClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIK\nICAgICAgICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBO\nUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0\nIGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUg\nbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBBUAogICAgICAgICBBUCBp\ncyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4qKE4rMSkvMikKICAgICAgICAg\nVGhlIHVwcGVyIG9yIGxvd2VyIHRyaWFuZ2xlIG9mIHRoZSBzeW1tZXRyaWMgbWF0cml4IEEsIHBh\nY2tlZAogICAgICAgICBjb2x1bW53aXNlIGluIGEgbGluZWFyIGFycmF5LiAgVGhlIGotdGggY29s\ndW1uIG9mIEEgaXMgc3RvcmVkCiAgICAgICAgIGluIHRoZSBhcnJheSBBUCBhcyBmb2xsb3dzOgog\nICAgICAgICBpZiBVUExPID0gJ1UnLCBBUChpICsgKGotMSkqai8yKSA9IEEoaSxqKSBmb3IgMTw9\naTw9ajsKICAgICAgICAgaWYgVVBMTyA9ICdMJywgQVAoaSArIChqLTEpKigyKm4taikvMikgPSBB\nKGksaikgZm9yIGo8PWk8PW4uClxwYXJhbVtpbl0gQUZQCiAgICAgICAgIEFGUCBpcyBET1VCTEUg\nUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4qKE4rMSkvMikKICAgICAgICAgVGhlIGZhY3Rv\ncmVkIGZvcm0gb2YgdGhlIG1hdHJpeCBBLiAgQUZQIGNvbnRhaW5zIHRoZSBibG9jawogICAgICAg\nICBkaWFnb25hbCBtYXRyaXggRCBhbmQgdGhlIG11bHRpcGxpZXJzIHVzZWQgdG8gb2J0YWluIHRo\nZQogICAgICAgICBmYWN0b3IgVSBvciBMIGZyb20gdGhlIGZhY3Rvcml6YXRpb24gQSA9IFUqRCpV\nKipUIG9yCiAgICAgICAgIEEgPSBMKkQqTCoqVCBhcyBjb21wdXRlZCBieSBEU1BUUkYsIHN0b3Jl\nZCBhcyBhIHBhY2tlZAogICAgICAgICB0cmlhbmd1bGFyIG1hdHJpeC4KXHBhcmFtW2luXSBJUElW\nCiAgICAgICAgIElQSVYgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgICAgICBE\nZXRhaWxzIG9mIHRoZSBpbnRlcmNoYW5nZXMgYW5kIHRoZSBibG9jayBzdHJ1Y3R1cmUgb2YgRAog\nICAgICAgICBhcyBkZXRlcm1pbmVkIGJ5IERTUFRSRi4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIg\naXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAg\nVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERC\nIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBC\nLiAgTERCID49IG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgRE9VQkxF\nIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnks\nIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgRFNQVFJTLgogICAgICAgICBP\nbiBleGl0LCB0aGUgaW1wcm92ZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAg\nICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0\naGUgYXJyYXkgWC4gIExEWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBG\nRVJSIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAg\nVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3Rv\ncgogICAgICAgICBYKGopICh0aGUgai10aCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBY\nKS4KICAgICAgICAgSWYgWFRSVUUgaXMgdGhlIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0\nbyBYKGopLCBGRVJSKGopCiAgICAgICAgIGlzIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3Ig\ndGhlIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2VzdAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0g\nWFRSVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25pdHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBl\nbGVtZW50IGluIFgoaikuICBUaGUgZXN0aW1hdGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAg\ndGhlIGVzdGltYXRlIGZvciBSQ09ORCwgYW5kIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAg\nICAgICAgb3ZlcmVzdGltYXRlIG9mIHRoZSB0cnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAg\nICAgICAgIEJFUlIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQog\nICAgICAgICBUaGUgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNo\nIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBYKGopIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRp\ndmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0IG1ha2VzIFgo\naikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMg\nRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uICgzKk4pClxwYXJhbVtvdXRdIElXT1JL\nCiAgICAgICAgIElXT1JLIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKXHBhcmFtW291\ndF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgICAgPSAwOiAgc3VjY2Vzc2Z1\nbCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFk\nIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRNQVggaXMgdGhl\nIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50LgpBdXRob3Jz\nOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlh\nIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcg\nTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCBkb3VibGVPVEhFUmNvbXB1dGF0aW9u\nYWwKaB1oHimBclcBAAB9clgBAAAoaCGJaCJoI3ViaC2KAgYBaC5YDgAAAGRzcHJmc18yNjIudHh0\ndWJoL4oCBgFoMFgFAAAAc3ByZnNoLYoBJnViaBVoFl1oF4dSclkBAAB9cloBAAAoaBpYCQAAAHN5\nbW1ldHJpY2gbWAYAAABwYWNrZWRoHFg/AAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJv\nciBlc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZpbmVtZW50aB1oHimBclsBAAB9clwBAAAoaCGJaCJo\nI3ViaCRYIAAAAERveHlnZW4vZG9jcy9odG1sL2NzcHJmc184Zi5odG1saCVYAQAAAGNoJmgVaCdd\naBeHUnJdAQAAfXJeAQAAKGgqWBMNAABDU1BSRlMgaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0\naW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgplcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQg\nbWF0cml4IGlzIHN5bW1ldHJpYyBpbmRlZmluaXRlCmFuZCBwYWNrZWQsIGFuZCBwcm92aWRlcyBl\ncnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcwpmb3IgdGhlIHNvbHV0aW9u\nLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUiox\nCiAgICAgICAgID0gJ1UnOiAgVXBwZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQ7CiAgICAgICAg\nID0gJ0wnOiAgTG93ZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQuClxwYXJhbVtpbl0gTgogICAg\nICAgICBOIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4g\nPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBU\naGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1u\ncwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2lu\nXSBBUAogICAgICAgICBBUCBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKE4qKE4rMSkvMikK\nICAgICAgICAgVGhlIHVwcGVyIG9yIGxvd2VyIHRyaWFuZ2xlIG9mIHRoZSBzeW1tZXRyaWMgbWF0\ncml4IEEsIHBhY2tlZAogICAgICAgICBjb2x1bW53aXNlIGluIGEgbGluZWFyIGFycmF5LiAgVGhl\nIGotdGggY29sdW1uIG9mIEEgaXMgc3RvcmVkCiAgICAgICAgIGluIHRoZSBhcnJheSBBUCBhcyBm\nb2xsb3dzOgogICAgICAgICBpZiBVUExPID0gJ1UnLCBBUChpICsgKGotMSkqai8yKSA9IEEoaSxq\nKSBmb3IgMTw9aTw9ajsKICAgICAgICAgaWYgVVBMTyA9ICdMJywgQVAoaSArIChqLTEpKigyKm4t\naikvMikgPSBBKGksaikgZm9yIGo8PWk8PW4uClxwYXJhbVtpbl0gQUZQCiAgICAgICAgIEFGUCBp\ncyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKE4qKE4rMSkvMikKICAgICAgICAgVGhlIGZhY3Rv\ncmVkIGZvcm0gb2YgdGhlIG1hdHJpeCBBLiAgQUZQIGNvbnRhaW5zIHRoZSBibG9jawogICAgICAg\nICBkaWFnb25hbCBtYXRyaXggRCBhbmQgdGhlIG11bHRpcGxpZXJzIHVzZWQgdG8gb2J0YWluIHRo\nZQogICAgICAgICBmYWN0b3IgVSBvciBMIGZyb20gdGhlIGZhY3Rvcml6YXRpb24gQSA9IFUqRCpV\nKipUIG9yCiAgICAgICAgIEEgPSBMKkQqTCoqVCBhcyBjb21wdXRlZCBieSBDU1BUUkYsIHN0b3Jl\nZCBhcyBhIHBhY2tlZAogICAgICAgICB0cmlhbmd1bGFyIG1hdHJpeC4KXHBhcmFtW2luXSBJUElW\nCiAgICAgICAgIElQSVYgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgICAgICBE\nZXRhaWxzIG9mIHRoZSBpbnRlcmNoYW5nZXMgYW5kIHRoZSBibG9jayBzdHJ1Y3R1cmUgb2YgRAog\nICAgICAgICBhcyBkZXRlcm1pbmVkIGJ5IENTUFRSRi4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIg\naXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhlIHJpZ2h0\nIGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVH\nRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49\nIG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgQ09NUExFWCBhcnJheSwg\nZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRy\naXggWCwgYXMgY29tcHV0ZWQgYnkgQ1NQVFJTLgogICAgICAgICBPbiBleGl0LCB0aGUgaW1wcm92\nZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRF\nR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+\nPSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIFJFQUwgYXJyYXks\nIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9yIGJv\ndW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGopICh0aGUgai10aCBjb2x1\nbW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRSVUUgaXMgdGhlIHRy\ndWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAgICAgICAgIGlzIGFu\nIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2VzdAog\nICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25pdHVk\nZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBUaGUgZXN0aW1hdGUg\naXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBSQ09ORCwgYW5kIGlz\nIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRlIG9mIHRoZSB0cnVl\nIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgUkVBTCBhcnJheSwgZGlt\nZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBiYWNrd2Fy\nZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBYKGopIChpLmUuLCB0aGUg\nc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBlbGVtZW50IG9mIEEgb3Ig\nQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1bb3V0XSBXT1JLCiAg\nICAgICAgIFdPUksgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uICgyKk4pClxwYXJhbVtvdXRd\nIFJXT1JLCiAgICAgICAgIFJXT1JLIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTikKXHBhcmFt\nW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgICAgPSAwOiAgc3VjY2Vz\nc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQg\naGFkIGFuIGlsbGVnYWwgdmFsdWUKXHBhciBJbnRlcm5hbCBQYXJhbWV0ZXJzOgogSVRNQVggaXMg\ndGhlIG1heGltdW0gbnVtYmVyIG9mIHN0ZXBzIG9mIGl0ZXJhdGl2ZSByZWZpbmVtZW50LgpBdXRo\nb3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9y\nbmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBO\nQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCBjb21wbGV4T1RIRVJjb21wdXRh\ndGlvbmFsCmgdaB4pgXJfAQAAfXJgAQAAKGghiWgiaCN1YmgtigIHAWguWA4AAABjc3ByZnNfMjYz\nLnR4dHViaC+KAgcBaDBYBQAAAHNwcmZzaC2KASd1YmgVaBZdaBeHUnJhAQAAfXJiAQAAKGgaWAkA\nAABzeW1tZXRyaWNoG1gGAAAAcGFja2VkaBxYPwAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQg\nZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudGgdaB4pgXJjAQAAfXJkAQAAKGgh\niWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC96c3ByZnNfOGYuaHRtbGglWAEAAAB6aCZo\nFWgnXWgXh1JyZQEAAH1yZgEAAChoKlhIDQAAWlNQUkZTIGltcHJvdmVzIHRoZSBjb21wdXRlZCBz\nb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKZXF1YXRpb25zIHdoZW4gdGhlIGNvZWZmaWNp\nZW50IG1hdHJpeCBpcyBzeW1tZXRyaWMgaW5kZWZpbml0ZQphbmQgcGFja2VkLCBhbmQgcHJvdmlk\nZXMgZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMKZm9yIHRoZSBzb2x1\ndGlvbi4KQXJndW1lbnRzOgpccGFyYW1baW5dIFVQTE8KICAgICAgICAgVVBMTyBpcyBDSEFSQUNU\nRVIqMQogICAgICAgICA9ICdVJzogIFVwcGVyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkOwogICAg\nICAgICA9ICdMJzogIExvd2VyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkLgpccGFyYW1baW5dIE4K\nICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEu\nICBOID49IDAuClxwYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAg\nICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNv\nbHVtbnMKICAgICAgICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJh\nbVtpbl0gQVAKICAgICAgICAgQVAgaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChOKihO\nKzEpLzIpCiAgICAgICAgIFRoZSB1cHBlciBvciBsb3dlciB0cmlhbmdsZSBvZiB0aGUgc3ltbWV0\ncmljIG1hdHJpeCBBLCBwYWNrZWQKICAgICAgICAgY29sdW1ud2lzZSBpbiBhIGxpbmVhciBhcnJh\neS4gIFRoZSBqLXRoIGNvbHVtbiBvZiBBIGlzIHN0b3JlZAogICAgICAgICBpbiB0aGUgYXJyYXkg\nQVAgYXMgZm9sbG93czoKICAgICAgICAgaWYgVVBMTyA9ICdVJywgQVAoaSArIChqLTEpKmovMikg\nPSBBKGksaikgZm9yIDE8PWk8PWo7CiAgICAgICAgIGlmIFVQTE8gPSAnTCcsIEFQKGkgKyAoai0x\nKSooMipuLWopLzIpID0gQShpLGopIGZvciBqPD1pPD1uLgpccGFyYW1baW5dIEFGUAogICAgICAg\nICBBRlAgaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChOKihOKzEpLzIpCiAgICAgICAg\nIFRoZSBmYWN0b3JlZCBmb3JtIG9mIHRoZSBtYXRyaXggQS4gIEFGUCBjb250YWlucyB0aGUgYmxv\nY2sKICAgICAgICAgZGlhZ29uYWwgbWF0cml4IEQgYW5kIHRoZSBtdWx0aXBsaWVycyB1c2VkIHRv\nIG9idGFpbiB0aGUKICAgICAgICAgZmFjdG9yIFUgb3IgTCBmcm9tIHRoZSBmYWN0b3JpemF0aW9u\nIEEgPSBVKkQqVSoqVCBvcgogICAgICAgICBBID0gTCpEKkwqKlQgYXMgY29tcHV0ZWQgYnkgWlNQ\nVFJGLCBzdG9yZWQgYXMgYSBwYWNrZWQKICAgICAgICAgdHJpYW5ndWxhciBtYXRyaXguClxwYXJh\nbVtpbl0gSVBJVgogICAgICAgICBJUElWIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikK\nICAgICAgICAgRGV0YWlscyBvZiB0aGUgaW50ZXJjaGFuZ2VzIGFuZCB0aGUgYmxvY2sgc3RydWN0\ndXJlIG9mIEQKICAgICAgICAgYXMgZGV0ZXJtaW5lZCBieSBaU1BUUkYuClxwYXJhbVtpbl0gQgog\nICAgICAgICBCIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAg\nICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAg\nIExEQiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJy\nYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIENP\nTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICAgICAgIE9uIGVudHJ5LCB0\naGUgc29sdXRpb24gbWF0cml4IFgsIGFzIGNvbXB1dGVkIGJ5IFpTUFRSUy4KICAgICAgICAgT24g\nZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAg\nICAgICBMRFggaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhl\nIGFycmF5IFguICBMRFggPj0gbWF4KDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVS\nUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRo\nZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciBib3VuZCBmb3IgZWFjaCBzb2x1dGlvbiB2ZWN0b3IK\nICAgICAgICAgWChqKSAodGhlIGotdGggY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBtYXRyaXggWCku\nCiAgICAgICAgIElmIFhUUlVFIGlzIHRoZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8g\nWChqKSwgRkVSUihqKQogICAgICAgICBpcyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91bmQgZm9yIHRo\nZSBtYWduaXR1ZGUgb2YgdGhlIGxhcmdlc3QKICAgICAgICAgZWxlbWVudCBpbiAoWChqKSAtIFhU\nUlVFKSBkaXZpZGVkIGJ5IHRoZSBtYWduaXR1ZGUgb2YgdGhlCiAgICAgICAgIGxhcmdlc3QgZWxl\nbWVudCBpbiBYKGopLiAgVGhlIGVzdGltYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAgICAgICAgIHRo\nZSBlc3RpbWF0ZSBmb3IgUkNPTkQsIGFuZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xpZ2h0CiAgICAg\nICAgIG92ZXJlc3RpbWF0ZSBvZiB0aGUgdHJ1ZSBlcnJvci4KXHBhcmFtW291dF0gQkVSUgogICAg\nICAgICBCRVJSIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAg\nICAgICAgVGhlIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBz\nb2x1dGlvbgogICAgICAgICB2ZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZl\nIGNoYW5nZSBpbgogICAgICAgICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBYKGop\nIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIENP\nTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBSV09SSwogICAgICAg\nICBSV09SSyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtv\ndXRdIElORk8KICAgICAgICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3Nm\ndWwgZXhpdAogICAgICAgICA8IDA6ICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhh\nZCBhbiBpbGxlZ2FsIHZhbHVlClxwYXIgSW50ZXJuYWwgUGFyYW1ldGVyczoKIElUTUFYIGlzIHRo\nZSBtYXhpbXVtIG51bWJlciBvZiBzdGVwcyBvZiBpdGVyYXRpdmUgcmVmaW5lbWVudC4KQXV0aG9y\nczoKXGF1dGhvciBVbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5p\nYSBCZXJrZWxleSAKXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFH\nIEx0ZC4gClxkYXRlIE5vdmVtYmVyIDIwMTEKXGluZ3JvdXAgY29tcGxleDE2T1RIRVJjb21wdXRh\ndGlvbmFsCmgdaB4pgXJnAQAAfXJoAQAAKGghiWgiaCN1YmgtigIIAWguWA4AAAB6c3ByZnNfMjY0\nLnR4dHViaC+KAggBaDBYBQAAAHNwcmZzaC2KASh1YmgVaBZdaBeHUnJpAQAAfXJqAQAAKGgaWAoA\nAAB0cmlhbmd1bGFyaBtYBAAAAGZ1bGxoHFgpAAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBl\ncnJvciBlc3RpbWF0ZXNoHWgeKYFyawEAAH1ybAEAAChoIYloImgjdWJoJFggAAAARG94eWdlbi9k\nb2NzL2h0bWwvc3RycmZzXzhmLmh0bWxoJVgBAAAAc2gmaBVoJ11oF4dScm0BAAB9cm4BAAAoaCpY\ngA0AAFNUUlJGUyBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGlt\nYXRlcyBmb3IgdGhlCnNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgd2l0\naCBhIHRyaWFuZ3VsYXIKY29lZmZpY2llbnQgbWF0cml4LgpUaGUgc29sdXRpb24gbWF0cml4IFgg\nbXVzdCBiZSBjb21wdXRlZCBieSBTVFJUUlMgb3Igc29tZSBvdGhlcgptZWFucyBiZWZvcmUgZW50\nZXJpbmcgdGhpcyByb3V0aW5lLiAgU1RSUkZTIGRvZXMgbm90IGRvIGl0ZXJhdGl2ZQpyZWZpbmVt\nZW50IGJlY2F1c2UgZG9pbmcgc28gY2Fubm90IGltcHJvdmUgdGhlIGJhY2t3YXJkIGVycm9yLgpB\ncmd1bWVudHM6ClxwYXJhbVtpbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUioxCiAg\nICAgICAgID0gJ1UnOiAgQSBpcyB1cHBlciB0cmlhbmd1bGFyOwogICAgICAgICA9ICdMJzogIEEg\naXMgbG93ZXIgdHJpYW5ndWxhci4KXHBhcmFtW2luXSBUUkFOUwogICAgICAgICBUUkFOUyBpcyBD\nSEFSQUNURVIqMQogICAgICAgICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBvZiBl\ncXVhdGlvbnM6CiAgICAgICAgID0gJ04nOiAgQSAqIFggPSBCICAoTm8gdHJhbnNwb3NlKQogICAg\nICAgICA9ICdUJzogIEEqKlQgKiBYID0gQiAgKFRyYW5zcG9zZSkKICAgICAgICAgPSAnQyc6ICBB\nKipIICogWCA9IEIgIChDb25qdWdhdGUgdHJhbnNwb3NlID0gVHJhbnNwb3NlKQpccGFyYW1baW5d\nIERJQUcKICAgICAgICAgRElBRyBpcyBDSEFSQUNURVIqMQogICAgICAgICA9ICdOJzogIEEgaXMg\nbm9uLXVuaXQgdHJpYW5ndWxhcjsKICAgICAgICAgPSAnVSc6ICBBIGlzIHVuaXQgdHJpYW5ndWxh\nci4KXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIg\nb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBp\ncyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwg\ndGhlIG51bWJlciBvZiBjb2x1bW5zCiAgICAgICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAg\nTlJIUyA+PSAwLgpccGFyYW1baW5dIEEKICAgICAgICAgQSBpcyBSRUFMIGFycmF5LCBkaW1lbnNp\nb24gKExEQSxOKQogICAgICAgICBUaGUgdHJpYW5ndWxhciBtYXRyaXggQS4gIElmIFVQTE8gPSAn\nVScsIHRoZSBsZWFkaW5nIE4tYnktTgogICAgICAgICB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2Yg\ndGhlIGFycmF5IEEgY29udGFpbnMgdGhlIHVwcGVyCiAgICAgICAgIHRyaWFuZ3VsYXIgbWF0cml4\nLCBhbmQgdGhlIHN0cmljdGx5IGxvd2VyIHRyaWFuZ3VsYXIgcGFydCBvZgogICAgICAgICBBIGlz\nIG5vdCByZWZlcmVuY2VkLiAgSWYgVVBMTyA9ICdMJywgdGhlIGxlYWRpbmcgTi1ieS1OIGxvd2Vy\nCiAgICAgICAgIHRyaWFuZ3VsYXIgcGFydCBvZiB0aGUgYXJyYXkgQSBjb250YWlucyB0aGUgbG93\nZXIgdHJpYW5ndWxhcgogICAgICAgICBtYXRyaXgsIGFuZCB0aGUgc3RyaWN0bHkgdXBwZXIgdHJp\nYW5ndWxhciBwYXJ0IG9mIEEgaXMgbm90CiAgICAgICAgIHJlZmVyZW5jZWQuICBJZiBESUFHID0g\nJ1UnLCB0aGUgZGlhZ29uYWwgZWxlbWVudHMgb2YgQSBhcmUKICAgICAgICAgYWxzbyBub3QgcmVm\nZXJlbmNlZCBhbmQgYXJlIGFzc3VtZWQgdG8gYmUgMS4KXHBhcmFtW2luXSBMREEKICAgICAgICAg\nTERBIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJh\neSBBLiAgTERBID49IG1heCgxLE4pLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBSRUFMIGFy\ncmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1h\ndHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBU\naGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxw\nYXJhbVtpbl0gWAogICAgICAgICBYIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMp\nCiAgICAgICAgIFRoZSBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAg\nTERYIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJh\neSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMg\nUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndh\ncmQgZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRo\nZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJV\nRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAg\nICAgICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRo\nZSBsYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0\naGUgbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRo\nZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJD\nT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUg\nb2YgdGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFM\nIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0\naXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikg\nKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1l\nbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtv\ndXRdIFdPUksKICAgICAgICAgV09SSyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKDMqTikKXHBh\ncmFtW291dF0gSVdPUksKICAgICAgICAgSVdPUksgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9u\nIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9\nIDA6ICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10\naCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9m\nIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9y\nIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1i\nZXIgMjAxMQpcaW5ncm91cCByZWFsT1RIRVJjb21wdXRhdGlvbmFsCmgdaB4pgXJvAQAAfXJwAQAA\nKGghiWgiaCN1YmgtigIJAWguWA4AAABzdHJyZnNfMjY1LnR4dHViaC+KAgkBaDBYBQAAAHRycmZz\naC2KASl1YmgVaBZdaBeHUnJxAQAAfXJyAQAAKGgaWAoAAAB0cmlhbmd1bGFyaBtYBAAAAGZ1bGxo\nHFgpAAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXNoHWgeKYFycwEA\nAH1ydAEAAChoIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwvZHRycmZzXzhmLmh0bWxo\nJVgBAAAAZGgmaBVoJ11oF4dScnUBAAB9cnYBAAAoaCpYyg0AAERUUlJGUyBwcm92aWRlcyBlcnJv\nciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcyBmb3IgdGhlCnNvbHV0aW9uIHRv\nIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgd2l0aCBhIHRyaWFuZ3VsYXIKY29lZmZpY2ll\nbnQgbWF0cml4LgpUaGUgc29sdXRpb24gbWF0cml4IFggbXVzdCBiZSBjb21wdXRlZCBieSBEVFJU\nUlMgb3Igc29tZSBvdGhlcgptZWFucyBiZWZvcmUgZW50ZXJpbmcgdGhpcyByb3V0aW5lLiAgRFRS\nUkZTIGRvZXMgbm90IGRvIGl0ZXJhdGl2ZQpyZWZpbmVtZW50IGJlY2F1c2UgZG9pbmcgc28gY2Fu\nbm90IGltcHJvdmUgdGhlIGJhY2t3YXJkIGVycm9yLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVVBM\nTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUioxCiAgICAgICAgID0gJ1UnOiAgQSBpcyB1cHBl\nciB0cmlhbmd1bGFyOwogICAgICAgICA9ICdMJzogIEEgaXMgbG93ZXIgdHJpYW5ndWxhci4KXHBh\ncmFtW2luXSBUUkFOUwogICAgICAgICBUUkFOUyBpcyBDSEFSQUNURVIqMQogICAgICAgICBTcGVj\naWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnM6CiAgICAgICAgID0gJ04n\nOiAgQSAqIFggPSBCICAoTm8gdHJhbnNwb3NlKQogICAgICAgICA9ICdUJzogIEEqKlQgKiBYID0g\nQiAgKFRyYW5zcG9zZSkKICAgICAgICAgPSAnQyc6ICBBKipIICogWCA9IEIgIChDb25qdWdhdGUg\ndHJhbnNwb3NlID0gVHJhbnNwb3NlKQpccGFyYW1baW5dIERJQUcKICAgICAgICAgRElBRyBpcyBD\nSEFSQUNURVIqMQogICAgICAgICA9ICdOJzogIEEgaXMgbm9uLXVuaXQgdHJpYW5ndWxhcjsKICAg\nICAgICAgPSAnVSc6ICBBIGlzIHVuaXQgdHJpYW5ndWxhci4KXHBhcmFtW2luXSBOCiAgICAgICAg\nIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAw\nLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBu\ndW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5zCiAg\nICAgICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEEK\nICAgICAgICAgQSBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKExEQSxOKQog\nICAgICAgICBUaGUgdHJpYW5ndWxhciBtYXRyaXggQS4gIElmIFVQTE8gPSAnVScsIHRoZSBsZWFk\naW5nIE4tYnktTgogICAgICAgICB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2YgdGhlIGFycmF5IEEg\nY29udGFpbnMgdGhlIHVwcGVyCiAgICAgICAgIHRyaWFuZ3VsYXIgbWF0cml4LCBhbmQgdGhlIHN0\ncmljdGx5IGxvd2VyIHRyaWFuZ3VsYXIgcGFydCBvZgogICAgICAgICBBIGlzIG5vdCByZWZlcmVu\nY2VkLiAgSWYgVVBMTyA9ICdMJywgdGhlIGxlYWRpbmcgTi1ieS1OIGxvd2VyCiAgICAgICAgIHRy\naWFuZ3VsYXIgcGFydCBvZiB0aGUgYXJyYXkgQSBjb250YWlucyB0aGUgbG93ZXIgdHJpYW5ndWxh\ncgogICAgICAgICBtYXRyaXgsIGFuZCB0aGUgc3RyaWN0bHkgdXBwZXIgdHJpYW5ndWxhciBwYXJ0\nIG9mIEEgaXMgbm90CiAgICAgICAgIHJlZmVyZW5jZWQuICBJZiBESUFHID0gJ1UnLCB0aGUgZGlh\nZ29uYWwgZWxlbWVudHMgb2YgQSBhcmUKICAgICAgICAgYWxzbyBub3QgcmVmZXJlbmNlZCBhbmQg\nYXJlIGFzc3VtZWQgdG8gYmUgMS4KXHBhcmFtW2luXSBMREEKICAgICAgICAgTERBIGlzIElOVEVH\nRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBLiAgTERBID49\nIG1heCgxLE4pLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFy\ncmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1h\ndHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBU\naGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxw\nYXJhbVtpbl0gWAogICAgICAgICBYIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lv\nbiAoTERYLE5SSFMpCiAgICAgICAgIFRoZSBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBM\nRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9u\nIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAg\nICAgIEZFUlIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAg\nICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24g\ndmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0\ncml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25k\naW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5k\nIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgo\naikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJn\nZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAg\nICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdo\ndAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJF\nUlIKICAgICAgICAgQkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5S\nSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9m\nIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCBy\nZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFr\nZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09S\nSyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKDMqTikKXHBhcmFtW291dF0g\nSVdPUksKICAgICAgICAgSVdPUksgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFy\nYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNj\nZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVu\ndCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3Nl\nZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9m\nIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpc\naW5ncm91cCBkb3VibGVPVEhFUmNvbXB1dGF0aW9uYWwKaB1oHimBcncBAAB9cngBAAAoaCGJaCJo\nI3ViaC2KAgoBaC5YDgAAAGR0cnJmc18yNjYudHh0dWJoL4oCCgFoMFgFAAAAdHJyZnNoLYoBKnVi\naBVoFl1oF4dScnkBAAB9cnoBAAAoaBpYCgAAAHRyaWFuZ3VsYXJoG1gEAAAAZnVsbGgcWCkAAABl\ncnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlc2gdaB4pgXJ7AQAAfXJ8AQAA\nKGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC9jdHJyZnNfOGYuaHRtbGglWAEAAABj\naCZoFWgnXWgXh1JyfQEAAH1yfgEAAChoKliDDQAAQ1RSUkZTIHByb3ZpZGVzIGVycm9yIGJvdW5k\ncyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzIGZvciB0aGUKc29sdXRpb24gdG8gYSBzeXN0\nZW0gb2YgbGluZWFyIGVxdWF0aW9ucyB3aXRoIGEgdHJpYW5ndWxhcgpjb2VmZmljaWVudCBtYXRy\naXguClRoZSBzb2x1dGlvbiBtYXRyaXggWCBtdXN0IGJlIGNvbXB1dGVkIGJ5IENUUlRSUyBvciBz\nb21lIG90aGVyCm1lYW5zIGJlZm9yZSBlbnRlcmluZyB0aGlzIHJvdXRpbmUuICBDVFJSRlMgZG9l\ncyBub3QgZG8gaXRlcmF0aXZlCnJlZmluZW1lbnQgYmVjYXVzZSBkb2luZyBzbyBjYW5ub3QgaW1w\ncm92ZSB0aGUgYmFja3dhcmQgZXJyb3IuCkFyZ3VtZW50czoKXHBhcmFtW2luXSBVUExPCiAgICAg\nICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgPSAnVSc6ICBBIGlzIHVwcGVyIHRyaWFu\nZ3VsYXI7CiAgICAgICAgID0gJ0wnOiAgQSBpcyBsb3dlciB0cmlhbmd1bGFyLgpccGFyYW1baW5d\nIFRSQU5TCiAgICAgICAgIFRSQU5TIGlzIENIQVJBQ1RFUioxCiAgICAgICAgIFNwZWNpZmllcyB0\naGUgZm9ybSBvZiB0aGUgc3lzdGVtIG9mIGVxdWF0aW9uczoKICAgICAgICAgPSAnTic6ICBBICog\nWCA9IEIgICAgIChObyB0cmFuc3Bvc2UpCiAgICAgICAgID0gJ1QnOiAgQSoqVCAqIFggPSBCICAo\nVHJhbnNwb3NlKQogICAgICAgICA9ICdDJzogIEEqKkggKiBYID0gQiAgKENvbmp1Z2F0ZSB0cmFu\nc3Bvc2UpClxwYXJhbVtpbl0gRElBRwogICAgICAgICBESUFHIGlzIENIQVJBQ1RFUioxCiAgICAg\nICAgID0gJ04nOiAgQSBpcyBub24tdW5pdCB0cmlhbmd1bGFyOwogICAgICAgICA9ICdVJzogIEEg\naXMgdW5pdCB0cmlhbmd1bGFyLgpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAg\nICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJI\nUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBo\nYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1h\ndHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQQogICAgICAgICBBIGlzIENP\nTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERBLE4pCiAgICAgICAgIFRoZSB0cmlhbmd1bGFyIG1h\ndHJpeCBBLiAgSWYgVVBMTyA9ICdVJywgdGhlIGxlYWRpbmcgTi1ieS1OCiAgICAgICAgIHVwcGVy\nIHRyaWFuZ3VsYXIgcGFydCBvZiB0aGUgYXJyYXkgQSBjb250YWlucyB0aGUgdXBwZXIKICAgICAg\nICAgdHJpYW5ndWxhciBtYXRyaXgsIGFuZCB0aGUgc3RyaWN0bHkgbG93ZXIgdHJpYW5ndWxhciBw\nYXJ0IG9mCiAgICAgICAgIEEgaXMgbm90IHJlZmVyZW5jZWQuICBJZiBVUExPID0gJ0wnLCB0aGUg\nbGVhZGluZyBOLWJ5LU4gbG93ZXIKICAgICAgICAgdHJpYW5ndWxhciBwYXJ0IG9mIHRoZSBhcnJh\neSBBIGNvbnRhaW5zIHRoZSBsb3dlciB0cmlhbmd1bGFyCiAgICAgICAgIG1hdHJpeCwgYW5kIHRo\nZSBzdHJpY3RseSB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2YgQSBpcyBub3QKICAgICAgICAgcmVm\nZXJlbmNlZC4gIElmIERJQUcgPSAnVScsIHRoZSBkaWFnb25hbCBlbGVtZW50cyBvZiBBIGFyZQog\nICAgICAgICBhbHNvIG5vdCByZWZlcmVuY2VkIGFuZCBhcmUgYXNzdW1lZCB0byBiZSAxLgpccGFy\nYW1baW5dIExEQQogICAgICAgICBMREEgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBk\naW1lbnNpb24gb2YgdGhlIGFycmF5IEEuICBMREEgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gQgog\nICAgICAgICBCIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAg\nIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExE\nQiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkg\nQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBYCiAgICAgICAgIFggaXMgQ09NUExFWCBh\ncnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgVGhlIHNvbHV0aW9uIG1hdHJpeCBY\nLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVh\nZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4KDEsTikuClxwYXJhbVtv\ndXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAg\nICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciBib3VuZCBmb3IgZWFjaCBzb2x1dGlv\nbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhlIGotdGggY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBt\nYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVFIGlzIHRoZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3Bv\nbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAgICAgICBpcyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91\nbmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGxhcmdlc3QKICAgICAgICAgZWxlbWVudCBpbiAo\nWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRoZSBtYWduaXR1ZGUgb2YgdGhlCiAgICAgICAgIGxh\ncmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhlIGVzdGltYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAg\nICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNPTkQsIGFuZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xp\nZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBvZiB0aGUgdHJ1ZSBlcnJvci4KXHBhcmFtW291dF0g\nQkVSUgogICAgICAgICBCRVJSIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAg\nICAgVGhlIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1\ndGlvbgogICAgICAgICB2ZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNo\nYW5nZSBpbgogICAgICAgICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBYKGopIGFu\nIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIENPTVBM\nRVggYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBSV09SSwogICAgICAgICBSV09S\nSyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRdIElORk8KICAgICAgICAg\nSU5GTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3NmdWwgZXhpdAogICAgICAgICA8\nIDA6ICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVl\nCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENh\nbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0\naG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIGNvbXBsZXhPVEhFUmNv\nbXB1dGF0aW9uYWwKaB1oHimBcn8BAAB9coABAAAoaCGJaCJoI3ViaC2KAgsBaC5YDgAAAGN0cnJm\nc18yNjcudHh0dWJoL4oCCwFoMFgFAAAAdHJyZnNoLYoBK3ViaBVoFl1oF4dScoEBAAB9coIBAAAo\naBpYCgAAAHRyaWFuZ3VsYXJoG1gEAAAAZnVsbGgcWCkAAABlcnJvciBib3VuZHMgYW5kIGJhY2t3\nYXJkIGVycm9yIGVzdGltYXRlc2gdaB4pgXKDAQAAfXKEAQAAKGghiWgiaCN1YmgkWCAAAABEb3h5\nZ2VuL2RvY3MvaHRtbC96dHJyZnNfOGYuaHRtbGglWAEAAAB6aCZoFWgnXWgXh1JyhQEAAH1yhgEA\nAChoKli1DQAAWlRSUkZTIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3Ig\nZXN0aW1hdGVzIGZvciB0aGUKc29sdXRpb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9u\ncyB3aXRoIGEgdHJpYW5ndWxhcgpjb2VmZmljaWVudCBtYXRyaXguClRoZSBzb2x1dGlvbiBtYXRy\naXggWCBtdXN0IGJlIGNvbXB1dGVkIGJ5IFpUUlRSUyBvciBzb21lIG90aGVyCm1lYW5zIGJlZm9y\nZSBlbnRlcmluZyB0aGlzIHJvdXRpbmUuICBaVFJSRlMgZG9lcyBub3QgZG8gaXRlcmF0aXZlCnJl\nZmluZW1lbnQgYmVjYXVzZSBkb2luZyBzbyBjYW5ub3QgaW1wcm92ZSB0aGUgYmFja3dhcmQgZXJy\nb3IuCkFyZ3VtZW50czoKXHBhcmFtW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hBUkFDVEVS\nKjEKICAgICAgICAgPSAnVSc6ICBBIGlzIHVwcGVyIHRyaWFuZ3VsYXI7CiAgICAgICAgID0gJ0wn\nOiAgQSBpcyBsb3dlciB0cmlhbmd1bGFyLgpccGFyYW1baW5dIFRSQU5TCiAgICAgICAgIFRSQU5T\nIGlzIENIQVJBQ1RFUioxCiAgICAgICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiB0aGUgc3lzdGVt\nIG9mIGVxdWF0aW9uczoKICAgICAgICAgPSAnTic6ICBBICogWCA9IEIgICAgIChObyB0cmFuc3Bv\nc2UpCiAgICAgICAgID0gJ1QnOiAgQSoqVCAqIFggPSBCICAoVHJhbnNwb3NlKQogICAgICAgICA9\nICdDJzogIEEqKkggKiBYID0gQiAgKENvbmp1Z2F0ZSB0cmFuc3Bvc2UpClxwYXJhbVtpbl0gRElB\nRwogICAgICAgICBESUFHIGlzIENIQVJBQ1RFUioxCiAgICAgICAgID0gJ04nOiAgQSBpcyBub24t\ndW5pdCB0cmlhbmd1bGFyOwogICAgICAgICA9ICdVJzogIEEgaXMgdW5pdCB0cmlhbmd1bGFyLgpc\ncGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBvcmRlciBvZiB0\naGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlzIElO\nVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUg\nbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhT\nID49IDAuClxwYXJhbVtpbl0gQQogICAgICAgICBBIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVu\nc2lvbiAoTERBLE4pCiAgICAgICAgIFRoZSB0cmlhbmd1bGFyIG1hdHJpeCBBLiAgSWYgVVBMTyA9\nICdVJywgdGhlIGxlYWRpbmcgTi1ieS1OCiAgICAgICAgIHVwcGVyIHRyaWFuZ3VsYXIgcGFydCBv\nZiB0aGUgYXJyYXkgQSBjb250YWlucyB0aGUgdXBwZXIKICAgICAgICAgdHJpYW5ndWxhciBtYXRy\naXgsIGFuZCB0aGUgc3RyaWN0bHkgbG93ZXIgdHJpYW5ndWxhciBwYXJ0IG9mCiAgICAgICAgIEEg\naXMgbm90IHJlZmVyZW5jZWQuICBJZiBVUExPID0gJ0wnLCB0aGUgbGVhZGluZyBOLWJ5LU4gbG93\nZXIKICAgICAgICAgdHJpYW5ndWxhciBwYXJ0IG9mIHRoZSBhcnJheSBBIGNvbnRhaW5zIHRoZSBs\nb3dlciB0cmlhbmd1bGFyCiAgICAgICAgIG1hdHJpeCwgYW5kIHRoZSBzdHJpY3RseSB1cHBlciB0\ncmlhbmd1bGFyIHBhcnQgb2YgQSBpcyBub3QKICAgICAgICAgcmVmZXJlbmNlZC4gIElmIERJQUcg\nPSAnVScsIHRoZSBkaWFnb25hbCBlbGVtZW50cyBvZiBBIGFyZQogICAgICAgICBhbHNvIG5vdCBy\nZWZlcmVuY2VkIGFuZCBhcmUgYXNzdW1lZCB0byBiZSAxLgpccGFyYW1baW5dIExEQQogICAgICAg\nICBMREEgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFy\ncmF5IEEuICBMREEgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gQgogICAgICAgICBCIGlzIENPTVBM\nRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRoZSByaWdodCBoYW5k\nIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VSCiAg\nICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgo\nMSxOKS4KXHBhcmFtW2luXSBYCiAgICAgICAgIFggaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5z\naW9uIChMRFgsTlJIUykKICAgICAgICAgVGhlIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5d\nIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNp\nb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4KDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAg\nICAgICAgRkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAg\nICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciBib3VuZCBmb3IgZWFjaCBzb2x1dGlv\nbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhlIGotdGggY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBt\nYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVFIGlzIHRoZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3Bv\nbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAgICAgICBpcyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91\nbmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhlIGxhcmdlc3QKICAgICAgICAgZWxlbWVudCBpbiAo\nWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRoZSBtYWduaXR1ZGUgb2YgdGhlCiAgICAgICAgIGxh\ncmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhlIGVzdGltYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAg\nICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNPTkQsIGFuZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xp\nZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBvZiB0aGUgdHJ1ZSBlcnJvci4KXHBhcmFtW291dF0g\nQkVSUgogICAgICAgICBCRVJSIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAo\nTlJIUykKICAgICAgICAgVGhlIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Ig\nb2YgZWFjaCBzb2x1dGlvbgogICAgICAgICB2ZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0\nIHJlbGF0aXZlIGNoYW5nZSBpbgogICAgICAgICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBt\nYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW291dF0gV09SSwogICAgICAgICBX\nT1JLIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBSV09S\nSwogICAgICAgICBSV09SSyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4p\nClxwYXJhbVtvdXRdIElORk8KICAgICAgICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDog\nIHN1Y2Nlc3NmdWwgZXhpdAogICAgICAgICA8IDA6ICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFy\nZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVlCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVu\nbmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5p\ndi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAy\nMDExClxpbmdyb3VwIGNvbXBsZXgxNk9USEVSY29tcHV0YXRpb25hbApoHWgeKYFyhwEAAH1yiAEA\nAChoIYloImgjdWJoLYoCDAFoLlgOAAAAenRycmZzXzI2OC50eHR1YmgvigIMAWgwWAUAAAB0cnJm\nc2gtigEsdWJoFWgWXWgXh1JyiQEAAH1yigEAAChoGlgKAAAAdHJpYW5ndWxhcmgbWAQAAABiYW5k\naBxYKQAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzaB1oHimBcosB\nAAB9cowBAAAoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4vZG9jcy9odG1sL3N0YnJmc184Zi5odG1s\naCVYAQAAAHNoJmgVaCddaBeHUnKNAQAAfXKOAQAAKGgqWLgNAABTVEJSRlMgcHJvdmlkZXMgZXJy\nb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMgZm9yIHRoZQpzb2x1dGlvbiB0\nbyBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zIHdpdGggYSB0cmlhbmd1bGFyIGJhbmQKY29l\nZmZpY2llbnQgbWF0cml4LgpUaGUgc29sdXRpb24gbWF0cml4IFggbXVzdCBiZSBjb21wdXRlZCBi\neSBTVEJUUlMgb3Igc29tZSBvdGhlcgptZWFucyBiZWZvcmUgZW50ZXJpbmcgdGhpcyByb3V0aW5l\nLiAgU1RCUkZTIGRvZXMgbm90IGRvIGl0ZXJhdGl2ZQpyZWZpbmVtZW50IGJlY2F1c2UgZG9pbmcg\nc28gY2Fubm90IGltcHJvdmUgdGhlIGJhY2t3YXJkIGVycm9yLgpBcmd1bWVudHM6ClxwYXJhbVtp\nbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUioxCiAgICAgICAgID0gJ1UnOiAgQSBp\ncyB1cHBlciB0cmlhbmd1bGFyOwogICAgICAgICA9ICdMJzogIEEgaXMgbG93ZXIgdHJpYW5ndWxh\nci4KXHBhcmFtW2luXSBUUkFOUwogICAgICAgICBUUkFOUyBpcyBDSEFSQUNURVIqMQogICAgICAg\nICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnM6CiAgICAgICAg\nID0gJ04nOiAgQSAqIFggPSBCICAoTm8gdHJhbnNwb3NlKQogICAgICAgICA9ICdUJzogIEEqKlQg\nKiBYID0gQiAgKFRyYW5zcG9zZSkKICAgICAgICAgPSAnQyc6ICBBKipIICogWCA9IEIgIChDb25q\ndWdhdGUgdHJhbnNwb3NlID0gVHJhbnNwb3NlKQpccGFyYW1baW5dIERJQUcKICAgICAgICAgRElB\nRyBpcyBDSEFSQUNURVIqMQogICAgICAgICA9ICdOJzogIEEgaXMgbm9uLXVuaXQgdHJpYW5ndWxh\ncjsKICAgICAgICAgPSAnVSc6ICBBIGlzIHVuaXQgdHJpYW5ndWxhci4KXHBhcmFtW2luXSBOCiAg\nICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAg\nTiA+PSAwLgpccGFyYW1baW5dIEtECiAgICAgICAgIEtEIGlzIElOVEVHRVIKICAgICAgICAgVGhl\nIG51bWJlciBvZiBzdXBlcmRpYWdvbmFscyBvciBzdWJkaWFnb25hbHMgb2YgdGhlCiAgICAgICAg\nIHRyaWFuZ3VsYXIgYmFuZCBtYXRyaXggQS4gIEtEID49IDAuClxwYXJhbVtpbl0gTlJIUwogICAg\nICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNp\nZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAgb2YgdGhlIG1hdHJpY2Vz\nIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQUIKICAgICAgICAgQUIgaXMgUkVBTCBh\ncnJheSwgZGltZW5zaW9uIChMREFCLE4pCiAgICAgICAgIFRoZSB1cHBlciBvciBsb3dlciB0cmlh\nbmd1bGFyIGJhbmQgbWF0cml4IEEsIHN0b3JlZCBpbiB0aGUKICAgICAgICAgZmlyc3Qga2QrMSBy\nb3dzIG9mIHRoZSBhcnJheS4gVGhlIGotdGggY29sdW1uIG9mIEEgaXMgc3RvcmVkCiAgICAgICAg\nIGluIHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgYXJyYXkgQUIgYXMgZm9sbG93czoKICAgICAgICAg\naWYgVVBMTyA9ICdVJywgQUIoa2QrMStpLWosaikgPSBBKGksaikgZm9yIG1heCgxLGota2QpPD1p\nPD1qOwogICAgICAgICBpZiBVUExPID0gJ0wnLCBBQigxK2ktaixqKSAgICA9IEEoaSxqKSBmb3Ig\najw9aTw9bWluKG4saitrZCkuCiAgICAgICAgIElmIERJQUcgPSAnVScsIHRoZSBkaWFnb25hbCBl\nbGVtZW50cyBvZiBBIGFyZSBub3QgcmVmZXJlbmNlZAogICAgICAgICBhbmQgYXJlIGFzc3VtZWQg\ndG8gYmUgMS4KXHBhcmFtW2luXSBMREFCCiAgICAgICAgIExEQUIgaXMgSU5URUdFUgogICAgICAg\nICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFCLiAgTERBQiA+PSBLRCsxLgpc\ncGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhT\nKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpccGFyYW1baW5dIExEQgog\nICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2Yg\ndGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gWAogICAgICAgICBYIGlz\nIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICAgICAgIFRoZSBzb2x1dGlvbiBt\nYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgICAgICAg\nVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpc\ncGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChO\nUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IgYm91bmQgZm9yIGVhY2gg\nc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29s\ndXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBj\nb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAgaXMgYW4gZXN0aW1hdGVkIHVw\ncGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJnZXN0CiAgICAgICAgIGVsZW1l\nbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFnbml0dWRlIG9mIHRoZQogICAg\nICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJs\nZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5\ncyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhlIHRydWUgZXJyb3IuClxwYXJh\nbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5SSFMp\nCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVh\nY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxh\ndGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMg\nWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBp\ncyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKDMqTikKXHBhcmFtW291dF0gSVdPUksKICAgICAgICAg\nSVdPUksgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAg\nICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBzdWNjZXNzZnVsIGV4aXQKICAg\nICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxsZWdh\nbCB2YWx1ZQpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2\nLiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZl\nciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCByZWFsT1RI\nRVJjb21wdXRhdGlvbmFsCmgdaB4pgXKPAQAAfXKQAQAAKGghiWgiaCN1YmgtigINAWguWA4AAABz\ndGJyZnNfMjY5LnR4dHViaC+KAg0BaDBYBQAAAHRicmZzaC2KAS11YmgVaBZdaBeHUnKRAQAAfXKS\nAQAAKGgaWAoAAAB0cmlhbmd1bGFyaBtYBAAAAGJhbmRoHFgpAAAAZXJyb3IgYm91bmRzIGFuZCBi\nYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXNoHWgeKYFykwEAAH1ylAEAAChoIYloImgjdWJoJFggAAAA\nRG94eWdlbi9kb2NzL2h0bWwvZHRicmZzXzhmLmh0bWxoJVgBAAAAZGgmaBVoJ11oF4dScpUBAAB9\ncpYBAAAoaCpYAg4AAERUQlJGUyBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVy\ncm9yIGVzdGltYXRlcyBmb3IgdGhlCnNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVh\ndGlvbnMgd2l0aCBhIHRyaWFuZ3VsYXIgYmFuZApjb2VmZmljaWVudCBtYXRyaXguClRoZSBzb2x1\ndGlvbiBtYXRyaXggWCBtdXN0IGJlIGNvbXB1dGVkIGJ5IERUQlRSUyBvciBzb21lIG90aGVyCm1l\nYW5zIGJlZm9yZSBlbnRlcmluZyB0aGlzIHJvdXRpbmUuICBEVEJSRlMgZG9lcyBub3QgZG8gaXRl\ncmF0aXZlCnJlZmluZW1lbnQgYmVjYXVzZSBkb2luZyBzbyBjYW5ub3QgaW1wcm92ZSB0aGUgYmFj\na3dhcmQgZXJyb3IuCkFyZ3VtZW50czoKXHBhcmFtW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMg\nQ0hBUkFDVEVSKjEKICAgICAgICAgPSAnVSc6ICBBIGlzIHVwcGVyIHRyaWFuZ3VsYXI7CiAgICAg\nICAgID0gJ0wnOiAgQSBpcyBsb3dlciB0cmlhbmd1bGFyLgpccGFyYW1baW5dIFRSQU5TCiAgICAg\nICAgIFRSQU5TIGlzIENIQVJBQ1RFUioxCiAgICAgICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiB0\naGUgc3lzdGVtIG9mIGVxdWF0aW9uczoKICAgICAgICAgPSAnTic6ICBBICogWCA9IEIgIChObyB0\ncmFuc3Bvc2UpCiAgICAgICAgID0gJ1QnOiAgQSoqVCAqIFggPSBCICAoVHJhbnNwb3NlKQogICAg\nICAgICA9ICdDJzogIEEqKkggKiBYID0gQiAgKENvbmp1Z2F0ZSB0cmFuc3Bvc2UgPSBUcmFuc3Bv\nc2UpClxwYXJhbVtpbl0gRElBRwogICAgICAgICBESUFHIGlzIENIQVJBQ1RFUioxCiAgICAgICAg\nID0gJ04nOiAgQSBpcyBub24tdW5pdCB0cmlhbmd1bGFyOwogICAgICAgICA9ICdVJzogIEEgaXMg\ndW5pdCB0cmlhbmd1bGFyLgpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICAg\nICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gS0QKICAg\nICAgICAgS0QgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHN1cGVyZGlhZ29uYWxz\nIG9yIHN1YmRpYWdvbmFscyBvZiB0aGUKICAgICAgICAgdHJpYW5ndWxhciBiYW5kIG1hdHJpeCBB\nLiAgS0QgPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAg\nICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2Yg\nY29sdW1ucwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBh\ncmFtW2luXSBBQgogICAgICAgICBBQiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNp\nb24gKExEQUIsTikKICAgICAgICAgVGhlIHVwcGVyIG9yIGxvd2VyIHRyaWFuZ3VsYXIgYmFuZCBt\nYXRyaXggQSwgc3RvcmVkIGluIHRoZQogICAgICAgICBmaXJzdCBrZCsxIHJvd3Mgb2YgdGhlIGFy\ncmF5LiBUaGUgai10aCBjb2x1bW4gb2YgQSBpcyBzdG9yZWQKICAgICAgICAgaW4gdGhlIGotdGgg\nY29sdW1uIG9mIHRoZSBhcnJheSBBQiBhcyBmb2xsb3dzOgogICAgICAgICBpZiBVUExPID0gJ1Un\nLCBBQihrZCsxK2ktaixqKSA9IEEoaSxqKSBmb3IgbWF4KDEsai1rZCk8PWk8PWo7CiAgICAgICAg\nIGlmIFVQTE8gPSAnTCcsIEFCKDEraS1qLGopICAgID0gQShpLGopIGZvciBqPD1pPD1taW4obixq\nK2tkKS4KICAgICAgICAgSWYgRElBRyA9ICdVJywgdGhlIGRpYWdvbmFsIGVsZW1lbnRzIG9mIEEg\nYXJlIG5vdCByZWZlcmVuY2VkCiAgICAgICAgIGFuZCBhcmUgYXNzdW1lZCB0byBiZSAxLgpccGFy\nYW1baW5dIExEQUIKICAgICAgICAgTERBQiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5n\nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUIuICBMREFCID49IEtEKzEuClxwYXJhbVtpbl0gQgog\nICAgICAgICBCIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMp\nCiAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAg\nICAgICAgIExEQiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0\naGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBYCiAgICAgICAgIFggaXMg\nRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgVGhl\nIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdF\nUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0g\nbWF4KDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBET1VCTEUgUFJFQ0lT\nSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2Fy\nZCBlcnJvciBib3VuZCBmb3IgZWFjaCBzb2x1dGlvbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhl\nIGotdGggY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBtYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVF\nIGlzIHRoZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAg\nICAgICBpcyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91bmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhl\nIGxhcmdlc3QKICAgICAgICAgZWxlbWVudCBpbiAoWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRo\nZSBtYWduaXR1ZGUgb2YgdGhlCiAgICAgICAgIGxhcmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhl\nIGVzdGltYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAgICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNP\nTkQsIGFuZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xpZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBv\nZiB0aGUgdHJ1ZSBlcnJvci4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIERPVUJM\nRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGNvbXBvbmVu\ndHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1dGlvbgogICAgICAgICB2\nZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbgogICAgICAg\nICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9u\nKS4KXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIERPVUJMRSBQUkVDSVNJT04gYXJy\nYXksIGRpbWVuc2lvbiAoMypOKQpccGFyYW1bb3V0XSBJV09SSwogICAgICAgICBJV09SSyBpcyBJ\nTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRdIElORk8KICAgICAgICAgSU5G\nTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3NmdWwgZXhpdAogICAgICAgICA8IDA6\nICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVlCkF1\ndGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlm\nb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9y\nIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIGRvdWJsZU9USEVSY29tcHV0\nYXRpb25hbApoHWgeKYFylwEAAH1ymAEAAChoIYloImgjdWJoLYoCDgFoLlgOAAAAZHRicmZzXzI3\nMC50eHR1YmgvigIOAWgwWAUAAAB0YnJmc2gtigEudWJoFWgWXWgXh1JymQEAAH1ymgEAAChoGlgK\nAAAAdHJpYW5ndWxhcmgbWAQAAABiYW5kaBxYKQAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQg\nZXJyb3IgZXN0aW1hdGVzaB1oHimBcpsBAAB9cpwBAAAoaCGJaCJoI3ViaCRYIAAAAERveHlnZW4v\nZG9jcy9odG1sL2N0YnJmc184Zi5odG1saCVYAQAAAGNoJmgVaCddaBeHUnKdAQAAfXKeAQAAKGgq\nWLsNAABDVEJSRlMgcHJvdmlkZXMgZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3Rp\nbWF0ZXMgZm9yIHRoZQpzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zIHdp\ndGggYSB0cmlhbmd1bGFyIGJhbmQKY29lZmZpY2llbnQgbWF0cml4LgpUaGUgc29sdXRpb24gbWF0\ncml4IFggbXVzdCBiZSBjb21wdXRlZCBieSBDVEJUUlMgb3Igc29tZSBvdGhlcgptZWFucyBiZWZv\ncmUgZW50ZXJpbmcgdGhpcyByb3V0aW5lLiAgQ1RCUkZTIGRvZXMgbm90IGRvIGl0ZXJhdGl2ZQpy\nZWZpbmVtZW50IGJlY2F1c2UgZG9pbmcgc28gY2Fubm90IGltcHJvdmUgdGhlIGJhY2t3YXJkIGVy\ncm9yLgpBcmd1bWVudHM6ClxwYXJhbVtpbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RF\nUioxCiAgICAgICAgID0gJ1UnOiAgQSBpcyB1cHBlciB0cmlhbmd1bGFyOwogICAgICAgICA9ICdM\nJzogIEEgaXMgbG93ZXIgdHJpYW5ndWxhci4KXHBhcmFtW2luXSBUUkFOUwogICAgICAgICBUUkFO\nUyBpcyBDSEFSQUNURVIqMQogICAgICAgICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5c3Rl\nbSBvZiBlcXVhdGlvbnM6CiAgICAgICAgID0gJ04nOiAgQSAqIFggPSBCICAgICAoTm8gdHJhbnNw\nb3NlKQogICAgICAgICA9ICdUJzogIEEqKlQgKiBYID0gQiAgKFRyYW5zcG9zZSkKICAgICAgICAg\nPSAnQyc6ICBBKipIICogWCA9IEIgIChDb25qdWdhdGUgdHJhbnNwb3NlKQpccGFyYW1baW5dIERJ\nQUcKICAgICAgICAgRElBRyBpcyBDSEFSQUNURVIqMQogICAgICAgICA9ICdOJzogIEEgaXMgbm9u\nLXVuaXQgdHJpYW5ndWxhcjsKICAgICAgICAgPSAnVSc6ICBBIGlzIHVuaXQgdHJpYW5ndWxhci4K\nXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2Yg\ndGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIEtECiAgICAgICAgIEtEIGlzIElOVEVH\nRVIKICAgICAgICAgVGhlIG51bWJlciBvZiBzdXBlcmRpYWdvbmFscyBvciBzdWJkaWFnb25hbHMg\nb2YgdGhlCiAgICAgICAgIHRyaWFuZ3VsYXIgYmFuZCBtYXRyaXggQS4gIEtEID49IDAuClxwYXJh\nbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG51bWJlciBv\nZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgICAgICAg\nb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQUIKICAgICAg\nICAgQUIgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREFCLE4pCiAgICAgICAgIFRoZSB1\ncHBlciBvciBsb3dlciB0cmlhbmd1bGFyIGJhbmQgbWF0cml4IEEsIHN0b3JlZCBpbiB0aGUKICAg\nICAgICAgZmlyc3Qga2QrMSByb3dzIG9mIHRoZSBhcnJheS4gVGhlIGotdGggY29sdW1uIG9mIEEg\naXMgc3RvcmVkCiAgICAgICAgIGluIHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUgYXJyYXkgQUIgYXMg\nZm9sbG93czoKICAgICAgICAgaWYgVVBMTyA9ICdVJywgQUIoa2QrMStpLWosaikgPSBBKGksaikg\nZm9yIG1heCgxLGota2QpPD1pPD1qOwogICAgICAgICBpZiBVUExPID0gJ0wnLCBBQigxK2ktaixq\nKSAgICA9IEEoaSxqKSBmb3Igajw9aTw9bWluKG4saitrZCkuCiAgICAgICAgIElmIERJQUcgPSAn\nVScsIHRoZSBkaWFnb25hbCBlbGVtZW50cyBvZiBBIGFyZSBub3QgcmVmZXJlbmNlZAogICAgICAg\nICBhbmQgYXJlIGFzc3VtZWQgdG8gYmUgMS4KXHBhcmFtW2luXSBMREFCCiAgICAgICAgIExEQUIg\naXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFC\nLiAgTERBQiA+PSBLRCsxLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBDT01QTEVYIGFycmF5\nLCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJp\neCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBUaGUg\nbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJh\nbVtpbl0gWAogICAgICAgICBYIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMp\nCiAgICAgICAgIFRoZSBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAg\nTERYIGlzIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJh\neSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMg\nUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndh\ncmQgZXJyb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRo\nZSBqLXRoIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJV\nRSBpcyB0aGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAg\nICAgICAgaXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRo\nZSBsYXJnZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0\naGUgbWFnbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRo\nZSBlc3RpbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJD\nT05ELCBhbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUg\nb2YgdGhlIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFM\nIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0\naXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikg\nKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1l\nbnQgb2YgQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtv\ndXRdIFdPUksKICAgICAgICAgV09SSyBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKDIqTikK\nXHBhcmFtW291dF0gUldPUksKICAgICAgICAgUldPUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9u\nIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9\nIDA6ICBzdWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10\naCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9m\nIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9y\nIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1i\nZXIgMjAxMQpcaW5ncm91cCBjb21wbGV4T1RIRVJjb21wdXRhdGlvbmFsCmgdaB4pgXKfAQAAfXKg\nAQAAKGghiWgiaCN1YmgtigIPAWguWA4AAABjdGJyZnNfMjcxLnR4dHViaC+KAg8BaDBYBQAAAHRi\ncmZzaC2KAS91YmgVaBZdaBeHUnKhAQAAfXKiAQAAKGgaWAoAAAB0cmlhbmd1bGFyaBtYBAAAAGJh\nbmRoHFgpAAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXNoHWgeKYFy\nowEAAH1ypAEAAChoIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwvenRicmZzXzhmLmh0\nbWxoJVgBAAAAemgmaBVoJ11oF4dScqUBAAB9cqYBAAAoaCpY7Q0AAFpUQlJGUyBwcm92aWRlcyBl\ncnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcyBmb3IgdGhlCnNvbHV0aW9u\nIHRvIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgd2l0aCBhIHRyaWFuZ3VsYXIgYmFuZApj\nb2VmZmljaWVudCBtYXRyaXguClRoZSBzb2x1dGlvbiBtYXRyaXggWCBtdXN0IGJlIGNvbXB1dGVk\nIGJ5IFpUQlRSUyBvciBzb21lIG90aGVyCm1lYW5zIGJlZm9yZSBlbnRlcmluZyB0aGlzIHJvdXRp\nbmUuICBaVEJSRlMgZG9lcyBub3QgZG8gaXRlcmF0aXZlCnJlZmluZW1lbnQgYmVjYXVzZSBkb2lu\nZyBzbyBjYW5ub3QgaW1wcm92ZSB0aGUgYmFja3dhcmQgZXJyb3IuCkFyZ3VtZW50czoKXHBhcmFt\nW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgPSAnVSc6ICBB\nIGlzIHVwcGVyIHRyaWFuZ3VsYXI7CiAgICAgICAgID0gJ0wnOiAgQSBpcyBsb3dlciB0cmlhbmd1\nbGFyLgpccGFyYW1baW5dIFRSQU5TCiAgICAgICAgIFRSQU5TIGlzIENIQVJBQ1RFUioxCiAgICAg\nICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiB0aGUgc3lzdGVtIG9mIGVxdWF0aW9uczoKICAgICAg\nICAgPSAnTic6ICBBICogWCA9IEIgICAgIChObyB0cmFuc3Bvc2UpCiAgICAgICAgID0gJ1QnOiAg\nQSoqVCAqIFggPSBCICAoVHJhbnNwb3NlKQogICAgICAgICA9ICdDJzogIEEqKkggKiBYID0gQiAg\nKENvbmp1Z2F0ZSB0cmFuc3Bvc2UpClxwYXJhbVtpbl0gRElBRwogICAgICAgICBESUFHIGlzIENI\nQVJBQ1RFUioxCiAgICAgICAgID0gJ04nOiAgQSBpcyBub24tdW5pdCB0cmlhbmd1bGFyOwogICAg\nICAgICA9ICdVJzogIEEgaXMgdW5pdCB0cmlhbmd1bGFyLgpccGFyYW1baW5dIE4KICAgICAgICAg\nTiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAu\nClxwYXJhbVtpbl0gS0QKICAgICAgICAgS0QgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVy\nIG9mIHN1cGVyZGlhZ29uYWxzIG9yIHN1YmRpYWdvbmFscyBvZiB0aGUKICAgICAgICAgdHJpYW5n\ndWxhciBiYW5kIG1hdHJpeCBBLiAgS0QgPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5S\nSFMgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGku\nZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQg\nWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBBQgogICAgICAgICBBQiBpcyBDT01QTEVYKjE2IGFy\ncmF5LCBkaW1lbnNpb24gKExEQUIsTikKICAgICAgICAgVGhlIHVwcGVyIG9yIGxvd2VyIHRyaWFu\nZ3VsYXIgYmFuZCBtYXRyaXggQSwgc3RvcmVkIGluIHRoZQogICAgICAgICBmaXJzdCBrZCsxIHJv\nd3Mgb2YgdGhlIGFycmF5LiBUaGUgai10aCBjb2x1bW4gb2YgQSBpcyBzdG9yZWQKICAgICAgICAg\naW4gdGhlIGotdGggY29sdW1uIG9mIHRoZSBhcnJheSBBQiBhcyBmb2xsb3dzOgogICAgICAgICBp\nZiBVUExPID0gJ1UnLCBBQihrZCsxK2ktaixqKSA9IEEoaSxqKSBmb3IgbWF4KDEsai1rZCk8PWk8\nPWo7CiAgICAgICAgIGlmIFVQTE8gPSAnTCcsIEFCKDEraS1qLGopICAgID0gQShpLGopIGZvciBq\nPD1pPD1taW4obixqK2tkKS4KICAgICAgICAgSWYgRElBRyA9ICdVJywgdGhlIGRpYWdvbmFsIGVs\nZW1lbnRzIG9mIEEgYXJlIG5vdCByZWZlcmVuY2VkCiAgICAgICAgIGFuZCBhcmUgYXNzdW1lZCB0\nbyBiZSAxLgpccGFyYW1baW5dIExEQUIKICAgICAgICAgTERBQiBpcyBJTlRFR0VSCiAgICAgICAg\nIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUIuICBMREFCID49IEtEKzEuClxw\nYXJhbVtpbl0gQgogICAgICAgICBCIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTERC\nLE5SSFMpCiAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0g\nTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lv\nbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBYCiAgICAgICAg\nIFggaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgVGhl\nIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdF\nUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0g\nbWF4KDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBET1VCTEUgUFJFQ0lT\nSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2Fy\nZCBlcnJvciBib3VuZCBmb3IgZWFjaCBzb2x1dGlvbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhl\nIGotdGggY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBtYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVF\nIGlzIHRoZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAg\nICAgICBpcyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91bmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhl\nIGxhcmdlc3QKICAgICAgICAgZWxlbWVudCBpbiAoWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRo\nZSBtYWduaXR1ZGUgb2YgdGhlCiAgICAgICAgIGxhcmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhl\nIGVzdGltYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAgICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNP\nTkQsIGFuZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xpZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBv\nZiB0aGUgdHJ1ZSBlcnJvci4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIERPVUJM\nRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGNvbXBvbmVu\ndHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1dGlvbgogICAgICAgICB2\nZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbgogICAgICAg\nICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9u\nKS4KXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIENPTVBMRVgqMTYgYXJyYXksIGRp\nbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBSV09SSwogICAgICAgICBSV09SSyBpcyBET1VCTEUg\nUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRdIElORk8KICAgICAgICAg\nSU5GTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3NmdWwgZXhpdAogICAgICAgICA8\nIDA6ICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVl\nCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENh\nbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0\naG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIGNvbXBsZXgxNk9USEVS\nY29tcHV0YXRpb25hbApoHWgeKYFypwEAAH1yqAEAAChoIYloImgjdWJoLYoCEAFoLlgOAAAAenRi\ncmZzXzI3Mi50eHR1YmgvigIQAWgwWAUAAAB0YnJmc2gtigEwdWJoFWgWXWgXh1JyqQEAAH1yqgEA\nAChoGlgKAAAAdHJpYW5ndWxhcmgbWAYAAABwYWNrZWRoHFgpAAAAZXJyb3IgYm91bmRzIGFuZCBi\nYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXNoHWgeKYFyqwEAAH1yrAEAAChoIYloImgjdWJoJFggAAAA\nRG94eWdlbi9kb2NzL2h0bWwvc3RwcmZzXzhmLmh0bWxoJVgBAAAAc2gmaBVoJ11oF4dScq0BAAB9\ncq4BAAAoaCpYoAwAAFNUUFJGUyBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVy\ncm9yIGVzdGltYXRlcyBmb3IgdGhlCnNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVh\ndGlvbnMgd2l0aCBhIHRyaWFuZ3VsYXIgcGFja2VkCmNvZWZmaWNpZW50IG1hdHJpeC4KVGhlIHNv\nbHV0aW9uIG1hdHJpeCBYIG11c3QgYmUgY29tcHV0ZWQgYnkgU1RQVFJTIG9yIHNvbWUgb3RoZXIK\nbWVhbnMgYmVmb3JlIGVudGVyaW5nIHRoaXMgcm91dGluZS4gIFNUUFJGUyBkb2VzIG5vdCBkbyBp\ndGVyYXRpdmUKcmVmaW5lbWVudCBiZWNhdXNlIGRvaW5nIHNvIGNhbm5vdCBpbXByb3ZlIHRoZSBi\nYWNrd2FyZCBlcnJvci4KQXJndW1lbnRzOgpccGFyYW1baW5dIFVQTE8KICAgICAgICAgVVBMTyBp\ncyBDSEFSQUNURVIqMQogICAgICAgICA9ICdVJzogIEEgaXMgdXBwZXIgdHJpYW5ndWxhcjsKICAg\nICAgICAgPSAnTCc6ICBBIGlzIGxvd2VyIHRyaWFuZ3VsYXIuClxwYXJhbVtpbl0gVFJBTlMKICAg\nICAgICAgVFJBTlMgaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgU3BlY2lmaWVzIHRoZSBmb3JtIG9m\nIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zOgogICAgICAgICA9ICdOJzogIEEgKiBYID0gQiAgKE5v\nIHRyYW5zcG9zZSkKICAgICAgICAgPSAnVCc6ICBBKipUICogWCA9IEIgIChUcmFuc3Bvc2UpCiAg\nICAgICAgID0gJ0MnOiAgQSoqSCAqIFggPSBCICAoQ29uanVnYXRlIHRyYW5zcG9zZSA9IFRyYW5z\ncG9zZSkKXHBhcmFtW2luXSBESUFHCiAgICAgICAgIERJQUcgaXMgQ0hBUkFDVEVSKjEKICAgICAg\nICAgPSAnTic6ICBBIGlzIG5vbi11bml0IHRyaWFuZ3VsYXI7CiAgICAgICAgID0gJ1UnOiAgQSBp\ncyB1bml0IHRyaWFuZ3VsYXIuClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAg\nICAgICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBOUkhT\nCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhh\nbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUgbWF0\ncmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBBUAogICAgICAgICBBUCBpcyBS\nRUFMIGFycmF5LCBkaW1lbnNpb24gKE4qKE4rMSkvMikKICAgICAgICAgVGhlIHVwcGVyIG9yIGxv\nd2VyIHRyaWFuZ3VsYXIgbWF0cml4IEEsIHBhY2tlZCBjb2x1bW53aXNlIGluCiAgICAgICAgIGEg\nbGluZWFyIGFycmF5LiAgVGhlIGotdGggY29sdW1uIG9mIEEgaXMgc3RvcmVkIGluIHRoZSBhcnJh\neQogICAgICAgICBBUCBhcyBmb2xsb3dzOgogICAgICAgICBpZiBVUExPID0gJ1UnLCBBUChpICsg\nKGotMSkqai8yKSA9IEEoaSxqKSBmb3IgMTw9aTw9ajsKICAgICAgICAgaWYgVVBMTyA9ICdMJywg\nQVAoaSArIChqLTEpKigyKm4taikvMikgPSBBKGksaikgZm9yIGo8PWk8PW4uCiAgICAgICAgIElm\nIERJQUcgPSAnVScsIHRoZSBkaWFnb25hbCBlbGVtZW50cyBvZiBBIGFyZSBub3QgcmVmZXJlbmNl\nZAogICAgICAgICBhbmQgYXJlIGFzc3VtZWQgdG8gYmUgMS4KXHBhcmFtW2luXSBCCiAgICAgICAg\nIEIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhlIHJpZ2h0\nIGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVH\nRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49\nIG1heCgxLE4pLgpccGFyYW1baW5dIFgKICAgICAgICAgWCBpcyBSRUFMIGFycmF5LCBkaW1lbnNp\nb24gKExEWCxOUkhTKQogICAgICAgICBUaGUgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0g\nTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lv\nbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0gRkVSUgogICAg\nICAgICBGRVJSIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVz\ndGltYXRlZCBmb3J3YXJkIGVycm9yIGJvdW5kIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAg\nICAgICBYKGopICh0aGUgai10aCBjb2x1bW4gb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAg\nICAgICAgSWYgWFRSVUUgaXMgdGhlIHRydWUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGop\nLCBGRVJSKGopCiAgICAgICAgIGlzIGFuIGVzdGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1h\nZ25pdHVkZSBvZiB0aGUgbGFyZ2VzdAogICAgICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUp\nIGRpdmlkZWQgYnkgdGhlIG1hZ25pdHVkZSBvZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50\nIGluIFgoaikuICBUaGUgZXN0aW1hdGUgaXMgYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVz\ndGltYXRlIGZvciBSQ09ORCwgYW5kIGlzIGFsbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAg\nb3ZlcmVzdGltYXRlIG9mIHRoZSB0cnVlIGVycm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAg\nIEJFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9u\nZW50d2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAg\nIHZlY3RvciBYKGopIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAg\nICAgIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRp\nb24pLgpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgUkVBTCBhcnJheSwgZGltZW5z\naW9uICgzKk4pClxwYXJhbVtvdXRdIElXT1JLCiAgICAgICAgIElXT1JLIGlzIElOVEVHRVIgYXJy\nYXksIGRpbWVuc2lvbiAoTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVH\nRVIKICAgICAgICAgPSAwOiAgc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8g\nPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKQXV0aG9yczoKXGF1\ndGhvciBVbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBCZXJr\nZWxleSAKXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0ZC4g\nClxkYXRlIE5vdmVtYmVyIDIwMTEKXGluZ3JvdXAgcmVhbE9USEVSY29tcHV0YXRpb25hbApoHWge\nKYFyrwEAAH1ysAEAAChoIYloImgjdWJoLYoCEQFoLlgOAAAAc3RwcmZzXzI3My50eHR1YmgvigIR\nAWgwWAUAAAB0cHJmc2gtigExdWJoFWgWXWgXh1JysQEAAH1ysgEAAChoGlgKAAAAdHJpYW5ndWxh\ncmgbWAYAAABwYWNrZWRoHFgpAAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3Rp\nbWF0ZXNoHWgeKYFyswEAAH1ytAEAAChoIYloImgjdWJoJFggAAAARG94eWdlbi9kb2NzL2h0bWwv\nZHRwcmZzXzhmLmh0bWxoJVgBAAAAZGgmaBVoJ11oF4dScrUBAAB9crYBAAAoaCpY6gwAAERUUFJG\nUyBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcyBmb3Ig\ndGhlCnNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgd2l0aCBhIHRyaWFu\nZ3VsYXIgcGFja2VkCmNvZWZmaWNpZW50IG1hdHJpeC4KVGhlIHNvbHV0aW9uIG1hdHJpeCBYIG11\nc3QgYmUgY29tcHV0ZWQgYnkgRFRQVFJTIG9yIHNvbWUgb3RoZXIKbWVhbnMgYmVmb3JlIGVudGVy\naW5nIHRoaXMgcm91dGluZS4gIERUUFJGUyBkb2VzIG5vdCBkbyBpdGVyYXRpdmUKcmVmaW5lbWVu\ndCBiZWNhdXNlIGRvaW5nIHNvIGNhbm5vdCBpbXByb3ZlIHRoZSBiYWNrd2FyZCBlcnJvci4KQXJn\ndW1lbnRzOgpccGFyYW1baW5dIFVQTE8KICAgICAgICAgVVBMTyBpcyBDSEFSQUNURVIqMQogICAg\nICAgICA9ICdVJzogIEEgaXMgdXBwZXIgdHJpYW5ndWxhcjsKICAgICAgICAgPSAnTCc6ICBBIGlz\nIGxvd2VyIHRyaWFuZ3VsYXIuClxwYXJhbVtpbl0gVFJBTlMKICAgICAgICAgVFJBTlMgaXMgQ0hB\nUkFDVEVSKjEKICAgICAgICAgU3BlY2lmaWVzIHRoZSBmb3JtIG9mIHRoZSBzeXN0ZW0gb2YgZXF1\nYXRpb25zOgogICAgICAgICA9ICdOJzogIEEgKiBYID0gQiAgKE5vIHRyYW5zcG9zZSkKICAgICAg\nICAgPSAnVCc6ICBBKipUICogWCA9IEIgIChUcmFuc3Bvc2UpCiAgICAgICAgID0gJ0MnOiAgQSoq\nSCAqIFggPSBCICAoQ29uanVnYXRlIHRyYW5zcG9zZSA9IFRyYW5zcG9zZSkKXHBhcmFtW2luXSBE\nSUFHCiAgICAgICAgIERJQUcgaXMgQ0hBUkFDVEVSKjEKICAgICAgICAgPSAnTic6ICBBIGlzIG5v\nbi11bml0IHRyaWFuZ3VsYXI7CiAgICAgICAgID0gJ1UnOiAgQSBpcyB1bml0IHRyaWFuZ3VsYXIu\nClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAgICAgICAgVGhlIG9yZGVyIG9m\nIHRoZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMg\nSU5URUdFUgogICAgICAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRo\nZSBudW1iZXIgb2YgY29sdW1ucwogICAgICAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5S\nSFMgPj0gMC4KXHBhcmFtW2luXSBBUAogICAgICAgICBBUCBpcyBET1VCTEUgUFJFQ0lTSU9OIGFy\ncmF5LCBkaW1lbnNpb24gKE4qKE4rMSkvMikKICAgICAgICAgVGhlIHVwcGVyIG9yIGxvd2VyIHRy\naWFuZ3VsYXIgbWF0cml4IEEsIHBhY2tlZCBjb2x1bW53aXNlIGluCiAgICAgICAgIGEgbGluZWFy\nIGFycmF5LiAgVGhlIGotdGggY29sdW1uIG9mIEEgaXMgc3RvcmVkIGluIHRoZSBhcnJheQogICAg\nICAgICBBUCBhcyBmb2xsb3dzOgogICAgICAgICBpZiBVUExPID0gJ1UnLCBBUChpICsgKGotMSkq\nai8yKSA9IEEoaSxqKSBmb3IgMTw9aTw9ajsKICAgICAgICAgaWYgVVBMTyA9ICdMJywgQVAoaSAr\nIChqLTEpKigyKm4taikvMikgPSBBKGksaikgZm9yIGo8PWk8PW4uCiAgICAgICAgIElmIERJQUcg\nPSAnVScsIHRoZSBkaWFnb25hbCBlbGVtZW50cyBvZiBBIGFyZSBub3QgcmVmZXJlbmNlZAogICAg\nICAgICBhbmQgYXJlIGFzc3VtZWQgdG8gYmUgMS4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIgaXMg\nRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgICAgICAgVGhl\nIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlz\nIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAg\nTERCID49IG1heCgxLE4pLgpccGFyYW1baW5dIFgKICAgICAgICAgWCBpcyBET1VCTEUgUFJFQ0lT\nSU9OIGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgICAgICBUaGUgc29sdXRpb24gbWF0\ncml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICAgICAgIFRo\nZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+PSBtYXgoMSxOKS4KXHBh\ncmFtW291dF0gRkVSUgogICAgICAgICBGRVJSIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRp\nbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9yIGJvdW5k\nIGZvciBlYWNoIHNvbHV0aW9uIHZlY3RvcgogICAgICAgICBYKGopICh0aGUgai10aCBjb2x1bW4g\nb2YgdGhlIHNvbHV0aW9uIG1hdHJpeCBYKS4KICAgICAgICAgSWYgWFRSVUUgaXMgdGhlIHRydWUg\nc29sdXRpb24gY29ycmVzcG9uZGluZyB0byBYKGopLCBGRVJSKGopCiAgICAgICAgIGlzIGFuIGVz\ndGltYXRlZCB1cHBlciBib3VuZCBmb3IgdGhlIG1hZ25pdHVkZSBvZiB0aGUgbGFyZ2VzdAogICAg\nICAgICBlbGVtZW50IGluIChYKGopIC0gWFRSVUUpIGRpdmlkZWQgYnkgdGhlIG1hZ25pdHVkZSBv\nZiB0aGUKICAgICAgICAgbGFyZ2VzdCBlbGVtZW50IGluIFgoaikuICBUaGUgZXN0aW1hdGUgaXMg\nYXMgcmVsaWFibGUgYXMKICAgICAgICAgdGhlIGVzdGltYXRlIGZvciBSQ09ORCwgYW5kIGlzIGFs\nbW9zdCBhbHdheXMgYSBzbGlnaHQKICAgICAgICAgb3ZlcmVzdGltYXRlIG9mIHRoZSB0cnVlIGVy\ncm9yLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgRE9VQkxFIFBSRUNJU0lPTiBh\ncnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgY29tcG9uZW50d2lzZSByZWxhdGl2\nZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uCiAgICAgICAgIHZlY3RvciBYKGopIChp\nLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluCiAgICAgICAgIGFueSBlbGVtZW50\nIG9mIEEgb3IgQiB0aGF0IG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1bb3V0\nXSBXT1JLCiAgICAgICAgIFdPUksgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9u\nICgzKk4pClxwYXJhbVtvdXRdIElXT1JLCiAgICAgICAgIElXT1JLIGlzIElOVEVHRVIgYXJyYXks\nIGRpbWVuc2lvbiAoTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIK\nICAgICAgICAgPSAwOiAgc3VjY2Vzc2Z1bCBleGl0CiAgICAgICAgIDwgMDogIGlmIElORk8gPSAt\naSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKQXV0aG9yczoKXGF1dGhv\nciBVbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBCZXJrZWxl\neSAKXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0ZC4gClxk\nYXRlIE5vdmVtYmVyIDIwMTEKXGluZ3JvdXAgZG91YmxlT1RIRVJjb21wdXRhdGlvbmFsCmgdaB4p\ngXK3AQAAfXK4AQAAKGghiWgiaCN1YmgtigISAWguWA4AAABkdHByZnNfMjc0LnR4dHViaC+KAhIB\naDBYBQAAAHRwcmZzaC2KATJ1YmgVaBZdaBeHUnK5AQAAfXK6AQAAKGgaWAoAAAB0cmlhbmd1bGFy\naBtYBgAAAHBhY2tlZGgcWCkAAABlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGlt\nYXRlc2gdaB4pgXK7AQAAfXK8AQAAKGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC9j\ndHByZnNfOGYuaHRtbGglWAEAAABjaCZoFWgnXWgXh1JyvQEAAH1yvgEAAChoKlijDAAAQ1RQUkZT\nIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzIGZvciB0\naGUKc29sdXRpb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyB3aXRoIGEgdHJpYW5n\ndWxhciBwYWNrZWQKY29lZmZpY2llbnQgbWF0cml4LgpUaGUgc29sdXRpb24gbWF0cml4IFggbXVz\ndCBiZSBjb21wdXRlZCBieSBDVFBUUlMgb3Igc29tZSBvdGhlcgptZWFucyBiZWZvcmUgZW50ZXJp\nbmcgdGhpcyByb3V0aW5lLiAgQ1RQUkZTIGRvZXMgbm90IGRvIGl0ZXJhdGl2ZQpyZWZpbmVtZW50\nIGJlY2F1c2UgZG9pbmcgc28gY2Fubm90IGltcHJvdmUgdGhlIGJhY2t3YXJkIGVycm9yLgpBcmd1\nbWVudHM6ClxwYXJhbVtpbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUioxCiAgICAg\nICAgID0gJ1UnOiAgQSBpcyB1cHBlciB0cmlhbmd1bGFyOwogICAgICAgICA9ICdMJzogIEEgaXMg\nbG93ZXIgdHJpYW5ndWxhci4KXHBhcmFtW2luXSBUUkFOUwogICAgICAgICBUUkFOUyBpcyBDSEFS\nQUNURVIqMQogICAgICAgICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBvZiBlcXVh\ndGlvbnM6CiAgICAgICAgID0gJ04nOiAgQSAqIFggPSBCICAgICAoTm8gdHJhbnNwb3NlKQogICAg\nICAgICA9ICdUJzogIEEqKlQgKiBYID0gQiAgKFRyYW5zcG9zZSkKICAgICAgICAgPSAnQyc6ICBB\nKipIICogWCA9IEIgIChDb25qdWdhdGUgdHJhbnNwb3NlKQpccGFyYW1baW5dIERJQUcKICAgICAg\nICAgRElBRyBpcyBDSEFSQUNURVIqMQogICAgICAgICA9ICdOJzogIEEgaXMgbm9uLXVuaXQgdHJp\nYW5ndWxhcjsKICAgICAgICAgPSAnVSc6ICBBIGlzIHVuaXQgdHJpYW5ndWxhci4KXHBhcmFtW2lu\nXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJp\neCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAg\nICAgICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBv\nZiBjb2x1bW5zCiAgICAgICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpc\ncGFyYW1baW5dIEFQCiAgICAgICAgIEFQIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTioo\nTisxKS8yKQogICAgICAgICBUaGUgdXBwZXIgb3IgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggQSwg\ncGFja2VkIGNvbHVtbndpc2UgaW4KICAgICAgICAgYSBsaW5lYXIgYXJyYXkuICBUaGUgai10aCBj\nb2x1bW4gb2YgQSBpcyBzdG9yZWQgaW4gdGhlIGFycmF5CiAgICAgICAgIEFQIGFzIGZvbGxvd3M6\nCiAgICAgICAgIGlmIFVQTE8gPSAnVScsIEFQKGkgKyAoai0xKSpqLzIpID0gQShpLGopIGZvciAx\nPD1pPD1qOwogICAgICAgICBpZiBVUExPID0gJ0wnLCBBUChpICsgKGotMSkqKDJuLWopLzIpID0g\nQShpLGopIGZvciBqPD1pPD1uLgogICAgICAgICBJZiBESUFHID0gJ1UnLCB0aGUgZGlhZ29uYWwg\nZWxlbWVudHMgb2YgQSBhcmUgbm90IHJlZmVyZW5jZWQKICAgICAgICAgYW5kIGFyZSBhc3N1bWVk\nIHRvIGJlIDEuClxwYXJhbVtpbl0gQgogICAgICAgICBCIGlzIENPTVBMRVggYXJyYXksIGRpbWVu\nc2lvbiAoTERCLE5SSFMpCiAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuIApc\ncGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgICAgICBUaGUgbGVhZGlu\nZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0g\nWAogICAgICAgICBYIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICAg\nICAgIFRoZSBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlz\nIElOVEVHRVIKICAgICAgICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAg\nTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBGRVJSCiAgICAgICAgIEZFUlIgaXMgUkVBTCBh\ncnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgICAgICBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJy\nb3IgYm91bmQgZm9yIGVhY2ggc29sdXRpb24gdmVjdG9yCiAgICAgICAgIFgoaikgKHRoZSBqLXRo\nIGNvbHVtbiBvZiB0aGUgc29sdXRpb24gbWF0cml4IFgpLgogICAgICAgICBJZiBYVFJVRSBpcyB0\naGUgdHJ1ZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIFgoaiksIEZFUlIoaikKICAgICAgICAg\naXMgYW4gZXN0aW1hdGVkIHVwcGVyIGJvdW5kIGZvciB0aGUgbWFnbml0dWRlIG9mIHRoZSBsYXJn\nZXN0CiAgICAgICAgIGVsZW1lbnQgaW4gKFgoaikgLSBYVFJVRSkgZGl2aWRlZCBieSB0aGUgbWFn\nbml0dWRlIG9mIHRoZQogICAgICAgICBsYXJnZXN0IGVsZW1lbnQgaW4gWChqKS4gIFRoZSBlc3Rp\nbWF0ZSBpcyBhcyByZWxpYWJsZSBhcwogICAgICAgICB0aGUgZXN0aW1hdGUgZm9yIFJDT05ELCBh\nbmQgaXMgYWxtb3N0IGFsd2F5cyBhIHNsaWdodAogICAgICAgICBvdmVyZXN0aW1hdGUgb2YgdGhl\nIHRydWUgZXJyb3IuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFycmF5\nLCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJh\nY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24KICAgICAgICAgdmVjdG9yIFgoaikgKGkuZS4s\nIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4KICAgICAgICAgYW55IGVsZW1lbnQgb2Yg\nQSBvciBCIHRoYXQgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtvdXRdIFdP\nUksKICAgICAgICAgV09SSyBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFt\nW291dF0gUldPUksKICAgICAgICAgUldPUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOKQpc\ncGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICAgICA9IDA6ICBz\ndWNjZXNzZnVsIGV4aXQKICAgICAgICAgPCAwOiAgaWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1\nbWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5l\nc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYu\nIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAx\nMQpcaW5ncm91cCBjb21wbGV4T1RIRVJjb21wdXRhdGlvbmFsCmgdaB4pgXK/AQAAfXLAAQAAKGgh\niWgiaCN1YmgtigITAWguWA4AAABjdHByZnNfMjc1LnR4dHViaC+KAhMBaDBYBQAAAHRwcmZzaC2K\nATN1YmgVaBZdaBeHUnLBAQAAfXLCAQAAKGgaWAoAAAB0cmlhbmd1bGFyaBtYBgAAAHBhY2tlZGgc\nWCkAAABlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlc2gdaB4pgXLDAQAA\nfXLEAQAAKGghiWgiaCN1YmgkWCAAAABEb3h5Z2VuL2RvY3MvaHRtbC96dHByZnNfOGYuaHRtbGgl\nWAEAAAB6aCZoFWgnXWgXh1JyxQEAAH1yxgEAAChoKljUDAAAWlRQUkZTIHByb3ZpZGVzIGVycm9y\nIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzIGZvciB0aGUKc29sdXRpb24gdG8g\nYSBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyB3aXRoIGEgdHJpYW5ndWxhciBwYWNrZWQKY29l\nZmZpY2llbnQgbWF0cml4LgpUaGUgc29sdXRpb24gbWF0cml4IFggbXVzdCBiZSBjb21wdXRlZCBi\neSBaVFBUUlMgb3Igc29tZSBvdGhlcgptZWFucyBiZWZvcmUgZW50ZXJpbmcgdGhpcyByb3V0aW5l\nLiAgWlRQUkZTIGRvZXMgbm90IGRvIGl0ZXJhdGl2ZQpyZWZpbmVtZW50IGJlY2F1c2UgZG9pbmcg\nc28gY2Fubm90IGltcHJvdmUgdGhlIGJhY2t3YXJkIGVycm9yLgpBcmd1bWVudHM6ClxwYXJhbVtp\nbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUioxCiAgICAgICAgID0gJ1UnOiAgQSBp\ncyB1cHBlciB0cmlhbmd1bGFyOwogICAgICAgICA9ICdMJzogIEEgaXMgbG93ZXIgdHJpYW5ndWxh\nci4KXHBhcmFtW2luXSBUUkFOUwogICAgICAgICBUUkFOUyBpcyBDSEFSQUNURVIqMQogICAgICAg\nICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnM6CiAgICAgICAg\nID0gJ04nOiAgQSAqIFggPSBCICAgICAoTm8gdHJhbnNwb3NlKQogICAgICAgICA9ICdUJzogIEEq\nKlQgKiBYID0gQiAgKFRyYW5zcG9zZSkKICAgICAgICAgPSAnQyc6ICBBKipIICogWCA9IEIgIChD\nb25qdWdhdGUgdHJhbnNwb3NlKQpccGFyYW1baW5dIERJQUcKICAgICAgICAgRElBRyBpcyBDSEFS\nQUNURVIqMQogICAgICAgICA9ICdOJzogIEEgaXMgbm9uLXVuaXQgdHJpYW5ndWxhcjsKICAgICAg\nICAgPSAnVSc6ICBBIGlzIHVuaXQgdHJpYW5ndWxhci4KXHBhcmFtW2luXSBOCiAgICAgICAgIE4g\naXMgSU5URUdFUgogICAgICAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpc\ncGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBudW1i\nZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5zCiAgICAg\nICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEFQCiAg\nICAgICAgIEFQIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTiooTisxKS8yKQogICAg\nICAgICBUaGUgdXBwZXIgb3IgbG93ZXIgdHJpYW5ndWxhciBtYXRyaXggQSwgcGFja2VkIGNvbHVt\nbndpc2UgaW4KICAgICAgICAgYSBsaW5lYXIgYXJyYXkuICBUaGUgai10aCBjb2x1bW4gb2YgQSBp\ncyBzdG9yZWQgaW4gdGhlIGFycmF5CiAgICAgICAgIEFQIGFzIGZvbGxvd3M6CiAgICAgICAgIGlm\nIFVQTE8gPSAnVScsIEFQKGkgKyAoai0xKSpqLzIpID0gQShpLGopIGZvciAxPD1pPD1qOwogICAg\nICAgICBpZiBVUExPID0gJ0wnLCBBUChpICsgKGotMSkqKDJuLWopLzIpID0gQShpLGopIGZvciBq\nPD1pPD1uLgogICAgICAgICBJZiBESUFHID0gJ1UnLCB0aGUgZGlhZ29uYWwgZWxlbWVudHMgb2Yg\nQSBhcmUgbm90IHJlZmVyZW5jZWQKICAgICAgICAgYW5kIGFyZSBhc3N1bWVkIHRvIGJlIDEuClxw\nYXJhbVtpbl0gQgogICAgICAgICBCIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTERC\nLE5SSFMpCiAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0g\nTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VSCiAgICAgICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lv\nbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBYCiAgICAgICAg\nIFggaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgICAgICAgVGhl\nIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdF\nUgogICAgICAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0g\nbWF4KDEsTikuClxwYXJhbVtvdXRdIEZFUlIKICAgICAgICAgRkVSUiBpcyBET1VCTEUgUFJFQ0lT\nSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICAgICAgIFRoZSBlc3RpbWF0ZWQgZm9yd2Fy\nZCBlcnJvciBib3VuZCBmb3IgZWFjaCBzb2x1dGlvbiB2ZWN0b3IKICAgICAgICAgWChqKSAodGhl\nIGotdGggY29sdW1uIG9mIHRoZSBzb2x1dGlvbiBtYXRyaXggWCkuCiAgICAgICAgIElmIFhUUlVF\nIGlzIHRoZSB0cnVlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8gWChqKSwgRkVSUihqKQogICAg\nICAgICBpcyBhbiBlc3RpbWF0ZWQgdXBwZXIgYm91bmQgZm9yIHRoZSBtYWduaXR1ZGUgb2YgdGhl\nIGxhcmdlc3QKICAgICAgICAgZWxlbWVudCBpbiAoWChqKSAtIFhUUlVFKSBkaXZpZGVkIGJ5IHRo\nZSBtYWduaXR1ZGUgb2YgdGhlCiAgICAgICAgIGxhcmdlc3QgZWxlbWVudCBpbiBYKGopLiAgVGhl\nIGVzdGltYXRlIGlzIGFzIHJlbGlhYmxlIGFzCiAgICAgICAgIHRoZSBlc3RpbWF0ZSBmb3IgUkNP\nTkQsIGFuZCBpcyBhbG1vc3QgYWx3YXlzIGEgc2xpZ2h0CiAgICAgICAgIG92ZXJlc3RpbWF0ZSBv\nZiB0aGUgdHJ1ZSBlcnJvci4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIERPVUJM\nRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgICAgICAgVGhlIGNvbXBvbmVu\ndHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1dGlvbgogICAgICAgICB2\nZWN0b3IgWChqKSAoaS5lLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbgogICAgICAg\nICBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdCBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9u\nKS4KXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIENPTVBMRVgqMTYgYXJyYXksIGRp\nbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBSV09SSwogICAgICAgICBSV09SSyBpcyBET1VCTEUg\nUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRdIElORk8KICAgICAgICAg\nSU5GTyBpcyBJTlRFR0VSCiAgICAgICAgID0gMDogIHN1Y2Nlc3NmdWwgZXhpdAogICAgICAgICA8\nIDA6ICBpZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVl\nCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENh\nbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0\naG9yIE5BRyBMdGQuIApcZGF0ZSBOb3ZlbWJlciAyMDExClxpbmdyb3VwIGNvbXBsZXgxNk9USEVS\nY29tcHV0YXRpb25hbApoHWgeKYFyxwEAAH1yyAEAAChoIYloImgjdWJoLYoCFAFoLlgOAAAAenRw\ncmZzXzI3Ni50eHR1YmgvigIUAWgwWAUAAAB0cHJmc2gtigE0dWJoFWgWXWgXh1JyyQEAAH1yygEA\nAChoGlgHAAAAZ2VuZXJhbGgbWAQAAABmdWxsaBxYRgAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dh\ncmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudDsgRVFVRURoHWgeKYFyywEA\nAH1yzAEAAChoIYloImgjdWJoJFghAAAARG94eWdlbi9kb2NzL2h0bWwvc2dlcmZzeF84Zi5odG1s\naCVYAQAAAHNoJmgVaCddaBeHUnLNAQAAfXLOAQAAKGgqWGkyAAAgICBTR0VSRlNYIGltcHJvdmVz\nIHRoZSBjb21wdXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKICAgZXF1YXRpb25z\nIGFuZCBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcwog\nICBmb3IgdGhlIHNvbHV0aW9uLiAgSW4gYWRkaXRpb24gdG8gbm9ybXdpc2UgZXJyb3IgYm91bmQs\nIHRoZSBjb2RlCiAgIHByb3ZpZGVzIG1heGltdW0gY29tcG9uZW50d2lzZSBlcnJvciBib3VuZCBp\nZiBwb3NzaWJsZS4gIFNlZQogICBjb21tZW50cyBmb3IgRVJSX0JORFNfTk9STSBhbmQgRVJSX0JO\nRFNfQ09NUCBmb3IgZGV0YWlscyBvZiB0aGUKICAgZXJyb3IgYm91bmRzLgogICBUaGUgb3JpZ2lu\nYWwgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgbWF5IGhhdmUgYmVlbiBlcXVpbGlicmF0ZWQK\nICAgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0aW5lLCBhcyBkZXNjcmliZWQgYnkgYXJndW1lbnRz\nIEVRVUVELCBSCiAgIGFuZCBDIGJlbG93LiBJbiB0aGlzIGNhc2UsIHRoZSBzb2x1dGlvbiBhbmQg\nZXJyb3IgYm91bmRzIHJldHVybmVkCiAgIGFyZSBmb3IgdGhlIG9yaWdpbmFsIHVuZXF1aWxpYnJh\ndGVkIHN5c3RlbS4KQXJndW1lbnRzOgogICAgU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzIGFyZSBi\ndW5kbGVkIGluIHRoZSBQQVJBTVMgYXJyYXkuICBUaGVzZQogICAgc2V0dGluZ3MgZGV0ZXJtaW5l\nIGhvdyByZWZpbmVtZW50IGlzIHBlcmZvcm1lZCwgYnV0IG9mdGVuIHRoZQogICAgZGVmYXVsdHMg\nYXJlIGFjY2VwdGFibGUuICBJZiB0aGUgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUsIHVzZXJzCiAg\nICBjYW4gcGFzcyBOUEFSQU1TID0gMCB3aGljaCBwcmV2ZW50cyB0aGUgc291cmNlIGNvZGUgZnJv\nbSBhY2Nlc3NpbmcKICAgIHRoZSBQQVJBTVMgYXJndW1lbnQuClxwYXJhbVtpbl0gVFJBTlMKICAg\nICAgICAgVFJBTlMgaXMgQ0hBUkFDVEVSKjEKICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiB0aGUg\nc3lzdGVtIG9mIGVxdWF0aW9uczoKICAgICAgPSAnTic6ICBBICogWCA9IEIgICAgIChObyB0cmFu\nc3Bvc2UpCiAgICAgID0gJ1QnOiAgQSoqVCAqIFggPSBCICAoVHJhbnNwb3NlKQogICAgICA9ICdD\nJzogIEEqKkggKiBYID0gQiAgKENvbmp1Z2F0ZSB0cmFuc3Bvc2UgPSBUcmFuc3Bvc2UpClxwYXJh\nbVtpbl0gRVFVRUQKICAgICAgICAgRVFVRUQgaXMgQ0hBUkFDVEVSKjEKICAgIFNwZWNpZmllcyB0\naGUgZm9ybSBvZiBlcXVpbGlicmF0aW9uIHRoYXQgd2FzIGRvbmUgdG8gQQogICAgYmVmb3JlIGNh\nbGxpbmcgdGhpcyByb3V0aW5lLiBUaGlzIGlzIG5lZWRlZCB0byBjb21wdXRlCiAgICB0aGUgc29s\ndXRpb24gYW5kIGVycm9yIGJvdW5kcyBjb3JyZWN0bHkuCiAgICAgID0gJ04nOiAgTm8gZXF1aWxp\nYnJhdGlvbgogICAgICA9ICdSJzogIFJvdyBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBiZWVu\nIHByZW11bHRpcGxpZWQgYnkKICAgICAgICAgICAgICBkaWFnKFIpLgogICAgICA9ICdDJzogIENv\nbHVtbiBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBiZWVuIHBvc3RtdWx0aXBsaWVkCiAgICAg\nICAgICAgICAgYnkgZGlhZyhDKS4KICAgICAgPSAnQic6ICBCb3RoIHJvdyBhbmQgY29sdW1uIGVx\ndWlsaWJyYXRpb24sIGkuZS4sIEEgaGFzIGJlZW4KICAgICAgICAgICAgICByZXBsYWNlZCBieSBk\naWFnKFIpICogQSAqIGRpYWcoQykuCiAgICAgICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBC\nIGhhcyBiZWVuIGNoYW5nZWQgYWNjb3JkaW5nbHkuClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlz\nIElOVEVHRVIKICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtp\nbl0gTlJIUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgIFRoZSBudW1iZXIgb2YgcmlnaHQg\naGFuZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5zCiAgICBvZiB0aGUgbWF0cmlj\nZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBBCiAgICAgICAgIEEgaXMgUkVBTCBh\ncnJheSwgZGltZW5zaW9uIChMREEsTikKICAgIFRoZSBvcmlnaW5hbCBOLWJ5LU4gbWF0cml4IEEu\nClxwYXJhbVtpbl0gTERBCiAgICAgICAgIExEQSBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBk\naW1lbnNpb24gb2YgdGhlIGFycmF5IEEuICBMREEgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gQUYK\nICAgICAgICAgQUYgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMREFGLE4pCiAgICBUaGUgZmFj\ndG9ycyBMIGFuZCBVIGZyb20gdGhlIGZhY3Rvcml6YXRpb24gQSA9IFAqTCpVCiAgICBhcyBjb21w\ndXRlZCBieSBTR0VUUkYuClxwYXJhbVtpbl0gTERBRgogICAgICAgICBMREFGIGlzIElOVEVHRVIK\nICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUYuICBMREFGID49IG1heCgx\nLE4pLgpccGFyYW1baW5dIElQSVYKICAgICAgICAgSVBJViBpcyBJTlRFR0VSIGFycmF5LCBkaW1l\nbnNpb24gKE4pCiAgICBUaGUgcGl2b3QgaW5kaWNlcyBmcm9tIFNHRVRSRjsgZm9yIDE8PWk8PU4s\nIHJvdyBpIG9mIHRoZQogICAgbWF0cml4IHdhcyBpbnRlcmNoYW5nZWQgd2l0aCByb3cgSVBJVihp\nKS4KXHBhcmFtW2luXSBSCiAgICAgICAgIFIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOKQog\nICAgVGhlIHJvdyBzY2FsZSBmYWN0b3JzIGZvciBBLiAgSWYgRVFVRUQgPSAnUicgb3IgJ0InLCBB\nIGlzCiAgICBtdWx0aXBsaWVkIG9uIHRoZSBsZWZ0IGJ5IGRpYWcoUik7IGlmIEVRVUVEID0gJ04n\nIG9yICdDJywgUgogICAgaXMgbm90IGFjY2Vzc2VkLiAgCiAgICBJZiBSIGlzIGFjY2Vzc2VkLCBl\nYWNoIGVsZW1lbnQgb2YgUiBzaG91bGQgYmUgYSBwb3dlciBvZiB0aGUgcmFkaXgKICAgIHRvIGVu\nc3VyZSBhIHJlbGlhYmxlIHNvbHV0aW9uIGFuZCBlcnJvciBlc3RpbWF0ZXMuIFNjYWxpbmcgYnkK\nICAgIHBvd2VycyBvZiB0aGUgcmFkaXggZG9lcyBub3QgY2F1c2Ugcm91bmRpbmcgZXJyb3JzIHVu\nbGVzcyB0aGUKICAgIHJlc3VsdCB1bmRlcmZsb3dzIG9yIG92ZXJmbG93cy4gUm91bmRpbmcgZXJy\nb3JzIGR1cmluZyBzY2FsaW5nCiAgICBsZWFkIHRvIHJlZmluaW5nIHdpdGggYSBtYXRyaXggdGhh\ndCBpcyBub3QgZXF1aXZhbGVudCB0byB0aGUKICAgIGlucHV0IG1hdHJpeCwgcHJvZHVjaW5nIGVy\ncm9yIGVzdGltYXRlcyB0aGF0IG1heSBub3QgYmUKICAgIHJlbGlhYmxlLgpccGFyYW1baW5dIEMK\nICAgICAgICAgQyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICBUaGUgY29sdW1uIHNj\nYWxlIGZhY3RvcnMgZm9yIEEuICBJZiBFUVVFRCA9ICdDJyBvciAnQicsIEEgaXMKICAgIG11bHRp\ncGxpZWQgb24gdGhlIHJpZ2h0IGJ5IGRpYWcoQyk7IGlmIEVRVUVEID0gJ04nIG9yICdSJywgQwog\nICAgaXMgbm90IGFjY2Vzc2VkLiAKICAgIElmIEMgaXMgYWNjZXNzZWQsIGVhY2ggZWxlbWVudCBv\nZiBDIHNob3VsZCBiZSBhIHBvd2VyIG9mIHRoZSByYWRpeAogICAgdG8gZW5zdXJlIGEgcmVsaWFi\nbGUgc29sdXRpb24gYW5kIGVycm9yIGVzdGltYXRlcy4gU2NhbGluZyBieQogICAgcG93ZXJzIG9m\nIHRoZSByYWRpeCBkb2VzIG5vdCBjYXVzZSByb3VuZGluZyBlcnJvcnMgdW5sZXNzIHRoZQogICAg\ncmVzdWx0IHVuZGVyZmxvd3Mgb3Igb3ZlcmZsb3dzLiBSb3VuZGluZyBlcnJvcnMgZHVyaW5nIHNj\nYWxpbmcKICAgIGxlYWQgdG8gcmVmaW5pbmcgd2l0aCBhIG1hdHJpeCB0aGF0IGlzIG5vdCBlcXVp\ndmFsZW50IHRvIHRoZQogICAgaW5wdXQgbWF0cml4LCBwcm9kdWNpbmcgZXJyb3IgZXN0aW1hdGVz\nIHRoYXQgbWF5IG5vdCBiZQogICAgcmVsaWFibGUuClxwYXJhbVtpbl0gQgogICAgICAgICBCIGlz\nIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICBUaGUgcmlnaHQgaGFuZCBzaWRl\nIG1hdHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgVGhl\nIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49IG1heCgxLE4pLgpccGFy\nYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJI\nUykKICAgIE9uIGVudHJ5LCB0aGUgc29sdXRpb24gbWF0cml4IFgsIGFzIGNvbXB1dGVkIGJ5IFNH\nRVRSUy4KICAgIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFt\nW2luXSBMRFgKICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lv\nbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0gUkNPTkQKICAg\nICAgICAgUkNPTkQgaXMgUkVBTAogICAgUmVjaXByb2NhbCBzY2FsZWQgY29uZGl0aW9uIG51bWJl\nci4gIFRoaXMgaXMgYW4gZXN0aW1hdGUgb2YgdGhlCiAgICByZWNpcHJvY2FsIFNrZWVsIGNvbmRp\ndGlvbiBudW1iZXIgb2YgdGhlIG1hdHJpeCBBIGFmdGVyCiAgICBlcXVpbGlicmF0aW9uIChpZiBk\nb25lKS4gIElmIHRoaXMgaXMgbGVzcyB0aGFuIHRoZSBtYWNoaW5lCiAgICBwcmVjaXNpb24gKGlu\nIHBhcnRpY3VsYXIsIGlmIGl0IGlzIHplcm8pLCB0aGUgbWF0cml4IGlzIHNpbmd1bGFyCiAgICB0\nbyB3b3JraW5nIHByZWNpc2lvbi4gIE5vdGUgdGhhdCB0aGUgZXJyb3IgbWF5IHN0aWxsIGJlIHNt\nYWxsIGV2ZW4KICAgIGlmIHRoaXMgbnVtYmVyIGlzIHZlcnkgc21hbGwgYW5kIHRoZSBtYXRyaXgg\nYXBwZWFycyBpbGwtCiAgICBjb25kaXRpb25lZC4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBC\nRVJSIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgIENvbXBvbmVudHdpc2UgcmVs\nYXRpdmUgYmFja3dhcmQgZXJyb3IuICBUaGlzIGlzIHRoZQogICAgY29tcG9uZW50d2lzZSByZWxh\ndGl2ZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uIHZlY3RvciBYKGopCiAgICAoaS5l\nLiwgdGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbiBhbnkgZWxlbWVudCBvZiBBIG9yIEIg\ndGhhdAogICAgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtpbl0gTl9FUlJf\nQk5EUwogICAgICAgICBOX0VSUl9CTkRTIGlzIElOVEVHRVIKICAgIE51bWJlciBvZiBlcnJvciBi\nb3VuZHMgdG8gcmV0dXJuIGZvciBlYWNoIHJpZ2h0IGhhbmQgc2lkZQogICAgYW5kIGVhY2ggdHlw\nZSAobm9ybXdpc2Ugb3IgY29tcG9uZW50d2lzZSkuICBTZWUgRVJSX0JORFNfTk9STSBhbmQKICAg\nIEVSUl9CTkRTX0NPTVAgYmVsb3cuClxwYXJhbVtvdXRdIEVSUl9CTkRTX05PUk0KICAgICAgICAg\nRVJSX0JORFNfTk9STSBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5SSFMsIE5fRVJSX0JORFMp\nCiAgICBGb3IgZWFjaCByaWdodC1oYW5kIHNpZGUsIHRoaXMgYXJyYXkgY29udGFpbnMgaW5mb3Jt\nYXRpb24gYWJvdXQKICAgIHZhcmlvdXMgZXJyb3IgYm91bmRzIGFuZCBjb25kaXRpb24gbnVtYmVy\ncyBjb3JyZXNwb25kaW5nIHRvIHRoZQogICAgbm9ybXdpc2UgcmVsYXRpdmUgZXJyb3IsIHdoaWNo\nIGlzIGRlZmluZWQgYXMgZm9sbG93czoKICAgIE5vcm13aXNlIHJlbGF0aXZlIGVycm9yIGluIHRo\nZSBpdGggc29sdXRpb24gdmVjdG9yOgogICAgICAgICAgICBtYXhfaiAoYWJzKFhUUlVFKGosaSkg\nLSBYKGosaSkpKQogICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICAg\nICAgICAgICAgICAgIG1heF9qIGFicyhYKGosaSkpCiAgICBUaGUgYXJyYXkgaXMgaW5kZXhlZCBi\neSB0aGUgdHlwZSBvZiBlcnJvciBpbmZvcm1hdGlvbiBhcyBkZXNjcmliZWQKICAgIGJlbG93LiBU\naGVyZSBjdXJyZW50bHkgYXJlIHVwIHRvIHRocmVlIHBpZWNlcyBvZiBpbmZvcm1hdGlvbgogICAg\ncmV0dXJuZWQuCiAgICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfTk9STShpLDopIGNvcnJl\nc3BvbmRzIHRvIHRoZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBzZWNvbmQgaW5k\nZXggaW4gRVJSX0JORFNfTk9STSg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2luZwogICAgdGhy\nZWUgZmllbGRzOgogICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xlYW4uIFRydXN0\nIHRoZSBhbnN3ZXIgaWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1i\nZXIgaXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFt\nY2goJ0Vwc2lsb24nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJvdW5kOiBUaGUg\nZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2VydGFpbmx5IHdp\ndGhpbiBhIGZhY3RvciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAgICAgc28gbG9u\nZyBhcyB0aGUgbmV4dCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAg\nICAgICAgc3FydChuKSAqIHNsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJvdW5kIHNob3Vs\nZCBvbmx5CiAgICAgICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBib29sZWFuIGlz\nIHRydWUuCiAgICBlcnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6IEVzdGltYXRl\nZCBub3Jtd2lzZQogICAgICAgICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyLiAgQ29t\ncGFyZWQgd2l0aCB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdF\ncHNpbG9uJykgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlcnJvcgogICAgICAgICAgICAgZXN0aW1hdGUg\naXMgImd1YXJhbnRlZWQiLiBUaGVzZSByZWNpcHJvY2FsIGNvbmRpdGlvbgogICAgICAgICAgICAg\nbnVtYmVycyBhcmUgMSAvIChub3JtKFpeey0xfSxpbmYpICogbm9ybShaLGluZikpIGZvciBzb21l\nCiAgICAgICAgICAgICBhcHByb3ByaWF0ZWx5IHNjYWxlZCBtYXRyaXggWi4KICAgICAgICAgICAg\nIExldCBaID0gUypBLCB3aGVyZSBTIHNjYWxlcyBlYWNoIHJvdyBieSBhIHBvd2VyIG9mIHRoZQog\nICAgICAgICAgICAgcmFkaXggc28gYWxsIGFic29sdXRlIHJvdyBzdW1zIG9mIFogYXJlIGFwcHJv\neGltYXRlbHkgMS4KICAgIFNlZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhlciBk\nZXRhaWxzIGFuZCBleHRyYQogICAgY2F1dGlvbnMuClxwYXJhbVtvdXRdIEVSUl9CTkRTX0NPTVAK\nICAgICAgICAgRVJSX0JORFNfQ09NUCBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5SSFMsIE5f\nRVJSX0JORFMpCiAgICBGb3IgZWFjaCByaWdodC1oYW5kIHNpZGUsIHRoaXMgYXJyYXkgY29udGFp\nbnMgaW5mb3JtYXRpb24gYWJvdXQKICAgIHZhcmlvdXMgZXJyb3IgYm91bmRzIGFuZCBjb25kaXRp\nb24gbnVtYmVycyBjb3JyZXNwb25kaW5nIHRvIHRoZQogICAgY29tcG9uZW50d2lzZSByZWxhdGl2\nZSBlcnJvciwgd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dzOgogICAgQ29tcG9uZW50d2lzZSBy\nZWxhdGl2ZSBlcnJvciBpbiB0aGUgaXRoIHNvbHV0aW9uIHZlY3RvcjoKICAgICAgICAgICAgICAg\nICAgIGFicyhYVFJVRShqLGkpIC0gWChqLGkpKQogICAgICAgICAgICBtYXhfaiAtLS0tLS0tLS0t\nLS0tLS0tLS0tLS0tCiAgICAgICAgICAgICAgICAgICAgICAgIGFicyhYKGosaSkpCiAgICBUaGUg\nYXJyYXkgaXMgaW5kZXhlZCBieSB0aGUgcmlnaHQtaGFuZCBzaWRlIGkgKG9uIHdoaWNoIHRoZQog\nICAgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBlcnJvciBkZXBlbmRzKSwgYW5kIHRoZSB0eXBlIG9m\nIGVycm9yCiAgICBpbmZvcm1hdGlvbiBhcyBkZXNjcmliZWQgYmVsb3cuIFRoZXJlIGN1cnJlbnRs\neSBhcmUgdXAgdG8gdGhyZWUKICAgIHBpZWNlcyBvZiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmb3Ig\nZWFjaCByaWdodC1oYW5kIHNpZGUuIElmCiAgICBjb21wb25lbnR3aXNlIGFjY3VyYWN5IGlzIG5v\ndCByZXF1ZXN0ZWQgKFBBUkFNUygzKSA9IDAuMCksIHRoZW4KICAgIEVSUl9CTkRTX0NPTVAgaXMg\nbm90IGFjY2Vzc2VkLiAgSWYgTl9FUlJfQk5EUyAuTFQuIDMsIHRoZW4gYXQgbW9zdAogICAgdGhl\nIGZpcnN0ICg6LE5fRVJSX0JORFMpIGVudHJpZXMgYXJlIHJldHVybmVkLgogICAgVGhlIGZpcnN0\nIGluZGV4IGluIEVSUl9CTkRTX0NPTVAoaSw6KSBjb3JyZXNwb25kcyB0byB0aGUgaXRoCiAgICBy\naWdodC1oYW5kIHNpZGUuCiAgICBUaGUgc2Vjb25kIGluZGV4IGluIEVSUl9CTkRTX0NPTVAoOixl\ncnIpIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcKICAgIHRocmVlIGZpZWxkczoKICAgIGVyciA9IDEg\nIlRydXN0L2Rvbid0IHRydXN0IiBib29sZWFuLiBUcnVzdCB0aGUgYW5zd2VyIGlmIHRoZQogICAg\nICAgICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdGhy\nZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykuCiAgICBlcnIg\nPSAyICJHdWFyYW50ZWVkIiBlcnJvciBib3VuZDogVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9y\nLAogICAgICAgICAgICAgYWxtb3N0IGNlcnRhaW5seSB3aXRoaW4gYSBmYWN0b3Igb2YgMTAgb2Yg\ndGhlIHRydWUgZXJyb3IKICAgICAgICAgICAgIHNvIGxvbmcgYXMgdGhlIG5leHQgZW50cnkgaXMg\nZ3JlYXRlciB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2go\nJ0Vwc2lsb24nKS4gVGhpcyBlcnJvciBib3VuZCBzaG91bGQgb25seQogICAgICAgICAgICAgYmUg\ndHJ1c3RlZCBpZiB0aGUgcHJldmlvdXMgYm9vbGVhbiBpcyB0cnVlLgogICAgZXJyID0gMyAgUmVj\naXByb2NhbCBjb25kaXRpb24gbnVtYmVyOiBFc3RpbWF0ZWQgY29tcG9uZW50d2lzZQogICAgICAg\nICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyLiAgQ29tcGFyZWQgd2l0aCB0aGUgdGhy\nZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykgdG8gZGV0ZXJt\naW5lIGlmIHRoZSBlcnJvcgogICAgICAgICAgICAgZXN0aW1hdGUgaXMgImd1YXJhbnRlZWQiLiBU\naGVzZSByZWNpcHJvY2FsIGNvbmRpdGlvbgogICAgICAgICAgICAgbnVtYmVycyBhcmUgMSAvIChu\nb3JtKFpeey0xfSxpbmYpICogbm9ybShaLGluZikpIGZvciBzb21lCiAgICAgICAgICAgICBhcHBy\nb3ByaWF0ZWx5IHNjYWxlZCBtYXRyaXggWi4KICAgICAgICAgICAgIExldCBaID0gUyooQSpkaWFn\nKHgpKSwgd2hlcmUgeCBpcyB0aGUgc29sdXRpb24gZm9yIHRoZQogICAgICAgICAgICAgY3VycmVu\ndCByaWdodC1oYW5kIHNpZGUgYW5kIFMgc2NhbGVzIGVhY2ggcm93IG9mCiAgICAgICAgICAgICBB\nKmRpYWcoeCkgYnkgYSBwb3dlciBvZiB0aGUgcmFkaXggc28gYWxsIGFic29sdXRlIHJvdwogICAg\nICAgICAgICAgc3VtcyBvZiBaIGFyZSBhcHByb3hpbWF0ZWx5IDEuCiAgICBTZWUgTGFwYWNrIFdv\ncmtpbmcgTm90ZSAxNjUgZm9yIGZ1cnRoZXIgZGV0YWlscyBhbmQgZXh0cmEKICAgIGNhdXRpb25z\nLgpccGFyYW1baW5dIE5QQVJBTVMKICAgICAgICAgTlBBUkFNUyBpcyBJTlRFR0VSCiAgICBTcGVj\naWZpZXMgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIHNldCBpbiBQQVJBTVMuICBJZiAuTEUuIDAs\nIHRoZQogICAgUEFSQU1TIGFycmF5IGlzIG5ldmVyIHJlZmVyZW5jZWQgYW5kIGRlZmF1bHQgdmFs\ndWVzIGFyZSB1c2VkLgpccGFyYW1baW4sb3V0XSBQQVJBTVMKICAgICAgICAgUEFSQU1TIGlzIFJF\nQUwgYXJyYXksIGRpbWVuc2lvbiBOUEFSQU1TCiAgICBTcGVjaWZpZXMgYWxnb3JpdGhtIHBhcmFt\nZXRlcnMuICBJZiBhbiBlbnRyeSBpcyAuTFQuIDAuMCwgdGhlbgogICAgdGhhdCBlbnRyeSB3aWxs\nIGJlIGZpbGxlZCB3aXRoIGRlZmF1bHQgdmFsdWUgdXNlZCBmb3IgdGhhdAogICAgcGFyYW1ldGVy\nLiAgT25seSBwb3NpdGlvbnMgdXAgdG8gTlBBUkFNUyBhcmUgYWNjZXNzZWQ7IGRlZmF1bHRzCiAg\nICBhcmUgdXNlZCBmb3IgaGlnaGVyLW51bWJlcmVkIHBhcmFtZXRlcnMuCiAgICAgIFBBUkFNUyhM\nQV9MSU5SWF9JVFJFRl9JID0gMSkgOiBXaGV0aGVyIHRvIHBlcmZvcm0gaXRlcmF0aXZlCiAgICAg\nICAgICAgcmVmaW5lbWVudCBvciBub3QuCiAgICAgICAgRGVmYXVsdDogMS4wCiAgICAgICAgICAg\nPSAwLjAgOiBObyByZWZpbmVtZW50IGlzIHBlcmZvcm1lZCwgYW5kIG5vIGVycm9yIGJvdW5kcyBh\ncmUKICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkLgogICAgICAgICAgID0gMS4wIDogVXNlIHRo\nZSBkb3VibGUtcHJlY2lzaW9uIHJlZmluZW1lbnQgYWxnb3JpdGhtLAogICAgICAgICAgICAgICAg\nICAgcG9zc2libHkgd2l0aCBkb3VibGVkLXNpbmdsZSBjb21wdXRhdGlvbnMgaWYgdGhlCiAgICAg\nICAgICAgICAgICAgICBjb21waWxhdGlvbiBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IERP\nVUJMRQogICAgICAgICAgICAgICAgICAgUFJFQ0lTSU9OLgogICAgICAgICAgICAgKG90aGVyIHZh\nbHVlcyBhcmUgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UpCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9J\nVEhSRVNIX0kgPSAyKSA6IE1heGltdW0gbnVtYmVyIG9mIHJlc2lkdWFsCiAgICAgICAgICAgY29t\ncHV0YXRpb25zIGFsbG93ZWQgZm9yIHJlZmluZW1lbnQuCiAgICAgICAgRGVmYXVsdDogMTAKICAg\nICAgICBBZ2dyZXNzaXZlOiBTZXQgdG8gMTAwIHRvIHBlcm1pdCBjb252ZXJnZW5jZSB1c2luZyBh\ncHByb3hpbWF0ZQogICAgICAgICAgICAgICAgICAgIGZhY3Rvcml6YXRpb25zIG9yIGZhY3Rvcml6\nYXRpb25zIG90aGVyIHRoYW4gTFUuIElmCiAgICAgICAgICAgICAgICAgICAgdGhlIGZhY3Rvcml6\nYXRpb24gdXNlcyBhIHRlY2huaXF1ZSBvdGhlciB0aGFuCiAgICAgICAgICAgICAgICAgICAgR2F1\nc3NpYW4gZWxpbWluYXRpb24sIHRoZSBndWFyYW50ZWVzIGluCiAgICAgICAgICAgICAgICAgICAg\nZXJyX2JuZHNfbm9ybSBhbmQgZXJyX2JuZHNfY29tcCBtYXkgbm8gbG9uZ2VyIGJlCiAgICAgICAg\nICAgICAgICAgICAgdHJ1c3R3b3J0aHkuCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9DV0lTRV9JID0g\nMykgOiBGbGFnIGRldGVybWluaW5nIGlmIHRoZSBjb2RlCiAgICAgICAgICAgd2lsbCBhdHRlbXB0\nIHRvIGZpbmQgYSBzb2x1dGlvbiB3aXRoIHNtYWxsIGNvbXBvbmVudHdpc2UKICAgICAgICAgICBy\nZWxhdGl2ZSBlcnJvciBpbiB0aGUgZG91YmxlLXByZWNpc2lvbiBhbGdvcml0aG0uICBQb3NpdGl2\nZQogICAgICAgICAgIGlzIHRydWUsIDAuMCBpcyBmYWxzZS4KICAgICAgICBEZWZhdWx0OiAxLjAg\nKGF0dGVtcHQgY29tcG9uZW50d2lzZSBjb252ZXJnZW5jZSkKXHBhcmFtW291dF0gV09SSwogICAg\nICAgICBXT1JLIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoNCpOKQpccGFyYW1bb3V0XSBJV09S\nSwogICAgICAgICBJV09SSyBpcyBJTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtv\ndXRdIElORk8KICAgICAgICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgID0gMDogIFN1Y2Nlc3NmdWwg\nZXhpdC4gVGhlIHNvbHV0aW9uIHRvIGV2ZXJ5IHJpZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIGd1\nYXJhbnRlZWQuCiAgICAgIDwgMDogIElmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFk\nIGFuIGlsbGVnYWwgdmFsdWUKICAgICAgPiAwIGFuZCA8PSBOOiAgVShJTkZPLElORk8pIGlzIGV4\nYWN0bHkgemVyby4gIFRoZSBmYWN0b3JpemF0aW9uCiAgICAgICAgaGFzIGJlZW4gY29tcGxldGVk\nLCBidXQgdGhlIGZhY3RvciBVIGlzIGV4YWN0bHkgc2luZ3VsYXIsIHNvCiAgICAgICAgdGhlIHNv\nbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgY291bGQgbm90IGJlIGNvbXB1dGVkLiBSQ09ORCA9IDAK\nICAgICAgICBpcyByZXR1cm5lZC4KICAgICAgPSBOK0o6IFRoZSBzb2x1dGlvbiBjb3JyZXNwb25k\naW5nIHRvIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzCiAgICAgICAgbm90IGd1YXJhbnRlZWQu\nIFRoZSBzb2x1dGlvbnMgY29ycmVzcG9uZGluZyB0byBvdGhlciByaWdodC0KICAgICAgICBoYW5k\nIHNpZGVzIEsgd2l0aCBLID4gSiBtYXkgbm90IGJlIGd1YXJhbnRlZWQgYXMgd2VsbCwgYnV0CiAg\nICAgICAgb25seSB0aGUgZmlyc3Qgc3VjaCByaWdodC1oYW5kIHNpZGUgaXMgcmVwb3J0ZWQuIElm\nIGEgc21hbGwKICAgICAgICBjb21wb25lbnR3aXNlIGVycm9yIGlzIG5vdCByZXF1ZXN0ZWQgKFBB\nUkFNUygzKSA9IDAuMCkgdGhlbgogICAgICAgIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzIHRo\nZSBmaXJzdCB3aXRoIGEgbm9ybXdpc2UgZXJyb3IKICAgICAgICBib3VuZCB0aGF0IGlzIG5vdCBn\ndWFyYW50ZWVkICh0aGUgc21hbGxlc3QgSiBzdWNoCiAgICAgICAgdGhhdCBFUlJfQk5EU19OT1JN\nKEosMSkgPSAwLjApLiBCeSBkZWZhdWx0IChQQVJBTVMoMykgPSAxLjApCiAgICAgICAgdGhlIEp0\naCByaWdodC1oYW5kIHNpZGUgaXMgdGhlIGZpcnN0IHdpdGggZWl0aGVyIGEgbm9ybXdpc2Ugb3IK\nICAgICAgICBjb21wb25lbnR3aXNlIGVycm9yIGJvdW5kIHRoYXQgaXMgbm90IGd1YXJhbnRlZWQg\nKHRoZSBzbWFsbGVzdAogICAgICAgIEogc3VjaCB0aGF0IGVpdGhlciBFUlJfQk5EU19OT1JNKEos\nMSkgPSAwLjAgb3IKICAgICAgICBFUlJfQk5EU19DT01QKEosMSkgPSAwLjApLiBTZWUgdGhlIGRl\nZmluaXRpb24gb2YKICAgICAgICBFUlJfQk5EU19OT1JNKDosMSkgYW5kIEVSUl9CTkRTX0NPTVAo\nOiwxKS4gVG8gZ2V0IGluZm9ybWF0aW9uCiAgICAgICAgYWJvdXQgYWxsIG9mIHRoZSByaWdodC1o\nYW5kIHNpZGVzIGNoZWNrIEVSUl9CTkRTX05PUk0gb3IKICAgICAgICBFUlJfQk5EU19DT01QLgpB\ndXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxp\nZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhv\nciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCByZWFsR0Vjb21wdXRhdGlv\nbmFsCmgdaB4pgXLPAQAAfXLQAQAAKGghiWgiaCN1YmgtigKbAWguWA8AAABzZ2VyZnN4XzQxMS50\neHR1YmgvigKbAWgwWAYAAABnZXJmc3hoLYoBNXViaBVoFl1oF4dSctEBAAB9ctIBAAAoaBpYBwAA\nAGdlbmVyYWxoG1gEAAAAZnVsbGgcWEYAAABlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9y\nIGVzdGltYXRlczsgaXRlcmF0aXZlIHJlZmluZW1lbnQ7IEVRVUVEaB1oHimBctMBAAB9ctQBAAAo\naCGJaCJoI3ViaCRYIQAAAERveHlnZW4vZG9jcy9odG1sL2RnZXJmc3hfOGYuaHRtbGglWAEAAABk\naCZoFWgnXWgXh1Jy1QEAAH1y1gEAAChoKlgAMwAAICAgREdFUkZTWCBpbXByb3ZlcyB0aGUgY29t\ncHV0ZWQgc29sdXRpb24gdG8gYSBzeXN0ZW0gb2YgbGluZWFyCiAgIGVxdWF0aW9ucyBhbmQgcHJv\ndmlkZXMgZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMKICAgZm9yIHRo\nZSBzb2x1dGlvbi4gIEluIGFkZGl0aW9uIHRvIG5vcm13aXNlIGVycm9yIGJvdW5kLCB0aGUgY29k\nZQogICBwcm92aWRlcyBtYXhpbXVtIGNvbXBvbmVudHdpc2UgZXJyb3IgYm91bmQgaWYgcG9zc2li\nbGUuICBTZWUKICAgY29tbWVudHMgZm9yIEVSUl9CTkRTX05PUk0gYW5kIEVSUl9CTkRTX0NPTVAg\nZm9yIGRldGFpbHMgb2YgdGhlCiAgIGVycm9yIGJvdW5kcy4KICAgVGhlIG9yaWdpbmFsIHN5c3Rl\nbSBvZiBsaW5lYXIgZXF1YXRpb25zIG1heSBoYXZlIGJlZW4gZXF1aWxpYnJhdGVkCiAgIGJlZm9y\nZSBjYWxsaW5nIHRoaXMgcm91dGluZSwgYXMgZGVzY3JpYmVkIGJ5IGFyZ3VtZW50cyBFUVVFRCwg\nUgogICBhbmQgQyBiZWxvdy4gSW4gdGhpcyBjYXNlLCB0aGUgc29sdXRpb24gYW5kIGVycm9yIGJv\ndW5kcyByZXR1cm5lZAogICBhcmUgZm9yIHRoZSBvcmlnaW5hbCB1bmVxdWlsaWJyYXRlZCBzeXN0\nZW0uCkFyZ3VtZW50czoKICAgIFNvbWUgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgYnVuZGxlZCBp\nbiB0aGUgUEFSQU1TIGFycmF5LiAgVGhlc2UKICAgIHNldHRpbmdzIGRldGVybWluZSBob3cgcmVm\naW5lbWVudCBpcyBwZXJmb3JtZWQsIGJ1dCBvZnRlbiB0aGUKICAgIGRlZmF1bHRzIGFyZSBhY2Nl\ncHRhYmxlLiAgSWYgdGhlIGRlZmF1bHRzIGFyZSBhY2NlcHRhYmxlLCB1c2VycwogICAgY2FuIHBh\nc3MgTlBBUkFNUyA9IDAgd2hpY2ggcHJldmVudHMgdGhlIHNvdXJjZSBjb2RlIGZyb20gYWNjZXNz\naW5nCiAgICB0aGUgUEFSQU1TIGFyZ3VtZW50LgpccGFyYW1baW5dIFRSQU5TCiAgICAgICAgIFRS\nQU5TIGlzIENIQVJBQ1RFUioxCiAgICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBv\nZiBlcXVhdGlvbnM6CiAgICAgID0gJ04nOiAgQSAqIFggPSBCICAgICAoTm8gdHJhbnNwb3NlKQog\nICAgICA9ICdUJzogIEEqKlQgKiBYID0gQiAgKFRyYW5zcG9zZSkKICAgICAgPSAnQyc6ICBBKipI\nICogWCA9IEIgIChDb25qdWdhdGUgdHJhbnNwb3NlID0gVHJhbnNwb3NlKQpccGFyYW1baW5dIEVR\nVUVECiAgICAgICAgIEVRVUVEIGlzIENIQVJBQ1RFUioxCiAgICBTcGVjaWZpZXMgdGhlIGZvcm0g\nb2YgZXF1aWxpYnJhdGlvbiB0aGF0IHdhcyBkb25lIHRvIEEKICAgIGJlZm9yZSBjYWxsaW5nIHRo\naXMgcm91dGluZS4gVGhpcyBpcyBuZWVkZWQgdG8gY29tcHV0ZQogICAgdGhlIHNvbHV0aW9uIGFu\nZCBlcnJvciBib3VuZHMgY29ycmVjdGx5LgogICAgICA9ICdOJzogIE5vIGVxdWlsaWJyYXRpb24K\nICAgICAgPSAnUic6ICBSb3cgZXF1aWxpYnJhdGlvbiwgaS5lLiwgQSBoYXMgYmVlbiBwcmVtdWx0\naXBsaWVkIGJ5CiAgICAgICAgICAgICAgZGlhZyhSKS4KICAgICAgPSAnQyc6ICBDb2x1bW4gZXF1\naWxpYnJhdGlvbiwgaS5lLiwgQSBoYXMgYmVlbiBwb3N0bXVsdGlwbGllZAogICAgICAgICAgICAg\nIGJ5IGRpYWcoQykuCiAgICAgID0gJ0InOiAgQm90aCByb3cgYW5kIGNvbHVtbiBlcXVpbGlicmF0\naW9uLCBpLmUuLCBBIGhhcyBiZWVuCiAgICAgICAgICAgICAgcmVwbGFjZWQgYnkgZGlhZyhSKSAq\nIEEgKiBkaWFnKEMpLgogICAgICAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgQiBoYXMgYmVl\nbiBjaGFuZ2VkIGFjY29yZGluZ2x5LgpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VS\nCiAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMK\nICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lk\nZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5k\nIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQQogICAgICAgICBBIGlzIERPVUJMRSBQUkVDSVNJ\nT04gYXJyYXksIGRpbWVuc2lvbiAoTERBLE4pCiAgICBUaGUgb3JpZ2luYWwgTi1ieS1OIG1hdHJp\neCBBLgpccGFyYW1baW5dIExEQQogICAgICAgICBMREEgaXMgSU5URUdFUgogICAgVGhlIGxlYWRp\nbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBLiAgTERBID49IG1heCgxLE4pLgpccGFyYW1baW5d\nIEFGCiAgICAgICAgIEFGIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTERB\nRixOKQogICAgVGhlIGZhY3RvcnMgTCBhbmQgVSBmcm9tIHRoZSBmYWN0b3JpemF0aW9uIEEgPSBQ\nKkwqVQogICAgYXMgY29tcHV0ZWQgYnkgREdFVFJGLgpccGFyYW1baW5dIExEQUYKICAgICAgICAg\nTERBRiBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFG\nLiAgTERBRiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBJUElWCiAgICAgICAgIElQSVYgaXMgSU5U\nRUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgVGhlIHBpdm90IGluZGljZXMgZnJvbSBER0VU\nUkY7IGZvciAxPD1pPD1OLCByb3cgaSBvZiB0aGUKICAgIG1hdHJpeCB3YXMgaW50ZXJjaGFuZ2Vk\nIHdpdGggcm93IElQSVYoaSkuClxwYXJhbVtpbl0gUgogICAgICAgICBSIGlzIERPVUJMRSBQUkVD\nSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTikKICAgIFRoZSByb3cgc2NhbGUgZmFjdG9ycyBmb3Ig\nQS4gIElmIEVRVUVEID0gJ1InIG9yICdCJywgQSBpcwogICAgbXVsdGlwbGllZCBvbiB0aGUgbGVm\ndCBieSBkaWFnKFIpOyBpZiBFUVVFRCA9ICdOJyBvciAnQycsIFIKICAgIGlzIG5vdCBhY2Nlc3Nl\nZC4gIAogICAgSWYgUiBpcyBhY2Nlc3NlZCwgZWFjaCBlbGVtZW50IG9mIFIgc2hvdWxkIGJlIGEg\ncG93ZXIgb2YgdGhlIHJhZGl4CiAgICB0byBlbnN1cmUgYSByZWxpYWJsZSBzb2x1dGlvbiBhbmQg\nZXJyb3IgZXN0aW1hdGVzLiBTY2FsaW5nIGJ5CiAgICBwb3dlcnMgb2YgdGhlIHJhZGl4IGRvZXMg\nbm90IGNhdXNlIHJvdW5kaW5nIGVycm9ycyB1bmxlc3MgdGhlCiAgICByZXN1bHQgdW5kZXJmbG93\ncyBvciBvdmVyZmxvd3MuIFJvdW5kaW5nIGVycm9ycyBkdXJpbmcgc2NhbGluZwogICAgbGVhZCB0\nbyByZWZpbmluZyB3aXRoIGEgbWF0cml4IHRoYXQgaXMgbm90IGVxdWl2YWxlbnQgdG8gdGhlCiAg\nICBpbnB1dCBtYXRyaXgsIHByb2R1Y2luZyBlcnJvciBlc3RpbWF0ZXMgdGhhdCBtYXkgbm90IGJl\nCiAgICByZWxpYWJsZS4KXHBhcmFtW2luXSBDCiAgICAgICAgIEMgaXMgRE9VQkxFIFBSRUNJU0lP\nTiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgVGhlIGNvbHVtbiBzY2FsZSBmYWN0b3JzIGZvciBB\nLiAgSWYgRVFVRUQgPSAnQycgb3IgJ0InLCBBIGlzCiAgICBtdWx0aXBsaWVkIG9uIHRoZSByaWdo\ndCBieSBkaWFnKEMpOyBpZiBFUVVFRCA9ICdOJyBvciAnUicsIEMKICAgIGlzIG5vdCBhY2Nlc3Nl\nZC4gCiAgICBJZiBDIGlzIGFjY2Vzc2VkLCBlYWNoIGVsZW1lbnQgb2YgQyBzaG91bGQgYmUgYSBw\nb3dlciBvZiB0aGUgcmFkaXgKICAgIHRvIGVuc3VyZSBhIHJlbGlhYmxlIHNvbHV0aW9uIGFuZCBl\ncnJvciBlc3RpbWF0ZXMuIFNjYWxpbmcgYnkKICAgIHBvd2VycyBvZiB0aGUgcmFkaXggZG9lcyBu\nb3QgY2F1c2Ugcm91bmRpbmcgZXJyb3JzIHVubGVzcyB0aGUKICAgIHJlc3VsdCB1bmRlcmZsb3dz\nIG9yIG92ZXJmbG93cy4gUm91bmRpbmcgZXJyb3JzIGR1cmluZyBzY2FsaW5nCiAgICBsZWFkIHRv\nIHJlZmluaW5nIHdpdGggYSBtYXRyaXggdGhhdCBpcyBub3QgZXF1aXZhbGVudCB0byB0aGUKICAg\nIGlucHV0IG1hdHJpeCwgcHJvZHVjaW5nIGVycm9yIGVzdGltYXRlcyB0aGF0IG1heSBub3QgYmUK\nICAgIHJlbGlhYmxlLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBET1VCTEUgUFJFQ0lTSU9O\nIGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRy\naXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVHRVIKICAgIFRoZSBsZWFk\naW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2lu\nLG91dF0gWAogICAgICAgICBYIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAo\nTERYLE5SSFMpCiAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21wdXRl\nZCBieSBER0VUUlMuCiAgICBPbiBleGl0LCB0aGUgaW1wcm92ZWQgc29sdXRpb24gbWF0cml4IFgu\nClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBk\naW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4KDEsTikuClxwYXJhbVtvdXRdIFJD\nT05ECiAgICAgICAgIFJDT05EIGlzIERPVUJMRSBQUkVDSVNJT04KICAgIFJlY2lwcm9jYWwgc2Nh\nbGVkIGNvbmRpdGlvbiBudW1iZXIuICBUaGlzIGlzIGFuIGVzdGltYXRlIG9mIHRoZQogICAgcmVj\naXByb2NhbCBTa2VlbCBjb25kaXRpb24gbnVtYmVyIG9mIHRoZSBtYXRyaXggQSBhZnRlcgogICAg\nZXF1aWxpYnJhdGlvbiAoaWYgZG9uZSkuICBJZiB0aGlzIGlzIGxlc3MgdGhhbiB0aGUgbWFjaGlu\nZQogICAgcHJlY2lzaW9uIChpbiBwYXJ0aWN1bGFyLCBpZiBpdCBpcyB6ZXJvKSwgdGhlIG1hdHJp\neCBpcyBzaW5ndWxhcgogICAgdG8gd29ya2luZyBwcmVjaXNpb24uICBOb3RlIHRoYXQgdGhlIGVy\ncm9yIG1heSBzdGlsbCBiZSBzbWFsbCBldmVuCiAgICBpZiB0aGlzIG51bWJlciBpcyB2ZXJ5IHNt\nYWxsIGFuZCB0aGUgbWF0cml4IGFwcGVhcnMgaWxsLQogICAgY29uZGl0aW9uZWQuClxwYXJhbVtv\ndXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNp\nb24gKE5SSFMpCiAgICBDb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yLiAgVGhp\ncyBpcyB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFj\naCBzb2x1dGlvbiB2ZWN0b3IgWChqKQogICAgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBj\naGFuZ2UgaW4gYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQKICAgIG1ha2VzIFgoaikgYW4gZXhh\nY3Qgc29sdXRpb24pLgpccGFyYW1baW5dIE5fRVJSX0JORFMKICAgICAgICAgTl9FUlJfQk5EUyBp\ncyBJTlRFR0VSCiAgICBOdW1iZXIgb2YgZXJyb3IgYm91bmRzIHRvIHJldHVybiBmb3IgZWFjaCBy\naWdodCBoYW5kIHNpZGUKICAgIGFuZCBlYWNoIHR5cGUgKG5vcm13aXNlIG9yIGNvbXBvbmVudHdp\nc2UpLiAgU2VlIEVSUl9CTkRTX05PUk0gYW5kCiAgICBFUlJfQk5EU19DT01QIGJlbG93LgpccGFy\nYW1bb3V0XSBFUlJfQk5EU19OT1JNCiAgICAgICAgIEVSUl9CTkRTX05PUk0gaXMgRE9VQkxFIFBS\nRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTLCBOX0VSUl9CTkRTKQogICAgRm9yIGVhY2gg\ncmlnaHQtaGFuZCBzaWRlLCB0aGlzIGFycmF5IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0CiAg\nICB2YXJpb3VzIGVycm9yIGJvdW5kcyBhbmQgY29uZGl0aW9uIG51bWJlcnMgY29ycmVzcG9uZGlu\nZyB0byB0aGUKICAgIG5vcm13aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFz\nIGZvbGxvd3M6CiAgICBOb3Jtd2lzZSByZWxhdGl2ZSBlcnJvciBpbiB0aGUgaXRoIHNvbHV0aW9u\nIHZlY3RvcjoKICAgICAgICAgICAgbWF4X2ogKGFicyhYVFJVRShqLGkpIC0gWChqLGkpKSkKICAg\nICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAgICBt\nYXhfaiBhYnMoWChqLGkpKQogICAgVGhlIGFycmF5IGlzIGluZGV4ZWQgYnkgdGhlIHR5cGUgb2Yg\nZXJyb3IgaW5mb3JtYXRpb24gYXMgZGVzY3JpYmVkCiAgICBiZWxvdy4gVGhlcmUgY3VycmVudGx5\nIGFyZSB1cCB0byB0aHJlZSBwaWVjZXMgb2YgaW5mb3JtYXRpb24KICAgIHJldHVybmVkLgogICAg\nVGhlIGZpcnN0IGluZGV4IGluIEVSUl9CTkRTX05PUk0oaSw6KSBjb3JyZXNwb25kcyB0byB0aGUg\naXRoCiAgICByaWdodC1oYW5kIHNpZGUuCiAgICBUaGUgc2Vjb25kIGluZGV4IGluIEVSUl9CTkRT\nX05PUk0oOixlcnIpIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcKICAgIHRocmVlIGZpZWxkczoKICAg\nIGVyciA9IDEgIlRydXN0L2Rvbid0IHRydXN0IiBib29sZWFuLiBUcnVzdCB0aGUgYW5zd2VyIGlm\nIHRoZQogICAgICAgICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyIGlzIGxlc3MgdGhh\nbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogZGxhbWNoKCdFcHNpbG9uJyku\nCiAgICBlcnIgPSAyICJHdWFyYW50ZWVkIiBlcnJvciBib3VuZDogVGhlIGVzdGltYXRlZCBmb3J3\nYXJkIGVycm9yLAogICAgICAgICAgICAgYWxtb3N0IGNlcnRhaW5seSB3aXRoaW4gYSBmYWN0b3Ig\nb2YgMTAgb2YgdGhlIHRydWUgZXJyb3IKICAgICAgICAgICAgIHNvIGxvbmcgYXMgdGhlIG5leHQg\nZW50cnkgaXMgZ3JlYXRlciB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikg\nKiBkbGFtY2goJ0Vwc2lsb24nKS4gVGhpcyBlcnJvciBib3VuZCBzaG91bGQgb25seQogICAgICAg\nICAgICAgYmUgdHJ1c3RlZCBpZiB0aGUgcHJldmlvdXMgYm9vbGVhbiBpcyB0cnVlLgogICAgZXJy\nID0gMyAgUmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyOiBFc3RpbWF0ZWQgbm9ybXdpc2UKICAg\nICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlci4gIENvbXBhcmVkIHdpdGggdGhl\nIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpIHRvIGRl\ndGVybWluZSBpZiB0aGUgZXJyb3IKICAgICAgICAgICAgIGVzdGltYXRlIGlzICJndWFyYW50ZWVk\nIi4gVGhlc2UgcmVjaXByb2NhbCBjb25kaXRpb24KICAgICAgICAgICAgIG51bWJlcnMgYXJlIDEg\nLyAobm9ybShaXnstMX0saW5mKSAqIG5vcm0oWixpbmYpKSBmb3Igc29tZQogICAgICAgICAgICAg\nYXBwcm9wcmlhdGVseSBzY2FsZWQgbWF0cml4IFouCiAgICAgICAgICAgICBMZXQgWiA9IFMqQSwg\nd2hlcmUgUyBzY2FsZXMgZWFjaCByb3cgYnkgYSBwb3dlciBvZiB0aGUKICAgICAgICAgICAgIHJh\nZGl4IHNvIGFsbCBhYnNvbHV0ZSByb3cgc3VtcyBvZiBaIGFyZSBhcHByb3hpbWF0ZWx5IDEuCiAg\nICBTZWUgTGFwYWNrIFdvcmtpbmcgTm90ZSAxNjUgZm9yIGZ1cnRoZXIgZGV0YWlscyBhbmQgZXh0\ncmEKICAgIGNhdXRpb25zLgpccGFyYW1bb3V0XSBFUlJfQk5EU19DT01QCiAgICAgICAgIEVSUl9C\nTkRTX0NPTVAgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTLCBOX0VS\nUl9CTkRTKQogICAgRm9yIGVhY2ggcmlnaHQtaGFuZCBzaWRlLCB0aGlzIGFycmF5IGNvbnRhaW5z\nIGluZm9ybWF0aW9uIGFib3V0CiAgICB2YXJpb3VzIGVycm9yIGJvdW5kcyBhbmQgY29uZGl0aW9u\nIG51bWJlcnMgY29ycmVzcG9uZGluZyB0byB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUg\nZXJyb3IsIHdoaWNoIGlzIGRlZmluZWQgYXMgZm9sbG93czoKICAgIENvbXBvbmVudHdpc2UgcmVs\nYXRpdmUgZXJyb3IgaW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAgICAgICAgICAgICAg\nICBhYnMoWFRSVUUoaixpKSAtIFgoaixpKSkKICAgICAgICAgICAgbWF4X2ogLS0tLS0tLS0tLS0t\nLS0tLS0tLS0tLQogICAgICAgICAgICAgICAgICAgICAgICBhYnMoWChqLGkpKQogICAgVGhlIGFy\ncmF5IGlzIGluZGV4ZWQgYnkgdGhlIHJpZ2h0LWhhbmQgc2lkZSBpIChvbiB3aGljaCB0aGUKICAg\nIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJyb3IgZGVwZW5kcyksIGFuZCB0aGUgdHlwZSBvZiBl\ncnJvcgogICAgaW5mb3JtYXRpb24gYXMgZGVzY3JpYmVkIGJlbG93LiBUaGVyZSBjdXJyZW50bHkg\nYXJlIHVwIHRvIHRocmVlCiAgICBwaWVjZXMgb2YgaW5mb3JtYXRpb24gcmV0dXJuZWQgZm9yIGVh\nY2ggcmlnaHQtaGFuZCBzaWRlLiBJZgogICAgY29tcG9uZW50d2lzZSBhY2N1cmFjeSBpcyBub3Qg\ncmVxdWVzdGVkIChQQVJBTVMoMykgPSAwLjApLCB0aGVuCiAgICBFUlJfQk5EU19DT01QIGlzIG5v\ndCBhY2Nlc3NlZC4gIElmIE5fRVJSX0JORFMgLkxULiAzLCB0aGVuIGF0IG1vc3QKICAgIHRoZSBm\naXJzdCAoOixOX0VSUl9CTkRTKSBlbnRyaWVzIGFyZSByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBp\nbmRleCBpbiBFUlJfQk5EU19DT01QKGksOikgY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmln\naHQtaGFuZCBzaWRlLgogICAgVGhlIHNlY29uZCBpbmRleCBpbiBFUlJfQk5EU19DT01QKDosZXJy\nKSBjb250YWlucyB0aGUgZm9sbG93aW5nCiAgICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJU\ncnVzdC9kb24ndCB0cnVzdCIgYm9vbGVhbi4gVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAg\nICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVz\naG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0g\nMiAiR3VhcmFudGVlZCIgZXJyb3IgYm91bmQ6IFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwK\nICAgICAgICAgICAgIGFsbW9zdCBjZXJ0YWlubHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRo\nZSB0cnVlIGVycm9yCiAgICAgICAgICAgICBzbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdy\nZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogZGxhbWNoKCdF\ncHNpbG9uJykuIFRoaXMgZXJyb3IgYm91bmQgc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRy\ndXN0ZWQgaWYgdGhlIHByZXZpb3VzIGJvb2xlYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lw\ncm9jYWwgY29uZGl0aW9uIG51bWJlcjogRXN0aW1hdGVkIGNvbXBvbmVudHdpc2UKICAgICAgICAg\nICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlci4gIENvbXBhcmVkIHdpdGggdGhlIHRocmVz\naG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpIHRvIGRldGVybWlu\nZSBpZiB0aGUgZXJyb3IKICAgICAgICAgICAgIGVzdGltYXRlIGlzICJndWFyYW50ZWVkIi4gVGhl\nc2UgcmVjaXByb2NhbCBjb25kaXRpb24KICAgICAgICAgICAgIG51bWJlcnMgYXJlIDEgLyAobm9y\nbShaXnstMX0saW5mKSAqIG5vcm0oWixpbmYpKSBmb3Igc29tZQogICAgICAgICAgICAgYXBwcm9w\ncmlhdGVseSBzY2FsZWQgbWF0cml4IFouCiAgICAgICAgICAgICBMZXQgWiA9IFMqKEEqZGlhZyh4\nKSksIHdoZXJlIHggaXMgdGhlIHNvbHV0aW9uIGZvciB0aGUKICAgICAgICAgICAgIGN1cnJlbnQg\ncmlnaHQtaGFuZCBzaWRlIGFuZCBTIHNjYWxlcyBlYWNoIHJvdyBvZgogICAgICAgICAgICAgQSpk\naWFnKHgpIGJ5IGEgcG93ZXIgb2YgdGhlIHJhZGl4IHNvIGFsbCBhYnNvbHV0ZSByb3cKICAgICAg\nICAgICAgIHN1bXMgb2YgWiBhcmUgYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFjayBXb3Jr\naW5nIE5vdGUgMTY1IGZvciBmdXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4K\nXHBhcmFtW2luXSBOUEFSQU1TCiAgICAgICAgIE5QQVJBTVMgaXMgSU5URUdFUgogICAgU3BlY2lm\naWVzIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycyBzZXQgaW4gUEFSQU1TLiAgSWYgLkxFLiAwLCB0\naGUKICAgIFBBUkFNUyBhcnJheSBpcyBuZXZlciByZWZlcmVuY2VkIGFuZCBkZWZhdWx0IHZhbHVl\ncyBhcmUgdXNlZC4KXHBhcmFtW2luLG91dF0gUEFSQU1TCiAgICAgICAgIFBBUkFNUyBpcyBET1VC\nTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5QQVJBTVMpCiAgICBTcGVjaWZpZXMgYWxn\nb3JpdGhtIHBhcmFtZXRlcnMuICBJZiBhbiBlbnRyeSBpcyAuTFQuIDAuMCwgdGhlbgogICAgdGhh\ndCBlbnRyeSB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlZmF1bHQgdmFsdWUgdXNlZCBmb3IgdGhhdAog\nICAgcGFyYW1ldGVyLiAgT25seSBwb3NpdGlvbnMgdXAgdG8gTlBBUkFNUyBhcmUgYWNjZXNzZWQ7\nIGRlZmF1bHRzCiAgICBhcmUgdXNlZCBmb3IgaGlnaGVyLW51bWJlcmVkIHBhcmFtZXRlcnMuCiAg\nICAgIFBBUkFNUyhMQV9MSU5SWF9JVFJFRl9JID0gMSkgOiBXaGV0aGVyIHRvIHBlcmZvcm0gaXRl\ncmF0aXZlCiAgICAgICAgICAgcmVmaW5lbWVudCBvciBub3QuCiAgICAgICAgRGVmYXVsdDogMS4w\nRCswCiAgICAgICAgICAgPSAwLjAgOiBObyByZWZpbmVtZW50IGlzIHBlcmZvcm1lZCwgYW5kIG5v\nIGVycm9yIGJvdW5kcyBhcmUKICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkLgogICAgICAgICAg\nID0gMS4wIDogVXNlIHRoZSBkb3VibGUtcHJlY2lzaW9uIHJlZmluZW1lbnQgYWxnb3JpdGhtLAog\nICAgICAgICAgICAgICAgICAgcG9zc2libHkgd2l0aCBkb3VibGVkLXNpbmdsZSBjb21wdXRhdGlv\nbnMgaWYgdGhlCiAgICAgICAgICAgICAgICAgICBjb21waWxhdGlvbiBlbnZpcm9ubWVudCBkb2Vz\nIG5vdCBzdXBwb3J0IERPVUJMRQogICAgICAgICAgICAgICAgICAgUFJFQ0lTSU9OLgogICAgICAg\nICAgICAgKG90aGVyIHZhbHVlcyBhcmUgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UpCiAgICAgIFBB\nUkFNUyhMQV9MSU5SWF9JVEhSRVNIX0kgPSAyKSA6IE1heGltdW0gbnVtYmVyIG9mIHJlc2lkdWFs\nCiAgICAgICAgICAgY29tcHV0YXRpb25zIGFsbG93ZWQgZm9yIHJlZmluZW1lbnQuCiAgICAgICAg\nRGVmYXVsdDogMTAKICAgICAgICBBZ2dyZXNzaXZlOiBTZXQgdG8gMTAwIHRvIHBlcm1pdCBjb252\nZXJnZW5jZSB1c2luZyBhcHByb3hpbWF0ZQogICAgICAgICAgICAgICAgICAgIGZhY3Rvcml6YXRp\nb25zIG9yIGZhY3Rvcml6YXRpb25zIG90aGVyIHRoYW4gTFUuIElmCiAgICAgICAgICAgICAgICAg\nICAgdGhlIGZhY3Rvcml6YXRpb24gdXNlcyBhIHRlY2huaXF1ZSBvdGhlciB0aGFuCiAgICAgICAg\nICAgICAgICAgICAgR2F1c3NpYW4gZWxpbWluYXRpb24sIHRoZSBndWFyYW50ZWVzIGluCiAgICAg\nICAgICAgICAgICAgICAgZXJyX2JuZHNfbm9ybSBhbmQgZXJyX2JuZHNfY29tcCBtYXkgbm8gbG9u\nZ2VyIGJlCiAgICAgICAgICAgICAgICAgICAgdHJ1c3R3b3J0aHkuCiAgICAgIFBBUkFNUyhMQV9M\nSU5SWF9DV0lTRV9JID0gMykgOiBGbGFnIGRldGVybWluaW5nIGlmIHRoZSBjb2RlCiAgICAgICAg\nICAgd2lsbCBhdHRlbXB0IHRvIGZpbmQgYSBzb2x1dGlvbiB3aXRoIHNtYWxsIGNvbXBvbmVudHdp\nc2UKICAgICAgICAgICByZWxhdGl2ZSBlcnJvciBpbiB0aGUgZG91YmxlLXByZWNpc2lvbiBhbGdv\ncml0aG0uICBQb3NpdGl2ZQogICAgICAgICAgIGlzIHRydWUsIDAuMCBpcyBmYWxzZS4KICAgICAg\nICBEZWZhdWx0OiAxLjAgKGF0dGVtcHQgY29tcG9uZW50d2lzZSBjb252ZXJnZW5jZSkKXHBhcmFt\nW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVu\nc2lvbiAoNCpOKQpccGFyYW1bb3V0XSBJV09SSwogICAgICAgICBJV09SSyBpcyBJTlRFR0VSIGFy\ncmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRdIElORk8KICAgICAgICAgSU5GTyBpcyBJTlRF\nR0VSCiAgICAgID0gMDogIFN1Y2Nlc3NmdWwgZXhpdC4gVGhlIHNvbHV0aW9uIHRvIGV2ZXJ5IHJp\nZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIGd1YXJhbnRlZWQuCiAgICAgIDwgMDogIElmIElORk8g\nPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKICAgICAgPiAwIGFu\nZCA8PSBOOiAgVShJTkZPLElORk8pIGlzIGV4YWN0bHkgemVyby4gIFRoZSBmYWN0b3JpemF0aW9u\nCiAgICAgICAgaGFzIGJlZW4gY29tcGxldGVkLCBidXQgdGhlIGZhY3RvciBVIGlzIGV4YWN0bHkg\nc2luZ3VsYXIsIHNvCiAgICAgICAgdGhlIHNvbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgY291bGQg\nbm90IGJlIGNvbXB1dGVkLiBSQ09ORCA9IDAKICAgICAgICBpcyByZXR1cm5lZC4KICAgICAgPSBO\nK0o6IFRoZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRl\nIGlzCiAgICAgICAgbm90IGd1YXJhbnRlZWQuIFRoZSBzb2x1dGlvbnMgY29ycmVzcG9uZGluZyB0\nbyBvdGhlciByaWdodC0KICAgICAgICBoYW5kIHNpZGVzIEsgd2l0aCBLID4gSiBtYXkgbm90IGJl\nIGd1YXJhbnRlZWQgYXMgd2VsbCwgYnV0CiAgICAgICAgb25seSB0aGUgZmlyc3Qgc3VjaCByaWdo\ndC1oYW5kIHNpZGUgaXMgcmVwb3J0ZWQuIElmIGEgc21hbGwKICAgICAgICBjb21wb25lbnR3aXNl\nIGVycm9yIGlzIG5vdCByZXF1ZXN0ZWQgKFBBUkFNUygzKSA9IDAuMCkgdGhlbgogICAgICAgIHRo\nZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzIHRoZSBmaXJzdCB3aXRoIGEgbm9ybXdpc2UgZXJyb3IK\nICAgICAgICBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50ZWVkICh0aGUgc21hbGxlc3QgSiBzdWNo\nCiAgICAgICAgdGhhdCBFUlJfQk5EU19OT1JNKEosMSkgPSAwLjApLiBCeSBkZWZhdWx0IChQQVJB\nTVMoMykgPSAxLjApCiAgICAgICAgdGhlIEp0aCByaWdodC1oYW5kIHNpZGUgaXMgdGhlIGZpcnN0\nIHdpdGggZWl0aGVyIGEgbm9ybXdpc2Ugb3IKICAgICAgICBjb21wb25lbnR3aXNlIGVycm9yIGJv\ndW5kIHRoYXQgaXMgbm90IGd1YXJhbnRlZWQgKHRoZSBzbWFsbGVzdAogICAgICAgIEogc3VjaCB0\naGF0IGVpdGhlciBFUlJfQk5EU19OT1JNKEosMSkgPSAwLjAgb3IKICAgICAgICBFUlJfQk5EU19D\nT01QKEosMSkgPSAwLjApLiBTZWUgdGhlIGRlZmluaXRpb24gb2YKICAgICAgICBFUlJfQk5EU19O\nT1JNKDosMSkgYW5kIEVSUl9CTkRTX0NPTVAoOiwxKS4gVG8gZ2V0IGluZm9ybWF0aW9uCiAgICAg\nICAgYWJvdXQgYWxsIG9mIHRoZSByaWdodC1oYW5kIHNpZGVzIGNoZWNrIEVSUl9CTkRTX05PUk0g\nb3IKICAgICAgICBFUlJfQk5EU19DT01QLgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5l\nc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYu\nIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgTm92ZW1iZXIgMjAx\nMQpcaW5ncm91cCBkb3VibGVHRWNvbXB1dGF0aW9uYWwKaB1oHimBctcBAAB9ctgBAAAoaCGJaCJo\nI3ViaC2KApwBaC5YDwAAAGRnZXJmc3hfNDEyLnR4dHViaC+KApwBaDBYBgAAAGdlcmZzeGgtigE2\ndWJoFWgWXWgXh1Jy2QEAAH1y2gEAAChoGlgHAAAAZ2VuZXJhbGgbWAQAAABmdWxsaBxYRgAAAGVy\ncm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5l\nbWVudDsgRVFVRURoHWgeKYFy2wEAAH1y3AEAAChoIYloImgjdWJoJFghAAAARG94eWdlbi9kb2Nz\nL2h0bWwvY2dlcmZzeF84Zi5odG1saCVYAQAAAGNoJmgVaCddaBeHUnLdAQAAfXLeAQAAKGgqWHky\nAAAgICBDR0VSRlNYIGltcHJvdmVzIHRoZSBjb21wdXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBv\nZiBsaW5lYXIKICAgZXF1YXRpb25zIGFuZCBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3\nYXJkIGVycm9yIGVzdGltYXRlcwogICBmb3IgdGhlIHNvbHV0aW9uLiAgSW4gYWRkaXRpb24gdG8g\nbm9ybXdpc2UgZXJyb3IgYm91bmQsIHRoZSBjb2RlCiAgIHByb3ZpZGVzIG1heGltdW0gY29tcG9u\nZW50d2lzZSBlcnJvciBib3VuZCBpZiBwb3NzaWJsZS4gIFNlZQogICBjb21tZW50cyBmb3IgRVJS\nX0JORFNfTk9STSBhbmQgRVJSX0JORFNfQ09NUCBmb3IgZGV0YWlscyBvZiB0aGUKICAgZXJyb3Ig\nYm91bmRzLgogICBUaGUgb3JpZ2luYWwgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgbWF5IGhh\ndmUgYmVlbiBlcXVpbGlicmF0ZWQKICAgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0aW5lLCBhcyBk\nZXNjcmliZWQgYnkgYXJndW1lbnRzIEVRVUVELCBSCiAgIGFuZCBDIGJlbG93LiBJbiB0aGlzIGNh\nc2UsIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIHJldHVybmVkCiAgIGFyZSBmb3IgdGhl\nIG9yaWdpbmFsIHVuZXF1aWxpYnJhdGVkIHN5c3RlbS4KQXJndW1lbnRzOgogICAgU29tZSBvcHRp\nb25hbCBwYXJhbWV0ZXJzIGFyZSBidW5kbGVkIGluIHRoZSBQQVJBTVMgYXJyYXkuICBUaGVzZQog\nICAgc2V0dGluZ3MgZGV0ZXJtaW5lIGhvdyByZWZpbmVtZW50IGlzIHBlcmZvcm1lZCwgYnV0IG9m\ndGVuIHRoZQogICAgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUuICBJZiB0aGUgZGVmYXVsdHMgYXJl\nIGFjY2VwdGFibGUsIHVzZXJzCiAgICBjYW4gcGFzcyBOUEFSQU1TID0gMCB3aGljaCBwcmV2ZW50\ncyB0aGUgc291cmNlIGNvZGUgZnJvbSBhY2Nlc3NpbmcKICAgIHRoZSBQQVJBTVMgYXJndW1lbnQu\nClxwYXJhbVtpbl0gVFJBTlMKICAgICAgICAgVFJBTlMgaXMgQ0hBUkFDVEVSKjEKICAgIFNwZWNp\nZmllcyB0aGUgZm9ybSBvZiB0aGUgc3lzdGVtIG9mIGVxdWF0aW9uczoKICAgICAgPSAnTic6ICBB\nICogWCA9IEIgICAgIChObyB0cmFuc3Bvc2UpCiAgICAgID0gJ1QnOiAgQSoqVCAqIFggPSBCICAo\nVHJhbnNwb3NlKQogICAgICA9ICdDJzogIEEqKkggKiBYID0gQiAgKENvbmp1Z2F0ZSB0cmFuc3Bv\nc2UgPSBUcmFuc3Bvc2UpClxwYXJhbVtpbl0gRVFVRUQKICAgICAgICAgRVFVRUQgaXMgQ0hBUkFD\nVEVSKjEKICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiBlcXVpbGlicmF0aW9uIHRoYXQgd2FzIGRv\nbmUgdG8gQQogICAgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0aW5lLiBUaGlzIGlzIG5lZWRlZCB0\nbyBjb21wdXRlCiAgICB0aGUgc29sdXRpb24gYW5kIGVycm9yIGJvdW5kcyBjb3JyZWN0bHkuCiAg\nICAgID0gJ04nOiAgTm8gZXF1aWxpYnJhdGlvbgogICAgICA9ICdSJzogIFJvdyBlcXVpbGlicmF0\naW9uLCBpLmUuLCBBIGhhcyBiZWVuIHByZW11bHRpcGxpZWQgYnkKICAgICAgICAgICAgICBkaWFn\nKFIpLgogICAgICA9ICdDJzogIENvbHVtbiBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBiZWVu\nIHBvc3RtdWx0aXBsaWVkCiAgICAgICAgICAgICAgYnkgZGlhZyhDKS4KICAgICAgPSAnQic6ICBC\nb3RoIHJvdyBhbmQgY29sdW1uIGVxdWlsaWJyYXRpb24sIGkuZS4sIEEgaGFzIGJlZW4KICAgICAg\nICAgICAgICByZXBsYWNlZCBieSBkaWFnKFIpICogQSAqIGRpYWcoQykuCiAgICAgICAgICAgICAg\nVGhlIHJpZ2h0IGhhbmQgc2lkZSBCIGhhcyBiZWVuIGNoYW5nZWQgYWNjb3JkaW5nbHkuClxwYXJh\nbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4\nIEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAg\nIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1\nbW5zCiAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBB\nCiAgICAgICAgIEEgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREEsTikKICAgIFRoZSBv\ncmlnaW5hbCBOLWJ5LU4gbWF0cml4IEEuClxwYXJhbVtpbl0gTERBCiAgICAgICAgIExEQSBpcyBJ\nTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEEuICBMREEgPj0g\nbWF4KDEsTikuClxwYXJhbVtpbl0gQUYKICAgICAgICAgQUYgaXMgQ09NUExFWCBhcnJheSwgZGlt\nZW5zaW9uIChMREFGLE4pCiAgICBUaGUgZmFjdG9ycyBMIGFuZCBVIGZyb20gdGhlIGZhY3Rvcml6\nYXRpb24gQSA9IFAqTCpVCiAgICBhcyBjb21wdXRlZCBieSBDR0VUUkYuClxwYXJhbVtpbl0gTERB\nRgogICAgICAgICBMREFGIGlzIElOVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0\naGUgYXJyYXkgQUYuICBMREFGID49IG1heCgxLE4pLgpccGFyYW1baW5dIElQSVYKICAgICAgICAg\nSVBJViBpcyBJTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICBUaGUgcGl2b3QgaW5kaWNl\ncyBmcm9tIENHRVRSRjsgZm9yIDE8PWk8PU4sIHJvdyBpIG9mIHRoZQogICAgbWF0cml4IHdhcyBp\nbnRlcmNoYW5nZWQgd2l0aCByb3cgSVBJVihpKS4KXHBhcmFtW2luXSBSCiAgICAgICAgIFIgaXMg\nUkVBTCBhcnJheSwgZGltZW5zaW9uIChOKQogICAgVGhlIHJvdyBzY2FsZSBmYWN0b3JzIGZvciBB\nLiAgSWYgRVFVRUQgPSAnUicgb3IgJ0InLCBBIGlzCiAgICBtdWx0aXBsaWVkIG9uIHRoZSBsZWZ0\nIGJ5IGRpYWcoUik7IGlmIEVRVUVEID0gJ04nIG9yICdDJywgUgogICAgaXMgbm90IGFjY2Vzc2Vk\nLiAKICAgIElmIFIgaXMgYWNjZXNzZWQsIGVhY2ggZWxlbWVudCBvZiBSIHNob3VsZCBiZSBhIHBv\nd2VyIG9mIHRoZSByYWRpeAogICAgdG8gZW5zdXJlIGEgcmVsaWFibGUgc29sdXRpb24gYW5kIGVy\ncm9yIGVzdGltYXRlcy4gU2NhbGluZyBieQogICAgcG93ZXJzIG9mIHRoZSByYWRpeCBkb2VzIG5v\ndCBjYXVzZSByb3VuZGluZyBlcnJvcnMgdW5sZXNzIHRoZQogICAgcmVzdWx0IHVuZGVyZmxvd3Mg\nb3Igb3ZlcmZsb3dzLiBSb3VuZGluZyBlcnJvcnMgZHVyaW5nIHNjYWxpbmcKICAgIGxlYWQgdG8g\ncmVmaW5pbmcgd2l0aCBhIG1hdHJpeCB0aGF0IGlzIG5vdCBlcXVpdmFsZW50IHRvIHRoZQogICAg\naW5wdXQgbWF0cml4LCBwcm9kdWNpbmcgZXJyb3IgZXN0aW1hdGVzIHRoYXQgbWF5IG5vdCBiZQog\nICAgcmVsaWFibGUuClxwYXJhbVtpbl0gQwogICAgICAgICBDIGlzIFJFQUwgYXJyYXksIGRpbWVu\nc2lvbiAoTikKICAgIFRoZSBjb2x1bW4gc2NhbGUgZmFjdG9ycyBmb3IgQS4gIElmIEVRVUVEID0g\nJ0MnIG9yICdCJywgQSBpcwogICAgbXVsdGlwbGllZCBvbiB0aGUgcmlnaHQgYnkgZGlhZyhDKTsg\naWYgRVFVRUQgPSAnTicgb3IgJ1InLCBDCiAgICBpcyBub3QgYWNjZXNzZWQuIAogICAgSWYgQyBp\ncyBhY2Nlc3NlZCwgZWFjaCBlbGVtZW50IG9mIEMgc2hvdWxkIGJlIGEgcG93ZXIgb2YgdGhlIHJh\nZGl4CiAgICB0byBlbnN1cmUgYSByZWxpYWJsZSBzb2x1dGlvbiBhbmQgZXJyb3IgZXN0aW1hdGVz\nLiBTY2FsaW5nIGJ5CiAgICBwb3dlcnMgb2YgdGhlIHJhZGl4IGRvZXMgbm90IGNhdXNlIHJvdW5k\naW5nIGVycm9ycyB1bmxlc3MgdGhlCiAgICByZXN1bHQgdW5kZXJmbG93cyBvciBvdmVyZmxvd3Mu\nIFJvdW5kaW5nIGVycm9ycyBkdXJpbmcgc2NhbGluZwogICAgbGVhZCB0byByZWZpbmluZyB3aXRo\nIGEgbWF0cml4IHRoYXQgaXMgbm90IGVxdWl2YWxlbnQgdG8gdGhlCiAgICBpbnB1dCBtYXRyaXgs\nIHByb2R1Y2luZyBlcnJvciBlc3RpbWF0ZXMgdGhhdCBtYXkgbm90IGJlCiAgICByZWxpYWJsZS4K\nXHBhcmFtW2luXSBCCiAgICAgICAgIEIgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREIs\nTlJIUykKICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAg\nICAgICAgIExEQiBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFy\ncmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBD\nT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgT24gZW50cnksIHRoZSBzb2x1\ndGlvbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgQ0dFVFJTLgogICAgT24gZXhpdCwgdGhlIGlt\ncHJvdmVkIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMg\nSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49\nIG1heCgxLE4pLgpccGFyYW1bb3V0XSBSQ09ORAogICAgICAgICBSQ09ORCBpcyBSRUFMCiAgICBS\nZWNpcHJvY2FsIHNjYWxlZCBjb25kaXRpb24gbnVtYmVyLiAgVGhpcyBpcyBhbiBlc3RpbWF0ZSBv\nZiB0aGUKICAgIHJlY2lwcm9jYWwgU2tlZWwgY29uZGl0aW9uIG51bWJlciBvZiB0aGUgbWF0cml4\nIEEgYWZ0ZXIKICAgIGVxdWlsaWJyYXRpb24gKGlmIGRvbmUpLiAgSWYgdGhpcyBpcyBsZXNzIHRo\nYW4gdGhlIG1hY2hpbmUKICAgIHByZWNpc2lvbiAoaW4gcGFydGljdWxhciwgaWYgaXQgaXMgemVy\nbyksIHRoZSBtYXRyaXggaXMgc2luZ3VsYXIKICAgIHRvIHdvcmtpbmcgcHJlY2lzaW9uLiAgTm90\nZSB0aGF0IHRoZSBlcnJvciBtYXkgc3RpbGwgYmUgc21hbGwgZXZlbgogICAgaWYgdGhpcyBudW1i\nZXIgaXMgdmVyeSBzbWFsbCBhbmQgdGhlIG1hdHJpeCBhcHBlYXJzIGlsbC0KICAgIGNvbmRpdGlv\nbmVkLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5z\naW9uIChOUkhTKQogICAgQ29tcG9uZW50d2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvci4gIFRo\naXMgaXMgdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVh\nY2ggc29sdXRpb24gdmVjdG9yIFgoaikKICAgIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUg\nY2hhbmdlIGluIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0CiAgICBtYWtlcyBYKGopIGFuIGV4\nYWN0IHNvbHV0aW9uKS4KXHBhcmFtW2luXSBOX0VSUl9CTkRTCiAgICAgICAgIE5fRVJSX0JORFMg\naXMgSU5URUdFUgogICAgTnVtYmVyIG9mIGVycm9yIGJvdW5kcyB0byByZXR1cm4gZm9yIGVhY2gg\ncmlnaHQgaGFuZCBzaWRlCiAgICBhbmQgZWFjaCB0eXBlIChub3Jtd2lzZSBvciBjb21wb25lbnR3\naXNlKS4gIFNlZSBFUlJfQk5EU19OT1JNIGFuZAogICAgRVJSX0JORFNfQ09NUCBiZWxvdy4KXHBh\ncmFtW291dF0gRVJSX0JORFNfTk9STQogICAgICAgICBFUlJfQk5EU19OT1JNIGlzIFJFQUwgYXJy\nYXksIGRpbWVuc2lvbiAoTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQg\nc2lkZSwgdGhpcyBhcnJheSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBl\ncnJvciBib3VuZHMgYW5kIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAg\nICBub3Jtd2lzZSByZWxhdGl2ZSBlcnJvciwgd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dzOgog\nICAgTm9ybXdpc2UgcmVsYXRpdmUgZXJyb3IgaW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAg\nICAgICAgICAgIG1heF9qIChhYnMoWFRSVUUoaixpKSAtIFgoaixpKSkpCiAgICAgICAgICAgLS0t\nLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgICAgICAgICAgICAgICAgbWF4X2ogYWJzKFgo\naixpKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSB0eXBlIG9mIGVycm9yIGluZm9y\nbWF0aW9uIGFzIGRlc2NyaWJlZAogICAgYmVsb3cuIFRoZXJlIGN1cnJlbnRseSBhcmUgdXAgdG8g\ndGhyZWUgcGllY2VzIG9mIGluZm9ybWF0aW9uCiAgICByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBp\nbmRleCBpbiBFUlJfQk5EU19OT1JNKGksOikgY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmln\naHQtaGFuZCBzaWRlLgogICAgVGhlIHNlY29uZCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKDosZXJy\nKSBjb250YWlucyB0aGUgZm9sbG93aW5nCiAgICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJU\ncnVzdC9kb24ndCB0cnVzdCIgYm9vbGVhbi4gVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAg\nICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVz\naG9sZAogICAgICAgICAgICAgc3FydChuKSAqIHNsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0g\nMiAiR3VhcmFudGVlZCIgZXJyb3IgYm91bmQ6IFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwK\nICAgICAgICAgICAgIGFsbW9zdCBjZXJ0YWlubHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRo\nZSB0cnVlIGVycm9yCiAgICAgICAgICAgICBzbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdy\nZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdF\ncHNpbG9uJykuIFRoaXMgZXJyb3IgYm91bmQgc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRy\ndXN0ZWQgaWYgdGhlIHByZXZpb3VzIGJvb2xlYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lw\ncm9jYWwgY29uZGl0aW9uIG51bWJlcjogRXN0aW1hdGVkIG5vcm13aXNlCiAgICAgICAgICAgICBy\nZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIuICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQK\nICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYg\ndGhlIGVycm9yCiAgICAgICAgICAgICBlc3RpbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJl\nY2lwcm9jYWwgY29uZGl0aW9uCiAgICAgICAgICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57\nLTF9LGluZikgKiBub3JtKFosaW5mKSkgZm9yIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRl\nbHkgc2NhbGVkIG1hdHJpeCBaLgogICAgICAgICAgICAgTGV0IFogPSBTKkEsIHdoZXJlIFMgc2Nh\nbGVzIGVhY2ggcm93IGJ5IGEgcG93ZXIgb2YgdGhlCiAgICAgICAgICAgICByYWRpeCBzbyBhbGwg\nYWJzb2x1dGUgcm93IHN1bXMgb2YgWiBhcmUgYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFj\nayBXb3JraW5nIE5vdGUgMTY1IGZvciBmdXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0\naW9ucy4KXHBhcmFtW291dF0gRVJSX0JORFNfQ09NUAogICAgICAgICBFUlJfQk5EU19DT01QIGlz\nIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJp\nZ2h0LWhhbmQgc2lkZSwgdGhpcyBhcnJheSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAg\ndmFyaW91cyBlcnJvciBib3VuZHMgYW5kIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcg\ndG8gdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVk\nIGFzIGZvbGxvd3M6CiAgICBDb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGluIHRoZSBpdGgg\nc29sdXRpb24gdmVjdG9yOgogICAgICAgICAgICAgICAgICAgYWJzKFhUUlVFKGosaSkgLSBYKGos\naSkpCiAgICAgICAgICAgIG1heF9qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAg\nICAgICAgICAgICAgYWJzKFgoaixpKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSBy\naWdodC1oYW5kIHNpZGUgaSAob24gd2hpY2ggdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZl\nIGVycm9yIGRlcGVuZHMpLCBhbmQgdGhlIHR5cGUgb2YgZXJyb3IKICAgIGluZm9ybWF0aW9uIGFz\nIGRlc2NyaWJlZCBiZWxvdy4gVGhlcmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZQogICAgcGll\nY2VzIG9mIGluZm9ybWF0aW9uIHJldHVybmVkIGZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZS4gSWYK\nICAgIGNvbXBvbmVudHdpc2UgYWNjdXJhY3kgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1TKDMpID0g\nMC4wKSwgdGhlbgogICAgRVJSX0JORFNfQ09NUCBpcyBub3QgYWNjZXNzZWQuICBJZiBOX0VSUl9C\nTkRTIC5MVC4gMywgdGhlbiBhdCBtb3N0CiAgICB0aGUgZmlyc3QgKDosTl9FUlJfQk5EUykgZW50\ncmllcyBhcmUgcmV0dXJuZWQuCiAgICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfQ09NUChp\nLDopIGNvcnJlc3BvbmRzIHRvIHRoZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBz\nZWNvbmQgaW5kZXggaW4gRVJSX0JORFNfQ09NUCg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2lu\nZwogICAgdGhyZWUgZmllbGRzOgogICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xl\nYW4uIFRydXN0IHRoZSBhbnN3ZXIgaWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRp\ndGlvbiBudW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQo\nbikgKiBzbGFtY2goJ0Vwc2lsb24nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJv\ndW5kOiBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2Vy\ndGFpbmx5IHdpdGhpbiBhIGZhY3RvciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAg\nICAgc28gbG9uZyBhcyB0aGUgbmV4dCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9s\nZAogICAgICAgICAgICAgc3FydChuKSAqIHNsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJv\ndW5kIHNob3VsZCBvbmx5CiAgICAgICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBi\nb29sZWFuIGlzIHRydWUuCiAgICBlcnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6\nIEVzdGltYXRlZCBjb21wb25lbnR3aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlv\nbiBudW1iZXIuICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQo\nbikgKiBzbGFtY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAg\nICAgICBlc3RpbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9u\nCiAgICAgICAgICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFos\naW5mKSkgZm9yIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBa\nLgogICAgICAgICAgICAgTGV0IFogPSBTKihBKmRpYWcoeCkpLCB3aGVyZSB4IGlzIHRoZSBzb2x1\ndGlvbiBmb3IgdGhlCiAgICAgICAgICAgICBjdXJyZW50IHJpZ2h0LWhhbmQgc2lkZSBhbmQgUyBz\nY2FsZXMgZWFjaCByb3cgb2YKICAgICAgICAgICAgIEEqZGlhZyh4KSBieSBhIHBvd2VyIG9mIHRo\nZSByYWRpeCBzbyBhbGwgYWJzb2x1dGUgcm93CiAgICAgICAgICAgICBzdW1zIG9mIFogYXJlIGFw\ncHJveGltYXRlbHkgMS4KICAgIFNlZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhl\nciBkZXRhaWxzIGFuZCBleHRyYQogICAgY2F1dGlvbnMuClxwYXJhbVtpbl0gTlBBUkFNUwogICAg\nICAgICBOUEFSQU1TIGlzIElOVEVHRVIKICAgIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHBhcmFt\nZXRlcnMgc2V0IGluIFBBUkFNUy4gIElmIC5MRS4gMCwgdGhlCiAgICBQQVJBTVMgYXJyYXkgaXMg\nbmV2ZXIgcmVmZXJlbmNlZCBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIHVzZWQuClxwYXJhbVtpbixv\ndXRdIFBBUkFNUwogICAgICAgICBQQVJBTVMgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIE5QQVJB\nTVMKICAgIFNwZWNpZmllcyBhbGdvcml0aG0gcGFyYW1ldGVycy4gIElmIGFuIGVudHJ5IGlzIC5M\nVC4gMC4wLCB0aGVuCiAgICB0aGF0IGVudHJ5IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVmYXVsdCB2\nYWx1ZSB1c2VkIGZvciB0aGF0CiAgICBwYXJhbWV0ZXIuICBPbmx5IHBvc2l0aW9ucyB1cCB0byBO\nUEFSQU1TIGFyZSBhY2Nlc3NlZDsgZGVmYXVsdHMKICAgIGFyZSB1c2VkIGZvciBoaWdoZXItbnVt\nYmVyZWQgcGFyYW1ldGVycy4KICAgICAgUEFSQU1TKExBX0xJTlJYX0lUUkVGX0kgPSAxKSA6IFdo\nZXRoZXIgdG8gcGVyZm9ybSBpdGVyYXRpdmUKICAgICAgICAgICByZWZpbmVtZW50IG9yIG5vdC4K\nICAgICAgICBEZWZhdWx0OiAxLjAKICAgICAgICAgICA9IDAuMCA6IE5vIHJlZmluZW1lbnQgaXMg\ncGVyZm9ybWVkLCBhbmQgbm8gZXJyb3IgYm91bmRzIGFyZQogICAgICAgICAgICAgICAgICAgY29t\ncHV0ZWQuCiAgICAgICAgICAgPSAxLjAgOiBVc2UgdGhlIGRvdWJsZS1wcmVjaXNpb24gcmVmaW5l\nbWVudCBhbGdvcml0aG0sCiAgICAgICAgICAgICAgICAgICBwb3NzaWJseSB3aXRoIGRvdWJsZWQt\nc2luZ2xlIGNvbXB1dGF0aW9ucyBpZiB0aGUKICAgICAgICAgICAgICAgICAgIGNvbXBpbGF0aW9u\nIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgRE9VQkxFCiAgICAgICAgICAgICAgICAgICBQ\nUkVDSVNJT04uCiAgICAgICAgICAgICAob3RoZXIgdmFsdWVzIGFyZSByZXNlcnZlZCBmb3IgZnV0\ndXJlIHVzZSkKICAgICAgUEFSQU1TKExBX0xJTlJYX0lUSFJFU0hfSSA9IDIpIDogTWF4aW11bSBu\ndW1iZXIgb2YgcmVzaWR1YWwKICAgICAgICAgICBjb21wdXRhdGlvbnMgYWxsb3dlZCBmb3IgcmVm\naW5lbWVudC4KICAgICAgICBEZWZhdWx0OiAxMAogICAgICAgIEFnZ3Jlc3NpdmU6IFNldCB0byAx\nMDAgdG8gcGVybWl0IGNvbnZlcmdlbmNlIHVzaW5nIGFwcHJveGltYXRlCiAgICAgICAgICAgICAg\nICAgICAgZmFjdG9yaXphdGlvbnMgb3IgZmFjdG9yaXphdGlvbnMgb3RoZXIgdGhhbiBMVS4gSWYK\nICAgICAgICAgICAgICAgICAgICB0aGUgZmFjdG9yaXphdGlvbiB1c2VzIGEgdGVjaG5pcXVlIG90\naGVyIHRoYW4KICAgICAgICAgICAgICAgICAgICBHYXVzc2lhbiBlbGltaW5hdGlvbiwgdGhlIGd1\nYXJhbnRlZXMgaW4KICAgICAgICAgICAgICAgICAgICBlcnJfYm5kc19ub3JtIGFuZCBlcnJfYm5k\nc19jb21wIG1heSBubyBsb25nZXIgYmUKICAgICAgICAgICAgICAgICAgICB0cnVzdHdvcnRoeS4K\nICAgICAgUEFSQU1TKExBX0xJTlJYX0NXSVNFX0kgPSAzKSA6IEZsYWcgZGV0ZXJtaW5pbmcgaWYg\ndGhlIGNvZGUKICAgICAgICAgICB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIHNvbHV0aW9uIHdpdGgg\nc21hbGwgY29tcG9uZW50d2lzZQogICAgICAgICAgIHJlbGF0aXZlIGVycm9yIGluIHRoZSBkb3Vi\nbGUtcHJlY2lzaW9uIGFsZ29yaXRobS4gIFBvc2l0aXZlCiAgICAgICAgICAgaXMgdHJ1ZSwgMC4w\nIGlzIGZhbHNlLgogICAgICAgIERlZmF1bHQ6IDEuMCAoYXR0ZW1wdCBjb21wb25lbnR3aXNlIGNv\nbnZlcmdlbmNlKQpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgQ09NUExFWCBhcnJh\neSwgZGltZW5zaW9uICgyKk4pClxwYXJhbVtvdXRdIFJXT1JLCiAgICAgICAgIFJXT1JLIGlzIFJF\nQUwgYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8g\naXMgSU5URUdFUgogICAgICA9IDA6ICBTdWNjZXNzZnVsIGV4aXQuIFRoZSBzb2x1dGlvbiB0byBl\ndmVyeSByaWdodC1oYW5kIHNpZGUgaXMKICAgICAgICBndWFyYW50ZWVkLgogICAgICA8IDA6ICBJ\nZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVlCiAgICAg\nID4gMCBhbmQgPD0gTjogIFUoSU5GTyxJTkZPKSBpcyBleGFjdGx5IHplcm8uICBUaGUgZmFjdG9y\naXphdGlvbgogICAgICAgIGhhcyBiZWVuIGNvbXBsZXRlZCwgYnV0IHRoZSBmYWN0b3IgVSBpcyBl\neGFjdGx5IHNpbmd1bGFyLCBzbwogICAgICAgIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRz\nIGNvdWxkIG5vdCBiZSBjb21wdXRlZC4gUkNPTkQgPSAwCiAgICAgICAgaXMgcmV0dXJuZWQuCiAg\nICAgID0gTitKOiBUaGUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgSnRoIHJpZ2h0LWhh\nbmQgc2lkZSBpcwogICAgICAgIG5vdCBndWFyYW50ZWVkLiBUaGUgc29sdXRpb25zIGNvcnJlc3Bv\nbmRpbmcgdG8gb3RoZXIgcmlnaHQtCiAgICAgICAgaGFuZCBzaWRlcyBLIHdpdGggSyA+IEogbWF5\nIG5vdCBiZSBndWFyYW50ZWVkIGFzIHdlbGwsIGJ1dAogICAgICAgIG9ubHkgdGhlIGZpcnN0IHN1\nY2ggcmlnaHQtaGFuZCBzaWRlIGlzIHJlcG9ydGVkLiBJZiBhIHNtYWxsCiAgICAgICAgY29tcG9u\nZW50d2lzZSBlcnJvciBpcyBub3QgcmVxdWVzdGVkIChQQVJBTVMoMykgPSAwLjApIHRoZW4KICAg\nICAgICB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcyB0aGUgZmlyc3Qgd2l0aCBhIG5vcm13aXNl\nIGVycm9yCiAgICAgICAgYm91bmQgdGhhdCBpcyBub3QgZ3VhcmFudGVlZCAodGhlIHNtYWxsZXN0\nIEogc3VjaAogICAgICAgIHRoYXQgRVJSX0JORFNfTk9STShKLDEpID0gMC4wKS4gQnkgZGVmYXVs\ndCAoUEFSQU1TKDMpID0gMS4wKQogICAgICAgIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzIHRo\nZSBmaXJzdCB3aXRoIGVpdGhlciBhIG5vcm13aXNlIG9yCiAgICAgICAgY29tcG9uZW50d2lzZSBl\ncnJvciBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50ZWVkICh0aGUgc21hbGxlc3QKICAgICAgICBK\nIHN1Y2ggdGhhdCBlaXRoZXIgRVJSX0JORFNfTk9STShKLDEpID0gMC4wIG9yCiAgICAgICAgRVJS\nX0JORFNfQ09NUChKLDEpID0gMC4wKS4gU2VlIHRoZSBkZWZpbml0aW9uIG9mCiAgICAgICAgRVJS\nX0JORFNfTk9STSg6LDEpIGFuZCBFUlJfQk5EU19DT01QKDosMSkuIFRvIGdldCBpbmZvcm1hdGlv\nbgogICAgICAgIGFib3V0IGFsbCBvZiB0aGUgcmlnaHQtaGFuZCBzaWRlcyBjaGVjayBFUlJfQk5E\nU19OT1JNIG9yCiAgICAgICAgRVJSX0JORFNfQ09NUC4KQXV0aG9yczoKXGF1dGhvciBVbml2LiBv\nZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBCZXJrZWxleSAKXGF1dGhv\nciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0ZC4gClxkYXRlIE5vdmVt\nYmVyIDIwMTEKXGluZ3JvdXAgY29tcGxleEdFY29tcHV0YXRpb25hbApoHWgeKYFy3wEAAH1y4AEA\nAChoIYloImgjdWJoLYoCnQFoLlgPAAAAY2dlcmZzeF80MTMudHh0dWJoL4oCnQFoMFgGAAAAZ2Vy\nZnN4aC2KATd1YmgVaBZdaBeHUnLhAQAAfXLiAQAAKGgaWAcAAABnZW5lcmFsaBtYBAAAAGZ1bGxo\nHFhGAAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2\nZSByZWZpbmVtZW50OyBFUVVFRGgdaB4pgXLjAQAAfXLkAQAAKGghiWgiaCN1YmgkWCEAAABEb3h5\nZ2VuL2RvY3MvaHRtbC96Z2VyZnN4XzhmLmh0bWxoJVgBAAAAemgmaBVoJ11oF4dScuUBAAB9cuYB\nAAAoaCpY7TIAACAgIFpHRVJGU1ggaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEg\nc3lzdGVtIG9mIGxpbmVhcgogICBlcXVhdGlvbnMgYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBh\nbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzCiAgIGZvciB0aGUgc29sdXRpb24uICBJbiBhZGRp\ndGlvbiB0byBub3Jtd2lzZSBlcnJvciBib3VuZCwgdGhlIGNvZGUKICAgcHJvdmlkZXMgbWF4aW11\nbSBjb21wb25lbnR3aXNlIGVycm9yIGJvdW5kIGlmIHBvc3NpYmxlLiAgU2VlCiAgIGNvbW1lbnRz\nIGZvciBFUlJfQk5EU19OT1JNIGFuZCBFUlJfQk5EU19DT01QIGZvciBkZXRhaWxzIG9mIHRoZQog\nICBlcnJvciBib3VuZHMuCiAgIFRoZSBvcmlnaW5hbCBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9u\ncyBtYXkgaGF2ZSBiZWVuIGVxdWlsaWJyYXRlZAogICBiZWZvcmUgY2FsbGluZyB0aGlzIHJvdXRp\nbmUsIGFzIGRlc2NyaWJlZCBieSBhcmd1bWVudHMgRVFVRUQsIFIKICAgYW5kIEMgYmVsb3cuIElu\nIHRoaXMgY2FzZSwgdGhlIHNvbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgcmV0dXJuZWQKICAgYXJl\nIGZvciB0aGUgb3JpZ2luYWwgdW5lcXVpbGlicmF0ZWQgc3lzdGVtLgpBcmd1bWVudHM6CiAgICBT\nb21lIG9wdGlvbmFsIHBhcmFtZXRlcnMgYXJlIGJ1bmRsZWQgaW4gdGhlIFBBUkFNUyBhcnJheS4g\nIFRoZXNlCiAgICBzZXR0aW5ncyBkZXRlcm1pbmUgaG93IHJlZmluZW1lbnQgaXMgcGVyZm9ybWVk\nLCBidXQgb2Z0ZW4gdGhlCiAgICBkZWZhdWx0cyBhcmUgYWNjZXB0YWJsZS4gIElmIHRoZSBkZWZh\ndWx0cyBhcmUgYWNjZXB0YWJsZSwgdXNlcnMKICAgIGNhbiBwYXNzIE5QQVJBTVMgPSAwIHdoaWNo\nIHByZXZlbnRzIHRoZSBzb3VyY2UgY29kZSBmcm9tIGFjY2Vzc2luZwogICAgdGhlIFBBUkFNUyBh\ncmd1bWVudC4KXHBhcmFtW2luXSBUUkFOUwogICAgICAgICBUUkFOUyBpcyBDSEFSQUNURVIqMQog\nICAgU3BlY2lmaWVzIHRoZSBmb3JtIG9mIHRoZSBzeXN0ZW0gb2YgZXF1YXRpb25zOgogICAgICA9\nICdOJzogIEEgKiBYID0gQiAgICAgKE5vIHRyYW5zcG9zZSkKICAgICAgPSAnVCc6ICBBKipUICog\nWCA9IEIgIChUcmFuc3Bvc2UpCiAgICAgID0gJ0MnOiAgQSoqSCAqIFggPSBCICAoQ29uanVnYXRl\nIHRyYW5zcG9zZSA9IFRyYW5zcG9zZSkKXHBhcmFtW2luXSBFUVVFRAogICAgICAgICBFUVVFRCBp\ncyBDSEFSQUNURVIqMQogICAgU3BlY2lmaWVzIHRoZSBmb3JtIG9mIGVxdWlsaWJyYXRpb24gdGhh\ndCB3YXMgZG9uZSB0byBBCiAgICBiZWZvcmUgY2FsbGluZyB0aGlzIHJvdXRpbmUuIFRoaXMgaXMg\nbmVlZGVkIHRvIGNvbXB1dGUKICAgIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIGNvcnJl\nY3RseS4KICAgICAgPSAnTic6ICBObyBlcXVpbGlicmF0aW9uCiAgICAgID0gJ1InOiAgUm93IGVx\ndWlsaWJyYXRpb24sIGkuZS4sIEEgaGFzIGJlZW4gcHJlbXVsdGlwbGllZCBieQogICAgICAgICAg\nICAgIGRpYWcoUikuCiAgICAgID0gJ0MnOiAgQ29sdW1uIGVxdWlsaWJyYXRpb24sIGkuZS4sIEEg\naGFzIGJlZW4gcG9zdG11bHRpcGxpZWQKICAgICAgICAgICAgICBieSBkaWFnKEMpLgogICAgICA9\nICdCJzogIEJvdGggcm93IGFuZCBjb2x1bW4gZXF1aWxpYnJhdGlvbiwgaS5lLiwgQSBoYXMgYmVl\nbgogICAgICAgICAgICAgIHJlcGxhY2VkIGJ5IGRpYWcoUikgKiBBICogZGlhZyhDKS4KICAgICAg\nICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIEIgaGFzIGJlZW4gY2hhbmdlZCBhY2NvcmRpbmds\neS4KXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgVGhlIG9yZGVyIG9mIHRo\nZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5U\nRUdFUgogICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVy\nIG9mIGNvbHVtbnMKICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFy\nYW1baW5dIEEKICAgICAgICAgQSBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQSxO\nKQogICAgVGhlIG9yaWdpbmFsIE4tYnktTiBtYXRyaXggQS4KXHBhcmFtW2luXSBMREEKICAgICAg\nICAgTERBIGlzIElOVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkg\nQS4gIExEQSA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBBRgogICAgICAgICBBRiBpcyBDT01QTEVY\nKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQUYsTikKICAgIFRoZSBmYWN0b3JzIEwgYW5kIFUgZnJv\nbSB0aGUgZmFjdG9yaXphdGlvbiBBID0gUCpMKlUKICAgIGFzIGNvbXB1dGVkIGJ5IFpHRVRSRi4K\nXHBhcmFtW2luXSBMREFGCiAgICAgICAgIExEQUYgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcg\nZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBRi4gIExEQUYgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0g\nSVBJVgogICAgICAgICBJUElWIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgIFRo\nZSBwaXZvdCBpbmRpY2VzIGZyb20gWkdFVFJGOyBmb3IgMTw9aTw9Tiwgcm93IGkgb2YgdGhlCiAg\nICBtYXRyaXggd2FzIGludGVyY2hhbmdlZCB3aXRoIHJvdyBJUElWKGkpLgpccGFyYW1baW5dIFIK\nICAgICAgICAgUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICBU\naGUgcm93IHNjYWxlIGZhY3RvcnMgZm9yIEEuICBJZiBFUVVFRCA9ICdSJyBvciAnQicsIEEgaXMK\nICAgIG11bHRpcGxpZWQgb24gdGhlIGxlZnQgYnkgZGlhZyhSKTsgaWYgRVFVRUQgPSAnTicgb3Ig\nJ0MnLCBSCiAgICBpcyBub3QgYWNjZXNzZWQuICAKICAgIElmIFIgaXMgYWNjZXNzZWQsIGVhY2gg\nZWxlbWVudCBvZiBSIHNob3VsZCBiZSBhIHBvd2VyIG9mIHRoZSByYWRpeAogICAgdG8gZW5zdXJl\nIGEgcmVsaWFibGUgc29sdXRpb24gYW5kIGVycm9yIGVzdGltYXRlcy4gU2NhbGluZyBieQogICAg\ncG93ZXJzIG9mIHRoZSByYWRpeCBkb2VzIG5vdCBjYXVzZSByb3VuZGluZyBlcnJvcnMgdW5sZXNz\nIHRoZQogICAgcmVzdWx0IHVuZGVyZmxvd3Mgb3Igb3ZlcmZsb3dzLiBSb3VuZGluZyBlcnJvcnMg\nZHVyaW5nIHNjYWxpbmcKICAgIGxlYWQgdG8gcmVmaW5pbmcgd2l0aCBhIG1hdHJpeCB0aGF0IGlz\nIG5vdCBlcXVpdmFsZW50IHRvIHRoZQogICAgaW5wdXQgbWF0cml4LCBwcm9kdWNpbmcgZXJyb3Ig\nZXN0aW1hdGVzIHRoYXQgbWF5IG5vdCBiZQogICAgcmVsaWFibGUuClxwYXJhbVtpbl0gQwogICAg\nICAgICBDIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTikKICAgIFRoZSBj\nb2x1bW4gc2NhbGUgZmFjdG9ycyBmb3IgQS4gIElmIEVRVUVEID0gJ0MnIG9yICdCJywgQSBpcwog\nICAgbXVsdGlwbGllZCBvbiB0aGUgcmlnaHQgYnkgZGlhZyhDKTsgaWYgRVFVRUQgPSAnTicgb3Ig\nJ1InLCBDCiAgICBpcyBub3QgYWNjZXNzZWQuCiAgICBJZiBDIGlzIGFjY2Vzc2VkLCBlYWNoIGVs\nZW1lbnQgb2YgQyBzaG91bGQgYmUgYSBwb3dlciBvZiB0aGUgcmFkaXgKICAgIHRvIGVuc3VyZSBh\nIHJlbGlhYmxlIHNvbHV0aW9uIGFuZCBlcnJvciBlc3RpbWF0ZXMuIFNjYWxpbmcgYnkKICAgIHBv\nd2VycyBvZiB0aGUgcmFkaXggZG9lcyBub3QgY2F1c2Ugcm91bmRpbmcgZXJyb3JzIHVubGVzcyB0\naGUKICAgIHJlc3VsdCB1bmRlcmZsb3dzIG9yIG92ZXJmbG93cy4gUm91bmRpbmcgZXJyb3JzIGR1\ncmluZyBzY2FsaW5nCiAgICBsZWFkIHRvIHJlZmluaW5nIHdpdGggYSBtYXRyaXggdGhhdCBpcyBu\nb3QgZXF1aXZhbGVudCB0byB0aGUKICAgIGlucHV0IG1hdHJpeCwgcHJvZHVjaW5nIGVycm9yIGVz\ndGltYXRlcyB0aGF0IG1heSBub3QgYmUKICAgIHJlbGlhYmxlLgpccGFyYW1baW5dIEIKICAgICAg\nICAgQiBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgVGhlIHJp\nZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElO\nVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBt\nYXgoMSxOKS4KXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIENPTVBMRVgqMTYgYXJyYXks\nIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBY\nLCBhcyBjb21wdXRlZCBieSBaR0VUUlMuCiAgICBPbiBleGl0LCB0aGUgaW1wcm92ZWQgc29sdXRp\nb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICBU\naGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4KDEsTikuClxw\nYXJhbVtvdXRdIFJDT05ECiAgICAgICAgIFJDT05EIGlzIERPVUJMRSBQUkVDSVNJT04KICAgIFJl\nY2lwcm9jYWwgc2NhbGVkIGNvbmRpdGlvbiBudW1iZXIuICBUaGlzIGlzIGFuIGVzdGltYXRlIG9m\nIHRoZQogICAgcmVjaXByb2NhbCBTa2VlbCBjb25kaXRpb24gbnVtYmVyIG9mIHRoZSBtYXRyaXgg\nQSBhZnRlcgogICAgZXF1aWxpYnJhdGlvbiAoaWYgZG9uZSkuICBJZiB0aGlzIGlzIGxlc3MgdGhh\nbiB0aGUgbWFjaGluZQogICAgcHJlY2lzaW9uIChpbiBwYXJ0aWN1bGFyLCBpZiBpdCBpcyB6ZXJv\nKSwgdGhlIG1hdHJpeCBpcyBzaW5ndWxhcgogICAgdG8gd29ya2luZyBwcmVjaXNpb24uICBOb3Rl\nIHRoYXQgdGhlIGVycm9yIG1heSBzdGlsbCBiZSBzbWFsbCBldmVuCiAgICBpZiB0aGlzIG51bWJl\nciBpcyB2ZXJ5IHNtYWxsIGFuZCB0aGUgbWF0cml4IGFwcGVhcnMgaWxsLQogICAgY29uZGl0aW9u\nZWQuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFy\ncmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICBDb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJk\nIGVycm9yLiAgVGhpcyBpcyB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQg\nZXJyb3Igb2YgZWFjaCBzb2x1dGlvbiB2ZWN0b3IgWChqKQogICAgKGkuZS4sIHRoZSBzbWFsbGVz\ndCByZWxhdGl2ZSBjaGFuZ2UgaW4gYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQKICAgIG1ha2Vz\nIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1baW5dIE5fRVJSX0JORFMKICAgICAgICAg\nTl9FUlJfQk5EUyBpcyBJTlRFR0VSCiAgICBOdW1iZXIgb2YgZXJyb3IgYm91bmRzIHRvIHJldHVy\nbiBmb3IgZWFjaCByaWdodCBoYW5kIHNpZGUKICAgIGFuZCBlYWNoIHR5cGUgKG5vcm13aXNlIG9y\nIGNvbXBvbmVudHdpc2UpLiAgU2VlIEVSUl9CTkRTX05PUk0gYW5kCiAgICBFUlJfQk5EU19DT01Q\nIGJlbG93LgpccGFyYW1bb3V0XSBFUlJfQk5EU19OT1JNCiAgICAgICAgIEVSUl9CTkRTX05PUk0g\naXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTLCBOX0VSUl9CTkRTKQog\nICAgRm9yIGVhY2ggcmlnaHQtaGFuZCBzaWRlLCB0aGlzIGFycmF5IGNvbnRhaW5zIGluZm9ybWF0\naW9uIGFib3V0CiAgICB2YXJpb3VzIGVycm9yIGJvdW5kcyBhbmQgY29uZGl0aW9uIG51bWJlcnMg\nY29ycmVzcG9uZGluZyB0byB0aGUKICAgIG5vcm13aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBp\ncyBkZWZpbmVkIGFzIGZvbGxvd3M6CiAgICBOb3Jtd2lzZSByZWxhdGl2ZSBlcnJvciBpbiB0aGUg\naXRoIHNvbHV0aW9uIHZlY3RvcjoKICAgICAgICAgICAgbWF4X2ogKGFicyhYVFJVRShqLGkpIC0g\nWChqLGkpKSkKICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAg\nICAgICAgICAgICBtYXhfaiBhYnMoWChqLGkpKQogICAgVGhlIGFycmF5IGlzIGluZGV4ZWQgYnkg\ndGhlIHR5cGUgb2YgZXJyb3IgaW5mb3JtYXRpb24gYXMgZGVzY3JpYmVkCiAgICBiZWxvdy4gVGhl\ncmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZSBwaWVjZXMgb2YgaW5mb3JtYXRpb24KICAgIHJl\ndHVybmVkLgogICAgVGhlIGZpcnN0IGluZGV4IGluIEVSUl9CTkRTX05PUk0oaSw6KSBjb3JyZXNw\nb25kcyB0byB0aGUgaXRoCiAgICByaWdodC1oYW5kIHNpZGUuCiAgICBUaGUgc2Vjb25kIGluZGV4\nIGluIEVSUl9CTkRTX05PUk0oOixlcnIpIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcKICAgIHRocmVl\nIGZpZWxkczoKICAgIGVyciA9IDEgIlRydXN0L2Rvbid0IHRydXN0IiBib29sZWFuLiBUcnVzdCB0\naGUgYW5zd2VyIGlmIHRoZQogICAgICAgICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVy\nIGlzIGxlc3MgdGhhbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogZGxhbWNo\nKCdFcHNpbG9uJykuCiAgICBlcnIgPSAyICJHdWFyYW50ZWVkIiBlcnJvciBib3VuZDogVGhlIGVz\ndGltYXRlZCBmb3J3YXJkIGVycm9yLAogICAgICAgICAgICAgYWxtb3N0IGNlcnRhaW5seSB3aXRo\naW4gYSBmYWN0b3Igb2YgMTAgb2YgdGhlIHRydWUgZXJyb3IKICAgICAgICAgICAgIHNvIGxvbmcg\nYXMgdGhlIG5leHQgZW50cnkgaXMgZ3JlYXRlciB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAg\nICAgIHNxcnQobikgKiBkbGFtY2goJ0Vwc2lsb24nKS4gVGhpcyBlcnJvciBib3VuZCBzaG91bGQg\nb25seQogICAgICAgICAgICAgYmUgdHJ1c3RlZCBpZiB0aGUgcHJldmlvdXMgYm9vbGVhbiBpcyB0\ncnVlLgogICAgZXJyID0gMyAgUmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyOiBFc3RpbWF0ZWQg\nbm9ybXdpc2UKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlci4gIENvbXBh\ncmVkIHdpdGggdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBz\naWxvbicpIHRvIGRldGVybWluZSBpZiB0aGUgZXJyb3IKICAgICAgICAgICAgIGVzdGltYXRlIGlz\nICJndWFyYW50ZWVkIi4gVGhlc2UgcmVjaXByb2NhbCBjb25kaXRpb24KICAgICAgICAgICAgIG51\nbWJlcnMgYXJlIDEgLyAobm9ybShaXnstMX0saW5mKSAqIG5vcm0oWixpbmYpKSBmb3Igc29tZQog\nICAgICAgICAgICAgYXBwcm9wcmlhdGVseSBzY2FsZWQgbWF0cml4IFouCiAgICAgICAgICAgICBM\nZXQgWiA9IFMqQSwgd2hlcmUgUyBzY2FsZXMgZWFjaCByb3cgYnkgYSBwb3dlciBvZiB0aGUKICAg\nICAgICAgICAgIHJhZGl4IHNvIGFsbCBhYnNvbHV0ZSByb3cgc3VtcyBvZiBaIGFyZSBhcHByb3hp\nbWF0ZWx5IDEuCiAgICBTZWUgTGFwYWNrIFdvcmtpbmcgTm90ZSAxNjUgZm9yIGZ1cnRoZXIgZGV0\nYWlscyBhbmQgZXh0cmEKICAgIGNhdXRpb25zLgpccGFyYW1bb3V0XSBFUlJfQk5EU19DT01QCiAg\nICAgICAgIEVSUl9CTkRTX0NPTVAgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9u\nIChOUkhTLCBOX0VSUl9CTkRTKQogICAgRm9yIGVhY2ggcmlnaHQtaGFuZCBzaWRlLCB0aGlzIGFy\ncmF5IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0CiAgICB2YXJpb3VzIGVycm9yIGJvdW5kcyBh\nbmQgY29uZGl0aW9uIG51bWJlcnMgY29ycmVzcG9uZGluZyB0byB0aGUKICAgIGNvbXBvbmVudHdp\nc2UgcmVsYXRpdmUgZXJyb3IsIHdoaWNoIGlzIGRlZmluZWQgYXMgZm9sbG93czoKICAgIENvbXBv\nbmVudHdpc2UgcmVsYXRpdmUgZXJyb3IgaW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAg\nICAgICAgICAgICAgICBhYnMoWFRSVUUoaixpKSAtIFgoaixpKSkKICAgICAgICAgICAgbWF4X2og\nLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICAgICAgICAgICAgICAgICAgICAgICBhYnMoWChqLGkp\nKQogICAgVGhlIGFycmF5IGlzIGluZGV4ZWQgYnkgdGhlIHJpZ2h0LWhhbmQgc2lkZSBpIChvbiB3\naGljaCB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJyb3IgZGVwZW5kcyksIGFuZCB0\naGUgdHlwZSBvZiBlcnJvcgogICAgaW5mb3JtYXRpb24gYXMgZGVzY3JpYmVkIGJlbG93LiBUaGVy\nZSBjdXJyZW50bHkgYXJlIHVwIHRvIHRocmVlCiAgICBwaWVjZXMgb2YgaW5mb3JtYXRpb24gcmV0\ndXJuZWQgZm9yIGVhY2ggcmlnaHQtaGFuZCBzaWRlLiBJZgogICAgY29tcG9uZW50d2lzZSBhY2N1\ncmFjeSBpcyBub3QgcmVxdWVzdGVkIChQQVJBTVMoMykgPSAwLjApLCB0aGVuCiAgICBFUlJfQk5E\nU19DT01QIGlzIG5vdCBhY2Nlc3NlZC4gIElmIE5fRVJSX0JORFMgLkxULiAzLCB0aGVuIGF0IG1v\nc3QKICAgIHRoZSBmaXJzdCAoOixOX0VSUl9CTkRTKSBlbnRyaWVzIGFyZSByZXR1cm5lZC4KICAg\nIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJfQk5EU19DT01QKGksOikgY29ycmVzcG9uZHMgdG8gdGhl\nIGl0aAogICAgcmlnaHQtaGFuZCBzaWRlLgogICAgVGhlIHNlY29uZCBpbmRleCBpbiBFUlJfQk5E\nU19DT01QKDosZXJyKSBjb250YWlucyB0aGUgZm9sbG93aW5nCiAgICB0aHJlZSBmaWVsZHM6CiAg\nICBlcnIgPSAxICJUcnVzdC9kb24ndCB0cnVzdCIgYm9vbGVhbi4gVHJ1c3QgdGhlIGFuc3dlciBp\nZiB0aGUKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlciBpcyBsZXNzIHRo\nYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicp\nLgogICAgZXJyID0gMiAiR3VhcmFudGVlZCIgZXJyb3IgYm91bmQ6IFRoZSBlc3RpbWF0ZWQgZm9y\nd2FyZCBlcnJvciwKICAgICAgICAgICAgIGFsbW9zdCBjZXJ0YWlubHkgd2l0aGluIGEgZmFjdG9y\nIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9yCiAgICAgICAgICAgICBzbyBsb25nIGFzIHRoZSBuZXh0\nIGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4p\nICogZGxhbWNoKCdFcHNpbG9uJykuIFRoaXMgZXJyb3IgYm91bmQgc2hvdWxkIG9ubHkKICAgICAg\nICAgICAgIGJlIHRydXN0ZWQgaWYgdGhlIHByZXZpb3VzIGJvb2xlYW4gaXMgdHJ1ZS4KICAgIGVy\nciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlcjogRXN0aW1hdGVkIGNvbXBvbmVudHdp\nc2UKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlci4gIENvbXBhcmVkIHdp\ndGggdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicp\nIHRvIGRldGVybWluZSBpZiB0aGUgZXJyb3IKICAgICAgICAgICAgIGVzdGltYXRlIGlzICJndWFy\nYW50ZWVkIi4gVGhlc2UgcmVjaXByb2NhbCBjb25kaXRpb24KICAgICAgICAgICAgIG51bWJlcnMg\nYXJlIDEgLyAobm9ybShaXnstMX0saW5mKSAqIG5vcm0oWixpbmYpKSBmb3Igc29tZQogICAgICAg\nICAgICAgYXBwcm9wcmlhdGVseSBzY2FsZWQgbWF0cml4IFouCiAgICAgICAgICAgICBMZXQgWiA9\nIFMqKEEqZGlhZyh4KSksIHdoZXJlIHggaXMgdGhlIHNvbHV0aW9uIGZvciB0aGUKICAgICAgICAg\nICAgIGN1cnJlbnQgcmlnaHQtaGFuZCBzaWRlIGFuZCBTIHNjYWxlcyBlYWNoIHJvdyBvZgogICAg\nICAgICAgICAgQSpkaWFnKHgpIGJ5IGEgcG93ZXIgb2YgdGhlIHJhZGl4IHNvIGFsbCBhYnNvbHV0\nZSByb3cKICAgICAgICAgICAgIHN1bXMgb2YgWiBhcmUgYXBwcm94aW1hdGVseSAxLgogICAgU2Vl\nIExhcGFjayBXb3JraW5nIE5vdGUgMTY1IGZvciBmdXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAg\nICBjYXV0aW9ucy4KXHBhcmFtW2luXSBOUEFSQU1TCiAgICAgICAgIE5QQVJBTVMgaXMgSU5URUdF\nUgogICAgU3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycyBzZXQgaW4gUEFSQU1TLiAg\nSWYgLkxFLiAwLCB0aGUKICAgIFBBUkFNUyBhcnJheSBpcyBuZXZlciByZWZlcmVuY2VkIGFuZCBk\nZWZhdWx0IHZhbHVlcyBhcmUgdXNlZC4KXHBhcmFtW2luLG91dF0gUEFSQU1TCiAgICAgICAgIFBB\nUkFNUyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gTlBBUkFNUwogICAgU3Bl\nY2lmaWVzIGFsZ29yaXRobSBwYXJhbWV0ZXJzLiAgSWYgYW4gZW50cnkgaXMgLkxULiAwLjAsIHRo\nZW4KICAgIHRoYXQgZW50cnkgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZWZhdWx0IHZhbHVlIHVzZWQg\nZm9yIHRoYXQKICAgIHBhcmFtZXRlci4gIE9ubHkgcG9zaXRpb25zIHVwIHRvIE5QQVJBTVMgYXJl\nIGFjY2Vzc2VkOyBkZWZhdWx0cwogICAgYXJlIHVzZWQgZm9yIGhpZ2hlci1udW1iZXJlZCBwYXJh\nbWV0ZXJzLgogICAgICBQQVJBTVMoTEFfTElOUlhfSVRSRUZfSSA9IDEpIDogV2hldGhlciB0byBw\nZXJmb3JtIGl0ZXJhdGl2ZQogICAgICAgICAgIHJlZmluZW1lbnQgb3Igbm90LgogICAgICAgIERl\nZmF1bHQ6IDEuMEQrMAogICAgICAgICAgID0gMC4wIDogTm8gcmVmaW5lbWVudCBpcyBwZXJmb3Jt\nZWQsIGFuZCBubyBlcnJvciBib3VuZHMgYXJlCiAgICAgICAgICAgICAgICAgICBjb21wdXRlZC4K\nICAgICAgICAgICA9IDEuMCA6IFVzZSB0aGUgZG91YmxlLXByZWNpc2lvbiByZWZpbmVtZW50IGFs\nZ29yaXRobSwKICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5IHdpdGggZG91YmxlZC1zaW5nbGUg\nY29tcHV0YXRpb25zIGlmIHRoZQogICAgICAgICAgICAgICAgICAgY29tcGlsYXRpb24gZW52aXJv\nbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBET1VCTEUKICAgICAgICAgICAgICAgICAgIFBSRUNJU0lP\nTi4KICAgICAgICAgICAgIChvdGhlciB2YWx1ZXMgYXJlIHJlc2VydmVkIGZvciBmdXR1cmUgdXNl\nKQogICAgICBQQVJBTVMoTEFfTElOUlhfSVRIUkVTSF9JID0gMikgOiBNYXhpbXVtIG51bWJlciBv\nZiByZXNpZHVhbAogICAgICAgICAgIGNvbXB1dGF0aW9ucyBhbGxvd2VkIGZvciByZWZpbmVtZW50\nLgogICAgICAgIERlZmF1bHQ6IDEwCiAgICAgICAgQWdncmVzc2l2ZTogU2V0IHRvIDEwMCB0byBw\nZXJtaXQgY29udmVyZ2VuY2UgdXNpbmcgYXBwcm94aW1hdGUKICAgICAgICAgICAgICAgICAgICBm\nYWN0b3JpemF0aW9ucyBvciBmYWN0b3JpemF0aW9ucyBvdGhlciB0aGFuIExVLiBJZgogICAgICAg\nICAgICAgICAgICAgIHRoZSBmYWN0b3JpemF0aW9uIHVzZXMgYSB0ZWNobmlxdWUgb3RoZXIgdGhh\nbgogICAgICAgICAgICAgICAgICAgIEdhdXNzaWFuIGVsaW1pbmF0aW9uLCB0aGUgZ3VhcmFudGVl\ncyBpbgogICAgICAgICAgICAgICAgICAgIGVycl9ibmRzX25vcm0gYW5kIGVycl9ibmRzX2NvbXAg\nbWF5IG5vIGxvbmdlciBiZQogICAgICAgICAgICAgICAgICAgIHRydXN0d29ydGh5LgogICAgICBQ\nQVJBTVMoTEFfTElOUlhfQ1dJU0VfSSA9IDMpIDogRmxhZyBkZXRlcm1pbmluZyBpZiB0aGUgY29k\nZQogICAgICAgICAgIHdpbGwgYXR0ZW1wdCB0byBmaW5kIGEgc29sdXRpb24gd2l0aCBzbWFsbCBj\nb21wb25lbnR3aXNlCiAgICAgICAgICAgcmVsYXRpdmUgZXJyb3IgaW4gdGhlIGRvdWJsZS1wcmVj\naXNpb24gYWxnb3JpdGhtLiAgUG9zaXRpdmUKICAgICAgICAgICBpcyB0cnVlLCAwLjAgaXMgZmFs\nc2UuCiAgICAgICAgRGVmYXVsdDogMS4wIChhdHRlbXB0IGNvbXBvbmVudHdpc2UgY29udmVyZ2Vu\nY2UpClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBDT01QTEVYKjE2IGFycmF5LCBk\naW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0gUldPUksKICAgICAgICAgUldPUksgaXMgRE9VQkxF\nIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uICgyKk4pClxwYXJhbVtvdXRdIElORk8KICAgICAg\nICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgID0gMDogIFN1Y2Nlc3NmdWwgZXhpdC4gVGhlIHNvbHV0\naW9uIHRvIGV2ZXJ5IHJpZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIGd1YXJhbnRlZWQuCiAgICAg\nIDwgMDogIElmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFs\ndWUKICAgICAgPiAwIGFuZCA8PSBOOiAgVShJTkZPLElORk8pIGlzIGV4YWN0bHkgemVyby4gIFRo\nZSBmYWN0b3JpemF0aW9uCiAgICAgICAgaGFzIGJlZW4gY29tcGxldGVkLCBidXQgdGhlIGZhY3Rv\nciBVIGlzIGV4YWN0bHkgc2luZ3VsYXIsIHNvCiAgICAgICAgdGhlIHNvbHV0aW9uIGFuZCBlcnJv\nciBib3VuZHMgY291bGQgbm90IGJlIGNvbXB1dGVkLiBSQ09ORCA9IDAKICAgICAgICBpcyByZXR1\ncm5lZC4KICAgICAgPSBOK0o6IFRoZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBKdGgg\ncmlnaHQtaGFuZCBzaWRlIGlzCiAgICAgICAgbm90IGd1YXJhbnRlZWQuIFRoZSBzb2x1dGlvbnMg\nY29ycmVzcG9uZGluZyB0byBvdGhlciByaWdodC0KICAgICAgICBoYW5kIHNpZGVzIEsgd2l0aCBL\nID4gSiBtYXkgbm90IGJlIGd1YXJhbnRlZWQgYXMgd2VsbCwgYnV0CiAgICAgICAgb25seSB0aGUg\nZmlyc3Qgc3VjaCByaWdodC1oYW5kIHNpZGUgaXMgcmVwb3J0ZWQuIElmIGEgc21hbGwKICAgICAg\nICBjb21wb25lbnR3aXNlIGVycm9yIGlzIG5vdCByZXF1ZXN0ZWQgKFBBUkFNUygzKSA9IDAuMCkg\ndGhlbgogICAgICAgIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzIHRoZSBmaXJzdCB3aXRoIGEg\nbm9ybXdpc2UgZXJyb3IKICAgICAgICBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50ZWVkICh0aGUg\nc21hbGxlc3QgSiBzdWNoCiAgICAgICAgdGhhdCBFUlJfQk5EU19OT1JNKEosMSkgPSAwLjApLiBC\neSBkZWZhdWx0IChQQVJBTVMoMykgPSAxLjApCiAgICAgICAgdGhlIEp0aCByaWdodC1oYW5kIHNp\nZGUgaXMgdGhlIGZpcnN0IHdpdGggZWl0aGVyIGEgbm9ybXdpc2Ugb3IKICAgICAgICBjb21wb25l\nbnR3aXNlIGVycm9yIGJvdW5kIHRoYXQgaXMgbm90IGd1YXJhbnRlZWQgKHRoZSBzbWFsbGVzdAog\nICAgICAgIEogc3VjaCB0aGF0IGVpdGhlciBFUlJfQk5EU19OT1JNKEosMSkgPSAwLjAgb3IKICAg\nICAgICBFUlJfQk5EU19DT01QKEosMSkgPSAwLjApLiBTZWUgdGhlIGRlZmluaXRpb24gb2YKICAg\nICAgICBFUlJfQk5EU19OT1JNKDosMSkgYW5kIEVSUl9CTkRTX0NPTVAoOiwxKS4gVG8gZ2V0IGlu\nZm9ybWF0aW9uCiAgICAgICAgYWJvdXQgYWxsIG9mIHRoZSByaWdodC1oYW5kIHNpZGVzIGNoZWNr\nIEVSUl9CTkRTX05PUk0gb3IKICAgICAgICBFUlJfQk5EU19DT01QLgpBdXRob3JzOgpcYXV0aG9y\nIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5\nIApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRh\ndGUgTm92ZW1iZXIgMjAxMQpcaW5ncm91cCBjb21wbGV4MTZHRWNvbXB1dGF0aW9uYWwKaB1oHimB\ncucBAAB9cugBAAAoaCGJaCJoI3ViaC2KAp4BaC5YDwAAAHpnZXJmc3hfNDE0LnR4dHViaC+KAp4B\naDBYBgAAAGdlcmZzeGgtigE4dWJoFWgWXWgXh1Jy6QEAAH1y6gEAAChoGlgHAAAAZ2VuZXJhbGgb\nWAQAAABiYW5kaBxYRgAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVz\nOyBpdGVyYXRpdmUgcmVmaW5lbWVudDsgRVFVRURoHWgeKYFy6wEAAH1y7AEAAChoIYloImgjdWJo\nJFghAAAARG94eWdlbi9kb2NzL2h0bWwvc2dicmZzeF84Zi5odG1saCVYAQAAAHNoJmgVaCddaBeH\nUnLtAQAAfXLuAQAAKGgqWIU2AAAgICBTR0JSRlNYIGltcHJvdmVzIHRoZSBjb21wdXRlZCBzb2x1\ndGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKICAgZXF1YXRpb25zIGFuZCBwcm92aWRlcyBlcnJv\nciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcwogICBmb3IgdGhlIHNvbHV0aW9u\nLiAgSW4gYWRkaXRpb24gdG8gbm9ybXdpc2UgZXJyb3IgYm91bmQsIHRoZSBjb2RlCiAgIHByb3Zp\nZGVzIG1heGltdW0gY29tcG9uZW50d2lzZSBlcnJvciBib3VuZCBpZiBwb3NzaWJsZS4gIFNlZQog\nICBjb21tZW50cyBmb3IgRVJSX0JORFNfTk9STSBhbmQgRVJSX0JORFNfQ09NUCBmb3IgZGV0YWls\ncyBvZiB0aGUKICAgZXJyb3IgYm91bmRzLgogICBUaGUgb3JpZ2luYWwgc3lzdGVtIG9mIGxpbmVh\nciBlcXVhdGlvbnMgbWF5IGhhdmUgYmVlbiBlcXVpbGlicmF0ZWQKICAgYmVmb3JlIGNhbGxpbmcg\ndGhpcyByb3V0aW5lLCBhcyBkZXNjcmliZWQgYnkgYXJndW1lbnRzIEVRVUVELCBSCiAgIGFuZCBD\nIGJlbG93LiBJbiB0aGlzIGNhc2UsIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIHJldHVy\nbmVkCiAgIGFyZSBmb3IgdGhlIG9yaWdpbmFsIHVuZXF1aWxpYnJhdGVkIHN5c3RlbS4KQXJndW1l\nbnRzOgogICAgU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzIGFyZSBidW5kbGVkIGluIHRoZSBQQVJB\nTVMgYXJyYXkuICBUaGVzZQogICAgc2V0dGluZ3MgZGV0ZXJtaW5lIGhvdyByZWZpbmVtZW50IGlz\nIHBlcmZvcm1lZCwgYnV0IG9mdGVuIHRoZQogICAgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUuICBJ\nZiB0aGUgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUsIHVzZXJzCiAgICBjYW4gcGFzcyBOUEFSQU1T\nID0gMCB3aGljaCBwcmV2ZW50cyB0aGUgc291cmNlIGNvZGUgZnJvbSBhY2Nlc3NpbmcKICAgIHRo\nZSBQQVJBTVMgYXJndW1lbnQuClxwYXJhbVtpbl0gVFJBTlMKICAgICAgICAgVFJBTlMgaXMgQ0hB\nUkFDVEVSKjEKICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiB0aGUgc3lzdGVtIG9mIGVxdWF0aW9u\nczoKICAgICAgPSAnTic6ICBBICogWCA9IEIgICAgIChObyB0cmFuc3Bvc2UpCiAgICAgID0gJ1Qn\nOiAgQSoqVCAqIFggPSBCICAoVHJhbnNwb3NlKQogICAgICA9ICdDJzogIEEqKkggKiBYID0gQiAg\nKENvbmp1Z2F0ZSB0cmFuc3Bvc2UgPSBUcmFuc3Bvc2UpClxwYXJhbVtpbl0gRVFVRUQKICAgICAg\nICAgRVFVRUQgaXMgQ0hBUkFDVEVSKjEKICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiBlcXVpbGli\ncmF0aW9uIHRoYXQgd2FzIGRvbmUgdG8gQQogICAgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0aW5l\nLiBUaGlzIGlzIG5lZWRlZCB0byBjb21wdXRlCiAgICB0aGUgc29sdXRpb24gYW5kIGVycm9yIGJv\ndW5kcyBjb3JyZWN0bHkuCiAgICAgID0gJ04nOiAgTm8gZXF1aWxpYnJhdGlvbgogICAgICA9ICdS\nJzogIFJvdyBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBiZWVuIHByZW11bHRpcGxpZWQgYnkK\nICAgICAgICAgICAgICBkaWFnKFIpLgogICAgICA9ICdDJzogIENvbHVtbiBlcXVpbGlicmF0aW9u\nLCBpLmUuLCBBIGhhcyBiZWVuIHBvc3RtdWx0aXBsaWVkCiAgICAgICAgICAgICAgYnkgZGlhZyhD\nKS4KICAgICAgPSAnQic6ICBCb3RoIHJvdyBhbmQgY29sdW1uIGVxdWlsaWJyYXRpb24sIGkuZS4s\nIEEgaGFzIGJlZW4KICAgICAgICAgICAgICByZXBsYWNlZCBieSBkaWFnKFIpICogQSAqIGRpYWco\nQykuCiAgICAgICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBCIGhhcyBiZWVuIGNoYW5nZWQg\nYWNjb3JkaW5nbHkuClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAgIFRoZSBv\ncmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gS0wKICAgICAgICAgS0wg\naXMgSU5URUdFUgogICAgVGhlIG51bWJlciBvZiBzdWJkaWFnb25hbHMgd2l0aGluIHRoZSBiYW5k\nIG9mIEEuICBLTCA+PSAwLgpccGFyYW1baW5dIEtVCiAgICAgICAgIEtVIGlzIElOVEVHRVIKICAg\nIFRoZSBudW1iZXIgb2Ygc3VwZXJkaWFnb25hbHMgd2l0aGluIHRoZSBiYW5kIG9mIEEuICBLVSA+\nPSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICBUaGUgbnVt\nYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAg\nb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQUIKICAgICAg\nICAgQUIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMREFCLE4pCiAgICBU\naGUgb3JpZ2luYWwgYmFuZCBtYXRyaXggQSwgc3RvcmVkIGluIHJvd3MgMSB0byBLTCtLVSsxLgog\nICAgVGhlIGotdGggY29sdW1uIG9mIEEgaXMgc3RvcmVkIGluIHRoZSBqLXRoIGNvbHVtbiBvZiB0\naGUKICAgIGFycmF5IEFCIGFzIGZvbGxvd3M6CiAgICBBQihrdSsxK2ktaixqKSA9IEEoaSxqKSBm\nb3IgbWF4KDEsai1rdSk8PWk8PW1pbihuLGora2wpLgpccGFyYW1baW5dIExEQUIKICAgICAgICAg\nTERBQiBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFC\nLiAgTERBQiA+PSBLTCtLVSsxLgpccGFyYW1baW5dIEFGQgogICAgICAgICBBRkIgaXMgRE9VQkxF\nIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMREFGQixOKQogICAgRGV0YWlscyBvZiB0aGUg\nTFUgZmFjdG9yaXphdGlvbiBvZiB0aGUgYmFuZCBtYXRyaXggQSwgYXMKICAgIGNvbXB1dGVkIGJ5\nIERHQlRSRi4gIFUgaXMgc3RvcmVkIGFzIGFuIHVwcGVyIHRyaWFuZ3VsYXIgYmFuZAogICAgbWF0\ncml4IHdpdGggS0wrS1Ugc3VwZXJkaWFnb25hbHMgaW4gcm93cyAxIHRvIEtMK0tVKzEsIGFuZAog\nICAgdGhlIG11bHRpcGxpZXJzIHVzZWQgZHVyaW5nIHRoZSBmYWN0b3JpemF0aW9uIGFyZSBzdG9y\nZWQgaW4KICAgIHJvd3MgS0wrS1UrMiB0byAyKktMK0tVKzEuClxwYXJhbVtpbl0gTERBRkIKICAg\nICAgICAgTERBRkIgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBh\ncnJheSBBRkIuICBMREFGQiA+PSAyKktMKktVKzEuClxwYXJhbVtpbl0gSVBJVgogICAgICAgICBJ\nUElWIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgIFRoZSBwaXZvdCBpbmRpY2Vz\nIGZyb20gU0dFVFJGOyBmb3IgMTw9aTw9Tiwgcm93IGkgb2YgdGhlCiAgICBtYXRyaXggd2FzIGlu\ndGVyY2hhbmdlZCB3aXRoIHJvdyBJUElWKGkpLgpccGFyYW1baW4sb3V0XSBSCiAgICAgICAgIFIg\naXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOKQogICAgVGhlIHJvdyBzY2FsZSBmYWN0b3JzIGZv\nciBBLiAgSWYgRVFVRUQgPSAnUicgb3IgJ0InLCBBIGlzCiAgICBtdWx0aXBsaWVkIG9uIHRoZSBs\nZWZ0IGJ5IGRpYWcoUik7IGlmIEVRVUVEID0gJ04nIG9yICdDJywgUgogICAgaXMgbm90IGFjY2Vz\nc2VkLiAgUiBpcyBhbiBpbnB1dCBhcmd1bWVudCBpZiBGQUNUID0gJ0YnOwogICAgb3RoZXJ3aXNl\nLCBSIGlzIGFuIG91dHB1dCBhcmd1bWVudC4gIElmIEZBQ1QgPSAnRicgYW5kCiAgICBFUVVFRCA9\nICdSJyBvciAnQicsIGVhY2ggZWxlbWVudCBvZiBSIG11c3QgYmUgcG9zaXRpdmUuCiAgICBJZiBS\nIGlzIG91dHB1dCwgZWFjaCBlbGVtZW50IG9mIFIgaXMgYSBwb3dlciBvZiB0aGUgcmFkaXguCiAg\nICBJZiBSIGlzIGlucHV0LCBlYWNoIGVsZW1lbnQgb2YgUiBzaG91bGQgYmUgYSBwb3dlciBvZiB0\naGUgcmFkaXgKICAgIHRvIGVuc3VyZSBhIHJlbGlhYmxlIHNvbHV0aW9uIGFuZCBlcnJvciBlc3Rp\nbWF0ZXMuIFNjYWxpbmcgYnkKICAgIHBvd2VycyBvZiB0aGUgcmFkaXggZG9lcyBub3QgY2F1c2Ug\ncm91bmRpbmcgZXJyb3JzIHVubGVzcyB0aGUKICAgIHJlc3VsdCB1bmRlcmZsb3dzIG9yIG92ZXJm\nbG93cy4gUm91bmRpbmcgZXJyb3JzIGR1cmluZyBzY2FsaW5nCiAgICBsZWFkIHRvIHJlZmluaW5n\nIHdpdGggYSBtYXRyaXggdGhhdCBpcyBub3QgZXF1aXZhbGVudCB0byB0aGUKICAgIGlucHV0IG1h\ndHJpeCwgcHJvZHVjaW5nIGVycm9yIGVzdGltYXRlcyB0aGF0IG1heSBub3QgYmUKICAgIHJlbGlh\nYmxlLgpccGFyYW1baW4sb3V0XSBDCiAgICAgICAgIEMgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9u\nIChOKQogICAgVGhlIGNvbHVtbiBzY2FsZSBmYWN0b3JzIGZvciBBLiAgSWYgRVFVRUQgPSAnQycg\nb3IgJ0InLCBBIGlzCiAgICBtdWx0aXBsaWVkIG9uIHRoZSByaWdodCBieSBkaWFnKEMpOyBpZiBF\nUVVFRCA9ICdOJyBvciAnUicsIEMKICAgIGlzIG5vdCBhY2Nlc3NlZC4gIEMgaXMgYW4gaW5wdXQg\nYXJndW1lbnQgaWYgRkFDVCA9ICdGJzsKICAgIG90aGVyd2lzZSwgQyBpcyBhbiBvdXRwdXQgYXJn\ndW1lbnQuICBJZiBGQUNUID0gJ0YnIGFuZAogICAgRVFVRUQgPSAnQycgb3IgJ0InLCBlYWNoIGVs\nZW1lbnQgb2YgQyBtdXN0IGJlIHBvc2l0aXZlLgogICAgSWYgQyBpcyBvdXRwdXQsIGVhY2ggZWxl\nbWVudCBvZiBDIGlzIGEgcG93ZXIgb2YgdGhlIHJhZGl4LgogICAgSWYgQyBpcyBpbnB1dCwgZWFj\naCBlbGVtZW50IG9mIEMgc2hvdWxkIGJlIGEgcG93ZXIgb2YgdGhlIHJhZGl4CiAgICB0byBlbnN1\ncmUgYSByZWxpYWJsZSBzb2x1dGlvbiBhbmQgZXJyb3IgZXN0aW1hdGVzLiBTY2FsaW5nIGJ5CiAg\nICBwb3dlcnMgb2YgdGhlIHJhZGl4IGRvZXMgbm90IGNhdXNlIHJvdW5kaW5nIGVycm9ycyB1bmxl\nc3MgdGhlCiAgICByZXN1bHQgdW5kZXJmbG93cyBvciBvdmVyZmxvd3MuIFJvdW5kaW5nIGVycm9y\ncyBkdXJpbmcgc2NhbGluZwogICAgbGVhZCB0byByZWZpbmluZyB3aXRoIGEgbWF0cml4IHRoYXQg\naXMgbm90IGVxdWl2YWxlbnQgdG8gdGhlCiAgICBpbnB1dCBtYXRyaXgsIHByb2R1Y2luZyBlcnJv\nciBlc3RpbWF0ZXMgdGhhdCBtYXkgbm90IGJlCiAgICByZWxpYWJsZS4KXHBhcmFtW2luXSBCCiAg\nICAgICAgIEIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgIFRoZSByaWdo\ndCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRF\nR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4\nKDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBSRUFMIGFycmF5LCBkaW1lbnNp\nb24gKExEWCxOUkhTKQogICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwgYXMgY29t\ncHV0ZWQgYnkgU0dFVFJTLgogICAgT24gZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0aW9uIG1hdHJp\neCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgogICAgVGhlIGxlYWRp\nbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0\nXSBSQ09ORAogICAgICAgICBSQ09ORCBpcyBSRUFMCiAgICBSZWNpcHJvY2FsIHNjYWxlZCBjb25k\naXRpb24gbnVtYmVyLiAgVGhpcyBpcyBhbiBlc3RpbWF0ZSBvZiB0aGUKICAgIHJlY2lwcm9jYWwg\nU2tlZWwgY29uZGl0aW9uIG51bWJlciBvZiB0aGUgbWF0cml4IEEgYWZ0ZXIKICAgIGVxdWlsaWJy\nYXRpb24gKGlmIGRvbmUpLiAgSWYgdGhpcyBpcyBsZXNzIHRoYW4gdGhlIG1hY2hpbmUKICAgIHBy\nZWNpc2lvbiAoaW4gcGFydGljdWxhciwgaWYgaXQgaXMgemVybyksIHRoZSBtYXRyaXggaXMgc2lu\nZ3VsYXIKICAgIHRvIHdvcmtpbmcgcHJlY2lzaW9uLiAgTm90ZSB0aGF0IHRoZSBlcnJvciBtYXkg\nc3RpbGwgYmUgc21hbGwgZXZlbgogICAgaWYgdGhpcyBudW1iZXIgaXMgdmVyeSBzbWFsbCBhbmQg\ndGhlIG1hdHJpeCBhcHBlYXJzIGlsbC0KICAgIGNvbmRpdGlvbmVkLgpccGFyYW1bb3V0XSBCRVJS\nCiAgICAgICAgIEJFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgQ29tcG9u\nZW50d2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvci4gIFRoaXMgaXMgdGhlCiAgICBjb21wb25l\nbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24gdmVjdG9yIFgo\naikKICAgIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluIGFueSBlbGVtZW50\nIG9mIEEgb3IgQiB0aGF0CiAgICBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFt\nW2luXSBOX0VSUl9CTkRTCiAgICAgICAgIE5fRVJSX0JORFMgaXMgSU5URUdFUgogICAgTnVtYmVy\nIG9mIGVycm9yIGJvdW5kcyB0byByZXR1cm4gZm9yIGVhY2ggcmlnaHQgaGFuZCBzaWRlCiAgICBh\nbmQgZWFjaCB0eXBlIChub3Jtd2lzZSBvciBjb21wb25lbnR3aXNlKS4gIFNlZSBFUlJfQk5EU19O\nT1JNIGFuZAogICAgRVJSX0JORFNfQ09NUCBiZWxvdy4KXHBhcmFtW291dF0gRVJSX0JORFNfTk9S\nTQogICAgICAgICBFUlJfQk5EU19OT1JNIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUywg\nTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhpcyBhcnJheSBjb250\nYWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3VuZHMgYW5kIGNvbmRp\ndGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBub3Jtd2lzZSByZWxhdGl2ZSBl\ncnJvciwgd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dzOgogICAgTm9ybXdpc2UgcmVsYXRpdmUg\nZXJyb3IgaW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAgICAgICAgIG1heF9qIChhYnMo\nWFRSVUUoaixpKSAtIFgoaixpKSkpCiAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t\nLS0tLS0tCiAgICAgICAgICAgICAgICAgbWF4X2ogYWJzKFgoaixpKSkKICAgIFRoZSBhcnJheSBp\ncyBpbmRleGVkIGJ5IHRoZSB0eXBlIG9mIGVycm9yIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZAog\nICAgYmVsb3cuIFRoZXJlIGN1cnJlbnRseSBhcmUgdXAgdG8gdGhyZWUgcGllY2VzIG9mIGluZm9y\nbWF0aW9uCiAgICByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJfQk5EU19OT1JN\nKGksOikgY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQtaGFuZCBzaWRlLgogICAgVGhl\nIHNlY29uZCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKDosZXJyKSBjb250YWlucyB0aGUgZm9sbG93\naW5nCiAgICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVzdC9kb24ndCB0cnVzdCIgYm9v\nbGVhbi4gVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29u\nZGl0aW9uIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3Fy\ndChuKSAqIHNsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAiR3VhcmFudGVlZCIgZXJyb3Ig\nYm91bmQ6IFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAgICAgICAgICAgIGFsbW9zdCBj\nZXJ0YWlubHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9yCiAgICAgICAg\nICAgICBzbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNo\nb2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykuIFRoaXMgZXJyb3Ig\nYm91bmQgc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0ZWQgaWYgdGhlIHByZXZpb3Vz\nIGJvb2xlYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJl\ncjogRXN0aW1hdGVkIG5vcm13aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBu\ndW1iZXIuICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikg\nKiBzbGFtY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAg\nICBlc3RpbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAg\nICAgICAgICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5m\nKSkgZm9yIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgog\nICAgICAgICAgICAgTGV0IFogPSBTKkEsIHdoZXJlIFMgc2NhbGVzIGVhY2ggcm93IGJ5IGEgcG93\nZXIgb2YgdGhlCiAgICAgICAgICAgICByYWRpeCBzbyBhbGwgYWJzb2x1dGUgcm93IHN1bXMgb2Yg\nWiBhcmUgYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFjayBXb3JraW5nIE5vdGUgMTY1IGZv\nciBmdXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4KXHBhcmFtW291dF0gRVJS\nX0JORFNfQ09NUAogICAgICAgICBFUlJfQk5EU19DT01QIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lv\nbiAoTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhpcyBh\ncnJheSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3VuZHMg\nYW5kIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBjb21wb25lbnR3\naXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFzIGZvbGxvd3M6CiAgICBDb21w\nb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGluIHRoZSBpdGggc29sdXRpb24gdmVjdG9yOgogICAg\nICAgICAgICAgICAgICAgYWJzKFhUUlVFKGosaSkgLSBYKGosaSkpCiAgICAgICAgICAgIG1heF9q\nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAgICAgICAgICAgYWJzKFgoaixp\nKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSByaWdodC1oYW5kIHNpZGUgaSAob24g\nd2hpY2ggdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGRlcGVuZHMpLCBhbmQg\ndGhlIHR5cGUgb2YgZXJyb3IKICAgIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZCBiZWxvdy4gVGhl\ncmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZQogICAgcGllY2VzIG9mIGluZm9ybWF0aW9uIHJl\ndHVybmVkIGZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZS4gSWYKICAgIGNvbXBvbmVudHdpc2UgYWNj\ndXJhY3kgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1TKDMpID0gMC4wKSwgdGhlbgogICAgRVJSX0JO\nRFNfQ09NUCBpcyBub3QgYWNjZXNzZWQuICBJZiBOX0VSUl9CTkRTIC5MVC4gMywgdGhlbiBhdCBt\nb3N0CiAgICB0aGUgZmlyc3QgKDosTl9FUlJfQk5EUykgZW50cmllcyBhcmUgcmV0dXJuZWQuCiAg\nICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfQ09NUChpLDopIGNvcnJlc3BvbmRzIHRvIHRo\nZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBzZWNvbmQgaW5kZXggaW4gRVJSX0JO\nRFNfQ09NUCg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2luZwogICAgdGhyZWUgZmllbGRzOgog\nICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xlYW4uIFRydXN0IHRoZSBhbnN3ZXIg\naWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIgaXMgbGVzcyB0\naGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2lsb24n\nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJvdW5kOiBUaGUgZXN0aW1hdGVkIGZv\ncndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2VydGFpbmx5IHdpdGhpbiBhIGZhY3Rv\nciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAgICAgc28gbG9uZyBhcyB0aGUgbmV4\ndCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChu\nKSAqIHNsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJvdW5kIHNob3VsZCBvbmx5CiAgICAg\nICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBib29sZWFuIGlzIHRydWUuCiAgICBl\ncnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6IEVzdGltYXRlZCBjb21wb25lbnR3\naXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIuICBDb21wYXJlZCB3\naXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2lsb24n\nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAgICBlc3RpbWF0ZSBpcyAiZ3Vh\ncmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAgICAgICAgICAgICBudW1iZXJz\nIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5mKSkgZm9yIHNvbWUKICAgICAg\nICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgogICAgICAgICAgICAgTGV0IFog\nPSBTKihBKmRpYWcoeCkpLCB3aGVyZSB4IGlzIHRoZSBzb2x1dGlvbiBmb3IgdGhlCiAgICAgICAg\nICAgICBjdXJyZW50IHJpZ2h0LWhhbmQgc2lkZSBhbmQgUyBzY2FsZXMgZWFjaCByb3cgb2YKICAg\nICAgICAgICAgIEEqZGlhZyh4KSBieSBhIHBvd2VyIG9mIHRoZSByYWRpeCBzbyBhbGwgYWJzb2x1\ndGUgcm93CiAgICAgICAgICAgICBzdW1zIG9mIFogYXJlIGFwcHJveGltYXRlbHkgMS4KICAgIFNl\nZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhlciBkZXRhaWxzIGFuZCBleHRyYQog\nICAgY2F1dGlvbnMuClxwYXJhbVtpbl0gTlBBUkFNUwogICAgICAgICBOUEFSQU1TIGlzIElOVEVH\nRVIKICAgIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgc2V0IGluIFBBUkFNUy4g\nIElmIC5MRS4gMCwgdGhlCiAgICBQQVJBTVMgYXJyYXkgaXMgbmV2ZXIgcmVmZXJlbmNlZCBhbmQg\nZGVmYXVsdCB2YWx1ZXMgYXJlIHVzZWQuClxwYXJhbVtpbixvdXRdIFBBUkFNUwogICAgICAgICBQ\nQVJBTVMgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIE5QQVJBTVMKICAgIFNwZWNpZmllcyBhbGdv\ncml0aG0gcGFyYW1ldGVycy4gIElmIGFuIGVudHJ5IGlzIC5MVC4gMC4wLCB0aGVuCiAgICB0aGF0\nIGVudHJ5IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVmYXVsdCB2YWx1ZSB1c2VkIGZvciB0aGF0CiAg\nICBwYXJhbWV0ZXIuICBPbmx5IHBvc2l0aW9ucyB1cCB0byBOUEFSQU1TIGFyZSBhY2Nlc3NlZDsg\nZGVmYXVsdHMKICAgIGFyZSB1c2VkIGZvciBoaWdoZXItbnVtYmVyZWQgcGFyYW1ldGVycy4KICAg\nICAgUEFSQU1TKExBX0xJTlJYX0lUUkVGX0kgPSAxKSA6IFdoZXRoZXIgdG8gcGVyZm9ybSBpdGVy\nYXRpdmUKICAgICAgICAgICByZWZpbmVtZW50IG9yIG5vdC4KICAgICAgICBEZWZhdWx0OiAxLjAK\nICAgICAgICAgICA9IDAuMCA6IE5vIHJlZmluZW1lbnQgaXMgcGVyZm9ybWVkLCBhbmQgbm8gZXJy\nb3IgYm91bmRzIGFyZQogICAgICAgICAgICAgICAgICAgY29tcHV0ZWQuCiAgICAgICAgICAgPSAx\nLjAgOiBVc2UgdGhlIGRvdWJsZS1wcmVjaXNpb24gcmVmaW5lbWVudCBhbGdvcml0aG0sCiAgICAg\nICAgICAgICAgICAgICBwb3NzaWJseSB3aXRoIGRvdWJsZWQtc2luZ2xlIGNvbXB1dGF0aW9ucyBp\nZiB0aGUKICAgICAgICAgICAgICAgICAgIGNvbXBpbGF0aW9uIGVudmlyb25tZW50IGRvZXMgbm90\nIHN1cHBvcnQgRE9VQkxFCiAgICAgICAgICAgICAgICAgICBQUkVDSVNJT04uCiAgICAgICAgICAg\nICAob3RoZXIgdmFsdWVzIGFyZSByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSkKICAgICAgUEFSQU1T\nKExBX0xJTlJYX0lUSFJFU0hfSSA9IDIpIDogTWF4aW11bSBudW1iZXIgb2YgcmVzaWR1YWwKICAg\nICAgICAgICBjb21wdXRhdGlvbnMgYWxsb3dlZCBmb3IgcmVmaW5lbWVudC4KICAgICAgICBEZWZh\ndWx0OiAxMAogICAgICAgIEFnZ3Jlc3NpdmU6IFNldCB0byAxMDAgdG8gcGVybWl0IGNvbnZlcmdl\nbmNlIHVzaW5nIGFwcHJveGltYXRlCiAgICAgICAgICAgICAgICAgICAgZmFjdG9yaXphdGlvbnMg\nb3IgZmFjdG9yaXphdGlvbnMgb3RoZXIgdGhhbiBMVS4gSWYKICAgICAgICAgICAgICAgICAgICB0\naGUgZmFjdG9yaXphdGlvbiB1c2VzIGEgdGVjaG5pcXVlIG90aGVyIHRoYW4KICAgICAgICAgICAg\nICAgICAgICBHYXVzc2lhbiBlbGltaW5hdGlvbiwgdGhlIGd1YXJhbnRlZXMgaW4KICAgICAgICAg\nICAgICAgICAgICBlcnJfYm5kc19ub3JtIGFuZCBlcnJfYm5kc19jb21wIG1heSBubyBsb25nZXIg\nYmUKICAgICAgICAgICAgICAgICAgICB0cnVzdHdvcnRoeS4KICAgICAgUEFSQU1TKExBX0xJTlJY\nX0NXSVNFX0kgPSAzKSA6IEZsYWcgZGV0ZXJtaW5pbmcgaWYgdGhlIGNvZGUKICAgICAgICAgICB3\naWxsIGF0dGVtcHQgdG8gZmluZCBhIHNvbHV0aW9uIHdpdGggc21hbGwgY29tcG9uZW50d2lzZQog\nICAgICAgICAgIHJlbGF0aXZlIGVycm9yIGluIHRoZSBkb3VibGUtcHJlY2lzaW9uIGFsZ29yaXRo\nbS4gIFBvc2l0aXZlCiAgICAgICAgICAgaXMgdHJ1ZSwgMC4wIGlzIGZhbHNlLgogICAgICAgIERl\nZmF1bHQ6IDEuMCAoYXR0ZW1wdCBjb21wb25lbnR3aXNlIGNvbnZlcmdlbmNlKQpccGFyYW1bb3V0\nXSBXT1JLCiAgICAgICAgIFdPUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uICg0Kk4pClxwYXJh\nbVtvdXRdIElXT1JLCiAgICAgICAgIElXT1JLIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAo\nTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgPSAwOiAg\nU3VjY2Vzc2Z1bCBleGl0LiBUaGUgc29sdXRpb24gdG8gZXZlcnkgcmlnaHQtaGFuZCBzaWRlIGlz\nCiAgICAgICAgZ3VhcmFudGVlZC4KICAgICAgPCAwOiAgSWYgSU5GTyA9IC1pLCB0aGUgaS10aCBh\ncmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQogICAgICA+IDAgYW5kIDw9IE46ICBVKElORk8s\nSU5GTykgaXMgZXhhY3RseSB6ZXJvLiAgVGhlIGZhY3Rvcml6YXRpb24KICAgICAgICBoYXMgYmVl\nbiBjb21wbGV0ZWQsIGJ1dCB0aGUgZmFjdG9yIFUgaXMgZXhhY3RseSBzaW5ndWxhciwgc28KICAg\nICAgICB0aGUgc29sdXRpb24gYW5kIGVycm9yIGJvdW5kcyBjb3VsZCBub3QgYmUgY29tcHV0ZWQu\nIFJDT05EID0gMAogICAgICAgIGlzIHJldHVybmVkLgogICAgICA9IE4rSjogVGhlIHNvbHV0aW9u\nIGNvcnJlc3BvbmRpbmcgdG8gdGhlIEp0aCByaWdodC1oYW5kIHNpZGUgaXMKICAgICAgICBub3Qg\nZ3VhcmFudGVlZC4gVGhlIHNvbHV0aW9ucyBjb3JyZXNwb25kaW5nIHRvIG90aGVyIHJpZ2h0LQog\nICAgICAgIGhhbmQgc2lkZXMgSyB3aXRoIEsgPiBKIG1heSBub3QgYmUgZ3VhcmFudGVlZCBhcyB3\nZWxsLCBidXQKICAgICAgICBvbmx5IHRoZSBmaXJzdCBzdWNoIHJpZ2h0LWhhbmQgc2lkZSBpcyBy\nZXBvcnRlZC4gSWYgYSBzbWFsbAogICAgICAgIGNvbXBvbmVudHdpc2UgZXJyb3IgaXMgbm90IHJl\ncXVlc3RlZCAoUEFSQU1TKDMpID0gMC4wKSB0aGVuCiAgICAgICAgdGhlIEp0aCByaWdodC1oYW5k\nIHNpZGUgaXMgdGhlIGZpcnN0IHdpdGggYSBub3Jtd2lzZSBlcnJvcgogICAgICAgIGJvdW5kIHRo\nYXQgaXMgbm90IGd1YXJhbnRlZWQgKHRoZSBzbWFsbGVzdCBKIHN1Y2gKICAgICAgICB0aGF0IEVS\nUl9CTkRTX05PUk0oSiwxKSA9IDAuMCkuIEJ5IGRlZmF1bHQgKFBBUkFNUygzKSA9IDEuMCkKICAg\nICAgICB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcyB0aGUgZmlyc3Qgd2l0aCBlaXRoZXIgYSBu\nb3Jtd2lzZSBvcgogICAgICAgIGNvbXBvbmVudHdpc2UgZXJyb3IgYm91bmQgdGhhdCBpcyBub3Qg\nZ3VhcmFudGVlZCAodGhlIHNtYWxsZXN0CiAgICAgICAgSiBzdWNoIHRoYXQgZWl0aGVyIEVSUl9C\nTkRTX05PUk0oSiwxKSA9IDAuMCBvcgogICAgICAgIEVSUl9CTkRTX0NPTVAoSiwxKSA9IDAuMCku\nIFNlZSB0aGUgZGVmaW5pdGlvbiBvZgogICAgICAgIEVSUl9CTkRTX05PUk0oOiwxKSBhbmQgRVJS\nX0JORFNfQ09NUCg6LDEpLiBUbyBnZXQgaW5mb3JtYXRpb24KICAgICAgICBhYm91dCBhbGwgb2Yg\ndGhlIHJpZ2h0LWhhbmQgc2lkZXMgY2hlY2sgRVJSX0JORFNfTk9STSBvcgogICAgICAgIEVSUl9C\nTkRTX0NPTVAuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVu\naXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVu\ndmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBBcHJpbCAyMDEyClxpbmdyb3VwIHJlYWxHQmNv\nbXB1dGF0aW9uYWwKaB1oHimBcu8BAAB9cvABAAAoaCGJaCJoI3ViaC2KAp8BaC5YDwAAAHNnYnJm\nc3hfNDE1LnR4dHViaC+KAp8BaDBYBgAAAGdicmZzeGgtigE5dWJoFWgWXWgXh1Jy8QEAAH1y8gEA\nAChoGlgHAAAAZ2VuZXJhbGgbWAQAAABiYW5kaBxYRgAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dh\ncmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudDsgRVFVRURoHWgeKYFy8wEA\nAH1y9AEAAChoIYloImgjdWJoJFghAAAARG94eWdlbi9kb2NzL2h0bWwvZGdicmZzeF84Zi5odG1s\naCVYAQAAAGRoJmgVaCddaBeHUnL1AQAAfXL2AQAAKGgqWAQ3AAAgICBER0JSRlNYIGltcHJvdmVz\nIHRoZSBjb21wdXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKICAgZXF1YXRpb25z\nIGFuZCBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcwog\nICBmb3IgdGhlIHNvbHV0aW9uLiAgSW4gYWRkaXRpb24gdG8gbm9ybXdpc2UgZXJyb3IgYm91bmQs\nIHRoZSBjb2RlCiAgIHByb3ZpZGVzIG1heGltdW0gY29tcG9uZW50d2lzZSBlcnJvciBib3VuZCBp\nZiBwb3NzaWJsZS4gIFNlZQogICBjb21tZW50cyBmb3IgRVJSX0JORFNfTk9STSBhbmQgRVJSX0JO\nRFNfQ09NUCBmb3IgZGV0YWlscyBvZiB0aGUKICAgZXJyb3IgYm91bmRzLgogICBUaGUgb3JpZ2lu\nYWwgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgbWF5IGhhdmUgYmVlbiBlcXVpbGlicmF0ZWQK\nICAgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0aW5lLCBhcyBkZXNjcmliZWQgYnkgYXJndW1lbnRz\nIEVRVUVELCBSCiAgIGFuZCBDIGJlbG93LiBJbiB0aGlzIGNhc2UsIHRoZSBzb2x1dGlvbiBhbmQg\nZXJyb3IgYm91bmRzIHJldHVybmVkCiAgIGFyZSBmb3IgdGhlIG9yaWdpbmFsIHVuZXF1aWxpYnJh\ndGVkIHN5c3RlbS4KQXJndW1lbnRzOgogICAgU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzIGFyZSBi\ndW5kbGVkIGluIHRoZSBQQVJBTVMgYXJyYXkuICBUaGVzZQogICAgc2V0dGluZ3MgZGV0ZXJtaW5l\nIGhvdyByZWZpbmVtZW50IGlzIHBlcmZvcm1lZCwgYnV0IG9mdGVuIHRoZQogICAgZGVmYXVsdHMg\nYXJlIGFjY2VwdGFibGUuICBJZiB0aGUgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUsIHVzZXJzCiAg\nICBjYW4gcGFzcyBOUEFSQU1TID0gMCB3aGljaCBwcmV2ZW50cyB0aGUgc291cmNlIGNvZGUgZnJv\nbSBhY2Nlc3NpbmcKICAgIHRoZSBQQVJBTVMgYXJndW1lbnQuClxwYXJhbVtpbl0gVFJBTlMKICAg\nICAgICAgVFJBTlMgaXMgQ0hBUkFDVEVSKjEKICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiB0aGUg\nc3lzdGVtIG9mIGVxdWF0aW9uczoKICAgICAgPSAnTic6ICBBICogWCA9IEIgICAgIChObyB0cmFu\nc3Bvc2UpCiAgICAgID0gJ1QnOiAgQSoqVCAqIFggPSBCICAoVHJhbnNwb3NlKQogICAgICA9ICdD\nJzogIEEqKkggKiBYID0gQiAgKENvbmp1Z2F0ZSB0cmFuc3Bvc2UgPSBUcmFuc3Bvc2UpClxwYXJh\nbVtpbl0gRVFVRUQKICAgICAgICAgRVFVRUQgaXMgQ0hBUkFDVEVSKjEKICAgIFNwZWNpZmllcyB0\naGUgZm9ybSBvZiBlcXVpbGlicmF0aW9uIHRoYXQgd2FzIGRvbmUgdG8gQQogICAgYmVmb3JlIGNh\nbGxpbmcgdGhpcyByb3V0aW5lLiBUaGlzIGlzIG5lZWRlZCB0byBjb21wdXRlCiAgICB0aGUgc29s\ndXRpb24gYW5kIGVycm9yIGJvdW5kcyBjb3JyZWN0bHkuCiAgICAgID0gJ04nOiAgTm8gZXF1aWxp\nYnJhdGlvbgogICAgICA9ICdSJzogIFJvdyBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBiZWVu\nIHByZW11bHRpcGxpZWQgYnkKICAgICAgICAgICAgICBkaWFnKFIpLgogICAgICA9ICdDJzogIENv\nbHVtbiBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBiZWVuIHBvc3RtdWx0aXBsaWVkCiAgICAg\nICAgICAgICAgYnkgZGlhZyhDKS4KICAgICAgPSAnQic6ICBCb3RoIHJvdyBhbmQgY29sdW1uIGVx\ndWlsaWJyYXRpb24sIGkuZS4sIEEgaGFzIGJlZW4KICAgICAgICAgICAgICByZXBsYWNlZCBieSBk\naWFnKFIpICogQSAqIGRpYWcoQykuCiAgICAgICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBC\nIGhhcyBiZWVuIGNoYW5nZWQgYWNjb3JkaW5nbHkuClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlz\nIElOVEVHRVIKICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtp\nbl0gS0wKICAgICAgICAgS0wgaXMgSU5URUdFUgogICAgVGhlIG51bWJlciBvZiBzdWJkaWFnb25h\nbHMgd2l0aGluIHRoZSBiYW5kIG9mIEEuICBLTCA+PSAwLgpccGFyYW1baW5dIEtVCiAgICAgICAg\nIEtVIGlzIElOVEVHRVIKICAgIFRoZSBudW1iZXIgb2Ygc3VwZXJkaWFnb25hbHMgd2l0aGluIHRo\nZSBiYW5kIG9mIEEuICBLVSA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJ\nTlRFR0VSCiAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1i\nZXIgb2YgY29sdW1ucwogICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxw\nYXJhbVtpbl0gQUIKICAgICAgICAgQUIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5z\naW9uIChMREFCLE4pCiAgICBUaGUgb3JpZ2luYWwgYmFuZCBtYXRyaXggQSwgc3RvcmVkIGluIHJv\nd3MgMSB0byBLTCtLVSsxLgogICAgVGhlIGotdGggY29sdW1uIG9mIEEgaXMgc3RvcmVkIGluIHRo\nZSBqLXRoIGNvbHVtbiBvZiB0aGUKICAgIGFycmF5IEFCIGFzIGZvbGxvd3M6CiAgICBBQihrdSsx\nK2ktaixqKSA9IEEoaSxqKSBmb3IgbWF4KDEsai1rdSk8PWk8PW1pbihuLGora2wpLgpccGFyYW1b\naW5dIExEQUIKICAgICAgICAgTERBQiBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNp\nb24gb2YgdGhlIGFycmF5IEFCLiAgTERBQiA+PSBLTCtLVSsxLgpccGFyYW1baW5dIEFGQgogICAg\nICAgICBBRkIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMREFGQixOKQog\nICAgRGV0YWlscyBvZiB0aGUgTFUgZmFjdG9yaXphdGlvbiBvZiB0aGUgYmFuZCBtYXRyaXggQSwg\nYXMKICAgIGNvbXB1dGVkIGJ5IERHQlRSRi4gIFUgaXMgc3RvcmVkIGFzIGFuIHVwcGVyIHRyaWFu\nZ3VsYXIgYmFuZAogICAgbWF0cml4IHdpdGggS0wrS1Ugc3VwZXJkaWFnb25hbHMgaW4gcm93cyAx\nIHRvIEtMK0tVKzEsIGFuZAogICAgdGhlIG11bHRpcGxpZXJzIHVzZWQgZHVyaW5nIHRoZSBmYWN0\nb3JpemF0aW9uIGFyZSBzdG9yZWQgaW4KICAgIHJvd3MgS0wrS1UrMiB0byAyKktMK0tVKzEuClxw\nYXJhbVtpbl0gTERBRkIKICAgICAgICAgTERBRkIgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcg\nZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBRkIuICBMREFGQiA+PSAyKktMKktVKzEuClxwYXJhbVtp\nbl0gSVBJVgogICAgICAgICBJUElWIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKICAg\nIFRoZSBwaXZvdCBpbmRpY2VzIGZyb20gREdFVFJGOyBmb3IgMTw9aTw9Tiwgcm93IGkgb2YgdGhl\nCiAgICBtYXRyaXggd2FzIGludGVyY2hhbmdlZCB3aXRoIHJvdyBJUElWKGkpLgpccGFyYW1baW4s\nb3V0XSBSCiAgICAgICAgIFIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChO\nKQogICAgVGhlIHJvdyBzY2FsZSBmYWN0b3JzIGZvciBBLiAgSWYgRVFVRUQgPSAnUicgb3IgJ0In\nLCBBIGlzCiAgICBtdWx0aXBsaWVkIG9uIHRoZSBsZWZ0IGJ5IGRpYWcoUik7IGlmIEVRVUVEID0g\nJ04nIG9yICdDJywgUgogICAgaXMgbm90IGFjY2Vzc2VkLiAgUiBpcyBhbiBpbnB1dCBhcmd1bWVu\ndCBpZiBGQUNUID0gJ0YnOwogICAgb3RoZXJ3aXNlLCBSIGlzIGFuIG91dHB1dCBhcmd1bWVudC4g\nIElmIEZBQ1QgPSAnRicgYW5kCiAgICBFUVVFRCA9ICdSJyBvciAnQicsIGVhY2ggZWxlbWVudCBv\nZiBSIG11c3QgYmUgcG9zaXRpdmUuCiAgICBJZiBSIGlzIG91dHB1dCwgZWFjaCBlbGVtZW50IG9m\nIFIgaXMgYSBwb3dlciBvZiB0aGUgcmFkaXguCiAgICBJZiBSIGlzIGlucHV0LCBlYWNoIGVsZW1l\nbnQgb2YgUiBzaG91bGQgYmUgYSBwb3dlciBvZiB0aGUgcmFkaXgKICAgIHRvIGVuc3VyZSBhIHJl\nbGlhYmxlIHNvbHV0aW9uIGFuZCBlcnJvciBlc3RpbWF0ZXMuIFNjYWxpbmcgYnkKICAgIHBvd2Vy\ncyBvZiB0aGUgcmFkaXggZG9lcyBub3QgY2F1c2Ugcm91bmRpbmcgZXJyb3JzIHVubGVzcyB0aGUK\nICAgIHJlc3VsdCB1bmRlcmZsb3dzIG9yIG92ZXJmbG93cy4gUm91bmRpbmcgZXJyb3JzIGR1cmlu\nZyBzY2FsaW5nCiAgICBsZWFkIHRvIHJlZmluaW5nIHdpdGggYSBtYXRyaXggdGhhdCBpcyBub3Qg\nZXF1aXZhbGVudCB0byB0aGUKICAgIGlucHV0IG1hdHJpeCwgcHJvZHVjaW5nIGVycm9yIGVzdGlt\nYXRlcyB0aGF0IG1heSBub3QgYmUKICAgIHJlbGlhYmxlLgpccGFyYW1baW4sb3V0XSBDCiAgICAg\nICAgIEMgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgVGhlIGNv\nbHVtbiBzY2FsZSBmYWN0b3JzIGZvciBBLiAgSWYgRVFVRUQgPSAnQycgb3IgJ0InLCBBIGlzCiAg\nICBtdWx0aXBsaWVkIG9uIHRoZSByaWdodCBieSBkaWFnKEMpOyBpZiBFUVVFRCA9ICdOJyBvciAn\nUicsIEMKICAgIGlzIG5vdCBhY2Nlc3NlZC4gIEMgaXMgYW4gaW5wdXQgYXJndW1lbnQgaWYgRkFD\nVCA9ICdGJzsKICAgIG90aGVyd2lzZSwgQyBpcyBhbiBvdXRwdXQgYXJndW1lbnQuICBJZiBGQUNU\nID0gJ0YnIGFuZAogICAgRVFVRUQgPSAnQycgb3IgJ0InLCBlYWNoIGVsZW1lbnQgb2YgQyBtdXN0\nIGJlIHBvc2l0aXZlLgogICAgSWYgQyBpcyBvdXRwdXQsIGVhY2ggZWxlbWVudCBvZiBDIGlzIGEg\ncG93ZXIgb2YgdGhlIHJhZGl4LgogICAgSWYgQyBpcyBpbnB1dCwgZWFjaCBlbGVtZW50IG9mIEMg\nc2hvdWxkIGJlIGEgcG93ZXIgb2YgdGhlIHJhZGl4CiAgICB0byBlbnN1cmUgYSByZWxpYWJsZSBz\nb2x1dGlvbiBhbmQgZXJyb3IgZXN0aW1hdGVzLiBTY2FsaW5nIGJ5CiAgICBwb3dlcnMgb2YgdGhl\nIHJhZGl4IGRvZXMgbm90IGNhdXNlIHJvdW5kaW5nIGVycm9ycyB1bmxlc3MgdGhlCiAgICByZXN1\nbHQgdW5kZXJmbG93cyBvciBvdmVyZmxvd3MuIFJvdW5kaW5nIGVycm9ycyBkdXJpbmcgc2NhbGlu\nZwogICAgbGVhZCB0byByZWZpbmluZyB3aXRoIGEgbWF0cml4IHRoYXQgaXMgbm90IGVxdWl2YWxl\nbnQgdG8gdGhlCiAgICBpbnB1dCBtYXRyaXgsIHByb2R1Y2luZyBlcnJvciBlc3RpbWF0ZXMgdGhh\ndCBtYXkgbm90IGJlCiAgICByZWxpYWJsZS4KXHBhcmFtW2luXSBCCiAgICAgICAgIEIgaXMgRE9V\nQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgIFRoZSByaWdodCBo\nYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VS\nCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEs\nTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5\nLCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRyaXgg\nWCwgYXMgY29tcHV0ZWQgYnkgREdFVFJTLgogICAgT24gZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0\naW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgogICAg\nVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpc\ncGFyYW1bb3V0XSBSQ09ORAogICAgICAgICBSQ09ORCBpcyBET1VCTEUgUFJFQ0lTSU9OCiAgICBS\nZWNpcHJvY2FsIHNjYWxlZCBjb25kaXRpb24gbnVtYmVyLiAgVGhpcyBpcyBhbiBlc3RpbWF0ZSBv\nZiB0aGUKICAgIHJlY2lwcm9jYWwgU2tlZWwgY29uZGl0aW9uIG51bWJlciBvZiB0aGUgbWF0cml4\nIEEgYWZ0ZXIKICAgIGVxdWlsaWJyYXRpb24gKGlmIGRvbmUpLiAgSWYgdGhpcyBpcyBsZXNzIHRo\nYW4gdGhlIG1hY2hpbmUKICAgIHByZWNpc2lvbiAoaW4gcGFydGljdWxhciwgaWYgaXQgaXMgemVy\nbyksIHRoZSBtYXRyaXggaXMgc2luZ3VsYXIKICAgIHRvIHdvcmtpbmcgcHJlY2lzaW9uLiAgTm90\nZSB0aGF0IHRoZSBlcnJvciBtYXkgc3RpbGwgYmUgc21hbGwgZXZlbgogICAgaWYgdGhpcyBudW1i\nZXIgaXMgdmVyeSBzbWFsbCBhbmQgdGhlIG1hdHJpeCBhcHBlYXJzIGlsbC0KICAgIGNvbmRpdGlv\nbmVkLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgRE9VQkxFIFBSRUNJU0lPTiBh\ncnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgQ29tcG9uZW50d2lzZSByZWxhdGl2ZSBiYWNrd2Fy\nZCBlcnJvci4gIFRoaXMgaXMgdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJk\nIGVycm9yIG9mIGVhY2ggc29sdXRpb24gdmVjdG9yIFgoaikKICAgIChpLmUuLCB0aGUgc21hbGxl\nc3QgcmVsYXRpdmUgY2hhbmdlIGluIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0CiAgICBtYWtl\ncyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW2luXSBOX0VSUl9CTkRTCiAgICAgICAg\nIE5fRVJSX0JORFMgaXMgSU5URUdFUgogICAgTnVtYmVyIG9mIGVycm9yIGJvdW5kcyB0byByZXR1\ncm4gZm9yIGVhY2ggcmlnaHQgaGFuZCBzaWRlCiAgICBhbmQgZWFjaCB0eXBlIChub3Jtd2lzZSBv\nciBjb21wb25lbnR3aXNlKS4gIFNlZSBFUlJfQk5EU19OT1JNIGFuZAogICAgRVJSX0JORFNfQ09N\nUCBiZWxvdy4KXHBhcmFtW291dF0gRVJSX0JORFNfTk9STQogICAgICAgICBFUlJfQk5EU19OT1JN\nIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUywgTl9FUlJfQk5EUykK\nICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhpcyBhcnJheSBjb250YWlucyBpbmZvcm1h\ndGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3VuZHMgYW5kIGNvbmRpdGlvbiBudW1iZXJz\nIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBub3Jtd2lzZSByZWxhdGl2ZSBlcnJvciwgd2hpY2gg\naXMgZGVmaW5lZCBhcyBmb2xsb3dzOgogICAgTm9ybXdpc2UgcmVsYXRpdmUgZXJyb3IgaW4gdGhl\nIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAgICAgICAgIG1heF9qIChhYnMoWFRSVUUoaixpKSAt\nIFgoaixpKSkpCiAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgICAg\nICAgICAgICAgICAgbWF4X2ogYWJzKFgoaixpKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5\nIHRoZSB0eXBlIG9mIGVycm9yIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZAogICAgYmVsb3cuIFRo\nZXJlIGN1cnJlbnRseSBhcmUgdXAgdG8gdGhyZWUgcGllY2VzIG9mIGluZm9ybWF0aW9uCiAgICBy\nZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKGksOikgY29ycmVz\ncG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQtaGFuZCBzaWRlLgogICAgVGhlIHNlY29uZCBpbmRl\neCBpbiBFUlJfQk5EU19OT1JNKDosZXJyKSBjb250YWlucyB0aGUgZm9sbG93aW5nCiAgICB0aHJl\nZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVzdC9kb24ndCB0cnVzdCIgYm9vbGVhbi4gVHJ1c3Qg\ndGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJl\nciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1j\naCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAiR3VhcmFudGVlZCIgZXJyb3IgYm91bmQ6IFRoZSBl\nc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAgICAgICAgICAgIGFsbW9zdCBjZXJ0YWlubHkgd2l0\naGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9yCiAgICAgICAgICAgICBzbyBsb25n\nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkCiAgICAgICAg\nICAgICBzcXJ0KG4pICogZGxhbWNoKCdFcHNpbG9uJykuIFRoaXMgZXJyb3IgYm91bmQgc2hvdWxk\nIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0ZWQgaWYgdGhlIHByZXZpb3VzIGJvb2xlYW4gaXMg\ndHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlcjogRXN0aW1hdGVk\nIG5vcm13aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIuICBDb21w\nYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBkbGFtY2goJ0Vw\nc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAgICBlc3RpbWF0ZSBp\ncyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAgICAgICAgICAgICBu\ndW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5mKSkgZm9yIHNvbWUK\nICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgogICAgICAgICAgICAg\nTGV0IFogPSBTKkEsIHdoZXJlIFMgc2NhbGVzIGVhY2ggcm93IGJ5IGEgcG93ZXIgb2YgdGhlCiAg\nICAgICAgICAgICByYWRpeCBzbyBhbGwgYWJzb2x1dGUgcm93IHN1bXMgb2YgWiBhcmUgYXBwcm94\naW1hdGVseSAxLgogICAgU2VlIExhcGFjayBXb3JraW5nIE5vdGUgMTY1IGZvciBmdXJ0aGVyIGRl\ndGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4KXHBhcmFtW291dF0gRVJSX0JORFNfQ09NUAog\nICAgICAgICBFUlJfQk5EU19DT01QIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lv\nbiAoTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhpcyBh\ncnJheSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3VuZHMg\nYW5kIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBjb21wb25lbnR3\naXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFzIGZvbGxvd3M6CiAgICBDb21w\nb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGluIHRoZSBpdGggc29sdXRpb24gdmVjdG9yOgogICAg\nICAgICAgICAgICAgICAgYWJzKFhUUlVFKGosaSkgLSBYKGosaSkpCiAgICAgICAgICAgIG1heF9q\nIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAgICAgICAgICAgYWJzKFgoaixp\nKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSByaWdodC1oYW5kIHNpZGUgaSAob24g\nd2hpY2ggdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGRlcGVuZHMpLCBhbmQg\ndGhlIHR5cGUgb2YgZXJyb3IKICAgIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZCBiZWxvdy4gVGhl\ncmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZQogICAgcGllY2VzIG9mIGluZm9ybWF0aW9uIHJl\ndHVybmVkIGZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZS4gSWYKICAgIGNvbXBvbmVudHdpc2UgYWNj\ndXJhY3kgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1TKDMpID0gMC4wKSwgdGhlbgogICAgRVJSX0JO\nRFNfQ09NUCBpcyBub3QgYWNjZXNzZWQuICBJZiBOX0VSUl9CTkRTIC5MVC4gMywgdGhlbiBhdCBt\nb3N0CiAgICB0aGUgZmlyc3QgKDosTl9FUlJfQk5EUykgZW50cmllcyBhcmUgcmV0dXJuZWQuCiAg\nICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfQ09NUChpLDopIGNvcnJlc3BvbmRzIHRvIHRo\nZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBzZWNvbmQgaW5kZXggaW4gRVJSX0JO\nRFNfQ09NUCg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2luZwogICAgdGhyZWUgZmllbGRzOgog\nICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xlYW4uIFRydXN0IHRoZSBhbnN3ZXIg\naWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIgaXMgbGVzcyB0\naGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBkbGFtY2goJ0Vwc2lsb24n\nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJvdW5kOiBUaGUgZXN0aW1hdGVkIGZv\ncndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2VydGFpbmx5IHdpdGhpbiBhIGZhY3Rv\nciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAgICAgc28gbG9uZyBhcyB0aGUgbmV4\ndCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChu\nKSAqIGRsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJvdW5kIHNob3VsZCBvbmx5CiAgICAg\nICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBib29sZWFuIGlzIHRydWUuCiAgICBl\ncnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6IEVzdGltYXRlZCBjb21wb25lbnR3\naXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIuICBDb21wYXJlZCB3\naXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBkbGFtY2goJ0Vwc2lsb24n\nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAgICBlc3RpbWF0ZSBpcyAiZ3Vh\ncmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAgICAgICAgICAgICBudW1iZXJz\nIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5mKSkgZm9yIHNvbWUKICAgICAg\nICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgogICAgICAgICAgICAgTGV0IFog\nPSBTKihBKmRpYWcoeCkpLCB3aGVyZSB4IGlzIHRoZSBzb2x1dGlvbiBmb3IgdGhlCiAgICAgICAg\nICAgICBjdXJyZW50IHJpZ2h0LWhhbmQgc2lkZSBhbmQgUyBzY2FsZXMgZWFjaCByb3cgb2YKICAg\nICAgICAgICAgIEEqZGlhZyh4KSBieSBhIHBvd2VyIG9mIHRoZSByYWRpeCBzbyBhbGwgYWJzb2x1\ndGUgcm93CiAgICAgICAgICAgICBzdW1zIG9mIFogYXJlIGFwcHJveGltYXRlbHkgMS4KICAgIFNl\nZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhlciBkZXRhaWxzIGFuZCBleHRyYQog\nICAgY2F1dGlvbnMuClxwYXJhbVtpbl0gTlBBUkFNUwogICAgICAgICBOUEFSQU1TIGlzIElOVEVH\nRVIKICAgIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgc2V0IGluIFBBUkFNUy4g\nIElmIC5MRS4gMCwgdGhlCiAgICBQQVJBTVMgYXJyYXkgaXMgbmV2ZXIgcmVmZXJlbmNlZCBhbmQg\nZGVmYXVsdCB2YWx1ZXMgYXJlIHVzZWQuClxwYXJhbVtpbixvdXRdIFBBUkFNUwogICAgICAgICBQ\nQVJBTVMgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUEFSQU1TKQogICAg\nU3BlY2lmaWVzIGFsZ29yaXRobSBwYXJhbWV0ZXJzLiAgSWYgYW4gZW50cnkgaXMgLkxULiAwLjAs\nIHRoZW4KICAgIHRoYXQgZW50cnkgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZWZhdWx0IHZhbHVlIHVz\nZWQgZm9yIHRoYXQKICAgIHBhcmFtZXRlci4gIE9ubHkgcG9zaXRpb25zIHVwIHRvIE5QQVJBTVMg\nYXJlIGFjY2Vzc2VkOyBkZWZhdWx0cwogICAgYXJlIHVzZWQgZm9yIGhpZ2hlci1udW1iZXJlZCBw\nYXJhbWV0ZXJzLgogICAgICBQQVJBTVMoTEFfTElOUlhfSVRSRUZfSSA9IDEpIDogV2hldGhlciB0\nbyBwZXJmb3JtIGl0ZXJhdGl2ZQogICAgICAgICAgIHJlZmluZW1lbnQgb3Igbm90LgogICAgICAg\nIERlZmF1bHQ6IDEuMEQrMAogICAgICAgICAgID0gMC4wIDogTm8gcmVmaW5lbWVudCBpcyBwZXJm\nb3JtZWQsIGFuZCBubyBlcnJvciBib3VuZHMgYXJlCiAgICAgICAgICAgICAgICAgICBjb21wdXRl\nZC4KICAgICAgICAgICA9IDEuMCA6IFVzZSB0aGUgZG91YmxlLXByZWNpc2lvbiByZWZpbmVtZW50\nIGFsZ29yaXRobSwKICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5IHdpdGggZG91YmxlZC1zaW5n\nbGUgY29tcHV0YXRpb25zIGlmIHRoZQogICAgICAgICAgICAgICAgICAgY29tcGlsYXRpb24gZW52\naXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBET1VCTEUKICAgICAgICAgICAgICAgICAgIFBSRUNJ\nU0lPTi4KICAgICAgICAgICAgIChvdGhlciB2YWx1ZXMgYXJlIHJlc2VydmVkIGZvciBmdXR1cmUg\ndXNlKQogICAgICBQQVJBTVMoTEFfTElOUlhfSVRIUkVTSF9JID0gMikgOiBNYXhpbXVtIG51bWJl\nciBvZiByZXNpZHVhbAogICAgICAgICAgIGNvbXB1dGF0aW9ucyBhbGxvd2VkIGZvciByZWZpbmVt\nZW50LgogICAgICAgIERlZmF1bHQ6IDEwCiAgICAgICAgQWdncmVzc2l2ZTogU2V0IHRvIDEwMCB0\nbyBwZXJtaXQgY29udmVyZ2VuY2UgdXNpbmcgYXBwcm94aW1hdGUKICAgICAgICAgICAgICAgICAg\nICBmYWN0b3JpemF0aW9ucyBvciBmYWN0b3JpemF0aW9ucyBvdGhlciB0aGFuIExVLiBJZgogICAg\nICAgICAgICAgICAgICAgIHRoZSBmYWN0b3JpemF0aW9uIHVzZXMgYSB0ZWNobmlxdWUgb3RoZXIg\ndGhhbgogICAgICAgICAgICAgICAgICAgIEdhdXNzaWFuIGVsaW1pbmF0aW9uLCB0aGUgZ3VhcmFu\ndGVlcyBpbgogICAgICAgICAgICAgICAgICAgIGVycl9ibmRzX25vcm0gYW5kIGVycl9ibmRzX2Nv\nbXAgbWF5IG5vIGxvbmdlciBiZQogICAgICAgICAgICAgICAgICAgIHRydXN0d29ydGh5LgogICAg\nICBQQVJBTVMoTEFfTElOUlhfQ1dJU0VfSSA9IDMpIDogRmxhZyBkZXRlcm1pbmluZyBpZiB0aGUg\nY29kZQogICAgICAgICAgIHdpbGwgYXR0ZW1wdCB0byBmaW5kIGEgc29sdXRpb24gd2l0aCBzbWFs\nbCBjb21wb25lbnR3aXNlCiAgICAgICAgICAgcmVsYXRpdmUgZXJyb3IgaW4gdGhlIGRvdWJsZS1w\ncmVjaXNpb24gYWxnb3JpdGhtLiAgUG9zaXRpdmUKICAgICAgICAgICBpcyB0cnVlLCAwLjAgaXMg\nZmFsc2UuCiAgICAgICAgRGVmYXVsdDogMS4wIChhdHRlbXB0IGNvbXBvbmVudHdpc2UgY29udmVy\nZ2VuY2UpClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBET1VCTEUgUFJFQ0lTSU9O\nIGFycmF5LCBkaW1lbnNpb24gKDQqTikKXHBhcmFtW291dF0gSVdPUksKICAgICAgICAgSVdPUksg\naXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAg\nIElORk8gaXMgSU5URUdFUgogICAgICA9IDA6ICBTdWNjZXNzZnVsIGV4aXQuIFRoZSBzb2x1dGlv\nbiB0byBldmVyeSByaWdodC1oYW5kIHNpZGUgaXMKICAgICAgICBndWFyYW50ZWVkLgogICAgICA8\nIDA6ICBJZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVl\nCiAgICAgID4gMCBhbmQgPD0gTjogIFUoSU5GTyxJTkZPKSBpcyBleGFjdGx5IHplcm8uICBUaGUg\nZmFjdG9yaXphdGlvbgogICAgICAgIGhhcyBiZWVuIGNvbXBsZXRlZCwgYnV0IHRoZSBmYWN0b3Ig\nVSBpcyBleGFjdGx5IHNpbmd1bGFyLCBzbwogICAgICAgIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3Ig\nYm91bmRzIGNvdWxkIG5vdCBiZSBjb21wdXRlZC4gUkNPTkQgPSAwCiAgICAgICAgaXMgcmV0dXJu\nZWQuCiAgICAgID0gTitKOiBUaGUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgSnRoIHJp\nZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIG5vdCBndWFyYW50ZWVkLiBUaGUgc29sdXRpb25zIGNv\ncnJlc3BvbmRpbmcgdG8gb3RoZXIgcmlnaHQtCiAgICAgICAgaGFuZCBzaWRlcyBLIHdpdGggSyA+\nIEogbWF5IG5vdCBiZSBndWFyYW50ZWVkIGFzIHdlbGwsIGJ1dAogICAgICAgIG9ubHkgdGhlIGZp\ncnN0IHN1Y2ggcmlnaHQtaGFuZCBzaWRlIGlzIHJlcG9ydGVkLiBJZiBhIHNtYWxsCiAgICAgICAg\nY29tcG9uZW50d2lzZSBlcnJvciBpcyBub3QgcmVxdWVzdGVkIChQQVJBTVMoMykgPSAwLjApIHRo\nZW4KICAgICAgICB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcyB0aGUgZmlyc3Qgd2l0aCBhIG5v\ncm13aXNlIGVycm9yCiAgICAgICAgYm91bmQgdGhhdCBpcyBub3QgZ3VhcmFudGVlZCAodGhlIHNt\nYWxsZXN0IEogc3VjaAogICAgICAgIHRoYXQgRVJSX0JORFNfTk9STShKLDEpID0gMC4wKS4gQnkg\nZGVmYXVsdCAoUEFSQU1TKDMpID0gMS4wKQogICAgICAgIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRl\nIGlzIHRoZSBmaXJzdCB3aXRoIGVpdGhlciBhIG5vcm13aXNlIG9yCiAgICAgICAgY29tcG9uZW50\nd2lzZSBlcnJvciBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50ZWVkICh0aGUgc21hbGxlc3QKICAg\nICAgICBKIHN1Y2ggdGhhdCBlaXRoZXIgRVJSX0JORFNfTk9STShKLDEpID0gMC4wIG9yCiAgICAg\nICAgRVJSX0JORFNfQ09NUChKLDEpID0gMC4wKS4gU2VlIHRoZSBkZWZpbml0aW9uIG9mCiAgICAg\nICAgRVJSX0JORFNfTk9STSg6LDEpIGFuZCBFUlJfQk5EU19DT01QKDosMSkuIFRvIGdldCBpbmZv\ncm1hdGlvbgogICAgICAgIGFib3V0IGFsbCBvZiB0aGUgcmlnaHQtaGFuZCBzaWRlcyBjaGVjayBF\nUlJfQk5EU19OT1JNIG9yCiAgICAgICAgRVJSX0JORFNfQ09NUC4KQXV0aG9yczoKXGF1dGhvciBV\nbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBCZXJrZWxleSAK\nXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0ZC4gClxkYXRl\nIEFwcmlsIDIwMTIKXGluZ3JvdXAgZG91YmxlR0Jjb21wdXRhdGlvbmFsCmgdaB4pgXL3AQAAfXL4\nAQAAKGghiWgiaCN1YmgtigKgAWguWA8AAABkZ2JyZnN4XzQxNi50eHR1YmgvigKgAWgwWAYAAABn\nYnJmc3hoLYoBOnViaBVoFl1oF4dScvkBAAB9cvoBAAAoaBpYBwAAAGdlbmVyYWxoG1gEAAAAYmFu\nZGgcWEYAAABlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlczsgaXRlcmF0\naXZlIHJlZmluZW1lbnQ7IEVRVUVEaB1oHimBcvsBAAB9cvwBAAAoaCGJaCJoI3ViaCRYIQAAAERv\neHlnZW4vZG9jcy9odG1sL2NnYnJmc3hfOGYuaHRtbGglWAEAAABjaCZoFWgnXWgXh1Jy/QEAAH1y\n/gEAAChoKlh+NgAAICAgQ0dCUkZTWCBpbXByb3ZlcyB0aGUgY29tcHV0ZWQgc29sdXRpb24gdG8g\nYSBzeXN0ZW0gb2YgbGluZWFyCiAgIGVxdWF0aW9ucyBhbmQgcHJvdmlkZXMgZXJyb3IgYm91bmRz\nIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMKICAgZm9yIHRoZSBzb2x1dGlvbi4gIEluIGFk\nZGl0aW9uIHRvIG5vcm13aXNlIGVycm9yIGJvdW5kLCB0aGUgY29kZQogICBwcm92aWRlcyBtYXhp\nbXVtIGNvbXBvbmVudHdpc2UgZXJyb3IgYm91bmQgaWYgcG9zc2libGUuICBTZWUKICAgY29tbWVu\ndHMgZm9yIEVSUl9CTkRTX05PUk0gYW5kIEVSUl9CTkRTX0NPTVAgZm9yIGRldGFpbHMgb2YgdGhl\nCiAgIGVycm9yIGJvdW5kcy4KICAgVGhlIG9yaWdpbmFsIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRp\nb25zIG1heSBoYXZlIGJlZW4gZXF1aWxpYnJhdGVkCiAgIGJlZm9yZSBjYWxsaW5nIHRoaXMgcm91\ndGluZSwgYXMgZGVzY3JpYmVkIGJ5IGFyZ3VtZW50cyBFUVVFRCwgUgogICBhbmQgQyBiZWxvdy4g\nSW4gdGhpcyBjYXNlLCB0aGUgc29sdXRpb24gYW5kIGVycm9yIGJvdW5kcyByZXR1cm5lZAogICBh\ncmUgZm9yIHRoZSBvcmlnaW5hbCB1bmVxdWlsaWJyYXRlZCBzeXN0ZW0uCkFyZ3VtZW50czoKICAg\nIFNvbWUgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgYnVuZGxlZCBpbiB0aGUgUEFSQU1TIGFycmF5\nLiAgVGhlc2UKICAgIHNldHRpbmdzIGRldGVybWluZSBob3cgcmVmaW5lbWVudCBpcyBwZXJmb3Jt\nZWQsIGJ1dCBvZnRlbiB0aGUKICAgIGRlZmF1bHRzIGFyZSBhY2NlcHRhYmxlLiAgSWYgdGhlIGRl\nZmF1bHRzIGFyZSBhY2NlcHRhYmxlLCB1c2VycwogICAgY2FuIHBhc3MgTlBBUkFNUyA9IDAgd2hp\nY2ggcHJldmVudHMgdGhlIHNvdXJjZSBjb2RlIGZyb20gYWNjZXNzaW5nCiAgICB0aGUgUEFSQU1T\nIGFyZ3VtZW50LgpccGFyYW1baW5dIFRSQU5TCiAgICAgICAgIFRSQU5TIGlzIENIQVJBQ1RFUiox\nCiAgICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgdGhlIHN5c3RlbSBvZiBlcXVhdGlvbnM6CiAgICAg\nID0gJ04nOiAgQSAqIFggPSBCICAgICAoTm8gdHJhbnNwb3NlKQogICAgICA9ICdUJzogIEEqKlQg\nKiBYID0gQiAgKFRyYW5zcG9zZSkKICAgICAgPSAnQyc6ICBBKipIICogWCA9IEIgIChDb25qdWdh\ndGUgdHJhbnNwb3NlID0gVHJhbnNwb3NlKQpccGFyYW1baW5dIEVRVUVECiAgICAgICAgIEVRVUVE\nIGlzIENIQVJBQ1RFUioxCiAgICBTcGVjaWZpZXMgdGhlIGZvcm0gb2YgZXF1aWxpYnJhdGlvbiB0\naGF0IHdhcyBkb25lIHRvIEEKICAgIGJlZm9yZSBjYWxsaW5nIHRoaXMgcm91dGluZS4gVGhpcyBp\ncyBuZWVkZWQgdG8gY29tcHV0ZQogICAgdGhlIHNvbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgY29y\ncmVjdGx5LgogICAgICA9ICdOJzogIE5vIGVxdWlsaWJyYXRpb24KICAgICAgPSAnUic6ICBSb3cg\nZXF1aWxpYnJhdGlvbiwgaS5lLiwgQSBoYXMgYmVlbiBwcmVtdWx0aXBsaWVkIGJ5CiAgICAgICAg\nICAgICAgZGlhZyhSKS4KICAgICAgPSAnQyc6ICBDb2x1bW4gZXF1aWxpYnJhdGlvbiwgaS5lLiwg\nQSBoYXMgYmVlbiBwb3N0bXVsdGlwbGllZAogICAgICAgICAgICAgIGJ5IGRpYWcoQykuCiAgICAg\nID0gJ0InOiAgQm90aCByb3cgYW5kIGNvbHVtbiBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBi\nZWVuCiAgICAgICAgICAgICAgcmVwbGFjZWQgYnkgZGlhZyhSKSAqIEEgKiBkaWFnKEMpLgogICAg\nICAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgQiBoYXMgYmVlbiBjaGFuZ2VkIGFjY29yZGlu\nZ2x5LgpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICBUaGUgb3JkZXIgb2Yg\ndGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIEtMCiAgICAgICAgIEtMIGlzIElOVEVH\nRVIKICAgIFRoZSBudW1iZXIgb2Ygc3ViZGlhZ29uYWxzIHdpdGhpbiB0aGUgYmFuZCBvZiBBLiAg\nS0wgPj0gMC4KXHBhcmFtW2luXSBLVQogICAgICAgICBLVSBpcyBJTlRFR0VSCiAgICBUaGUgbnVt\nYmVyIG9mIHN1cGVyZGlhZ29uYWxzIHdpdGhpbiB0aGUgYmFuZCBvZiBBLiAgS1UgPj0gMC4KXHBh\ncmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgVGhlIG51bWJlciBvZiBy\naWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgIG9mIHRoZSBt\nYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEFCCiAgICAgICAgIEFCIGlz\nIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERBQixOKQogICAgVGhlIG9yaWdpbmFsIGJhbmQg\nbWF0cml4IEEsIHN0b3JlZCBpbiByb3dzIDEgdG8gS0wrS1UrMS4KICAgIFRoZSBqLXRoIGNvbHVt\nbiBvZiBBIGlzIHN0b3JlZCBpbiB0aGUgai10aCBjb2x1bW4gb2YgdGhlCiAgICBhcnJheSBBQiBh\ncyBmb2xsb3dzOgogICAgQUIoa3UrMStpLWosaikgPSBBKGksaikgZm9yIG1heCgxLGota3UpPD1p\nPD1taW4obixqK2tsKS4KXHBhcmFtW2luXSBMREFCCiAgICAgICAgIExEQUIgaXMgSU5URUdFUgog\nICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBQi4gIExEQUIgPj0gS0wrS1Ur\nMS4KXHBhcmFtW2luXSBBRkIKICAgICAgICAgQUZCIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lv\nbiAoTERBRkIsTikKICAgIERldGFpbHMgb2YgdGhlIExVIGZhY3Rvcml6YXRpb24gb2YgdGhlIGJh\nbmQgbWF0cml4IEEsIGFzCiAgICBjb21wdXRlZCBieSBER0JUUkYuICBVIGlzIHN0b3JlZCBhcyBh\nbiB1cHBlciB0cmlhbmd1bGFyIGJhbmQKICAgIG1hdHJpeCB3aXRoIEtMK0tVIHN1cGVyZGlhZ29u\nYWxzIGluIHJvd3MgMSB0byBLTCtLVSsxLCBhbmQKICAgIHRoZSBtdWx0aXBsaWVycyB1c2VkIGR1\ncmluZyB0aGUgZmFjdG9yaXphdGlvbiBhcmUgc3RvcmVkIGluCiAgICByb3dzIEtMK0tVKzIgdG8g\nMipLTCtLVSsxLgpccGFyYW1baW5dIExEQUZCCiAgICAgICAgIExEQUZCIGlzIElOVEVHRVIKICAg\nIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUZCLiAgTERBRkIgPj0gMipLTCpL\nVSsxLgpccGFyYW1baW5dIElQSVYKICAgICAgICAgSVBJViBpcyBJTlRFR0VSIGFycmF5LCBkaW1l\nbnNpb24gKE4pCiAgICBUaGUgcGl2b3QgaW5kaWNlcyBmcm9tIFNHRVRSRjsgZm9yIDE8PWk8PU4s\nIHJvdyBpIG9mIHRoZQogICAgbWF0cml4IHdhcyBpbnRlcmNoYW5nZWQgd2l0aCByb3cgSVBJVihp\nKS4KXHBhcmFtW2luLG91dF0gUgogICAgICAgICBSIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAo\nTikKICAgIFRoZSByb3cgc2NhbGUgZmFjdG9ycyBmb3IgQS4gIElmIEVRVUVEID0gJ1InIG9yICdC\nJywgQSBpcwogICAgbXVsdGlwbGllZCBvbiB0aGUgbGVmdCBieSBkaWFnKFIpOyBpZiBFUVVFRCA9\nICdOJyBvciAnQycsIFIKICAgIGlzIG5vdCBhY2Nlc3NlZC4gIFIgaXMgYW4gaW5wdXQgYXJndW1l\nbnQgaWYgRkFDVCA9ICdGJzsKICAgIG90aGVyd2lzZSwgUiBpcyBhbiBvdXRwdXQgYXJndW1lbnQu\nICBJZiBGQUNUID0gJ0YnIGFuZAogICAgRVFVRUQgPSAnUicgb3IgJ0InLCBlYWNoIGVsZW1lbnQg\nb2YgUiBtdXN0IGJlIHBvc2l0aXZlLgogICAgSWYgUiBpcyBvdXRwdXQsIGVhY2ggZWxlbWVudCBv\nZiBSIGlzIGEgcG93ZXIgb2YgdGhlIHJhZGl4LgogICAgSWYgUiBpcyBpbnB1dCwgZWFjaCBlbGVt\nZW50IG9mIFIgc2hvdWxkIGJlIGEgcG93ZXIgb2YgdGhlIHJhZGl4CiAgICB0byBlbnN1cmUgYSBy\nZWxpYWJsZSBzb2x1dGlvbiBhbmQgZXJyb3IgZXN0aW1hdGVzLiBTY2FsaW5nIGJ5CiAgICBwb3dl\ncnMgb2YgdGhlIHJhZGl4IGRvZXMgbm90IGNhdXNlIHJvdW5kaW5nIGVycm9ycyB1bmxlc3MgdGhl\nCiAgICByZXN1bHQgdW5kZXJmbG93cyBvciBvdmVyZmxvd3MuIFJvdW5kaW5nIGVycm9ycyBkdXJp\nbmcgc2NhbGluZwogICAgbGVhZCB0byByZWZpbmluZyB3aXRoIGEgbWF0cml4IHRoYXQgaXMgbm90\nIGVxdWl2YWxlbnQgdG8gdGhlCiAgICBpbnB1dCBtYXRyaXgsIHByb2R1Y2luZyBlcnJvciBlc3Rp\nbWF0ZXMgdGhhdCBtYXkgbm90IGJlCiAgICByZWxpYWJsZS4KXHBhcmFtW2luLG91dF0gQwogICAg\nICAgICBDIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgIFRoZSBjb2x1bW4gc2NhbGUg\nZmFjdG9ycyBmb3IgQS4gIElmIEVRVUVEID0gJ0MnIG9yICdCJywgQSBpcwogICAgbXVsdGlwbGll\nZCBvbiB0aGUgcmlnaHQgYnkgZGlhZyhDKTsgaWYgRVFVRUQgPSAnTicgb3IgJ1InLCBDCiAgICBp\ncyBub3QgYWNjZXNzZWQuICBDIGlzIGFuIGlucHV0IGFyZ3VtZW50IGlmIEZBQ1QgPSAnRic7CiAg\nICBvdGhlcndpc2UsIEMgaXMgYW4gb3V0cHV0IGFyZ3VtZW50LiAgSWYgRkFDVCA9ICdGJyBhbmQK\nICAgIEVRVUVEID0gJ0MnIG9yICdCJywgZWFjaCBlbGVtZW50IG9mIEMgbXVzdCBiZSBwb3NpdGl2\nZS4KICAgIElmIEMgaXMgb3V0cHV0LCBlYWNoIGVsZW1lbnQgb2YgQyBpcyBhIHBvd2VyIG9mIHRo\nZSByYWRpeC4KICAgIElmIEMgaXMgaW5wdXQsIGVhY2ggZWxlbWVudCBvZiBDIHNob3VsZCBiZSBh\nIHBvd2VyIG9mIHRoZSByYWRpeAogICAgdG8gZW5zdXJlIGEgcmVsaWFibGUgc29sdXRpb24gYW5k\nIGVycm9yIGVzdGltYXRlcy4gU2NhbGluZyBieQogICAgcG93ZXJzIG9mIHRoZSByYWRpeCBkb2Vz\nIG5vdCBjYXVzZSByb3VuZGluZyBlcnJvcnMgdW5sZXNzIHRoZQogICAgcmVzdWx0IHVuZGVyZmxv\nd3Mgb3Igb3ZlcmZsb3dzLiBSb3VuZGluZyBlcnJvcnMgZHVyaW5nIHNjYWxpbmcKICAgIGxlYWQg\ndG8gcmVmaW5pbmcgd2l0aCBhIG1hdHJpeCB0aGF0IGlzIG5vdCBlcXVpdmFsZW50IHRvIHRoZQog\nICAgaW5wdXQgbWF0cml4LCBwcm9kdWNpbmcgZXJyb3IgZXN0aW1hdGVzIHRoYXQgbWF5IG5vdCBi\nZQogICAgcmVsaWFibGUuClxwYXJhbVtpbl0gQgogICAgICAgICBCIGlzIENPTVBMRVggYXJyYXks\nIGRpbWVuc2lvbiAoTERCLE5SSFMpCiAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpc\ncGFyYW1baW5dIExEQgogICAgICAgICBMREIgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGlt\nZW5zaW9uIG9mIHRoZSBhcnJheSBCLiAgTERCID49IG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBY\nCiAgICAgICAgIFggaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgIE9u\nIGVudHJ5LCB0aGUgc29sdXRpb24gbWF0cml4IFgsIGFzIGNvbXB1dGVkIGJ5IFNHRVRSUy4KICAg\nIE9uIGV4aXQsIHRoZSBpbXByb3ZlZCBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgK\nICAgICAgICAgTERYIGlzIElOVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUg\nYXJyYXkgWC4gIExEWCA+PSBtYXgoMSxOKS4KXHBhcmFtW291dF0gUkNPTkQKICAgICAgICAgUkNP\nTkQgaXMgUkVBTAogICAgUmVjaXByb2NhbCBzY2FsZWQgY29uZGl0aW9uIG51bWJlci4gIFRoaXMg\naXMgYW4gZXN0aW1hdGUgb2YgdGhlCiAgICByZWNpcHJvY2FsIFNrZWVsIGNvbmRpdGlvbiBudW1i\nZXIgb2YgdGhlIG1hdHJpeCBBIGFmdGVyCiAgICBlcXVpbGlicmF0aW9uIChpZiBkb25lKS4gIElm\nIHRoaXMgaXMgbGVzcyB0aGFuIHRoZSBtYWNoaW5lCiAgICBwcmVjaXNpb24gKGluIHBhcnRpY3Vs\nYXIsIGlmIGl0IGlzIHplcm8pLCB0aGUgbWF0cml4IGlzIHNpbmd1bGFyCiAgICB0byB3b3JraW5n\nIHByZWNpc2lvbi4gIE5vdGUgdGhhdCB0aGUgZXJyb3IgbWF5IHN0aWxsIGJlIHNtYWxsIGV2ZW4K\nICAgIGlmIHRoaXMgbnVtYmVyIGlzIHZlcnkgc21hbGwgYW5kIHRoZSBtYXRyaXggYXBwZWFycyBp\nbGwtCiAgICBjb25kaXRpb25lZC4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIFJF\nQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgIENvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFj\na3dhcmQgZXJyb3IuICBUaGlzIGlzIHRoZQogICAgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBiYWNr\nd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uIHZlY3RvciBYKGopCiAgICAoaS5lLiwgdGhlIHNt\nYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbiBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhhdAogICAg\nbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtpbl0gTl9FUlJfQk5EUwogICAg\nICAgICBOX0VSUl9CTkRTIGlzIElOVEVHRVIKICAgIE51bWJlciBvZiBlcnJvciBib3VuZHMgdG8g\ncmV0dXJuIGZvciBlYWNoIHJpZ2h0IGhhbmQgc2lkZQogICAgYW5kIGVhY2ggdHlwZSAobm9ybXdp\nc2Ugb3IgY29tcG9uZW50d2lzZSkuICBTZWUgRVJSX0JORFNfTk9STSBhbmQKICAgIEVSUl9CTkRT\nX0NPTVAgYmVsb3cuClxwYXJhbVtvdXRdIEVSUl9CTkRTX05PUk0KICAgICAgICAgRVJSX0JORFNf\nTk9STSBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5SSFMsIE5fRVJSX0JORFMpCiAgICBGb3Ig\nZWFjaCByaWdodC1oYW5kIHNpZGUsIHRoaXMgYXJyYXkgY29udGFpbnMgaW5mb3JtYXRpb24gYWJv\ndXQKICAgIHZhcmlvdXMgZXJyb3IgYm91bmRzIGFuZCBjb25kaXRpb24gbnVtYmVycyBjb3JyZXNw\nb25kaW5nIHRvIHRoZQogICAgbm9ybXdpc2UgcmVsYXRpdmUgZXJyb3IsIHdoaWNoIGlzIGRlZmlu\nZWQgYXMgZm9sbG93czoKICAgIE5vcm13aXNlIHJlbGF0aXZlIGVycm9yIGluIHRoZSBpdGggc29s\ndXRpb24gdmVjdG9yOgogICAgICAgICAgICBtYXhfaiAoYWJzKFhUUlVFKGosaSkgLSBYKGosaSkp\nKQogICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICAgICAgICAgICAg\nICAgIG1heF9qIGFicyhYKGosaSkpCiAgICBUaGUgYXJyYXkgaXMgaW5kZXhlZCBieSB0aGUgdHlw\nZSBvZiBlcnJvciBpbmZvcm1hdGlvbiBhcyBkZXNjcmliZWQKICAgIGJlbG93LiBUaGVyZSBjdXJy\nZW50bHkgYXJlIHVwIHRvIHRocmVlIHBpZWNlcyBvZiBpbmZvcm1hdGlvbgogICAgcmV0dXJuZWQu\nCiAgICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfTk9STShpLDopIGNvcnJlc3BvbmRzIHRv\nIHRoZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBzZWNvbmQgaW5kZXggaW4gRVJS\nX0JORFNfTk9STSg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2luZwogICAgdGhyZWUgZmllbGRz\nOgogICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xlYW4uIFRydXN0IHRoZSBhbnN3\nZXIgaWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIgaXMgbGVz\ncyB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2ls\nb24nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJvdW5kOiBUaGUgZXN0aW1hdGVk\nIGZvcndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2VydGFpbmx5IHdpdGhpbiBhIGZh\nY3RvciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAgICAgc28gbG9uZyBhcyB0aGUg\nbmV4dCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3Fy\ndChuKSAqIHNsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJvdW5kIHNob3VsZCBvbmx5CiAg\nICAgICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBib29sZWFuIGlzIHRydWUuCiAg\nICBlcnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6IEVzdGltYXRlZCBub3Jtd2lz\nZQogICAgICAgICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyLiAgQ29tcGFyZWQgd2l0\naCB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykg\ndG8gZGV0ZXJtaW5lIGlmIHRoZSBlcnJvcgogICAgICAgICAgICAgZXN0aW1hdGUgaXMgImd1YXJh\nbnRlZWQiLiBUaGVzZSByZWNpcHJvY2FsIGNvbmRpdGlvbgogICAgICAgICAgICAgbnVtYmVycyBh\ncmUgMSAvIChub3JtKFpeey0xfSxpbmYpICogbm9ybShaLGluZikpIGZvciBzb21lCiAgICAgICAg\nICAgICBhcHByb3ByaWF0ZWx5IHNjYWxlZCBtYXRyaXggWi4KICAgICAgICAgICAgIExldCBaID0g\nUypBLCB3aGVyZSBTIHNjYWxlcyBlYWNoIHJvdyBieSBhIHBvd2VyIG9mIHRoZQogICAgICAgICAg\nICAgcmFkaXggc28gYWxsIGFic29sdXRlIHJvdyBzdW1zIG9mIFogYXJlIGFwcHJveGltYXRlbHkg\nMS4KICAgIFNlZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhlciBkZXRhaWxzIGFu\nZCBleHRyYQogICAgY2F1dGlvbnMuClxwYXJhbVtvdXRdIEVSUl9CTkRTX0NPTVAKICAgICAgICAg\nRVJSX0JORFNfQ09NUCBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE5SSFMsIE5fRVJSX0JORFMp\nCiAgICBGb3IgZWFjaCByaWdodC1oYW5kIHNpZGUsIHRoaXMgYXJyYXkgY29udGFpbnMgaW5mb3Jt\nYXRpb24gYWJvdXQKICAgIHZhcmlvdXMgZXJyb3IgYm91bmRzIGFuZCBjb25kaXRpb24gbnVtYmVy\ncyBjb3JyZXNwb25kaW5nIHRvIHRoZQogICAgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBlcnJvciwg\nd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dzOgogICAgQ29tcG9uZW50d2lzZSByZWxhdGl2ZSBl\ncnJvciBpbiB0aGUgaXRoIHNvbHV0aW9uIHZlY3RvcjoKICAgICAgICAgICAgICAgICAgIGFicyhY\nVFJVRShqLGkpIC0gWChqLGkpKQogICAgICAgICAgICBtYXhfaiAtLS0tLS0tLS0tLS0tLS0tLS0t\nLS0tCiAgICAgICAgICAgICAgICAgICAgICAgIGFicyhYKGosaSkpCiAgICBUaGUgYXJyYXkgaXMg\naW5kZXhlZCBieSB0aGUgcmlnaHQtaGFuZCBzaWRlIGkgKG9uIHdoaWNoIHRoZQogICAgY29tcG9u\nZW50d2lzZSByZWxhdGl2ZSBlcnJvciBkZXBlbmRzKSwgYW5kIHRoZSB0eXBlIG9mIGVycm9yCiAg\nICBpbmZvcm1hdGlvbiBhcyBkZXNjcmliZWQgYmVsb3cuIFRoZXJlIGN1cnJlbnRseSBhcmUgdXAg\ndG8gdGhyZWUKICAgIHBpZWNlcyBvZiBpbmZvcm1hdGlvbiByZXR1cm5lZCBmb3IgZWFjaCByaWdo\ndC1oYW5kIHNpZGUuIElmCiAgICBjb21wb25lbnR3aXNlIGFjY3VyYWN5IGlzIG5vdCByZXF1ZXN0\nZWQgKFBBUkFNUygzKSA9IDAuMCksIHRoZW4KICAgIEVSUl9CTkRTX0NPTVAgaXMgbm90IGFjY2Vz\nc2VkLiAgSWYgTl9FUlJfQk5EUyAuTFQuIDMsIHRoZW4gYXQgbW9zdAogICAgdGhlIGZpcnN0ICg6\nLE5fRVJSX0JORFMpIGVudHJpZXMgYXJlIHJldHVybmVkLgogICAgVGhlIGZpcnN0IGluZGV4IGlu\nIEVSUl9CTkRTX0NPTVAoaSw6KSBjb3JyZXNwb25kcyB0byB0aGUgaXRoCiAgICByaWdodC1oYW5k\nIHNpZGUuCiAgICBUaGUgc2Vjb25kIGluZGV4IGluIEVSUl9CTkRTX0NPTVAoOixlcnIpIGNvbnRh\naW5zIHRoZSBmb2xsb3dpbmcKICAgIHRocmVlIGZpZWxkczoKICAgIGVyciA9IDEgIlRydXN0L2Rv\nbid0IHRydXN0IiBib29sZWFuLiBUcnVzdCB0aGUgYW5zd2VyIGlmIHRoZQogICAgICAgICAgICAg\ncmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdGhyZXNob2xkCiAg\nICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykuCiAgICBlcnIgPSAyICJHdWFy\nYW50ZWVkIiBlcnJvciBib3VuZDogVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9yLAogICAgICAg\nICAgICAgYWxtb3N0IGNlcnRhaW5seSB3aXRoaW4gYSBmYWN0b3Igb2YgMTAgb2YgdGhlIHRydWUg\nZXJyb3IKICAgICAgICAgICAgIHNvIGxvbmcgYXMgdGhlIG5leHQgZW50cnkgaXMgZ3JlYXRlciB0\naGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2lsb24n\nKS4gVGhpcyBlcnJvciBib3VuZCBzaG91bGQgb25seQogICAgICAgICAgICAgYmUgdHJ1c3RlZCBp\nZiB0aGUgcHJldmlvdXMgYm9vbGVhbiBpcyB0cnVlLgogICAgZXJyID0gMyAgUmVjaXByb2NhbCBj\nb25kaXRpb24gbnVtYmVyOiBFc3RpbWF0ZWQgY29tcG9uZW50d2lzZQogICAgICAgICAgICAgcmVj\naXByb2NhbCBjb25kaXRpb24gbnVtYmVyLiAgQ29tcGFyZWQgd2l0aCB0aGUgdGhyZXNob2xkCiAg\nICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykgdG8gZGV0ZXJtaW5lIGlmIHRo\nZSBlcnJvcgogICAgICAgICAgICAgZXN0aW1hdGUgaXMgImd1YXJhbnRlZWQiLiBUaGVzZSByZWNp\ncHJvY2FsIGNvbmRpdGlvbgogICAgICAgICAgICAgbnVtYmVycyBhcmUgMSAvIChub3JtKFpeey0x\nfSxpbmYpICogbm9ybShaLGluZikpIGZvciBzb21lCiAgICAgICAgICAgICBhcHByb3ByaWF0ZWx5\nIHNjYWxlZCBtYXRyaXggWi4KICAgICAgICAgICAgIExldCBaID0gUyooQSpkaWFnKHgpKSwgd2hl\ncmUgeCBpcyB0aGUgc29sdXRpb24gZm9yIHRoZQogICAgICAgICAgICAgY3VycmVudCByaWdodC1o\nYW5kIHNpZGUgYW5kIFMgc2NhbGVzIGVhY2ggcm93IG9mCiAgICAgICAgICAgICBBKmRpYWcoeCkg\nYnkgYSBwb3dlciBvZiB0aGUgcmFkaXggc28gYWxsIGFic29sdXRlIHJvdwogICAgICAgICAgICAg\nc3VtcyBvZiBaIGFyZSBhcHByb3hpbWF0ZWx5IDEuCiAgICBTZWUgTGFwYWNrIFdvcmtpbmcgTm90\nZSAxNjUgZm9yIGZ1cnRoZXIgZGV0YWlscyBhbmQgZXh0cmEKICAgIGNhdXRpb25zLgpccGFyYW1b\naW5dIE5QQVJBTVMKICAgICAgICAgTlBBUkFNUyBpcyBJTlRFR0VSCiAgICBTcGVjaWZpZXMgdGhl\nIG51bWJlciBvZiBwYXJhbWV0ZXJzIHNldCBpbiBQQVJBTVMuICBJZiAuTEUuIDAsIHRoZQogICAg\nUEFSQU1TIGFycmF5IGlzIG5ldmVyIHJlZmVyZW5jZWQgYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSB1\nc2VkLgpccGFyYW1baW4sb3V0XSBQQVJBTVMKICAgICAgICAgUEFSQU1TIGlzIFJFQUwgYXJyYXks\nIGRpbWVuc2lvbiBOUEFSQU1TCiAgICBTcGVjaWZpZXMgYWxnb3JpdGhtIHBhcmFtZXRlcnMuICBJ\nZiBhbiBlbnRyeSBpcyAuTFQuIDAuMCwgdGhlbgogICAgdGhhdCBlbnRyeSB3aWxsIGJlIGZpbGxl\nZCB3aXRoIGRlZmF1bHQgdmFsdWUgdXNlZCBmb3IgdGhhdAogICAgcGFyYW1ldGVyLiAgT25seSBw\nb3NpdGlvbnMgdXAgdG8gTlBBUkFNUyBhcmUgYWNjZXNzZWQ7IGRlZmF1bHRzCiAgICBhcmUgdXNl\nZCBmb3IgaGlnaGVyLW51bWJlcmVkIHBhcmFtZXRlcnMuCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9J\nVFJFRl9JID0gMSkgOiBXaGV0aGVyIHRvIHBlcmZvcm0gaXRlcmF0aXZlCiAgICAgICAgICAgcmVm\naW5lbWVudCBvciBub3QuCiAgICAgICAgRGVmYXVsdDogMS4wCiAgICAgICAgICAgPSAwLjAgOiBO\nbyByZWZpbmVtZW50IGlzIHBlcmZvcm1lZCwgYW5kIG5vIGVycm9yIGJvdW5kcyBhcmUKICAgICAg\nICAgICAgICAgICAgIGNvbXB1dGVkLgogICAgICAgICAgID0gMS4wIDogVXNlIHRoZSBkb3VibGUt\ncHJlY2lzaW9uIHJlZmluZW1lbnQgYWxnb3JpdGhtLAogICAgICAgICAgICAgICAgICAgcG9zc2li\nbHkgd2l0aCBkb3VibGVkLXNpbmdsZSBjb21wdXRhdGlvbnMgaWYgdGhlCiAgICAgICAgICAgICAg\nICAgICBjb21waWxhdGlvbiBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IERPVUJMRQogICAg\nICAgICAgICAgICAgICAgUFJFQ0lTSU9OLgogICAgICAgICAgICAgKG90aGVyIHZhbHVlcyBhcmUg\ncmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UpCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9JVEhSRVNIX0kg\nPSAyKSA6IE1heGltdW0gbnVtYmVyIG9mIHJlc2lkdWFsCiAgICAgICAgICAgY29tcHV0YXRpb25z\nIGFsbG93ZWQgZm9yIHJlZmluZW1lbnQuCiAgICAgICAgRGVmYXVsdDogMTAKICAgICAgICBBZ2dy\nZXNzaXZlOiBTZXQgdG8gMTAwIHRvIHBlcm1pdCBjb252ZXJnZW5jZSB1c2luZyBhcHByb3hpbWF0\nZQogICAgICAgICAgICAgICAgICAgIGZhY3Rvcml6YXRpb25zIG9yIGZhY3Rvcml6YXRpb25zIG90\naGVyIHRoYW4gTFUuIElmCiAgICAgICAgICAgICAgICAgICAgdGhlIGZhY3Rvcml6YXRpb24gdXNl\ncyBhIHRlY2huaXF1ZSBvdGhlciB0aGFuCiAgICAgICAgICAgICAgICAgICAgR2F1c3NpYW4gZWxp\nbWluYXRpb24sIHRoZSBndWFyYW50ZWVzIGluCiAgICAgICAgICAgICAgICAgICAgZXJyX2JuZHNf\nbm9ybSBhbmQgZXJyX2JuZHNfY29tcCBtYXkgbm8gbG9uZ2VyIGJlCiAgICAgICAgICAgICAgICAg\nICAgdHJ1c3R3b3J0aHkuCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9DV0lTRV9JID0gMykgOiBGbGFn\nIGRldGVybWluaW5nIGlmIHRoZSBjb2RlCiAgICAgICAgICAgd2lsbCBhdHRlbXB0IHRvIGZpbmQg\nYSBzb2x1dGlvbiB3aXRoIHNtYWxsIGNvbXBvbmVudHdpc2UKICAgICAgICAgICByZWxhdGl2ZSBl\ncnJvciBpbiB0aGUgZG91YmxlLXByZWNpc2lvbiBhbGdvcml0aG0uICBQb3NpdGl2ZQogICAgICAg\nICAgIGlzIHRydWUsIDAuMCBpcyBmYWxzZS4KICAgICAgICBEZWZhdWx0OiAxLjAgKGF0dGVtcHQg\nY29tcG9uZW50d2lzZSBjb252ZXJnZW5jZSkKXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JL\nIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBSV09SSwogICAg\nICAgICBSV09SSyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0gSU5G\nTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgPSAwOiAgU3VjY2Vzc2Z1bCBleGl0LiBU\naGUgc29sdXRpb24gdG8gZXZlcnkgcmlnaHQtaGFuZCBzaWRlIGlzCiAgICAgICAgZ3VhcmFudGVl\nZC4KICAgICAgPCAwOiAgSWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4gaWxs\nZWdhbCB2YWx1ZQogICAgICA+IDAgYW5kIDw9IE46ICBVKElORk8sSU5GTykgaXMgZXhhY3RseSB6\nZXJvLiAgVGhlIGZhY3Rvcml6YXRpb24KICAgICAgICBoYXMgYmVlbiBjb21wbGV0ZWQsIGJ1dCB0\naGUgZmFjdG9yIFUgaXMgZXhhY3RseSBzaW5ndWxhciwgc28KICAgICAgICB0aGUgc29sdXRpb24g\nYW5kIGVycm9yIGJvdW5kcyBjb3VsZCBub3QgYmUgY29tcHV0ZWQuIFJDT05EID0gMAogICAgICAg\nIGlzIHJldHVybmVkLgogICAgICA9IE4rSjogVGhlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcgdG8g\ndGhlIEp0aCByaWdodC1oYW5kIHNpZGUgaXMKICAgICAgICBub3QgZ3VhcmFudGVlZC4gVGhlIHNv\nbHV0aW9ucyBjb3JyZXNwb25kaW5nIHRvIG90aGVyIHJpZ2h0LQogICAgICAgIGhhbmQgc2lkZXMg\nSyB3aXRoIEsgPiBKIG1heSBub3QgYmUgZ3VhcmFudGVlZCBhcyB3ZWxsLCBidXQKICAgICAgICBv\nbmx5IHRoZSBmaXJzdCBzdWNoIHJpZ2h0LWhhbmQgc2lkZSBpcyByZXBvcnRlZC4gSWYgYSBzbWFs\nbAogICAgICAgIGNvbXBvbmVudHdpc2UgZXJyb3IgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1TKDMp\nID0gMC4wKSB0aGVuCiAgICAgICAgdGhlIEp0aCByaWdodC1oYW5kIHNpZGUgaXMgdGhlIGZpcnN0\nIHdpdGggYSBub3Jtd2lzZSBlcnJvcgogICAgICAgIGJvdW5kIHRoYXQgaXMgbm90IGd1YXJhbnRl\nZWQgKHRoZSBzbWFsbGVzdCBKIHN1Y2gKICAgICAgICB0aGF0IEVSUl9CTkRTX05PUk0oSiwxKSA9\nIDAuMCkuIEJ5IGRlZmF1bHQgKFBBUkFNUygzKSA9IDEuMCkKICAgICAgICB0aGUgSnRoIHJpZ2h0\nLWhhbmQgc2lkZSBpcyB0aGUgZmlyc3Qgd2l0aCBlaXRoZXIgYSBub3Jtd2lzZSBvcgogICAgICAg\nIGNvbXBvbmVudHdpc2UgZXJyb3IgYm91bmQgdGhhdCBpcyBub3QgZ3VhcmFudGVlZCAodGhlIHNt\nYWxsZXN0CiAgICAgICAgSiBzdWNoIHRoYXQgZWl0aGVyIEVSUl9CTkRTX05PUk0oSiwxKSA9IDAu\nMCBvcgogICAgICAgIEVSUl9CTkRTX0NPTVAoSiwxKSA9IDAuMCkuIFNlZSB0aGUgZGVmaW5pdGlv\nbiBvZgogICAgICAgIEVSUl9CTkRTX05PUk0oOiwxKSBhbmQgRVJSX0JORFNfQ09NUCg6LDEpLiBU\nbyBnZXQgaW5mb3JtYXRpb24KICAgICAgICBhYm91dCBhbGwgb2YgdGhlIHJpZ2h0LWhhbmQgc2lk\nZXMgY2hlY2sgRVJSX0JORFNfTk9STSBvcgogICAgICAgIEVSUl9CTkRTX0NPTVAuCkF1dGhvcnM6\nClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3JuaWEg\nQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5BRyBM\ndGQuIApcZGF0ZSBBcHJpbCAyMDEyClxpbmdyb3VwIGNvbXBsZXhHQmNvbXB1dGF0aW9uYWwKaB1o\nHimBcv8BAAB9cgACAAAoaCGJaCJoI3ViaC2KAqEBaC5YDwAAAGNnYnJmc3hfNDE3LnR4dHViaC+K\nAqEBaDBYBgAAAGdicmZzeGgtigE7dWJoFWgWXWgXh1JyAQIAAH1yAgIAAChoGlgHAAAAZ2VuZXJh\nbGgbWAQAAABiYW5kaBxYRgAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1h\ndGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudDsgRVFVRURoHWgeKYFyAwIAAH1yBAIAAChoIYloImgj\ndWJoJFghAAAARG94eWdlbi9kb2NzL2h0bWwvemdicmZzeF84Zi5odG1saCVYAQAAAHpoJmgVaCdd\naBeHUnIFAgAAfXIGAgAAKGgqWPI2AAAgICBaR0JSRlNYIGltcHJvdmVzIHRoZSBjb21wdXRlZCBz\nb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKICAgZXF1YXRpb25zIGFuZCBwcm92aWRlcyBl\ncnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcwogICBmb3IgdGhlIHNvbHV0\naW9uLiAgSW4gYWRkaXRpb24gdG8gbm9ybXdpc2UgZXJyb3IgYm91bmQsIHRoZSBjb2RlCiAgIHBy\nb3ZpZGVzIG1heGltdW0gY29tcG9uZW50d2lzZSBlcnJvciBib3VuZCBpZiBwb3NzaWJsZS4gIFNl\nZQogICBjb21tZW50cyBmb3IgRVJSX0JORFNfTk9STSBhbmQgRVJSX0JORFNfQ09NUCBmb3IgZGV0\nYWlscyBvZiB0aGUKICAgZXJyb3IgYm91bmRzLgogICBUaGUgb3JpZ2luYWwgc3lzdGVtIG9mIGxp\nbmVhciBlcXVhdGlvbnMgbWF5IGhhdmUgYmVlbiBlcXVpbGlicmF0ZWQKICAgYmVmb3JlIGNhbGxp\nbmcgdGhpcyByb3V0aW5lLCBhcyBkZXNjcmliZWQgYnkgYXJndW1lbnRzIEVRVUVELCBSCiAgIGFu\nZCBDIGJlbG93LiBJbiB0aGlzIGNhc2UsIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIHJl\ndHVybmVkCiAgIGFyZSBmb3IgdGhlIG9yaWdpbmFsIHVuZXF1aWxpYnJhdGVkIHN5c3RlbS4KQXJn\ndW1lbnRzOgogICAgU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzIGFyZSBidW5kbGVkIGluIHRoZSBQ\nQVJBTVMgYXJyYXkuICBUaGVzZQogICAgc2V0dGluZ3MgZGV0ZXJtaW5lIGhvdyByZWZpbmVtZW50\nIGlzIHBlcmZvcm1lZCwgYnV0IG9mdGVuIHRoZQogICAgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUu\nICBJZiB0aGUgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUsIHVzZXJzCiAgICBjYW4gcGFzcyBOUEFS\nQU1TID0gMCB3aGljaCBwcmV2ZW50cyB0aGUgc291cmNlIGNvZGUgZnJvbSBhY2Nlc3NpbmcKICAg\nIHRoZSBQQVJBTVMgYXJndW1lbnQuClxwYXJhbVtpbl0gVFJBTlMKICAgICAgICAgVFJBTlMgaXMg\nQ0hBUkFDVEVSKjEKICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiB0aGUgc3lzdGVtIG9mIGVxdWF0\naW9uczoKICAgICAgPSAnTic6ICBBICogWCA9IEIgICAgIChObyB0cmFuc3Bvc2UpCiAgICAgID0g\nJ1QnOiAgQSoqVCAqIFggPSBCICAoVHJhbnNwb3NlKQogICAgICA9ICdDJzogIEEqKkggKiBYID0g\nQiAgKENvbmp1Z2F0ZSB0cmFuc3Bvc2UgPSBUcmFuc3Bvc2UpClxwYXJhbVtpbl0gRVFVRUQKICAg\nICAgICAgRVFVRUQgaXMgQ0hBUkFDVEVSKjEKICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiBlcXVp\nbGlicmF0aW9uIHRoYXQgd2FzIGRvbmUgdG8gQQogICAgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0\naW5lLiBUaGlzIGlzIG5lZWRlZCB0byBjb21wdXRlCiAgICB0aGUgc29sdXRpb24gYW5kIGVycm9y\nIGJvdW5kcyBjb3JyZWN0bHkuCiAgICAgID0gJ04nOiAgTm8gZXF1aWxpYnJhdGlvbgogICAgICA9\nICdSJzogIFJvdyBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBiZWVuIHByZW11bHRpcGxpZWQg\nYnkKICAgICAgICAgICAgICBkaWFnKFIpLgogICAgICA9ICdDJzogIENvbHVtbiBlcXVpbGlicmF0\naW9uLCBpLmUuLCBBIGhhcyBiZWVuIHBvc3RtdWx0aXBsaWVkCiAgICAgICAgICAgICAgYnkgZGlh\nZyhDKS4KICAgICAgPSAnQic6ICBCb3RoIHJvdyBhbmQgY29sdW1uIGVxdWlsaWJyYXRpb24sIGku\nZS4sIEEgaGFzIGJlZW4KICAgICAgICAgICAgICByZXBsYWNlZCBieSBkaWFnKFIpICogQSAqIGRp\nYWcoQykuCiAgICAgICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBCIGhhcyBiZWVuIGNoYW5n\nZWQgYWNjb3JkaW5nbHkuClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAgIFRo\nZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gS0wKICAgICAgICAg\nS0wgaXMgSU5URUdFUgogICAgVGhlIG51bWJlciBvZiBzdWJkaWFnb25hbHMgd2l0aGluIHRoZSBi\nYW5kIG9mIEEuICBLTCA+PSAwLgpccGFyYW1baW5dIEtVCiAgICAgICAgIEtVIGlzIElOVEVHRVIK\nICAgIFRoZSBudW1iZXIgb2Ygc3VwZXJkaWFnb25hbHMgd2l0aGluIHRoZSBiYW5kIG9mIEEuICBL\nVSA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICBUaGUg\nbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwog\nICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQUIKICAg\nICAgICAgQUIgaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChMREFCLE4pCiAgICBUaGUg\nb3JpZ2luYWwgYmFuZCBtYXRyaXggQSwgc3RvcmVkIGluIHJvd3MgMSB0byBLTCtLVSsxLgogICAg\nVGhlIGotdGggY29sdW1uIG9mIEEgaXMgc3RvcmVkIGluIHRoZSBqLXRoIGNvbHVtbiBvZiB0aGUK\nICAgIGFycmF5IEFCIGFzIGZvbGxvd3M6CiAgICBBQihrdSsxK2ktaixqKSA9IEEoaSxqKSBmb3Ig\nbWF4KDEsai1rdSk8PWk8PW1pbihuLGora2wpLgpccGFyYW1baW5dIExEQUIKICAgICAgICAgTERB\nQiBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFCLiAg\nTERBQiA+PSBLTCtLVSsxLgpccGFyYW1baW5dIEFGQgogICAgICAgICBBRkIgaXMgQ09NUExFWCox\nNiBhcnJheSwgZGltZW5zaW9uIChMREFGQixOKQogICAgRGV0YWlscyBvZiB0aGUgTFUgZmFjdG9y\naXphdGlvbiBvZiB0aGUgYmFuZCBtYXRyaXggQSwgYXMKICAgIGNvbXB1dGVkIGJ5IERHQlRSRi4g\nIFUgaXMgc3RvcmVkIGFzIGFuIHVwcGVyIHRyaWFuZ3VsYXIgYmFuZAogICAgbWF0cml4IHdpdGgg\nS0wrS1Ugc3VwZXJkaWFnb25hbHMgaW4gcm93cyAxIHRvIEtMK0tVKzEsIGFuZAogICAgdGhlIG11\nbHRpcGxpZXJzIHVzZWQgZHVyaW5nIHRoZSBmYWN0b3JpemF0aW9uIGFyZSBzdG9yZWQgaW4KICAg\nIHJvd3MgS0wrS1UrMiB0byAyKktMK0tVKzEuClxwYXJhbVtpbl0gTERBRkIKICAgICAgICAgTERB\nRkIgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBRkIu\nICBMREFGQiA+PSAyKktMKktVKzEuClxwYXJhbVtpbl0gSVBJVgogICAgICAgICBJUElWIGlzIElO\nVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgIFRoZSBwaXZvdCBpbmRpY2VzIGZyb20gREdF\nVFJGOyBmb3IgMTw9aTw9Tiwgcm93IGkgb2YgdGhlCiAgICBtYXRyaXggd2FzIGludGVyY2hhbmdl\nZCB3aXRoIHJvdyBJUElWKGkpLgpccGFyYW1baW4sb3V0XSBSCiAgICAgICAgIFIgaXMgRE9VQkxF\nIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgVGhlIHJvdyBzY2FsZSBmYWN0b3Jz\nIGZvciBBLiAgSWYgRVFVRUQgPSAnUicgb3IgJ0InLCBBIGlzCiAgICBtdWx0aXBsaWVkIG9uIHRo\nZSBsZWZ0IGJ5IGRpYWcoUik7IGlmIEVRVUVEID0gJ04nIG9yICdDJywgUgogICAgaXMgbm90IGFj\nY2Vzc2VkLiAgUiBpcyBhbiBpbnB1dCBhcmd1bWVudCBpZiBGQUNUID0gJ0YnOwogICAgb3RoZXJ3\naXNlLCBSIGlzIGFuIG91dHB1dCBhcmd1bWVudC4gIElmIEZBQ1QgPSAnRicgYW5kCiAgICBFUVVF\nRCA9ICdSJyBvciAnQicsIGVhY2ggZWxlbWVudCBvZiBSIG11c3QgYmUgcG9zaXRpdmUuCiAgICBJ\nZiBSIGlzIG91dHB1dCwgZWFjaCBlbGVtZW50IG9mIFIgaXMgYSBwb3dlciBvZiB0aGUgcmFkaXgu\nCiAgICBJZiBSIGlzIGlucHV0LCBlYWNoIGVsZW1lbnQgb2YgUiBzaG91bGQgYmUgYSBwb3dlciBv\nZiB0aGUgcmFkaXgKICAgIHRvIGVuc3VyZSBhIHJlbGlhYmxlIHNvbHV0aW9uIGFuZCBlcnJvciBl\nc3RpbWF0ZXMuIFNjYWxpbmcgYnkKICAgIHBvd2VycyBvZiB0aGUgcmFkaXggZG9lcyBub3QgY2F1\nc2Ugcm91bmRpbmcgZXJyb3JzIHVubGVzcyB0aGUKICAgIHJlc3VsdCB1bmRlcmZsb3dzIG9yIG92\nZXJmbG93cy4gUm91bmRpbmcgZXJyb3JzIGR1cmluZyBzY2FsaW5nCiAgICBsZWFkIHRvIHJlZmlu\naW5nIHdpdGggYSBtYXRyaXggdGhhdCBpcyBub3QgZXF1aXZhbGVudCB0byB0aGUKICAgIGlucHV0\nIG1hdHJpeCwgcHJvZHVjaW5nIGVycm9yIGVzdGltYXRlcyB0aGF0IG1heSBub3QgYmUKICAgIHJl\nbGlhYmxlLgpccGFyYW1baW4sb3V0XSBDCiAgICAgICAgIEMgaXMgRE9VQkxFIFBSRUNJU0lPTiBh\ncnJheSwgZGltZW5zaW9uIChOKQogICAgVGhlIGNvbHVtbiBzY2FsZSBmYWN0b3JzIGZvciBBLiAg\nSWYgRVFVRUQgPSAnQycgb3IgJ0InLCBBIGlzCiAgICBtdWx0aXBsaWVkIG9uIHRoZSByaWdodCBi\neSBkaWFnKEMpOyBpZiBFUVVFRCA9ICdOJyBvciAnUicsIEMKICAgIGlzIG5vdCBhY2Nlc3NlZC4g\nIEMgaXMgYW4gaW5wdXQgYXJndW1lbnQgaWYgRkFDVCA9ICdGJzsKICAgIG90aGVyd2lzZSwgQyBp\ncyBhbiBvdXRwdXQgYXJndW1lbnQuICBJZiBGQUNUID0gJ0YnIGFuZAogICAgRVFVRUQgPSAnQycg\nb3IgJ0InLCBlYWNoIGVsZW1lbnQgb2YgQyBtdXN0IGJlIHBvc2l0aXZlLgogICAgSWYgQyBpcyBv\ndXRwdXQsIGVhY2ggZWxlbWVudCBvZiBDIGlzIGEgcG93ZXIgb2YgdGhlIHJhZGl4LgogICAgSWYg\nQyBpcyBpbnB1dCwgZWFjaCBlbGVtZW50IG9mIEMgc2hvdWxkIGJlIGEgcG93ZXIgb2YgdGhlIHJh\nZGl4CiAgICB0byBlbnN1cmUgYSByZWxpYWJsZSBzb2x1dGlvbiBhbmQgZXJyb3IgZXN0aW1hdGVz\nLiBTY2FsaW5nIGJ5CiAgICBwb3dlcnMgb2YgdGhlIHJhZGl4IGRvZXMgbm90IGNhdXNlIHJvdW5k\naW5nIGVycm9ycyB1bmxlc3MgdGhlCiAgICByZXN1bHQgdW5kZXJmbG93cyBvciBvdmVyZmxvd3Mu\nIFJvdW5kaW5nIGVycm9ycyBkdXJpbmcgc2NhbGluZwogICAgbGVhZCB0byByZWZpbmluZyB3aXRo\nIGEgbWF0cml4IHRoYXQgaXMgbm90IGVxdWl2YWxlbnQgdG8gdGhlCiAgICBpbnB1dCBtYXRyaXgs\nIHByb2R1Y2luZyBlcnJvciBlc3RpbWF0ZXMgdGhhdCBtYXkgbm90IGJlCiAgICByZWxpYWJsZS4K\nXHBhcmFtW2luXSBCCiAgICAgICAgIEIgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5z\naW9uIChMREIsTlJIUykKICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtp\nbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24g\nb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAg\nICAgWCBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgT24gZW50\ncnksIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgREdFVFJTLgogICAgT24g\nZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAg\nICAgICBMRFggaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJh\neSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBSQ09ORAogICAgICAgICBSQ09ORCBp\ncyBET1VCTEUgUFJFQ0lTSU9OCiAgICBSZWNpcHJvY2FsIHNjYWxlZCBjb25kaXRpb24gbnVtYmVy\nLiAgVGhpcyBpcyBhbiBlc3RpbWF0ZSBvZiB0aGUKICAgIHJlY2lwcm9jYWwgU2tlZWwgY29uZGl0\naW9uIG51bWJlciBvZiB0aGUgbWF0cml4IEEgYWZ0ZXIKICAgIGVxdWlsaWJyYXRpb24gKGlmIGRv\nbmUpLiAgSWYgdGhpcyBpcyBsZXNzIHRoYW4gdGhlIG1hY2hpbmUKICAgIHByZWNpc2lvbiAoaW4g\ncGFydGljdWxhciwgaWYgaXQgaXMgemVybyksIHRoZSBtYXRyaXggaXMgc2luZ3VsYXIKICAgIHRv\nIHdvcmtpbmcgcHJlY2lzaW9uLiAgTm90ZSB0aGF0IHRoZSBlcnJvciBtYXkgc3RpbGwgYmUgc21h\nbGwgZXZlbgogICAgaWYgdGhpcyBudW1iZXIgaXMgdmVyeSBzbWFsbCBhbmQgdGhlIG1hdHJpeCBh\ncHBlYXJzIGlsbC0KICAgIGNvbmRpdGlvbmVkLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJF\nUlIgaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgQ29tcG9uZW50d2lz\nZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvci4gIFRoaXMgaXMgdGhlCiAgICBjb21wb25lbnR3aXNl\nIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24gdmVjdG9yIFgoaikKICAg\nIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluIGFueSBlbGVtZW50IG9mIEEg\nb3IgQiB0aGF0CiAgICBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW2luXSBO\nX0VSUl9CTkRTCiAgICAgICAgIE5fRVJSX0JORFMgaXMgSU5URUdFUgogICAgTnVtYmVyIG9mIGVy\ncm9yIGJvdW5kcyB0byByZXR1cm4gZm9yIGVhY2ggcmlnaHQgaGFuZCBzaWRlCiAgICBhbmQgZWFj\naCB0eXBlIChub3Jtd2lzZSBvciBjb21wb25lbnR3aXNlKS4gIFNlZSBFUlJfQk5EU19OT1JNIGFu\nZAogICAgRVJSX0JORFNfQ09NUCBiZWxvdy4KXHBhcmFtW291dF0gRVJSX0JORFNfTk9STQogICAg\nICAgICBFUlJfQk5EU19OT1JNIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAo\nTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhpcyBhcnJh\neSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3VuZHMgYW5k\nIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBub3Jtd2lzZSByZWxh\ndGl2ZSBlcnJvciwgd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dzOgogICAgTm9ybXdpc2UgcmVs\nYXRpdmUgZXJyb3IgaW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAgICAgICAgIG1heF9q\nIChhYnMoWFRSVUUoaixpKSAtIFgoaixpKSkpCiAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0t\nLS0tLS0tLS0tLS0tCiAgICAgICAgICAgICAgICAgbWF4X2ogYWJzKFgoaixpKSkKICAgIFRoZSBh\ncnJheSBpcyBpbmRleGVkIGJ5IHRoZSB0eXBlIG9mIGVycm9yIGluZm9ybWF0aW9uIGFzIGRlc2Ny\naWJlZAogICAgYmVsb3cuIFRoZXJlIGN1cnJlbnRseSBhcmUgdXAgdG8gdGhyZWUgcGllY2VzIG9m\nIGluZm9ybWF0aW9uCiAgICByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJfQk5E\nU19OT1JNKGksOikgY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQtaGFuZCBzaWRlLgog\nICAgVGhlIHNlY29uZCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKDosZXJyKSBjb250YWlucyB0aGUg\nZm9sbG93aW5nCiAgICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVzdC9kb24ndCB0cnVz\ndCIgYm9vbGVhbi4gVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAgICAgIHJlY2lwcm9j\nYWwgY29uZGl0aW9uIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAg\nICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAiR3VhcmFudGVlZCIg\nZXJyb3IgYm91bmQ6IFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAgICAgICAgICAgIGFs\nbW9zdCBjZXJ0YWlubHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9yCiAg\nICAgICAgICAgICBzbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0aGUg\ndGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogZGxhbWNoKCdFcHNpbG9uJykuIFRoaXMg\nZXJyb3IgYm91bmQgc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0ZWQgaWYgdGhlIHBy\nZXZpb3VzIGJvb2xlYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0aW9u\nIG51bWJlcjogRXN0aW1hdGVkIG5vcm13aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRp\ndGlvbiBudW1iZXIuICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNx\ncnQobikgKiBkbGFtY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAg\nICAgICAgICBlc3RpbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0\naW9uCiAgICAgICAgICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3Jt\nKFosaW5mKSkgZm9yIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJp\neCBaLgogICAgICAgICAgICAgTGV0IFogPSBTKkEsIHdoZXJlIFMgc2NhbGVzIGVhY2ggcm93IGJ5\nIGEgcG93ZXIgb2YgdGhlCiAgICAgICAgICAgICByYWRpeCBzbyBhbGwgYWJzb2x1dGUgcm93IHN1\nbXMgb2YgWiBhcmUgYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFjayBXb3JraW5nIE5vdGUg\nMTY1IGZvciBmdXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4KXHBhcmFtW291\ndF0gRVJSX0JORFNfQ09NUAogICAgICAgICBFUlJfQk5EU19DT01QIGlzIERPVUJMRSBQUkVDSVNJ\nT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0\nLWhhbmQgc2lkZSwgdGhpcyBhcnJheSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFy\naW91cyBlcnJvciBib3VuZHMgYW5kIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8g\ndGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFz\nIGZvbGxvd3M6CiAgICBDb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGluIHRoZSBpdGggc29s\ndXRpb24gdmVjdG9yOgogICAgICAgICAgICAgICAgICAgYWJzKFhUUlVFKGosaSkgLSBYKGosaSkp\nCiAgICAgICAgICAgIG1heF9qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAg\nICAgICAgICAgYWJzKFgoaixpKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSByaWdo\ndC1oYW5kIHNpZGUgaSAob24gd2hpY2ggdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVy\ncm9yIGRlcGVuZHMpLCBhbmQgdGhlIHR5cGUgb2YgZXJyb3IKICAgIGluZm9ybWF0aW9uIGFzIGRl\nc2NyaWJlZCBiZWxvdy4gVGhlcmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZQogICAgcGllY2Vz\nIG9mIGluZm9ybWF0aW9uIHJldHVybmVkIGZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZS4gSWYKICAg\nIGNvbXBvbmVudHdpc2UgYWNjdXJhY3kgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1TKDMpID0gMC4w\nKSwgdGhlbgogICAgRVJSX0JORFNfQ09NUCBpcyBub3QgYWNjZXNzZWQuICBJZiBOX0VSUl9CTkRT\nIC5MVC4gMywgdGhlbiBhdCBtb3N0CiAgICB0aGUgZmlyc3QgKDosTl9FUlJfQk5EUykgZW50cmll\ncyBhcmUgcmV0dXJuZWQuCiAgICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfQ09NUChpLDop\nIGNvcnJlc3BvbmRzIHRvIHRoZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBzZWNv\nbmQgaW5kZXggaW4gRVJSX0JORFNfQ09NUCg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2luZwog\nICAgdGhyZWUgZmllbGRzOgogICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xlYW4u\nIFRydXN0IHRoZSBhbnN3ZXIgaWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlv\nbiBudW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikg\nKiBkbGFtY2goJ0Vwc2lsb24nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJvdW5k\nOiBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2VydGFp\nbmx5IHdpdGhpbiBhIGZhY3RvciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAgICAg\nc28gbG9uZyBhcyB0aGUgbmV4dCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZAog\nICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJvdW5k\nIHNob3VsZCBvbmx5CiAgICAgICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBib29s\nZWFuIGlzIHRydWUuCiAgICBlcnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6IEVz\ndGltYXRlZCBjb21wb25lbnR3aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBu\ndW1iZXIuICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikg\nKiBkbGFtY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAg\nICBlc3RpbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAg\nICAgICAgICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5m\nKSkgZm9yIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgog\nICAgICAgICAgICAgTGV0IFogPSBTKihBKmRpYWcoeCkpLCB3aGVyZSB4IGlzIHRoZSBzb2x1dGlv\nbiBmb3IgdGhlCiAgICAgICAgICAgICBjdXJyZW50IHJpZ2h0LWhhbmQgc2lkZSBhbmQgUyBzY2Fs\nZXMgZWFjaCByb3cgb2YKICAgICAgICAgICAgIEEqZGlhZyh4KSBieSBhIHBvd2VyIG9mIHRoZSBy\nYWRpeCBzbyBhbGwgYWJzb2x1dGUgcm93CiAgICAgICAgICAgICBzdW1zIG9mIFogYXJlIGFwcHJv\neGltYXRlbHkgMS4KICAgIFNlZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhlciBk\nZXRhaWxzIGFuZCBleHRyYQogICAgY2F1dGlvbnMuClxwYXJhbVtpbl0gTlBBUkFNUwogICAgICAg\nICBOUEFSQU1TIGlzIElOVEVHRVIKICAgIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRl\ncnMgc2V0IGluIFBBUkFNUy4gIElmIC5MRS4gMCwgdGhlCiAgICBQQVJBTVMgYXJyYXkgaXMgbmV2\nZXIgcmVmZXJlbmNlZCBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIHVzZWQuClxwYXJhbVtpbixvdXRd\nIFBBUkFNUwogICAgICAgICBQQVJBTVMgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5z\naW9uIE5QQVJBTVMKICAgIFNwZWNpZmllcyBhbGdvcml0aG0gcGFyYW1ldGVycy4gIElmIGFuIGVu\ndHJ5IGlzIC5MVC4gMC4wLCB0aGVuCiAgICB0aGF0IGVudHJ5IHdpbGwgYmUgZmlsbGVkIHdpdGgg\nZGVmYXVsdCB2YWx1ZSB1c2VkIGZvciB0aGF0CiAgICBwYXJhbWV0ZXIuICBPbmx5IHBvc2l0aW9u\ncyB1cCB0byBOUEFSQU1TIGFyZSBhY2Nlc3NlZDsgZGVmYXVsdHMKICAgIGFyZSB1c2VkIGZvciBo\naWdoZXItbnVtYmVyZWQgcGFyYW1ldGVycy4KICAgICAgUEFSQU1TKExBX0xJTlJYX0lUUkVGX0kg\nPSAxKSA6IFdoZXRoZXIgdG8gcGVyZm9ybSBpdGVyYXRpdmUKICAgICAgICAgICByZWZpbmVtZW50\nIG9yIG5vdC4KICAgICAgICBEZWZhdWx0OiAxLjBEKzAKICAgICAgICAgICA9IDAuMCA6IE5vIHJl\nZmluZW1lbnQgaXMgcGVyZm9ybWVkLCBhbmQgbm8gZXJyb3IgYm91bmRzIGFyZQogICAgICAgICAg\nICAgICAgICAgY29tcHV0ZWQuCiAgICAgICAgICAgPSAxLjAgOiBVc2UgdGhlIGRvdWJsZS1wcmVj\naXNpb24gcmVmaW5lbWVudCBhbGdvcml0aG0sCiAgICAgICAgICAgICAgICAgICBwb3NzaWJseSB3\naXRoIGRvdWJsZWQtc2luZ2xlIGNvbXB1dGF0aW9ucyBpZiB0aGUKICAgICAgICAgICAgICAgICAg\nIGNvbXBpbGF0aW9uIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgRE9VQkxFCiAgICAgICAg\nICAgICAgICAgICBQUkVDSVNJT04uCiAgICAgICAgICAgICAob3RoZXIgdmFsdWVzIGFyZSByZXNl\ncnZlZCBmb3IgZnV0dXJlIHVzZSkKICAgICAgUEFSQU1TKExBX0xJTlJYX0lUSFJFU0hfSSA9IDIp\nIDogTWF4aW11bSBudW1iZXIgb2YgcmVzaWR1YWwKICAgICAgICAgICBjb21wdXRhdGlvbnMgYWxs\nb3dlZCBmb3IgcmVmaW5lbWVudC4KICAgICAgICBEZWZhdWx0OiAxMAogICAgICAgIEFnZ3Jlc3Np\ndmU6IFNldCB0byAxMDAgdG8gcGVybWl0IGNvbnZlcmdlbmNlIHVzaW5nIGFwcHJveGltYXRlCiAg\nICAgICAgICAgICAgICAgICAgZmFjdG9yaXphdGlvbnMgb3IgZmFjdG9yaXphdGlvbnMgb3RoZXIg\ndGhhbiBMVS4gSWYKICAgICAgICAgICAgICAgICAgICB0aGUgZmFjdG9yaXphdGlvbiB1c2VzIGEg\ndGVjaG5pcXVlIG90aGVyIHRoYW4KICAgICAgICAgICAgICAgICAgICBHYXVzc2lhbiBlbGltaW5h\ndGlvbiwgdGhlIGd1YXJhbnRlZXMgaW4KICAgICAgICAgICAgICAgICAgICBlcnJfYm5kc19ub3Jt\nIGFuZCBlcnJfYm5kc19jb21wIG1heSBubyBsb25nZXIgYmUKICAgICAgICAgICAgICAgICAgICB0\ncnVzdHdvcnRoeS4KICAgICAgUEFSQU1TKExBX0xJTlJYX0NXSVNFX0kgPSAzKSA6IEZsYWcgZGV0\nZXJtaW5pbmcgaWYgdGhlIGNvZGUKICAgICAgICAgICB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIHNv\nbHV0aW9uIHdpdGggc21hbGwgY29tcG9uZW50d2lzZQogICAgICAgICAgIHJlbGF0aXZlIGVycm9y\nIGluIHRoZSBkb3VibGUtcHJlY2lzaW9uIGFsZ29yaXRobS4gIFBvc2l0aXZlCiAgICAgICAgICAg\naXMgdHJ1ZSwgMC4wIGlzIGZhbHNlLgogICAgICAgIERlZmF1bHQ6IDEuMCAoYXR0ZW1wdCBjb21w\nb25lbnR3aXNlIGNvbnZlcmdlbmNlKQpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMg\nQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uICgyKk4pClxwYXJhbVtvdXRdIFJXT1JLCiAgICAg\nICAgIFJXT1JLIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFy\nYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICA9IDA6ICBTdWNjZXNz\nZnVsIGV4aXQuIFRoZSBzb2x1dGlvbiB0byBldmVyeSByaWdodC1oYW5kIHNpZGUgaXMKICAgICAg\nICBndWFyYW50ZWVkLgogICAgICA8IDA6ICBJZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50\nIGhhZCBhbiBpbGxlZ2FsIHZhbHVlCiAgICAgID4gMCBhbmQgPD0gTjogIFUoSU5GTyxJTkZPKSBp\ncyBleGFjdGx5IHplcm8uICBUaGUgZmFjdG9yaXphdGlvbgogICAgICAgIGhhcyBiZWVuIGNvbXBs\nZXRlZCwgYnV0IHRoZSBmYWN0b3IgVSBpcyBleGFjdGx5IHNpbmd1bGFyLCBzbwogICAgICAgIHRo\nZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIGNvdWxkIG5vdCBiZSBjb21wdXRlZC4gUkNPTkQg\nPSAwCiAgICAgICAgaXMgcmV0dXJuZWQuCiAgICAgID0gTitKOiBUaGUgc29sdXRpb24gY29ycmVz\ncG9uZGluZyB0byB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIG5vdCBndWFyYW50\nZWVkLiBUaGUgc29sdXRpb25zIGNvcnJlc3BvbmRpbmcgdG8gb3RoZXIgcmlnaHQtCiAgICAgICAg\naGFuZCBzaWRlcyBLIHdpdGggSyA+IEogbWF5IG5vdCBiZSBndWFyYW50ZWVkIGFzIHdlbGwsIGJ1\ndAogICAgICAgIG9ubHkgdGhlIGZpcnN0IHN1Y2ggcmlnaHQtaGFuZCBzaWRlIGlzIHJlcG9ydGVk\nLiBJZiBhIHNtYWxsCiAgICAgICAgY29tcG9uZW50d2lzZSBlcnJvciBpcyBub3QgcmVxdWVzdGVk\nIChQQVJBTVMoMykgPSAwLjApIHRoZW4KICAgICAgICB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBp\ncyB0aGUgZmlyc3Qgd2l0aCBhIG5vcm13aXNlIGVycm9yCiAgICAgICAgYm91bmQgdGhhdCBpcyBu\nb3QgZ3VhcmFudGVlZCAodGhlIHNtYWxsZXN0IEogc3VjaAogICAgICAgIHRoYXQgRVJSX0JORFNf\nTk9STShKLDEpID0gMC4wKS4gQnkgZGVmYXVsdCAoUEFSQU1TKDMpID0gMS4wKQogICAgICAgIHRo\nZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzIHRoZSBmaXJzdCB3aXRoIGVpdGhlciBhIG5vcm13aXNl\nIG9yCiAgICAgICAgY29tcG9uZW50d2lzZSBlcnJvciBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50\nZWVkICh0aGUgc21hbGxlc3QKICAgICAgICBKIHN1Y2ggdGhhdCBlaXRoZXIgRVJSX0JORFNfTk9S\nTShKLDEpID0gMC4wIG9yCiAgICAgICAgRVJSX0JORFNfQ09NUChKLDEpID0gMC4wKS4gU2VlIHRo\nZSBkZWZpbml0aW9uIG9mCiAgICAgICAgRVJSX0JORFNfTk9STSg6LDEpIGFuZCBFUlJfQk5EU19D\nT01QKDosMSkuIFRvIGdldCBpbmZvcm1hdGlvbgogICAgICAgIGFib3V0IGFsbCBvZiB0aGUgcmln\naHQtaGFuZCBzaWRlcyBjaGVjayBFUlJfQk5EU19OT1JNIG9yCiAgICAgICAgRVJSX0JORFNfQ09N\nUC4KQXV0aG9yczoKXGF1dGhvciBVbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2Yg\nQ2FsaWZvcm5pYSBCZXJrZWxleSAKXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxh\ndXRob3IgTkFHIEx0ZC4gClxkYXRlIEFwcmlsIDIwMTIKXGluZ3JvdXAgY29tcGxleDE2R0Jjb21w\ndXRhdGlvbmFsCmgdaB4pgXIHAgAAfXIIAgAAKGghiWgiaCN1YmgtigKiAWguWA8AAAB6Z2JyZnN4\nXzQxOC50eHR1YmgvigKiAWgwWAYAAABnYnJmc3hoLYoBPHViaBVoFl1oF4dScgkCAAB9cgoCAAAo\naBpYAwAAAFNQRGgbWAQAAABmdWxsaBxYRgAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJy\nb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudDsgRVFVRURoHWgeKYFyCwIAAH1yDAIA\nAChoIYloImgjdWJoJFghAAAARG94eWdlbi9kb2NzL2h0bWwvc3BvcmZzeF84Zi5odG1saCVYAQAA\nAHNoJmgVaCddaBeHUnINAgAAfXIOAgAAKGgqWKwwAAAgICBTUE9SRlNYIGltcHJvdmVzIHRoZSBj\nb21wdXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKICAgZXF1YXRpb25zIHdoZW4g\ndGhlIGNvZWZmaWNpZW50IG1hdHJpeCBpcyBzeW1tZXRyaWMgcG9zaXRpdmUKICAgZGVmaW5pdGUs\nIGFuZCBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcwog\nICBmb3IgdGhlIHNvbHV0aW9uLiAgSW4gYWRkaXRpb24gdG8gbm9ybXdpc2UgZXJyb3IgYm91bmQs\nIHRoZSBjb2RlCiAgIHByb3ZpZGVzIG1heGltdW0gY29tcG9uZW50d2lzZSBlcnJvciBib3VuZCBp\nZiBwb3NzaWJsZS4gIFNlZQogICBjb21tZW50cyBmb3IgRVJSX0JORFNfTk9STSBhbmQgRVJSX0JO\nRFNfQ09NUCBmb3IgZGV0YWlscyBvZiB0aGUKICAgZXJyb3IgYm91bmRzLgogICBUaGUgb3JpZ2lu\nYWwgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgbWF5IGhhdmUgYmVlbiBlcXVpbGlicmF0ZWQK\nICAgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0aW5lLCBhcyBkZXNjcmliZWQgYnkgYXJndW1lbnRz\nIEVRVUVEIGFuZCBTCiAgIGJlbG93LiBJbiB0aGlzIGNhc2UsIHRoZSBzb2x1dGlvbiBhbmQgZXJy\nb3IgYm91bmRzIHJldHVybmVkIGFyZQogICBmb3IgdGhlIG9yaWdpbmFsIHVuZXF1aWxpYnJhdGVk\nIHN5c3RlbS4KQXJndW1lbnRzOgogICAgU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzIGFyZSBidW5k\nbGVkIGluIHRoZSBQQVJBTVMgYXJyYXkuICBUaGVzZQogICAgc2V0dGluZ3MgZGV0ZXJtaW5lIGhv\ndyByZWZpbmVtZW50IGlzIHBlcmZvcm1lZCwgYnV0IG9mdGVuIHRoZQogICAgZGVmYXVsdHMgYXJl\nIGFjY2VwdGFibGUuICBJZiB0aGUgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUsIHVzZXJzCiAgICBj\nYW4gcGFzcyBOUEFSQU1TID0gMCB3aGljaCBwcmV2ZW50cyB0aGUgc291cmNlIGNvZGUgZnJvbSBh\nY2Nlc3NpbmcKICAgIHRoZSBQQVJBTVMgYXJndW1lbnQuClxwYXJhbVtpbl0gVVBMTwogICAgICAg\nICBVUExPIGlzIENIQVJBQ1RFUioxCiAgICAgID0gJ1UnOiAgVXBwZXIgdHJpYW5nbGUgb2YgQSBp\ncyBzdG9yZWQ7CiAgICAgID0gJ0wnOiAgTG93ZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQuClxw\nYXJhbVtpbl0gRVFVRUQKICAgICAgICAgRVFVRUQgaXMgQ0hBUkFDVEVSKjEKICAgIFNwZWNpZmll\ncyB0aGUgZm9ybSBvZiBlcXVpbGlicmF0aW9uIHRoYXQgd2FzIGRvbmUgdG8gQQogICAgYmVmb3Jl\nIGNhbGxpbmcgdGhpcyByb3V0aW5lLiBUaGlzIGlzIG5lZWRlZCB0byBjb21wdXRlCiAgICB0aGUg\nc29sdXRpb24gYW5kIGVycm9yIGJvdW5kcyBjb3JyZWN0bHkuCiAgICAgID0gJ04nOiAgTm8gZXF1\naWxpYnJhdGlvbgogICAgICA9ICdZJzogIEJvdGggcm93IGFuZCBjb2x1bW4gZXF1aWxpYnJhdGlv\nbiwgaS5lLiwgQSBoYXMgYmVlbgogICAgICAgICAgICAgIHJlcGxhY2VkIGJ5IGRpYWcoUykgKiBB\nICogZGlhZyhTKS4KICAgICAgICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIEIgaGFzIGJlZW4g\nY2hhbmdlZCBhY2NvcmRpbmdseS4KXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgog\nICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAg\nICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNpZGVz\nLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBY\nLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEEKICAgICAgICAgQSBpcyBSRUFMIGFycmF5LCBkaW1l\nbnNpb24gKExEQSxOKQogICAgVGhlIHN5bW1ldHJpYyBtYXRyaXggQS4gIElmIFVQTE8gPSAnVScs\nIHRoZSBsZWFkaW5nIE4tYnktTgogICAgdXBwZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEgY29udGFp\nbnMgdGhlIHVwcGVyIHRyaWFuZ3VsYXIgcGFydAogICAgb2YgdGhlIG1hdHJpeCBBLCBhbmQgdGhl\nIHN0cmljdGx5IGxvd2VyIHRyaWFuZ3VsYXIgcGFydCBvZiBBCiAgICBpcyBub3QgcmVmZXJlbmNl\nZC4gIElmIFVQTE8gPSAnTCcsIHRoZSBsZWFkaW5nIE4tYnktTiBsb3dlcgogICAgdHJpYW5ndWxh\nciBwYXJ0IG9mIEEgY29udGFpbnMgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgcGFydCBvZgogICAgdGhl\nIG1hdHJpeCBBLCBhbmQgdGhlIHN0cmljdGx5IHVwcGVyIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGlz\nCiAgICBub3QgcmVmZXJlbmNlZC4KXHBhcmFtW2luXSBMREEKICAgICAgICAgTERBIGlzIElOVEVH\nRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQS4gIExEQSA+PSBtYXgo\nMSxOKS4KXHBhcmFtW2luXSBBRgogICAgICAgICBBRiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24g\nKExEQUYsTikKICAgIFRoZSB0cmlhbmd1bGFyIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgQ2hvbGVz\na3kgZmFjdG9yaXphdGlvbgogICAgQSA9IFUqKlQqVSBvciBBID0gTCpMKipULCBhcyBjb21wdXRl\nZCBieSBTUE9UUkYuClxwYXJhbVtpbl0gTERBRgogICAgICAgICBMREFGIGlzIElOVEVHRVIKICAg\nIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUYuICBMREFGID49IG1heCgxLE4p\nLgpccGFyYW1baW4sb3V0XSBTCiAgICAgICAgIFMgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChO\nKQogICAgVGhlIHJvdyBzY2FsZSBmYWN0b3JzIGZvciBBLiAgSWYgRVFVRUQgPSAnWScsIEEgaXMg\nbXVsdGlwbGllZCBvbgogICAgdGhlIGxlZnQgYW5kIHJpZ2h0IGJ5IGRpYWcoUykuICBTIGlzIGFu\nIGlucHV0IGFyZ3VtZW50IGlmIEZBQ1QgPQogICAgJ0YnOyBvdGhlcndpc2UsIFMgaXMgYW4gb3V0\ncHV0IGFyZ3VtZW50LiAgSWYgRkFDVCA9ICdGJyBhbmQgRVFVRUQKICAgID0gJ1knLCBlYWNoIGVs\nZW1lbnQgb2YgUyBtdXN0IGJlIHBvc2l0aXZlLiAgSWYgUyBpcyBvdXRwdXQsIGVhY2gKICAgIGVs\nZW1lbnQgb2YgUyBpcyBhIHBvd2VyIG9mIHRoZSByYWRpeC4gSWYgUyBpcyBpbnB1dCwgZWFjaCBl\nbGVtZW50CiAgICBvZiBTIHNob3VsZCBiZSBhIHBvd2VyIG9mIHRoZSByYWRpeCB0byBlbnN1cmUg\nYSByZWxpYWJsZSBzb2x1dGlvbgogICAgYW5kIGVycm9yIGVzdGltYXRlcy4gU2NhbGluZyBieSBw\nb3dlcnMgb2YgdGhlIHJhZGl4IGRvZXMgbm90IGNhdXNlCiAgICByb3VuZGluZyBlcnJvcnMgdW5s\nZXNzIHRoZSByZXN1bHQgdW5kZXJmbG93cyBvciBvdmVyZmxvd3MuCiAgICBSb3VuZGluZyBlcnJv\ncnMgZHVyaW5nIHNjYWxpbmcgbGVhZCB0byByZWZpbmluZyB3aXRoIGEgbWF0cml4IHRoYXQKICAg\nIGlzIG5vdCBlcXVpdmFsZW50IHRvIHRoZSBpbnB1dCBtYXRyaXgsIHByb2R1Y2luZyBlcnJvciBl\nc3RpbWF0ZXMKICAgIHRoYXQgbWF5IG5vdCBiZSByZWxpYWJsZS4KXHBhcmFtW2luXSBCCiAgICAg\nICAgIEIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgIFRoZSByaWdodCBo\nYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJTlRFR0VS\nCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0gbWF4KDEs\nTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24g\nKExEWCxOUkhTKQogICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwgYXMgY29tcHV0\nZWQgYnkgU0dFVFJTLgogICAgT24gZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0aW9uIG1hdHJpeCBY\nLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcg\nZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1bb3V0XSBS\nQ09ORAogICAgICAgICBSQ09ORCBpcyBSRUFMCiAgICBSZWNpcHJvY2FsIHNjYWxlZCBjb25kaXRp\nb24gbnVtYmVyLiAgVGhpcyBpcyBhbiBlc3RpbWF0ZSBvZiB0aGUKICAgIHJlY2lwcm9jYWwgU2tl\nZWwgY29uZGl0aW9uIG51bWJlciBvZiB0aGUgbWF0cml4IEEgYWZ0ZXIKICAgIGVxdWlsaWJyYXRp\nb24gKGlmIGRvbmUpLiAgSWYgdGhpcyBpcyBsZXNzIHRoYW4gdGhlIG1hY2hpbmUKICAgIHByZWNp\nc2lvbiAoaW4gcGFydGljdWxhciwgaWYgaXQgaXMgemVybyksIHRoZSBtYXRyaXggaXMgc2luZ3Vs\nYXIKICAgIHRvIHdvcmtpbmcgcHJlY2lzaW9uLiAgTm90ZSB0aGF0IHRoZSBlcnJvciBtYXkgc3Rp\nbGwgYmUgc21hbGwgZXZlbgogICAgaWYgdGhpcyBudW1iZXIgaXMgdmVyeSBzbWFsbCBhbmQgdGhl\nIG1hdHJpeCBhcHBlYXJzIGlsbC0KICAgIGNvbmRpdGlvbmVkLgpccGFyYW1bb3V0XSBCRVJSCiAg\nICAgICAgIEJFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgQ29tcG9uZW50\nd2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvci4gIFRoaXMgaXMgdGhlCiAgICBjb21wb25lbnR3\naXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24gdmVjdG9yIFgoaikK\nICAgIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluIGFueSBlbGVtZW50IG9m\nIEEgb3IgQiB0aGF0CiAgICBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW2lu\nXSBOX0VSUl9CTkRTCiAgICAgICAgIE5fRVJSX0JORFMgaXMgSU5URUdFUgogICAgTnVtYmVyIG9m\nIGVycm9yIGJvdW5kcyB0byByZXR1cm4gZm9yIGVhY2ggcmlnaHQgaGFuZCBzaWRlCiAgICBhbmQg\nZWFjaCB0eXBlIChub3Jtd2lzZSBvciBjb21wb25lbnR3aXNlKS4gIFNlZSBFUlJfQk5EU19OT1JN\nIGFuZAogICAgRVJSX0JORFNfQ09NUCBiZWxvdy4KXHBhcmFtW291dF0gRVJSX0JORFNfTk9STQog\nICAgICAgICBFUlJfQk5EU19OT1JNIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUywgTl9F\nUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhpcyBhcnJheSBjb250YWlu\ncyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3VuZHMgYW5kIGNvbmRpdGlv\nbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBub3Jtd2lzZSByZWxhdGl2ZSBlcnJv\nciwgd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dzOgogICAgTm9ybXdpc2UgcmVsYXRpdmUgZXJy\nb3IgaW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAgICAgICAgIG1heF9qIChhYnMoWFRS\nVUUoaixpKSAtIFgoaixpKSkpCiAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t\nLS0tCiAgICAgICAgICAgICAgICAgbWF4X2ogYWJzKFgoaixpKSkKICAgIFRoZSBhcnJheSBpcyBp\nbmRleGVkIGJ5IHRoZSB0eXBlIG9mIGVycm9yIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZAogICAg\nYmVsb3cuIFRoZXJlIGN1cnJlbnRseSBhcmUgdXAgdG8gdGhyZWUgcGllY2VzIG9mIGluZm9ybWF0\naW9uCiAgICByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKGks\nOikgY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQtaGFuZCBzaWRlLgogICAgVGhlIHNl\nY29uZCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKDosZXJyKSBjb250YWlucyB0aGUgZm9sbG93aW5n\nCiAgICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVzdC9kb24ndCB0cnVzdCIgYm9vbGVh\nbi4gVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0\naW9uIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChu\nKSAqIHNsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAiR3VhcmFudGVlZCIgZXJyb3IgYm91\nbmQ6IFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAgICAgICAgICAgIGFsbW9zdCBjZXJ0\nYWlubHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9yCiAgICAgICAgICAg\nICBzbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xk\nCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykuIFRoaXMgZXJyb3IgYm91\nbmQgc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0ZWQgaWYgdGhlIHByZXZpb3VzIGJv\nb2xlYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlcjog\nRXN0aW1hdGVkIG5vcm13aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1i\nZXIuICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBz\nbGFtY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAgICBl\nc3RpbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAgICAg\nICAgICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5mKSkg\nZm9yIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgogICAg\nICAgICAgICAgTGV0IFogPSBTKkEsIHdoZXJlIFMgc2NhbGVzIGVhY2ggcm93IGJ5IGEgcG93ZXIg\nb2YgdGhlCiAgICAgICAgICAgICByYWRpeCBzbyBhbGwgYWJzb2x1dGUgcm93IHN1bXMgb2YgWiBh\ncmUgYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFjayBXb3JraW5nIE5vdGUgMTY1IGZvciBm\ndXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4KXHBhcmFtW291dF0gRVJSX0JO\nRFNfQ09NUAogICAgICAgICBFUlJfQk5EU19DT01QIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAo\nTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhpcyBhcnJh\neSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3VuZHMgYW5k\nIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBjb21wb25lbnR3aXNl\nIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFzIGZvbGxvd3M6CiAgICBDb21wb25l\nbnR3aXNlIHJlbGF0aXZlIGVycm9yIGluIHRoZSBpdGggc29sdXRpb24gdmVjdG9yOgogICAgICAg\nICAgICAgICAgICAgYWJzKFhUUlVFKGosaSkgLSBYKGosaSkpCiAgICAgICAgICAgIG1heF9qIC0t\nLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAgICAgICAgICAgYWJzKFgoaixpKSkK\nICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSByaWdodC1oYW5kIHNpZGUgaSAob24gd2hp\nY2ggdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGRlcGVuZHMpLCBhbmQgdGhl\nIHR5cGUgb2YgZXJyb3IKICAgIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZCBiZWxvdy4gVGhlcmUg\nY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZQogICAgcGllY2VzIG9mIGluZm9ybWF0aW9uIHJldHVy\nbmVkIGZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZS4gSWYKICAgIGNvbXBvbmVudHdpc2UgYWNjdXJh\nY3kgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1TKDMpID0gMC4wKSwgdGhlbgogICAgRVJSX0JORFNf\nQ09NUCBpcyBub3QgYWNjZXNzZWQuICBJZiBOX0VSUl9CTkRTIC5MVC4gMywgdGhlbiBhdCBtb3N0\nCiAgICB0aGUgZmlyc3QgKDosTl9FUlJfQk5EUykgZW50cmllcyBhcmUgcmV0dXJuZWQuCiAgICBU\naGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfQ09NUChpLDopIGNvcnJlc3BvbmRzIHRvIHRoZSBp\ndGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBzZWNvbmQgaW5kZXggaW4gRVJSX0JORFNf\nQ09NUCg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2luZwogICAgdGhyZWUgZmllbGRzOgogICAg\nZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xlYW4uIFRydXN0IHRoZSBhbnN3ZXIgaWYg\ndGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIgaXMgbGVzcyB0aGFu\nIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2lsb24nKS4K\nICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJvdW5kOiBUaGUgZXN0aW1hdGVkIGZvcndh\ncmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2VydGFpbmx5IHdpdGhpbiBhIGZhY3RvciBv\nZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAgICAgc28gbG9uZyBhcyB0aGUgbmV4dCBl\nbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAq\nIHNsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJvdW5kIHNob3VsZCBvbmx5CiAgICAgICAg\nICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBib29sZWFuIGlzIHRydWUuCiAgICBlcnIg\nPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6IEVzdGltYXRlZCBjb21wb25lbnR3aXNl\nCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIuICBDb21wYXJlZCB3aXRo\nIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2lsb24nKSB0\nbyBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAgICBlc3RpbWF0ZSBpcyAiZ3VhcmFu\ndGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAgICAgICAgICAgICBudW1iZXJzIGFy\nZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5mKSkgZm9yIHNvbWUKICAgICAgICAg\nICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgogICAgICAgICAgICAgTGV0IFogPSBT\nKihBKmRpYWcoeCkpLCB3aGVyZSB4IGlzIHRoZSBzb2x1dGlvbiBmb3IgdGhlCiAgICAgICAgICAg\nICBjdXJyZW50IHJpZ2h0LWhhbmQgc2lkZSBhbmQgUyBzY2FsZXMgZWFjaCByb3cgb2YKICAgICAg\nICAgICAgIEEqZGlhZyh4KSBieSBhIHBvd2VyIG9mIHRoZSByYWRpeCBzbyBhbGwgYWJzb2x1dGUg\ncm93CiAgICAgICAgICAgICBzdW1zIG9mIFogYXJlIGFwcHJveGltYXRlbHkgMS4KICAgIFNlZSBM\nYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhlciBkZXRhaWxzIGFuZCBleHRyYQogICAg\nY2F1dGlvbnMuClxwYXJhbVtpbl0gTlBBUkFNUwogICAgICAgICBOUEFSQU1TIGlzIElOVEVHRVIK\nICAgIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgc2V0IGluIFBBUkFNUy4gIElm\nIC5MRS4gMCwgdGhlCiAgICBQQVJBTVMgYXJyYXkgaXMgbmV2ZXIgcmVmZXJlbmNlZCBhbmQgZGVm\nYXVsdCB2YWx1ZXMgYXJlIHVzZWQuClxwYXJhbVtpbixvdXRdIFBBUkFNUwogICAgICAgICBQQVJB\nTVMgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIE5QQVJBTVMKICAgIFNwZWNpZmllcyBhbGdvcml0\naG0gcGFyYW1ldGVycy4gIElmIGFuIGVudHJ5IGlzIC5MVC4gMC4wLCB0aGVuCiAgICB0aGF0IGVu\ndHJ5IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVmYXVsdCB2YWx1ZSB1c2VkIGZvciB0aGF0CiAgICBw\nYXJhbWV0ZXIuICBPbmx5IHBvc2l0aW9ucyB1cCB0byBOUEFSQU1TIGFyZSBhY2Nlc3NlZDsgZGVm\nYXVsdHMKICAgIGFyZSB1c2VkIGZvciBoaWdoZXItbnVtYmVyZWQgcGFyYW1ldGVycy4KICAgICAg\nUEFSQU1TKExBX0xJTlJYX0lUUkVGX0kgPSAxKSA6IFdoZXRoZXIgdG8gcGVyZm9ybSBpdGVyYXRp\ndmUKICAgICAgICAgICByZWZpbmVtZW50IG9yIG5vdC4KICAgICAgICBEZWZhdWx0OiAxLjAKICAg\nICAgICAgICA9IDAuMCA6IE5vIHJlZmluZW1lbnQgaXMgcGVyZm9ybWVkLCBhbmQgbm8gZXJyb3Ig\nYm91bmRzIGFyZQogICAgICAgICAgICAgICAgICAgY29tcHV0ZWQuCiAgICAgICAgICAgPSAxLjAg\nOiBVc2UgdGhlIGRvdWJsZS1wcmVjaXNpb24gcmVmaW5lbWVudCBhbGdvcml0aG0sCiAgICAgICAg\nICAgICAgICAgICBwb3NzaWJseSB3aXRoIGRvdWJsZWQtc2luZ2xlIGNvbXB1dGF0aW9ucyBpZiB0\naGUKICAgICAgICAgICAgICAgICAgIGNvbXBpbGF0aW9uIGVudmlyb25tZW50IGRvZXMgbm90IHN1\ncHBvcnQgRE9VQkxFCiAgICAgICAgICAgICAgICAgICBQUkVDSVNJT04uCiAgICAgICAgICAgICAo\nb3RoZXIgdmFsdWVzIGFyZSByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSkKICAgICAgUEFSQU1TKExB\nX0xJTlJYX0lUSFJFU0hfSSA9IDIpIDogTWF4aW11bSBudW1iZXIgb2YgcmVzaWR1YWwKICAgICAg\nICAgICBjb21wdXRhdGlvbnMgYWxsb3dlZCBmb3IgcmVmaW5lbWVudC4KICAgICAgICBEZWZhdWx0\nOiAxMAogICAgICAgIEFnZ3Jlc3NpdmU6IFNldCB0byAxMDAgdG8gcGVybWl0IGNvbnZlcmdlbmNl\nIHVzaW5nIGFwcHJveGltYXRlCiAgICAgICAgICAgICAgICAgICAgZmFjdG9yaXphdGlvbnMgb3Ig\nZmFjdG9yaXphdGlvbnMgb3RoZXIgdGhhbiBMVS4gSWYKICAgICAgICAgICAgICAgICAgICB0aGUg\nZmFjdG9yaXphdGlvbiB1c2VzIGEgdGVjaG5pcXVlIG90aGVyIHRoYW4KICAgICAgICAgICAgICAg\nICAgICBHYXVzc2lhbiBlbGltaW5hdGlvbiwgdGhlIGd1YXJhbnRlZXMgaW4KICAgICAgICAgICAg\nICAgICAgICBlcnJfYm5kc19ub3JtIGFuZCBlcnJfYm5kc19jb21wIG1heSBubyBsb25nZXIgYmUK\nICAgICAgICAgICAgICAgICAgICB0cnVzdHdvcnRoeS4KICAgICAgUEFSQU1TKExBX0xJTlJYX0NX\nSVNFX0kgPSAzKSA6IEZsYWcgZGV0ZXJtaW5pbmcgaWYgdGhlIGNvZGUKICAgICAgICAgICB3aWxs\nIGF0dGVtcHQgdG8gZmluZCBhIHNvbHV0aW9uIHdpdGggc21hbGwgY29tcG9uZW50d2lzZQogICAg\nICAgICAgIHJlbGF0aXZlIGVycm9yIGluIHRoZSBkb3VibGUtcHJlY2lzaW9uIGFsZ29yaXRobS4g\nIFBvc2l0aXZlCiAgICAgICAgICAgaXMgdHJ1ZSwgMC4wIGlzIGZhbHNlLgogICAgICAgIERlZmF1\nbHQ6IDEuMCAoYXR0ZW1wdCBjb21wb25lbnR3aXNlIGNvbnZlcmdlbmNlKQpccGFyYW1bb3V0XSBX\nT1JLCiAgICAgICAgIFdPUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uICg0Kk4pClxwYXJhbVtv\ndXRdIElXT1JLCiAgICAgICAgIElXT1JLIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikK\nXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgPSAwOiAgU3Vj\nY2Vzc2Z1bCBleGl0LiBUaGUgc29sdXRpb24gdG8gZXZlcnkgcmlnaHQtaGFuZCBzaWRlIGlzCiAg\nICAgICAgZ3VhcmFudGVlZC4KICAgICAgPCAwOiAgSWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1\nbWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQogICAgICA+IDAgYW5kIDw9IE46ICBVKElORk8sSU5G\nTykgaXMgZXhhY3RseSB6ZXJvLiAgVGhlIGZhY3Rvcml6YXRpb24KICAgICAgICBoYXMgYmVlbiBj\nb21wbGV0ZWQsIGJ1dCB0aGUgZmFjdG9yIFUgaXMgZXhhY3RseSBzaW5ndWxhciwgc28KICAgICAg\nICB0aGUgc29sdXRpb24gYW5kIGVycm9yIGJvdW5kcyBjb3VsZCBub3QgYmUgY29tcHV0ZWQuIFJD\nT05EID0gMAogICAgICAgIGlzIHJldHVybmVkLgogICAgICA9IE4rSjogVGhlIHNvbHV0aW9uIGNv\ncnJlc3BvbmRpbmcgdG8gdGhlIEp0aCByaWdodC1oYW5kIHNpZGUgaXMKICAgICAgICBub3QgZ3Vh\ncmFudGVlZC4gVGhlIHNvbHV0aW9ucyBjb3JyZXNwb25kaW5nIHRvIG90aGVyIHJpZ2h0LQogICAg\nICAgIGhhbmQgc2lkZXMgSyB3aXRoIEsgPiBKIG1heSBub3QgYmUgZ3VhcmFudGVlZCBhcyB3ZWxs\nLCBidXQKICAgICAgICBvbmx5IHRoZSBmaXJzdCBzdWNoIHJpZ2h0LWhhbmQgc2lkZSBpcyByZXBv\ncnRlZC4gSWYgYSBzbWFsbAogICAgICAgIGNvbXBvbmVudHdpc2UgZXJyb3IgaXMgbm90IHJlcXVl\nc3RlZCAoUEFSQU1TKDMpID0gMC4wKSB0aGVuCiAgICAgICAgdGhlIEp0aCByaWdodC1oYW5kIHNp\nZGUgaXMgdGhlIGZpcnN0IHdpdGggYSBub3Jtd2lzZSBlcnJvcgogICAgICAgIGJvdW5kIHRoYXQg\naXMgbm90IGd1YXJhbnRlZWQgKHRoZSBzbWFsbGVzdCBKIHN1Y2gKICAgICAgICB0aGF0IEVSUl9C\nTkRTX05PUk0oSiwxKSA9IDAuMCkuIEJ5IGRlZmF1bHQgKFBBUkFNUygzKSA9IDEuMCkKICAgICAg\nICB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcyB0aGUgZmlyc3Qgd2l0aCBlaXRoZXIgYSBub3Jt\nd2lzZSBvcgogICAgICAgIGNvbXBvbmVudHdpc2UgZXJyb3IgYm91bmQgdGhhdCBpcyBub3QgZ3Vh\ncmFudGVlZCAodGhlIHNtYWxsZXN0CiAgICAgICAgSiBzdWNoIHRoYXQgZWl0aGVyIEVSUl9CTkRT\nX05PUk0oSiwxKSA9IDAuMCBvcgogICAgICAgIEVSUl9CTkRTX0NPTVAoSiwxKSA9IDAuMCkuIFNl\nZSB0aGUgZGVmaW5pdGlvbiBvZgogICAgICAgIEVSUl9CTkRTX05PUk0oOiwxKSBhbmQgRVJSX0JO\nRFNfQ09NUCg6LDEpLiBUbyBnZXQgaW5mb3JtYXRpb24KICAgICAgICBhYm91dCBhbGwgb2YgdGhl\nIHJpZ2h0LWhhbmQgc2lkZXMgY2hlY2sgRVJSX0JORFNfTk9STSBvcgogICAgICAgIEVSUl9CTkRT\nX0NPTVAuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYu\nIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVy\nIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBBcHJpbCAyMDEyClxpbmdyb3VwIHJlYWxQT2NvbXB1\ndGF0aW9uYWwKaB1oHimBcg8CAAB9chACAAAoaCGJaCJoI3ViaC2KAqMBaC5YDwAAAHNwb3Jmc3hf\nNDE5LnR4dHViaC+KAqMBaDBYBgAAAHBvcmZzeGgtigE9dWJoFWgWXWgXh1JyEQIAAH1yEgIAACho\nGlgDAAAAU1BEaBtYBAAAAGZ1bGxoHFhGAAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJv\nciBlc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZpbmVtZW50OyBFUVVFRGgdaB4pgXITAgAAfXIUAgAA\nKGghiWgiaCN1YmgkWCEAAABEb3h5Z2VuL2RvY3MvaHRtbC9kcG9yZnN4XzhmLmh0bWxoJVgBAAAA\nZGgmaBVoJ11oF4dSchUCAAB9chYCAAAoaCpYNzEAACAgIERQT1JGU1ggaW1wcm92ZXMgdGhlIGNv\nbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgogICBlcXVhdGlvbnMgd2hlbiB0\naGUgY29lZmZpY2llbnQgbWF0cml4IGlzIHN5bW1ldHJpYyBwb3NpdGl2ZQogICBkZWZpbml0ZSwg\nYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzCiAg\nIGZvciB0aGUgc29sdXRpb24uICBJbiBhZGRpdGlvbiB0byBub3Jtd2lzZSBlcnJvciBib3VuZCwg\ndGhlIGNvZGUKICAgcHJvdmlkZXMgbWF4aW11bSBjb21wb25lbnR3aXNlIGVycm9yIGJvdW5kIGlm\nIHBvc3NpYmxlLiAgU2VlCiAgIGNvbW1lbnRzIGZvciBFUlJfQk5EU19OT1JNIGFuZCBFUlJfQk5E\nU19DT01QIGZvciBkZXRhaWxzIG9mIHRoZQogICBlcnJvciBib3VuZHMuCiAgIFRoZSBvcmlnaW5h\nbCBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyBtYXkgaGF2ZSBiZWVuIGVxdWlsaWJyYXRlZAog\nICBiZWZvcmUgY2FsbGluZyB0aGlzIHJvdXRpbmUsIGFzIGRlc2NyaWJlZCBieSBhcmd1bWVudHMg\nRVFVRUQgYW5kIFMKICAgYmVsb3cuIEluIHRoaXMgY2FzZSwgdGhlIHNvbHV0aW9uIGFuZCBlcnJv\nciBib3VuZHMgcmV0dXJuZWQgYXJlCiAgIGZvciB0aGUgb3JpZ2luYWwgdW5lcXVpbGlicmF0ZWQg\nc3lzdGVtLgpBcmd1bWVudHM6CiAgICBTb21lIG9wdGlvbmFsIHBhcmFtZXRlcnMgYXJlIGJ1bmRs\nZWQgaW4gdGhlIFBBUkFNUyBhcnJheS4gIFRoZXNlCiAgICBzZXR0aW5ncyBkZXRlcm1pbmUgaG93\nIHJlZmluZW1lbnQgaXMgcGVyZm9ybWVkLCBidXQgb2Z0ZW4gdGhlCiAgICBkZWZhdWx0cyBhcmUg\nYWNjZXB0YWJsZS4gIElmIHRoZSBkZWZhdWx0cyBhcmUgYWNjZXB0YWJsZSwgdXNlcnMKICAgIGNh\nbiBwYXNzIE5QQVJBTVMgPSAwIHdoaWNoIHByZXZlbnRzIHRoZSBzb3VyY2UgY29kZSBmcm9tIGFj\nY2Vzc2luZwogICAgdGhlIFBBUkFNUyBhcmd1bWVudC4KXHBhcmFtW2luXSBVUExPCiAgICAgICAg\nIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgPSAnVSc6ICBVcHBlciB0cmlhbmdsZSBvZiBBIGlz\nIHN0b3JlZDsKICAgICAgPSAnTCc6ICBMb3dlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZC4KXHBh\ncmFtW2luXSBFUVVFRAogICAgICAgICBFUVVFRCBpcyBDSEFSQUNURVIqMQogICAgU3BlY2lmaWVz\nIHRoZSBmb3JtIG9mIGVxdWlsaWJyYXRpb24gdGhhdCB3YXMgZG9uZSB0byBBCiAgICBiZWZvcmUg\nY2FsbGluZyB0aGlzIHJvdXRpbmUuIFRoaXMgaXMgbmVlZGVkIHRvIGNvbXB1dGUKICAgIHRoZSBz\nb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIGNvcnJlY3RseS4KICAgICAgPSAnTic6ICBObyBlcXVp\nbGlicmF0aW9uCiAgICAgID0gJ1knOiAgQm90aCByb3cgYW5kIGNvbHVtbiBlcXVpbGlicmF0aW9u\nLCBpLmUuLCBBIGhhcyBiZWVuCiAgICAgICAgICAgICAgcmVwbGFjZWQgYnkgZGlhZyhTKSAqIEEg\nKiBkaWFnKFMpLgogICAgICAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgQiBoYXMgYmVlbiBj\naGFuZ2VkIGFjY29yZGluZ2x5LgpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAg\nICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAg\nICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMs\nIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFgu\nICBOUkhTID49IDAuClxwYXJhbVtpbl0gQQogICAgICAgICBBIGlzIERPVUJMRSBQUkVDSVNJT04g\nYXJyYXksIGRpbWVuc2lvbiAoTERBLE4pCiAgICBUaGUgc3ltbWV0cmljIG1hdHJpeCBBLiAgSWYg\nVVBMTyA9ICdVJywgdGhlIGxlYWRpbmcgTi1ieS1OCiAgICB1cHBlciB0cmlhbmd1bGFyIHBhcnQg\nb2YgQSBjb250YWlucyB0aGUgdXBwZXIgdHJpYW5ndWxhciBwYXJ0CiAgICBvZiB0aGUgbWF0cml4\nIEEsIGFuZCB0aGUgc3RyaWN0bHkgbG93ZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEKICAgIGlzIG5v\ndCByZWZlcmVuY2VkLiAgSWYgVVBMTyA9ICdMJywgdGhlIGxlYWRpbmcgTi1ieS1OIGxvd2VyCiAg\nICB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgbG93ZXIgdHJpYW5ndWxhciBwYXJ0\nIG9mCiAgICB0aGUgbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkgdXBwZXIgdHJpYW5ndWxhciBw\nYXJ0IG9mIEEgaXMKICAgIG5vdCByZWZlcmVuY2VkLgpccGFyYW1baW5dIExEQQogICAgICAgICBM\nREEgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBLiAg\nTERBID49IG1heCgxLE4pLgpccGFyYW1baW5dIEFGCiAgICAgICAgIEFGIGlzIERPVUJMRSBQUkVD\nSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTERBRixOKQogICAgVGhlIHRyaWFuZ3VsYXIgZmFjdG9y\nIFUgb3IgTCBmcm9tIHRoZSBDaG9sZXNreSBmYWN0b3JpemF0aW9uCiAgICBBID0gVSoqVCpVIG9y\nIEEgPSBMKkwqKlQsIGFzIGNvbXB1dGVkIGJ5IERQT1RSRi4KXHBhcmFtW2luXSBMREFGCiAgICAg\nICAgIExEQUYgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJh\neSBBRi4gIExEQUYgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFMKICAgICAgICAgUyBpcyBE\nT1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICBUaGUgcm93IHNjYWxlIGZh\nY3RvcnMgZm9yIEEuICBJZiBFUVVFRCA9ICdZJywgQSBpcyBtdWx0aXBsaWVkIG9uCiAgICB0aGUg\nbGVmdCBhbmQgcmlnaHQgYnkgZGlhZyhTKS4gIFMgaXMgYW4gaW5wdXQgYXJndW1lbnQgaWYgRkFD\nVCA9CiAgICAnRic7IG90aGVyd2lzZSwgUyBpcyBhbiBvdXRwdXQgYXJndW1lbnQuICBJZiBGQUNU\nID0gJ0YnIGFuZCBFUVVFRAogICAgPSAnWScsIGVhY2ggZWxlbWVudCBvZiBTIG11c3QgYmUgcG9z\naXRpdmUuICBJZiBTIGlzIG91dHB1dCwgZWFjaAogICAgZWxlbWVudCBvZiBTIGlzIGEgcG93ZXIg\nb2YgdGhlIHJhZGl4LiBJZiBTIGlzIGlucHV0LCBlYWNoIGVsZW1lbnQKICAgIG9mIFMgc2hvdWxk\nIGJlIGEgcG93ZXIgb2YgdGhlIHJhZGl4IHRvIGVuc3VyZSBhIHJlbGlhYmxlIHNvbHV0aW9uCiAg\nICBhbmQgZXJyb3IgZXN0aW1hdGVzLiBTY2FsaW5nIGJ5IHBvd2VycyBvZiB0aGUgcmFkaXggZG9l\ncyBub3QgY2F1c2UKICAgIHJvdW5kaW5nIGVycm9ycyB1bmxlc3MgdGhlIHJlc3VsdCB1bmRlcmZs\nb3dzIG9yIG92ZXJmbG93cy4KICAgIFJvdW5kaW5nIGVycm9ycyBkdXJpbmcgc2NhbGluZyBsZWFk\nIHRvIHJlZmluaW5nIHdpdGggYSBtYXRyaXggdGhhdAogICAgaXMgbm90IGVxdWl2YWxlbnQgdG8g\ndGhlIGlucHV0IG1hdHJpeCwgcHJvZHVjaW5nIGVycm9yIGVzdGltYXRlcwogICAgdGhhdCBtYXkg\nbm90IGJlIHJlbGlhYmxlLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBET1VCTEUgUFJFQ0lT\nSU9OIGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQogICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBt\nYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVHRVIKICAgIFRoZSBs\nZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFt\nW2luLG91dF0gWAogICAgICAgICBYIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lv\nbiAoTERYLE5SSFMpCiAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21w\ndXRlZCBieSBER0VUUlMuCiAgICBPbiBleGl0LCB0aGUgaW1wcm92ZWQgc29sdXRpb24gbWF0cml4\nIFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGlu\nZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4KDEsTikuClxwYXJhbVtvdXRd\nIFJDT05ECiAgICAgICAgIFJDT05EIGlzIERPVUJMRSBQUkVDSVNJT04KICAgIFJlY2lwcm9jYWwg\nc2NhbGVkIGNvbmRpdGlvbiBudW1iZXIuICBUaGlzIGlzIGFuIGVzdGltYXRlIG9mIHRoZQogICAg\ncmVjaXByb2NhbCBTa2VlbCBjb25kaXRpb24gbnVtYmVyIG9mIHRoZSBtYXRyaXggQSBhZnRlcgog\nICAgZXF1aWxpYnJhdGlvbiAoaWYgZG9uZSkuICBJZiB0aGlzIGlzIGxlc3MgdGhhbiB0aGUgbWFj\naGluZQogICAgcHJlY2lzaW9uIChpbiBwYXJ0aWN1bGFyLCBpZiBpdCBpcyB6ZXJvKSwgdGhlIG1h\ndHJpeCBpcyBzaW5ndWxhcgogICAgdG8gd29ya2luZyBwcmVjaXNpb24uICBOb3RlIHRoYXQgdGhl\nIGVycm9yIG1heSBzdGlsbCBiZSBzbWFsbCBldmVuCiAgICBpZiB0aGlzIG51bWJlciBpcyB2ZXJ5\nIHNtYWxsIGFuZCB0aGUgbWF0cml4IGFwcGVhcnMgaWxsLQogICAgY29uZGl0aW9uZWQuClxwYXJh\nbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1l\nbnNpb24gKE5SSFMpCiAgICBDb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yLiAg\nVGhpcyBpcyB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2Yg\nZWFjaCBzb2x1dGlvbiB2ZWN0b3IgWChqKQogICAgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2\nZSBjaGFuZ2UgaW4gYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQKICAgIG1ha2VzIFgoaikgYW4g\nZXhhY3Qgc29sdXRpb24pLgpccGFyYW1baW5dIE5fRVJSX0JORFMKICAgICAgICAgTl9FUlJfQk5E\nUyBpcyBJTlRFR0VSCiAgICBOdW1iZXIgb2YgZXJyb3IgYm91bmRzIHRvIHJldHVybiBmb3IgZWFj\naCByaWdodCBoYW5kIHNpZGUKICAgIGFuZCBlYWNoIHR5cGUgKG5vcm13aXNlIG9yIGNvbXBvbmVu\ndHdpc2UpLiAgU2VlIEVSUl9CTkRTX05PUk0gYW5kCiAgICBFUlJfQk5EU19DT01QIGJlbG93Lgpc\ncGFyYW1bb3V0XSBFUlJfQk5EU19OT1JNCiAgICAgICAgIEVSUl9CTkRTX05PUk0gaXMgRE9VQkxF\nIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTLCBOX0VSUl9CTkRTKQogICAgRm9yIGVh\nY2ggcmlnaHQtaGFuZCBzaWRlLCB0aGlzIGFycmF5IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0\nCiAgICB2YXJpb3VzIGVycm9yIGJvdW5kcyBhbmQgY29uZGl0aW9uIG51bWJlcnMgY29ycmVzcG9u\nZGluZyB0byB0aGUKICAgIG5vcm13aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVk\nIGFzIGZvbGxvd3M6CiAgICBOb3Jtd2lzZSByZWxhdGl2ZSBlcnJvciBpbiB0aGUgaXRoIHNvbHV0\naW9uIHZlY3RvcjoKICAgICAgICAgICAgbWF4X2ogKGFicyhYVFJVRShqLGkpIC0gWChqLGkpKSkK\nICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAg\nICBtYXhfaiBhYnMoWChqLGkpKQogICAgVGhlIGFycmF5IGlzIGluZGV4ZWQgYnkgdGhlIHR5cGUg\nb2YgZXJyb3IgaW5mb3JtYXRpb24gYXMgZGVzY3JpYmVkCiAgICBiZWxvdy4gVGhlcmUgY3VycmVu\ndGx5IGFyZSB1cCB0byB0aHJlZSBwaWVjZXMgb2YgaW5mb3JtYXRpb24KICAgIHJldHVybmVkLgog\nICAgVGhlIGZpcnN0IGluZGV4IGluIEVSUl9CTkRTX05PUk0oaSw6KSBjb3JyZXNwb25kcyB0byB0\naGUgaXRoCiAgICByaWdodC1oYW5kIHNpZGUuCiAgICBUaGUgc2Vjb25kIGluZGV4IGluIEVSUl9C\nTkRTX05PUk0oOixlcnIpIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcKICAgIHRocmVlIGZpZWxkczoK\nICAgIGVyciA9IDEgIlRydXN0L2Rvbid0IHRydXN0IiBib29sZWFuLiBUcnVzdCB0aGUgYW5zd2Vy\nIGlmIHRoZQogICAgICAgICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyIGlzIGxlc3Mg\ndGhhbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogZGxhbWNoKCdFcHNpbG9u\nJykuCiAgICBlcnIgPSAyICJHdWFyYW50ZWVkIiBlcnJvciBib3VuZDogVGhlIGVzdGltYXRlZCBm\nb3J3YXJkIGVycm9yLAogICAgICAgICAgICAgYWxtb3N0IGNlcnRhaW5seSB3aXRoaW4gYSBmYWN0\nb3Igb2YgMTAgb2YgdGhlIHRydWUgZXJyb3IKICAgICAgICAgICAgIHNvIGxvbmcgYXMgdGhlIG5l\neHQgZW50cnkgaXMgZ3JlYXRlciB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQo\nbikgKiBkbGFtY2goJ0Vwc2lsb24nKS4gVGhpcyBlcnJvciBib3VuZCBzaG91bGQgb25seQogICAg\nICAgICAgICAgYmUgdHJ1c3RlZCBpZiB0aGUgcHJldmlvdXMgYm9vbGVhbiBpcyB0cnVlLgogICAg\nZXJyID0gMyAgUmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyOiBFc3RpbWF0ZWQgbm9ybXdpc2UK\nICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlci4gIENvbXBhcmVkIHdpdGgg\ndGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpIHRv\nIGRldGVybWluZSBpZiB0aGUgZXJyb3IKICAgICAgICAgICAgIGVzdGltYXRlIGlzICJndWFyYW50\nZWVkIi4gVGhlc2UgcmVjaXByb2NhbCBjb25kaXRpb24KICAgICAgICAgICAgIG51bWJlcnMgYXJl\nIDEgLyAobm9ybShaXnstMX0saW5mKSAqIG5vcm0oWixpbmYpKSBmb3Igc29tZQogICAgICAgICAg\nICAgYXBwcm9wcmlhdGVseSBzY2FsZWQgbWF0cml4IFouCiAgICAgICAgICAgICBMZXQgWiA9IFMq\nQSwgd2hlcmUgUyBzY2FsZXMgZWFjaCByb3cgYnkgYSBwb3dlciBvZiB0aGUKICAgICAgICAgICAg\nIHJhZGl4IHNvIGFsbCBhYnNvbHV0ZSByb3cgc3VtcyBvZiBaIGFyZSBhcHByb3hpbWF0ZWx5IDEu\nCiAgICBTZWUgTGFwYWNrIFdvcmtpbmcgTm90ZSAxNjUgZm9yIGZ1cnRoZXIgZGV0YWlscyBhbmQg\nZXh0cmEKICAgIGNhdXRpb25zLgpccGFyYW1bb3V0XSBFUlJfQk5EU19DT01QCiAgICAgICAgIEVS\nUl9CTkRTX0NPTVAgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTLCBO\nX0VSUl9CTkRTKQogICAgRm9yIGVhY2ggcmlnaHQtaGFuZCBzaWRlLCB0aGlzIGFycmF5IGNvbnRh\naW5zIGluZm9ybWF0aW9uIGFib3V0CiAgICB2YXJpb3VzIGVycm9yIGJvdW5kcyBhbmQgY29uZGl0\naW9uIG51bWJlcnMgY29ycmVzcG9uZGluZyB0byB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRp\ndmUgZXJyb3IsIHdoaWNoIGlzIGRlZmluZWQgYXMgZm9sbG93czoKICAgIENvbXBvbmVudHdpc2Ug\ncmVsYXRpdmUgZXJyb3IgaW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAgICAgICAgICAg\nICAgICBhYnMoWFRSVUUoaixpKSAtIFgoaixpKSkKICAgICAgICAgICAgbWF4X2ogLS0tLS0tLS0t\nLS0tLS0tLS0tLS0tLQogICAgICAgICAgICAgICAgICAgICAgICBhYnMoWChqLGkpKQogICAgVGhl\nIGFycmF5IGlzIGluZGV4ZWQgYnkgdGhlIHJpZ2h0LWhhbmQgc2lkZSBpIChvbiB3aGljaCB0aGUK\nICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJyb3IgZGVwZW5kcyksIGFuZCB0aGUgdHlwZSBv\nZiBlcnJvcgogICAgaW5mb3JtYXRpb24gYXMgZGVzY3JpYmVkIGJlbG93LiBUaGVyZSBjdXJyZW50\nbHkgYXJlIHVwIHRvIHRocmVlCiAgICBwaWVjZXMgb2YgaW5mb3JtYXRpb24gcmV0dXJuZWQgZm9y\nIGVhY2ggcmlnaHQtaGFuZCBzaWRlLiBJZgogICAgY29tcG9uZW50d2lzZSBhY2N1cmFjeSBpcyBu\nb3QgcmVxdWVzdGVkIChQQVJBTVMoMykgPSAwLjApLCB0aGVuCiAgICBFUlJfQk5EU19DT01QIGlz\nIG5vdCBhY2Nlc3NlZC4gIElmIE5fRVJSX0JORFMgLkxULiAzLCB0aGVuIGF0IG1vc3QKICAgIHRo\nZSBmaXJzdCAoOixOX0VSUl9CTkRTKSBlbnRyaWVzIGFyZSByZXR1cm5lZC4KICAgIFRoZSBmaXJz\ndCBpbmRleCBpbiBFUlJfQk5EU19DT01QKGksOikgY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAg\ncmlnaHQtaGFuZCBzaWRlLgogICAgVGhlIHNlY29uZCBpbmRleCBpbiBFUlJfQk5EU19DT01QKDos\nZXJyKSBjb250YWlucyB0aGUgZm9sbG93aW5nCiAgICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAx\nICJUcnVzdC9kb24ndCB0cnVzdCIgYm9vbGVhbi4gVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAg\nICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRo\ncmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpLgogICAgZXJy\nID0gMiAiR3VhcmFudGVlZCIgZXJyb3IgYm91bmQ6IFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJv\nciwKICAgICAgICAgICAgIGFsbW9zdCBjZXJ0YWlubHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9m\nIHRoZSB0cnVlIGVycm9yCiAgICAgICAgICAgICBzbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlz\nIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogZGxhbWNo\nKCdFcHNpbG9uJykuIFRoaXMgZXJyb3IgYm91bmQgc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJl\nIHRydXN0ZWQgaWYgdGhlIHByZXZpb3VzIGJvb2xlYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJl\nY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlcjogRXN0aW1hdGVkIGNvbXBvbmVudHdpc2UKICAgICAg\nICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlci4gIENvbXBhcmVkIHdpdGggdGhlIHRo\ncmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpIHRvIGRldGVy\nbWluZSBpZiB0aGUgZXJyb3IKICAgICAgICAgICAgIGVzdGltYXRlIGlzICJndWFyYW50ZWVkIi4g\nVGhlc2UgcmVjaXByb2NhbCBjb25kaXRpb24KICAgICAgICAgICAgIG51bWJlcnMgYXJlIDEgLyAo\nbm9ybShaXnstMX0saW5mKSAqIG5vcm0oWixpbmYpKSBmb3Igc29tZQogICAgICAgICAgICAgYXBw\ncm9wcmlhdGVseSBzY2FsZWQgbWF0cml4IFouCiAgICAgICAgICAgICBMZXQgWiA9IFMqKEEqZGlh\nZyh4KSksIHdoZXJlIHggaXMgdGhlIHNvbHV0aW9uIGZvciB0aGUKICAgICAgICAgICAgIGN1cnJl\nbnQgcmlnaHQtaGFuZCBzaWRlIGFuZCBTIHNjYWxlcyBlYWNoIHJvdyBvZgogICAgICAgICAgICAg\nQSpkaWFnKHgpIGJ5IGEgcG93ZXIgb2YgdGhlIHJhZGl4IHNvIGFsbCBhYnNvbHV0ZSByb3cKICAg\nICAgICAgICAgIHN1bXMgb2YgWiBhcmUgYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFjayBX\nb3JraW5nIE5vdGUgMTY1IGZvciBmdXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9u\ncy4KXHBhcmFtW2luXSBOUEFSQU1TCiAgICAgICAgIE5QQVJBTVMgaXMgSU5URUdFUgogICAgU3Bl\nY2lmaWVzIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycyBzZXQgaW4gUEFSQU1TLiAgSWYgLkxFLiAw\nLCB0aGUKICAgIFBBUkFNUyBhcnJheSBpcyBuZXZlciByZWZlcmVuY2VkIGFuZCBkZWZhdWx0IHZh\nbHVlcyBhcmUgdXNlZC4KXHBhcmFtW2luLG91dF0gUEFSQU1TCiAgICAgICAgIFBBUkFNUyBpcyBE\nT1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5QQVJBTVMpCiAgICBTcGVjaWZpZXMg\nYWxnb3JpdGhtIHBhcmFtZXRlcnMuICBJZiBhbiBlbnRyeSBpcyAuTFQuIDAuMCwgdGhlbgogICAg\ndGhhdCBlbnRyeSB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlZmF1bHQgdmFsdWUgdXNlZCBmb3IgdGhh\ndAogICAgcGFyYW1ldGVyLiAgT25seSBwb3NpdGlvbnMgdXAgdG8gTlBBUkFNUyBhcmUgYWNjZXNz\nZWQ7IGRlZmF1bHRzCiAgICBhcmUgdXNlZCBmb3IgaGlnaGVyLW51bWJlcmVkIHBhcmFtZXRlcnMu\nCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9JVFJFRl9JID0gMSkgOiBXaGV0aGVyIHRvIHBlcmZvcm0g\naXRlcmF0aXZlCiAgICAgICAgICAgcmVmaW5lbWVudCBvciBub3QuCiAgICAgICAgRGVmYXVsdDog\nMS4wRCswCiAgICAgICAgICAgPSAwLjAgOiBObyByZWZpbmVtZW50IGlzIHBlcmZvcm1lZCwgYW5k\nIG5vIGVycm9yIGJvdW5kcyBhcmUKICAgICAgICAgICAgICAgICAgIGNvbXB1dGVkLgogICAgICAg\nICAgID0gMS4wIDogVXNlIHRoZSBkb3VibGUtcHJlY2lzaW9uIHJlZmluZW1lbnQgYWxnb3JpdGht\nLAogICAgICAgICAgICAgICAgICAgcG9zc2libHkgd2l0aCBkb3VibGVkLXNpbmdsZSBjb21wdXRh\ndGlvbnMgaWYgdGhlCiAgICAgICAgICAgICAgICAgICBjb21waWxhdGlvbiBlbnZpcm9ubWVudCBk\nb2VzIG5vdCBzdXBwb3J0IERPVUJMRQogICAgICAgICAgICAgICAgICAgUFJFQ0lTSU9OLgogICAg\nICAgICAgICAgKG90aGVyIHZhbHVlcyBhcmUgcmVzZXJ2ZWQgZm9yIGZ1dHVyZSB1c2UpCiAgICAg\nIFBBUkFNUyhMQV9MSU5SWF9JVEhSRVNIX0kgPSAyKSA6IE1heGltdW0gbnVtYmVyIG9mIHJlc2lk\ndWFsCiAgICAgICAgICAgY29tcHV0YXRpb25zIGFsbG93ZWQgZm9yIHJlZmluZW1lbnQuCiAgICAg\nICAgRGVmYXVsdDogMTAKICAgICAgICBBZ2dyZXNzaXZlOiBTZXQgdG8gMTAwIHRvIHBlcm1pdCBj\nb252ZXJnZW5jZSB1c2luZyBhcHByb3hpbWF0ZQogICAgICAgICAgICAgICAgICAgIGZhY3Rvcml6\nYXRpb25zIG9yIGZhY3Rvcml6YXRpb25zIG90aGVyIHRoYW4gTFUuIElmCiAgICAgICAgICAgICAg\nICAgICAgdGhlIGZhY3Rvcml6YXRpb24gdXNlcyBhIHRlY2huaXF1ZSBvdGhlciB0aGFuCiAgICAg\nICAgICAgICAgICAgICAgR2F1c3NpYW4gZWxpbWluYXRpb24sIHRoZSBndWFyYW50ZWVzIGluCiAg\nICAgICAgICAgICAgICAgICAgZXJyX2JuZHNfbm9ybSBhbmQgZXJyX2JuZHNfY29tcCBtYXkgbm8g\nbG9uZ2VyIGJlCiAgICAgICAgICAgICAgICAgICAgdHJ1c3R3b3J0aHkuCiAgICAgIFBBUkFNUyhM\nQV9MSU5SWF9DV0lTRV9JID0gMykgOiBGbGFnIGRldGVybWluaW5nIGlmIHRoZSBjb2RlCiAgICAg\nICAgICAgd2lsbCBhdHRlbXB0IHRvIGZpbmQgYSBzb2x1dGlvbiB3aXRoIHNtYWxsIGNvbXBvbmVu\ndHdpc2UKICAgICAgICAgICByZWxhdGl2ZSBlcnJvciBpbiB0aGUgZG91YmxlLXByZWNpc2lvbiBh\nbGdvcml0aG0uICBQb3NpdGl2ZQogICAgICAgICAgIGlzIHRydWUsIDAuMCBpcyBmYWxzZS4KICAg\nICAgICBEZWZhdWx0OiAxLjAgKGF0dGVtcHQgY29tcG9uZW50d2lzZSBjb252ZXJnZW5jZSkKXHBh\ncmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRp\nbWVuc2lvbiAoNCpOKQpccGFyYW1bb3V0XSBJV09SSwogICAgICAgICBJV09SSyBpcyBJTlRFR0VS\nIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRdIElORk8KICAgICAgICAgSU5GTyBpcyBJ\nTlRFR0VSCiAgICAgID0gMDogIFN1Y2Nlc3NmdWwgZXhpdC4gVGhlIHNvbHV0aW9uIHRvIGV2ZXJ5\nIHJpZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIGd1YXJhbnRlZWQuCiAgICAgIDwgMDogIElmIElO\nRk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKICAgICAgPiAw\nIGFuZCA8PSBOOiAgVShJTkZPLElORk8pIGlzIGV4YWN0bHkgemVyby4gIFRoZSBmYWN0b3JpemF0\naW9uCiAgICAgICAgaGFzIGJlZW4gY29tcGxldGVkLCBidXQgdGhlIGZhY3RvciBVIGlzIGV4YWN0\nbHkgc2luZ3VsYXIsIHNvCiAgICAgICAgdGhlIHNvbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgY291\nbGQgbm90IGJlIGNvbXB1dGVkLiBSQ09ORCA9IDAKICAgICAgICBpcyByZXR1cm5lZC4KICAgICAg\nPSBOK0o6IFRoZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBKdGggcmlnaHQtaGFuZCBz\naWRlIGlzCiAgICAgICAgbm90IGd1YXJhbnRlZWQuIFRoZSBzb2x1dGlvbnMgY29ycmVzcG9uZGlu\nZyB0byBvdGhlciByaWdodC0KICAgICAgICBoYW5kIHNpZGVzIEsgd2l0aCBLID4gSiBtYXkgbm90\nIGJlIGd1YXJhbnRlZWQgYXMgd2VsbCwgYnV0CiAgICAgICAgb25seSB0aGUgZmlyc3Qgc3VjaCBy\naWdodC1oYW5kIHNpZGUgaXMgcmVwb3J0ZWQuIElmIGEgc21hbGwKICAgICAgICBjb21wb25lbnR3\naXNlIGVycm9yIGlzIG5vdCByZXF1ZXN0ZWQgKFBBUkFNUygzKSA9IDAuMCkgdGhlbgogICAgICAg\nIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzIHRoZSBmaXJzdCB3aXRoIGEgbm9ybXdpc2UgZXJy\nb3IKICAgICAgICBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50ZWVkICh0aGUgc21hbGxlc3QgSiBz\ndWNoCiAgICAgICAgdGhhdCBFUlJfQk5EU19OT1JNKEosMSkgPSAwLjApLiBCeSBkZWZhdWx0IChQ\nQVJBTVMoMykgPSAxLjApCiAgICAgICAgdGhlIEp0aCByaWdodC1oYW5kIHNpZGUgaXMgdGhlIGZp\ncnN0IHdpdGggZWl0aGVyIGEgbm9ybXdpc2Ugb3IKICAgICAgICBjb21wb25lbnR3aXNlIGVycm9y\nIGJvdW5kIHRoYXQgaXMgbm90IGd1YXJhbnRlZWQgKHRoZSBzbWFsbGVzdAogICAgICAgIEogc3Vj\naCB0aGF0IGVpdGhlciBFUlJfQk5EU19OT1JNKEosMSkgPSAwLjAgb3IKICAgICAgICBFUlJfQk5E\nU19DT01QKEosMSkgPSAwLjApLiBTZWUgdGhlIGRlZmluaXRpb24gb2YKICAgICAgICBFUlJfQk5E\nU19OT1JNKDosMSkgYW5kIEVSUl9CTkRTX0NPTVAoOiwxKS4gVG8gZ2V0IGluZm9ybWF0aW9uCiAg\nICAgICAgYWJvdXQgYWxsIG9mIHRoZSByaWdodC1oYW5kIHNpZGVzIGNoZWNrIEVSUl9CTkRTX05P\nUk0gb3IKICAgICAgICBFUlJfQk5EU19DT01QLgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRl\nbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVu\naXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgQXByaWwgMjAx\nMgpcaW5ncm91cCBkb3VibGVQT2NvbXB1dGF0aW9uYWwKaB1oHimBchcCAAB9chgCAAAoaCGJaCJo\nI3ViaC2KAqQBaC5YDwAAAGRwb3Jmc3hfNDIwLnR4dHViaC+KAqQBaDBYBgAAAHBvcmZzeGgtigE+\ndWJoFWgWXWgXh1JyGQIAAH1yGgIAAChoGlgDAAAASFBEaBtYBAAAAGZ1bGxoHFhGAAAAZXJyb3Ig\nYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZpbmVtZW50\nOyBFUVVFRGgdaB4pgXIbAgAAfXIcAgAAKGghiWgiaCN1YmgkWCEAAABEb3h5Z2VuL2RvY3MvaHRt\nbC9jcG9yZnN4XzhmLmh0bWxoJVgBAAAAY2gmaBVoJ11oF4dSch0CAAB9ch4CAAAoaCpYvTAAACAg\nIENQT1JGU1ggaW1wcm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxp\nbmVhcgogICBlcXVhdGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIHN5bW1ldHJp\nYyBwb3NpdGl2ZQogICBkZWZpbml0ZSwgYW5kIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFj\na3dhcmQgZXJyb3IgZXN0aW1hdGVzCiAgIGZvciB0aGUgc29sdXRpb24uICBJbiBhZGRpdGlvbiB0\nbyBub3Jtd2lzZSBlcnJvciBib3VuZCwgdGhlIGNvZGUKICAgcHJvdmlkZXMgbWF4aW11bSBjb21w\nb25lbnR3aXNlIGVycm9yIGJvdW5kIGlmIHBvc3NpYmxlLiAgU2VlCiAgIGNvbW1lbnRzIGZvciBF\nUlJfQk5EU19OT1JNIGFuZCBFUlJfQk5EU19DT01QIGZvciBkZXRhaWxzIG9mIHRoZQogICBlcnJv\nciBib3VuZHMuCiAgIFRoZSBvcmlnaW5hbCBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyBtYXkg\naGF2ZSBiZWVuIGVxdWlsaWJyYXRlZAogICBiZWZvcmUgY2FsbGluZyB0aGlzIHJvdXRpbmUsIGFz\nIGRlc2NyaWJlZCBieSBhcmd1bWVudHMgRVFVRUQgYW5kIFMKICAgYmVsb3cuIEluIHRoaXMgY2Fz\nZSwgdGhlIHNvbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgcmV0dXJuZWQgYXJlCiAgIGZvciB0aGUg\nb3JpZ2luYWwgdW5lcXVpbGlicmF0ZWQgc3lzdGVtLgpBcmd1bWVudHM6CiAgICBTb21lIG9wdGlv\nbmFsIHBhcmFtZXRlcnMgYXJlIGJ1bmRsZWQgaW4gdGhlIFBBUkFNUyBhcnJheS4gIFRoZXNlCiAg\nICBzZXR0aW5ncyBkZXRlcm1pbmUgaG93IHJlZmluZW1lbnQgaXMgcGVyZm9ybWVkLCBidXQgb2Z0\nZW4gdGhlCiAgICBkZWZhdWx0cyBhcmUgYWNjZXB0YWJsZS4gIElmIHRoZSBkZWZhdWx0cyBhcmUg\nYWNjZXB0YWJsZSwgdXNlcnMKICAgIGNhbiBwYXNzIE5QQVJBTVMgPSAwIHdoaWNoIHByZXZlbnRz\nIHRoZSBzb3VyY2UgY29kZSBmcm9tIGFjY2Vzc2luZwogICAgdGhlIFBBUkFNUyBhcmd1bWVudC4K\nXHBhcmFtW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgPSAnVSc6\nICBVcHBlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZDsKICAgICAgPSAnTCc6ICBMb3dlciB0cmlh\nbmdsZSBvZiBBIGlzIHN0b3JlZC4KXHBhcmFtW2luXSBFUVVFRAogICAgICAgICBFUVVFRCBpcyBD\nSEFSQUNURVIqMQogICAgU3BlY2lmaWVzIHRoZSBmb3JtIG9mIGVxdWlsaWJyYXRpb24gdGhhdCB3\nYXMgZG9uZSB0byBBCiAgICBiZWZvcmUgY2FsbGluZyB0aGlzIHJvdXRpbmUuIFRoaXMgaXMgbmVl\nZGVkIHRvIGNvbXB1dGUKICAgIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIGNvcnJlY3Rs\neS4KICAgICAgPSAnTic6ICBObyBlcXVpbGlicmF0aW9uCiAgICAgID0gJ1knOiAgQm90aCByb3cg\nYW5kIGNvbHVtbiBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBiZWVuCiAgICAgICAgICAgICAg\ncmVwbGFjZWQgYnkgZGlhZyhTKSAqIEEgKiBkaWFnKFMpLgogICAgICAgICAgICAgIFRoZSByaWdo\ndCBoYW5kIHNpZGUgQiBoYXMgYmVlbiBjaGFuZ2VkIGFjY29yZGluZ2x5LgpccGFyYW1baW5dIE4K\nICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+\nPSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICBUaGUgbnVt\nYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAg\nb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQQogICAgICAg\nICBBIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERBLE4pCiAgICBUaGUgc3ltbWV0cmlj\nIG1hdHJpeCBBLiAgSWYgVVBMTyA9ICdVJywgdGhlIGxlYWRpbmcgTi1ieS1OCiAgICB1cHBlciB0\ncmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgdXBwZXIgdHJpYW5ndWxhciBwYXJ0CiAg\nICBvZiB0aGUgbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkgbG93ZXIgdHJpYW5ndWxhciBwYXJ0\nIG9mIEEKICAgIGlzIG5vdCByZWZlcmVuY2VkLiAgSWYgVVBMTyA9ICdMJywgdGhlIGxlYWRpbmcg\nTi1ieS1OIGxvd2VyCiAgICB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgbG93ZXIg\ndHJpYW5ndWxhciBwYXJ0IG9mCiAgICB0aGUgbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkgdXBw\nZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEgaXMKICAgIG5vdCByZWZlcmVuY2VkLgpccGFyYW1baW5d\nIExEQQogICAgICAgICBMREEgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9m\nIHRoZSBhcnJheSBBLiAgTERBID49IG1heCgxLE4pLgpccGFyYW1baW5dIEFGCiAgICAgICAgIEFG\nIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERBRixOKQogICAgVGhlIHRyaWFuZ3VsYXIg\nZmFjdG9yIFUgb3IgTCBmcm9tIHRoZSBDaG9sZXNreSBmYWN0b3JpemF0aW9uCiAgICBBID0gVSoq\nVCpVIG9yIEEgPSBMKkwqKlQsIGFzIGNvbXB1dGVkIGJ5IFNQT1RSRi4KXHBhcmFtW2luXSBMREFG\nCiAgICAgICAgIExEQUYgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRo\nZSBhcnJheSBBRi4gIExEQUYgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFMKICAgICAgICAg\nUyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICBUaGUgcm93IHNjYWxlIGZhY3RvcnMg\nZm9yIEEuICBJZiBFUVVFRCA9ICdZJywgQSBpcyBtdWx0aXBsaWVkIG9uCiAgICB0aGUgbGVmdCBh\nbmQgcmlnaHQgYnkgZGlhZyhTKS4gIFMgaXMgYW4gaW5wdXQgYXJndW1lbnQgaWYgRkFDVCA9CiAg\nICAnRic7IG90aGVyd2lzZSwgUyBpcyBhbiBvdXRwdXQgYXJndW1lbnQuICBJZiBGQUNUID0gJ0Yn\nIGFuZCBFUVVFRAogICAgPSAnWScsIGVhY2ggZWxlbWVudCBvZiBTIG11c3QgYmUgcG9zaXRpdmUu\nICBJZiBTIGlzIG91dHB1dCwgZWFjaAogICAgZWxlbWVudCBvZiBTIGlzIGEgcG93ZXIgb2YgdGhl\nIHJhZGl4LiBJZiBTIGlzIGlucHV0LCBlYWNoIGVsZW1lbnQKICAgIG9mIFMgc2hvdWxkIGJlIGEg\ncG93ZXIgb2YgdGhlIHJhZGl4IHRvIGVuc3VyZSBhIHJlbGlhYmxlIHNvbHV0aW9uCiAgICBhbmQg\nZXJyb3IgZXN0aW1hdGVzLiBTY2FsaW5nIGJ5IHBvd2VycyBvZiB0aGUgcmFkaXggZG9lcyBub3Qg\nY2F1c2UKICAgIHJvdW5kaW5nIGVycm9ycyB1bmxlc3MgdGhlIHJlc3VsdCB1bmRlcmZsb3dzIG9y\nIG92ZXJmbG93cy4KICAgIFJvdW5kaW5nIGVycm9ycyBkdXJpbmcgc2NhbGluZyBsZWFkIHRvIHJl\nZmluaW5nIHdpdGggYSBtYXRyaXggdGhhdAogICAgaXMgbm90IGVxdWl2YWxlbnQgdG8gdGhlIGlu\ncHV0IG1hdHJpeCwgcHJvZHVjaW5nIGVycm9yIGVzdGltYXRlcwogICAgdGhhdCBtYXkgbm90IGJl\nIHJlbGlhYmxlLgpccGFyYW1baW5dIEIKICAgICAgICAgQiBpcyBDT01QTEVYIGFycmF5LCBkaW1l\nbnNpb24gKExEQixOUkhTKQogICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFt\nW2luXSBMREIKICAgICAgICAgTERCIGlzIElOVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lv\nbiBvZiB0aGUgYXJyYXkgQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luLG91dF0gWAogICAg\nICAgICBYIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICBPbiBlbnRy\neSwgdGhlIHNvbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBieSBTR0VUUlMuCiAgICBPbiBl\neGl0LCB0aGUgaW1wcm92ZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAg\nICAgIExEWCBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5\nIFguICBMRFggPj0gbWF4KDEsTikuClxwYXJhbVtvdXRdIFJDT05ECiAgICAgICAgIFJDT05EIGlz\nIFJFQUwKICAgIFJlY2lwcm9jYWwgc2NhbGVkIGNvbmRpdGlvbiBudW1iZXIuICBUaGlzIGlzIGFu\nIGVzdGltYXRlIG9mIHRoZQogICAgcmVjaXByb2NhbCBTa2VlbCBjb25kaXRpb24gbnVtYmVyIG9m\nIHRoZSBtYXRyaXggQSBhZnRlcgogICAgZXF1aWxpYnJhdGlvbiAoaWYgZG9uZSkuICBJZiB0aGlz\nIGlzIGxlc3MgdGhhbiB0aGUgbWFjaGluZQogICAgcHJlY2lzaW9uIChpbiBwYXJ0aWN1bGFyLCBp\nZiBpdCBpcyB6ZXJvKSwgdGhlIG1hdHJpeCBpcyBzaW5ndWxhcgogICAgdG8gd29ya2luZyBwcmVj\naXNpb24uICBOb3RlIHRoYXQgdGhlIGVycm9yIG1heSBzdGlsbCBiZSBzbWFsbCBldmVuCiAgICBp\nZiB0aGlzIG51bWJlciBpcyB2ZXJ5IHNtYWxsIGFuZCB0aGUgbWF0cml4IGFwcGVhcnMgaWxsLQog\nICAgY29uZGl0aW9uZWQuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFy\ncmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICBDb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJk\nIGVycm9yLiAgVGhpcyBpcyB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQg\nZXJyb3Igb2YgZWFjaCBzb2x1dGlvbiB2ZWN0b3IgWChqKQogICAgKGkuZS4sIHRoZSBzbWFsbGVz\ndCByZWxhdGl2ZSBjaGFuZ2UgaW4gYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQKICAgIG1ha2Vz\nIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1baW5dIE5fRVJSX0JORFMKICAgICAgICAg\nTl9FUlJfQk5EUyBpcyBJTlRFR0VSCiAgICBOdW1iZXIgb2YgZXJyb3IgYm91bmRzIHRvIHJldHVy\nbiBmb3IgZWFjaCByaWdodCBoYW5kIHNpZGUKICAgIGFuZCBlYWNoIHR5cGUgKG5vcm13aXNlIG9y\nIGNvbXBvbmVudHdpc2UpLiAgU2VlIEVSUl9CTkRTX05PUk0gYW5kCiAgICBFUlJfQk5EU19DT01Q\nIGJlbG93LgpccGFyYW1bb3V0XSBFUlJfQk5EU19OT1JNCiAgICAgICAgIEVSUl9CTkRTX05PUk0g\naXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTLCBOX0VSUl9CTkRTKQogICAgRm9yIGVhY2gg\ncmlnaHQtaGFuZCBzaWRlLCB0aGlzIGFycmF5IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0CiAg\nICB2YXJpb3VzIGVycm9yIGJvdW5kcyBhbmQgY29uZGl0aW9uIG51bWJlcnMgY29ycmVzcG9uZGlu\nZyB0byB0aGUKICAgIG5vcm13aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFz\nIGZvbGxvd3M6CiAgICBOb3Jtd2lzZSByZWxhdGl2ZSBlcnJvciBpbiB0aGUgaXRoIHNvbHV0aW9u\nIHZlY3RvcjoKICAgICAgICAgICAgbWF4X2ogKGFicyhYVFJVRShqLGkpIC0gWChqLGkpKSkKICAg\nICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAgICBt\nYXhfaiBhYnMoWChqLGkpKQogICAgVGhlIGFycmF5IGlzIGluZGV4ZWQgYnkgdGhlIHR5cGUgb2Yg\nZXJyb3IgaW5mb3JtYXRpb24gYXMgZGVzY3JpYmVkCiAgICBiZWxvdy4gVGhlcmUgY3VycmVudGx5\nIGFyZSB1cCB0byB0aHJlZSBwaWVjZXMgb2YgaW5mb3JtYXRpb24KICAgIHJldHVybmVkLgogICAg\nVGhlIGZpcnN0IGluZGV4IGluIEVSUl9CTkRTX05PUk0oaSw6KSBjb3JyZXNwb25kcyB0byB0aGUg\naXRoCiAgICByaWdodC1oYW5kIHNpZGUuCiAgICBUaGUgc2Vjb25kIGluZGV4IGluIEVSUl9CTkRT\nX05PUk0oOixlcnIpIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcKICAgIHRocmVlIGZpZWxkczoKICAg\nIGVyciA9IDEgIlRydXN0L2Rvbid0IHRydXN0IiBib29sZWFuLiBUcnVzdCB0aGUgYW5zd2VyIGlm\nIHRoZQogICAgICAgICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyIGlzIGxlc3MgdGhh\nbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJyku\nCiAgICBlcnIgPSAyICJHdWFyYW50ZWVkIiBlcnJvciBib3VuZDogVGhlIGVzdGltYXRlZCBmb3J3\nYXJkIGVycm9yLAogICAgICAgICAgICAgYWxtb3N0IGNlcnRhaW5seSB3aXRoaW4gYSBmYWN0b3Ig\nb2YgMTAgb2YgdGhlIHRydWUgZXJyb3IKICAgICAgICAgICAgIHNvIGxvbmcgYXMgdGhlIG5leHQg\nZW50cnkgaXMgZ3JlYXRlciB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikg\nKiBzbGFtY2goJ0Vwc2lsb24nKS4gVGhpcyBlcnJvciBib3VuZCBzaG91bGQgb25seQogICAgICAg\nICAgICAgYmUgdHJ1c3RlZCBpZiB0aGUgcHJldmlvdXMgYm9vbGVhbiBpcyB0cnVlLgogICAgZXJy\nID0gMyAgUmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyOiBFc3RpbWF0ZWQgbm9ybXdpc2UKICAg\nICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlci4gIENvbXBhcmVkIHdpdGggdGhl\nIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIHNsYW1jaCgnRXBzaWxvbicpIHRvIGRl\ndGVybWluZSBpZiB0aGUgZXJyb3IKICAgICAgICAgICAgIGVzdGltYXRlIGlzICJndWFyYW50ZWVk\nIi4gVGhlc2UgcmVjaXByb2NhbCBjb25kaXRpb24KICAgICAgICAgICAgIG51bWJlcnMgYXJlIDEg\nLyAobm9ybShaXnstMX0saW5mKSAqIG5vcm0oWixpbmYpKSBmb3Igc29tZQogICAgICAgICAgICAg\nYXBwcm9wcmlhdGVseSBzY2FsZWQgbWF0cml4IFouCiAgICAgICAgICAgICBMZXQgWiA9IFMqQSwg\nd2hlcmUgUyBzY2FsZXMgZWFjaCByb3cgYnkgYSBwb3dlciBvZiB0aGUKICAgICAgICAgICAgIHJh\nZGl4IHNvIGFsbCBhYnNvbHV0ZSByb3cgc3VtcyBvZiBaIGFyZSBhcHByb3hpbWF0ZWx5IDEuCiAg\nICBTZWUgTGFwYWNrIFdvcmtpbmcgTm90ZSAxNjUgZm9yIGZ1cnRoZXIgZGV0YWlscyBhbmQgZXh0\ncmEKICAgIGNhdXRpb25zLgpccGFyYW1bb3V0XSBFUlJfQk5EU19DT01QCiAgICAgICAgIEVSUl9C\nTkRTX0NPTVAgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTLCBOX0VSUl9CTkRTKQogICAg\nRm9yIGVhY2ggcmlnaHQtaGFuZCBzaWRlLCB0aGlzIGFycmF5IGNvbnRhaW5zIGluZm9ybWF0aW9u\nIGFib3V0CiAgICB2YXJpb3VzIGVycm9yIGJvdW5kcyBhbmQgY29uZGl0aW9uIG51bWJlcnMgY29y\ncmVzcG9uZGluZyB0byB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJyb3IsIHdoaWNo\nIGlzIGRlZmluZWQgYXMgZm9sbG93czoKICAgIENvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJyb3Ig\naW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAgICAgICAgICAgICAgICBhYnMoWFRSVUUo\naixpKSAtIFgoaixpKSkKICAgICAgICAgICAgbWF4X2ogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQog\nICAgICAgICAgICAgICAgICAgICAgICBhYnMoWChqLGkpKQogICAgVGhlIGFycmF5IGlzIGluZGV4\nZWQgYnkgdGhlIHJpZ2h0LWhhbmQgc2lkZSBpIChvbiB3aGljaCB0aGUKICAgIGNvbXBvbmVudHdp\nc2UgcmVsYXRpdmUgZXJyb3IgZGVwZW5kcyksIGFuZCB0aGUgdHlwZSBvZiBlcnJvcgogICAgaW5m\nb3JtYXRpb24gYXMgZGVzY3JpYmVkIGJlbG93LiBUaGVyZSBjdXJyZW50bHkgYXJlIHVwIHRvIHRo\ncmVlCiAgICBwaWVjZXMgb2YgaW5mb3JtYXRpb24gcmV0dXJuZWQgZm9yIGVhY2ggcmlnaHQtaGFu\nZCBzaWRlLiBJZgogICAgY29tcG9uZW50d2lzZSBhY2N1cmFjeSBpcyBub3QgcmVxdWVzdGVkIChQ\nQVJBTVMoMykgPSAwLjApLCB0aGVuCiAgICBFUlJfQk5EU19DT01QIGlzIG5vdCBhY2Nlc3NlZC4g\nIElmIE5fRVJSX0JORFMgLkxULiAzLCB0aGVuIGF0IG1vc3QKICAgIHRoZSBmaXJzdCAoOixOX0VS\nUl9CTkRTKSBlbnRyaWVzIGFyZSByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJf\nQk5EU19DT01QKGksOikgY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQtaGFuZCBzaWRl\nLgogICAgVGhlIHNlY29uZCBpbmRleCBpbiBFUlJfQk5EU19DT01QKDosZXJyKSBjb250YWlucyB0\naGUgZm9sbG93aW5nCiAgICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVzdC9kb24ndCB0\ncnVzdCIgYm9vbGVhbi4gVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAgICAgIHJlY2lw\ncm9jYWwgY29uZGl0aW9uIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAg\nICAgICAgc3FydChuKSAqIHNsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAiR3VhcmFudGVl\nZCIgZXJyb3IgYm91bmQ6IFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAgICAgICAgICAg\nIGFsbW9zdCBjZXJ0YWlubHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9y\nCiAgICAgICAgICAgICBzbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0\naGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykuIFRo\naXMgZXJyb3IgYm91bmQgc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0ZWQgaWYgdGhl\nIHByZXZpb3VzIGJvb2xlYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0\naW9uIG51bWJlcjogRXN0aW1hdGVkIGNvbXBvbmVudHdpc2UKICAgICAgICAgICAgIHJlY2lwcm9j\nYWwgY29uZGl0aW9uIG51bWJlci4gIENvbXBhcmVkIHdpdGggdGhlIHRocmVzaG9sZAogICAgICAg\nICAgICAgc3FydChuKSAqIHNsYW1jaCgnRXBzaWxvbicpIHRvIGRldGVybWluZSBpZiB0aGUgZXJy\nb3IKICAgICAgICAgICAgIGVzdGltYXRlIGlzICJndWFyYW50ZWVkIi4gVGhlc2UgcmVjaXByb2Nh\nbCBjb25kaXRpb24KICAgICAgICAgICAgIG51bWJlcnMgYXJlIDEgLyAobm9ybShaXnstMX0saW5m\nKSAqIG5vcm0oWixpbmYpKSBmb3Igc29tZQogICAgICAgICAgICAgYXBwcm9wcmlhdGVseSBzY2Fs\nZWQgbWF0cml4IFouCiAgICAgICAgICAgICBMZXQgWiA9IFMqKEEqZGlhZyh4KSksIHdoZXJlIHgg\naXMgdGhlIHNvbHV0aW9uIGZvciB0aGUKICAgICAgICAgICAgIGN1cnJlbnQgcmlnaHQtaGFuZCBz\naWRlIGFuZCBTIHNjYWxlcyBlYWNoIHJvdyBvZgogICAgICAgICAgICAgQSpkaWFnKHgpIGJ5IGEg\ncG93ZXIgb2YgdGhlIHJhZGl4IHNvIGFsbCBhYnNvbHV0ZSByb3cKICAgICAgICAgICAgIHN1bXMg\nb2YgWiBhcmUgYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFjayBXb3JraW5nIE5vdGUgMTY1\nIGZvciBmdXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4KXHBhcmFtW2luXSBO\nUEFSQU1TCiAgICAgICAgIE5QQVJBTVMgaXMgSU5URUdFUgogICAgU3BlY2lmaWVzIHRoZSBudW1i\nZXIgb2YgcGFyYW1ldGVycyBzZXQgaW4gUEFSQU1TLiAgSWYgLkxFLiAwLCB0aGUKICAgIFBBUkFN\nUyBhcnJheSBpcyBuZXZlciByZWZlcmVuY2VkIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgdXNlZC4K\nXHBhcmFtW2luLG91dF0gUEFSQU1TCiAgICAgICAgIFBBUkFNUyBpcyBSRUFMIGFycmF5LCBkaW1l\nbnNpb24gTlBBUkFNUwogICAgU3BlY2lmaWVzIGFsZ29yaXRobSBwYXJhbWV0ZXJzLiAgSWYgYW4g\nZW50cnkgaXMgLkxULiAwLjAsIHRoZW4KICAgIHRoYXQgZW50cnkgd2lsbCBiZSBmaWxsZWQgd2l0\naCBkZWZhdWx0IHZhbHVlIHVzZWQgZm9yIHRoYXQKICAgIHBhcmFtZXRlci4gIE9ubHkgcG9zaXRp\nb25zIHVwIHRvIE5QQVJBTVMgYXJlIGFjY2Vzc2VkOyBkZWZhdWx0cwogICAgYXJlIHVzZWQgZm9y\nIGhpZ2hlci1udW1iZXJlZCBwYXJhbWV0ZXJzLgogICAgICBQQVJBTVMoTEFfTElOUlhfSVRSRUZf\nSSA9IDEpIDogV2hldGhlciB0byBwZXJmb3JtIGl0ZXJhdGl2ZQogICAgICAgICAgIHJlZmluZW1l\nbnQgb3Igbm90LgogICAgICAgIERlZmF1bHQ6IDEuMAogICAgICAgICAgID0gMC4wIDogTm8gcmVm\naW5lbWVudCBpcyBwZXJmb3JtZWQsIGFuZCBubyBlcnJvciBib3VuZHMgYXJlCiAgICAgICAgICAg\nICAgICAgICBjb21wdXRlZC4KICAgICAgICAgICA9IDEuMCA6IFVzZSB0aGUgZG91YmxlLXByZWNp\nc2lvbiByZWZpbmVtZW50IGFsZ29yaXRobSwKICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5IHdp\ndGggZG91YmxlZC1zaW5nbGUgY29tcHV0YXRpb25zIGlmIHRoZQogICAgICAgICAgICAgICAgICAg\nY29tcGlsYXRpb24gZW52aXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBET1VCTEUKICAgICAgICAg\nICAgICAgICAgIFBSRUNJU0lPTi4KICAgICAgICAgICAgIChvdGhlciB2YWx1ZXMgYXJlIHJlc2Vy\ndmVkIGZvciBmdXR1cmUgdXNlKQogICAgICBQQVJBTVMoTEFfTElOUlhfSVRIUkVTSF9JID0gMikg\nOiBNYXhpbXVtIG51bWJlciBvZiByZXNpZHVhbAogICAgICAgICAgIGNvbXB1dGF0aW9ucyBhbGxv\nd2VkIGZvciByZWZpbmVtZW50LgogICAgICAgIERlZmF1bHQ6IDEwCiAgICAgICAgQWdncmVzc2l2\nZTogU2V0IHRvIDEwMCB0byBwZXJtaXQgY29udmVyZ2VuY2UgdXNpbmcgYXBwcm94aW1hdGUKICAg\nICAgICAgICAgICAgICAgICBmYWN0b3JpemF0aW9ucyBvciBmYWN0b3JpemF0aW9ucyBvdGhlciB0\naGFuIExVLiBJZgogICAgICAgICAgICAgICAgICAgIHRoZSBmYWN0b3JpemF0aW9uIHVzZXMgYSB0\nZWNobmlxdWUgb3RoZXIgdGhhbgogICAgICAgICAgICAgICAgICAgIEdhdXNzaWFuIGVsaW1pbmF0\naW9uLCB0aGUgZ3VhcmFudGVlcyBpbgogICAgICAgICAgICAgICAgICAgIGVycl9ibmRzX25vcm0g\nYW5kIGVycl9ibmRzX2NvbXAgbWF5IG5vIGxvbmdlciBiZQogICAgICAgICAgICAgICAgICAgIHRy\ndXN0d29ydGh5LgogICAgICBQQVJBTVMoTEFfTElOUlhfQ1dJU0VfSSA9IDMpIDogRmxhZyBkZXRl\ncm1pbmluZyBpZiB0aGUgY29kZQogICAgICAgICAgIHdpbGwgYXR0ZW1wdCB0byBmaW5kIGEgc29s\ndXRpb24gd2l0aCBzbWFsbCBjb21wb25lbnR3aXNlCiAgICAgICAgICAgcmVsYXRpdmUgZXJyb3Ig\naW4gdGhlIGRvdWJsZS1wcmVjaXNpb24gYWxnb3JpdGhtLiAgUG9zaXRpdmUKICAgICAgICAgICBp\ncyB0cnVlLCAwLjAgaXMgZmFsc2UuCiAgICAgICAgRGVmYXVsdDogMS4wIChhdHRlbXB0IGNvbXBv\nbmVudHdpc2UgY29udmVyZ2VuY2UpClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBD\nT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0gUldPUksKICAgICAgICAg\nUldPUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uICgyKk4pClxwYXJhbVtvdXRdIElORk8KICAg\nICAgICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgID0gMDogIFN1Y2Nlc3NmdWwgZXhpdC4gVGhlIHNv\nbHV0aW9uIHRvIGV2ZXJ5IHJpZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIGd1YXJhbnRlZWQuCiAg\nICAgIDwgMDogIElmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwg\ndmFsdWUKICAgICAgPiAwIGFuZCA8PSBOOiAgVShJTkZPLElORk8pIGlzIGV4YWN0bHkgemVyby4g\nIFRoZSBmYWN0b3JpemF0aW9uCiAgICAgICAgaGFzIGJlZW4gY29tcGxldGVkLCBidXQgdGhlIGZh\nY3RvciBVIGlzIGV4YWN0bHkgc2luZ3VsYXIsIHNvCiAgICAgICAgdGhlIHNvbHV0aW9uIGFuZCBl\ncnJvciBib3VuZHMgY291bGQgbm90IGJlIGNvbXB1dGVkLiBSQ09ORCA9IDAKICAgICAgICBpcyBy\nZXR1cm5lZC4KICAgICAgPSBOK0o6IFRoZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBK\ndGggcmlnaHQtaGFuZCBzaWRlIGlzCiAgICAgICAgbm90IGd1YXJhbnRlZWQuIFRoZSBzb2x1dGlv\nbnMgY29ycmVzcG9uZGluZyB0byBvdGhlciByaWdodC0KICAgICAgICBoYW5kIHNpZGVzIEsgd2l0\naCBLID4gSiBtYXkgbm90IGJlIGd1YXJhbnRlZWQgYXMgd2VsbCwgYnV0CiAgICAgICAgb25seSB0\naGUgZmlyc3Qgc3VjaCByaWdodC1oYW5kIHNpZGUgaXMgcmVwb3J0ZWQuIElmIGEgc21hbGwKICAg\nICAgICBjb21wb25lbnR3aXNlIGVycm9yIGlzIG5vdCByZXF1ZXN0ZWQgKFBBUkFNUygzKSA9IDAu\nMCkgdGhlbgogICAgICAgIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzIHRoZSBmaXJzdCB3aXRo\nIGEgbm9ybXdpc2UgZXJyb3IKICAgICAgICBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50ZWVkICh0\naGUgc21hbGxlc3QgSiBzdWNoCiAgICAgICAgdGhhdCBFUlJfQk5EU19OT1JNKEosMSkgPSAwLjAp\nLiBCeSBkZWZhdWx0IChQQVJBTVMoMykgPSAxLjApCiAgICAgICAgdGhlIEp0aCByaWdodC1oYW5k\nIHNpZGUgaXMgdGhlIGZpcnN0IHdpdGggZWl0aGVyIGEgbm9ybXdpc2Ugb3IKICAgICAgICBjb21w\nb25lbnR3aXNlIGVycm9yIGJvdW5kIHRoYXQgaXMgbm90IGd1YXJhbnRlZWQgKHRoZSBzbWFsbGVz\ndAogICAgICAgIEogc3VjaCB0aGF0IGVpdGhlciBFUlJfQk5EU19OT1JNKEosMSkgPSAwLjAgb3IK\nICAgICAgICBFUlJfQk5EU19DT01QKEosMSkgPSAwLjApLiBTZWUgdGhlIGRlZmluaXRpb24gb2YK\nICAgICAgICBFUlJfQk5EU19OT1JNKDosMSkgYW5kIEVSUl9CTkRTX0NPTVAoOiwxKS4gVG8gZ2V0\nIGluZm9ybWF0aW9uCiAgICAgICAgYWJvdXQgYWxsIG9mIHRoZSByaWdodC1oYW5kIHNpZGVzIGNo\nZWNrIEVSUl9CTkRTX05PUk0gb3IKICAgICAgICBFUlJfQk5EU19DT01QLgpBdXRob3JzOgpcYXV0\naG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtl\nbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAK\nXGRhdGUgQXByaWwgMjAxMgpcaW5ncm91cCBjb21wbGV4UE9jb21wdXRhdGlvbmFsCmgdaB4pgXIf\nAgAAfXIgAgAAKGghiWgiaCN1YmgtigKlAWguWA8AAABjcG9yZnN4XzQyMS50eHR1YmgvigKlAWgw\nWAYAAABwb3Jmc3hoLYoBP3ViaBVoFl1oF4dSciECAAB9ciICAAAoaBpYAwAAAEhQRGgbWAQAAABm\ndWxsaBxYRgAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVy\nYXRpdmUgcmVmaW5lbWVudDsgRVFVRURoHWgeKYFyIwIAAH1yJAIAAChoIYloImgjdWJoJFghAAAA\nRG94eWdlbi9kb2NzL2h0bWwvenBvcmZzeF84Zi5odG1saCVYAQAAAHpoJmgVaCddaBeHUnIlAgAA\nfXImAgAAKGgqWCUxAAAgICBaUE9SRlNYIGltcHJvdmVzIHRoZSBjb21wdXRlZCBzb2x1dGlvbiB0\nbyBhIHN5c3RlbSBvZiBsaW5lYXIKICAgZXF1YXRpb25zIHdoZW4gdGhlIGNvZWZmaWNpZW50IG1h\ndHJpeCBpcyBzeW1tZXRyaWMgcG9zaXRpdmUKICAgZGVmaW5pdGUsIGFuZCBwcm92aWRlcyBlcnJv\nciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlcwogICBmb3IgdGhlIHNvbHV0aW9u\nLiAgSW4gYWRkaXRpb24gdG8gbm9ybXdpc2UgZXJyb3IgYm91bmQsIHRoZSBjb2RlCiAgIHByb3Zp\nZGVzIG1heGltdW0gY29tcG9uZW50d2lzZSBlcnJvciBib3VuZCBpZiBwb3NzaWJsZS4gIFNlZQog\nICBjb21tZW50cyBmb3IgRVJSX0JORFNfTk9STSBhbmQgRVJSX0JORFNfQ09NUCBmb3IgZGV0YWls\ncyBvZiB0aGUKICAgZXJyb3IgYm91bmRzLgogICBUaGUgb3JpZ2luYWwgc3lzdGVtIG9mIGxpbmVh\nciBlcXVhdGlvbnMgbWF5IGhhdmUgYmVlbiBlcXVpbGlicmF0ZWQKICAgYmVmb3JlIGNhbGxpbmcg\ndGhpcyByb3V0aW5lLCBhcyBkZXNjcmliZWQgYnkgYXJndW1lbnRzIEVRVUVEIGFuZCBTCiAgIGJl\nbG93LiBJbiB0aGlzIGNhc2UsIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIHJldHVybmVk\nIGFyZQogICBmb3IgdGhlIG9yaWdpbmFsIHVuZXF1aWxpYnJhdGVkIHN5c3RlbS4KQXJndW1lbnRz\nOgogICAgU29tZSBvcHRpb25hbCBwYXJhbWV0ZXJzIGFyZSBidW5kbGVkIGluIHRoZSBQQVJBTVMg\nYXJyYXkuICBUaGVzZQogICAgc2V0dGluZ3MgZGV0ZXJtaW5lIGhvdyByZWZpbmVtZW50IGlzIHBl\ncmZvcm1lZCwgYnV0IG9mdGVuIHRoZQogICAgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUuICBJZiB0\naGUgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUsIHVzZXJzCiAgICBjYW4gcGFzcyBOUEFSQU1TID0g\nMCB3aGljaCBwcmV2ZW50cyB0aGUgc291cmNlIGNvZGUgZnJvbSBhY2Nlc3NpbmcKICAgIHRoZSBQ\nQVJBTVMgYXJndW1lbnQuClxwYXJhbVtpbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RF\nUioxCiAgICAgID0gJ1UnOiAgVXBwZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQ7CiAgICAgID0g\nJ0wnOiAgTG93ZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQuClxwYXJhbVtpbl0gRVFVRUQKICAg\nICAgICAgRVFVRUQgaXMgQ0hBUkFDVEVSKjEKICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiBlcXVp\nbGlicmF0aW9uIHRoYXQgd2FzIGRvbmUgdG8gQQogICAgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0\naW5lLiBUaGlzIGlzIG5lZWRlZCB0byBjb21wdXRlCiAgICB0aGUgc29sdXRpb24gYW5kIGVycm9y\nIGJvdW5kcyBjb3JyZWN0bHkuCiAgICAgID0gJ04nOiAgTm8gZXF1aWxpYnJhdGlvbgogICAgICA9\nICdZJzogIEJvdGggcm93IGFuZCBjb2x1bW4gZXF1aWxpYnJhdGlvbiwgaS5lLiwgQSBoYXMgYmVl\nbgogICAgICAgICAgICAgIHJlcGxhY2VkIGJ5IGRpYWcoUykgKiBBICogZGlhZyhTKS4KICAgICAg\nICAgICAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIEIgaGFzIGJlZW4gY2hhbmdlZCBhY2NvcmRpbmds\neS4KXHBhcmFtW2luXSBOCiAgICAgICAgIE4gaXMgSU5URUdFUgogICAgVGhlIG9yZGVyIG9mIHRo\nZSBtYXRyaXggQS4gIE4gPj0gMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5U\nRUdFUgogICAgVGhlIG51bWJlciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVy\nIG9mIGNvbHVtbnMKICAgIG9mIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFy\nYW1baW5dIEEKICAgICAgICAgQSBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQSxO\nKQogICAgVGhlIHN5bW1ldHJpYyBtYXRyaXggQS4gIElmIFVQTE8gPSAnVScsIHRoZSBsZWFkaW5n\nIE4tYnktTgogICAgdXBwZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEgY29udGFpbnMgdGhlIHVwcGVy\nIHRyaWFuZ3VsYXIgcGFydAogICAgb2YgdGhlIG1hdHJpeCBBLCBhbmQgdGhlIHN0cmljdGx5IGxv\nd2VyIHRyaWFuZ3VsYXIgcGFydCBvZiBBCiAgICBpcyBub3QgcmVmZXJlbmNlZC4gIElmIFVQTE8g\nPSAnTCcsIHRoZSBsZWFkaW5nIE4tYnktTiBsb3dlcgogICAgdHJpYW5ndWxhciBwYXJ0IG9mIEEg\nY29udGFpbnMgdGhlIGxvd2VyIHRyaWFuZ3VsYXIgcGFydCBvZgogICAgdGhlIG1hdHJpeCBBLCBh\nbmQgdGhlIHN0cmljdGx5IHVwcGVyIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGlzCiAgICBub3QgcmVm\nZXJlbmNlZC4KXHBhcmFtW2luXSBMREEKICAgICAgICAgTERBIGlzIElOVEVHRVIKICAgIFRoZSBs\nZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQS4gIExEQSA+PSBtYXgoMSxOKS4KXHBhcmFt\nW2luXSBBRgogICAgICAgICBBRiBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQUYs\nTikKICAgIFRoZSB0cmlhbmd1bGFyIGZhY3RvciBVIG9yIEwgZnJvbSB0aGUgQ2hvbGVza3kgZmFj\ndG9yaXphdGlvbgogICAgQSA9IFUqKlQqVSBvciBBID0gTCpMKipULCBhcyBjb21wdXRlZCBieSBE\nUE9UUkYuClxwYXJhbVtpbl0gTERBRgogICAgICAgICBMREFGIGlzIElOVEVHRVIKICAgIFRoZSBs\nZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQUYuICBMREFGID49IG1heCgxLE4pLgpccGFy\nYW1baW4sb3V0XSBTCiAgICAgICAgIFMgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5z\naW9uIChOKQogICAgVGhlIHJvdyBzY2FsZSBmYWN0b3JzIGZvciBBLiAgSWYgRVFVRUQgPSAnWScs\nIEEgaXMgbXVsdGlwbGllZCBvbgogICAgdGhlIGxlZnQgYW5kIHJpZ2h0IGJ5IGRpYWcoUykuICBT\nIGlzIGFuIGlucHV0IGFyZ3VtZW50IGlmIEZBQ1QgPQogICAgJ0YnOyBvdGhlcndpc2UsIFMgaXMg\nYW4gb3V0cHV0IGFyZ3VtZW50LiAgSWYgRkFDVCA9ICdGJyBhbmQgRVFVRUQKICAgID0gJ1knLCBl\nYWNoIGVsZW1lbnQgb2YgUyBtdXN0IGJlIHBvc2l0aXZlLiAgSWYgUyBpcyBvdXRwdXQsIGVhY2gK\nICAgIGVsZW1lbnQgb2YgUyBpcyBhIHBvd2VyIG9mIHRoZSByYWRpeC4gSWYgUyBpcyBpbnB1dCwg\nZWFjaCBlbGVtZW50CiAgICBvZiBTIHNob3VsZCBiZSBhIHBvd2VyIG9mIHRoZSByYWRpeCB0byBl\nbnN1cmUgYSByZWxpYWJsZSBzb2x1dGlvbgogICAgYW5kIGVycm9yIGVzdGltYXRlcy4gU2NhbGlu\nZyBieSBwb3dlcnMgb2YgdGhlIHJhZGl4IGRvZXMgbm90IGNhdXNlCiAgICByb3VuZGluZyBlcnJv\ncnMgdW5sZXNzIHRoZSByZXN1bHQgdW5kZXJmbG93cyBvciBvdmVyZmxvd3MuCiAgICBSb3VuZGlu\nZyBlcnJvcnMgZHVyaW5nIHNjYWxpbmcgbGVhZCB0byByZWZpbmluZyB3aXRoIGEgbWF0cml4IHRo\nYXQKICAgIGlzIG5vdCBlcXVpdmFsZW50IHRvIHRoZSBpbnB1dCBtYXRyaXgsIHByb2R1Y2luZyBl\ncnJvciBlc3RpbWF0ZXMKICAgIHRoYXQgbWF5IG5vdCBiZSByZWxpYWJsZS4KXHBhcmFtW2luXSBC\nCiAgICAgICAgIEIgaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAg\nIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExE\nQiBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBM\nREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBDT01QTEVYKjE2\nIGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBt\nYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgREdFVFJTLgogICAgT24gZXhpdCwgdGhlIGltcHJvdmVk\nIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdF\nUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgx\nLE4pLgpccGFyYW1bb3V0XSBSQ09ORAogICAgICAgICBSQ09ORCBpcyBET1VCTEUgUFJFQ0lTSU9O\nCiAgICBSZWNpcHJvY2FsIHNjYWxlZCBjb25kaXRpb24gbnVtYmVyLiAgVGhpcyBpcyBhbiBlc3Rp\nbWF0ZSBvZiB0aGUKICAgIHJlY2lwcm9jYWwgU2tlZWwgY29uZGl0aW9uIG51bWJlciBvZiB0aGUg\nbWF0cml4IEEgYWZ0ZXIKICAgIGVxdWlsaWJyYXRpb24gKGlmIGRvbmUpLiAgSWYgdGhpcyBpcyBs\nZXNzIHRoYW4gdGhlIG1hY2hpbmUKICAgIHByZWNpc2lvbiAoaW4gcGFydGljdWxhciwgaWYgaXQg\naXMgemVybyksIHRoZSBtYXRyaXggaXMgc2luZ3VsYXIKICAgIHRvIHdvcmtpbmcgcHJlY2lzaW9u\nLiAgTm90ZSB0aGF0IHRoZSBlcnJvciBtYXkgc3RpbGwgYmUgc21hbGwgZXZlbgogICAgaWYgdGhp\ncyBudW1iZXIgaXMgdmVyeSBzbWFsbCBhbmQgdGhlIG1hdHJpeCBhcHBlYXJzIGlsbC0KICAgIGNv\nbmRpdGlvbmVkLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgRE9VQkxFIFBSRUNJ\nU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgQ29tcG9uZW50d2lzZSByZWxhdGl2ZSBi\nYWNrd2FyZCBlcnJvci4gIFRoaXMgaXMgdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJh\nY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24gdmVjdG9yIFgoaikKICAgIChpLmUuLCB0aGUg\nc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0CiAg\nICBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW2luXSBOX0VSUl9CTkRTCiAg\nICAgICAgIE5fRVJSX0JORFMgaXMgSU5URUdFUgogICAgTnVtYmVyIG9mIGVycm9yIGJvdW5kcyB0\nbyByZXR1cm4gZm9yIGVhY2ggcmlnaHQgaGFuZCBzaWRlCiAgICBhbmQgZWFjaCB0eXBlIChub3Jt\nd2lzZSBvciBjb21wb25lbnR3aXNlKS4gIFNlZSBFUlJfQk5EU19OT1JNIGFuZAogICAgRVJSX0JO\nRFNfQ09NUCBiZWxvdy4KXHBhcmFtW291dF0gRVJSX0JORFNfTk9STQogICAgICAgICBFUlJfQk5E\nU19OT1JNIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUywgTl9FUlJf\nQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhpcyBhcnJheSBjb250YWlucyBp\nbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3VuZHMgYW5kIGNvbmRpdGlvbiBu\ndW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBub3Jtd2lzZSByZWxhdGl2ZSBlcnJvciwg\nd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dzOgogICAgTm9ybXdpc2UgcmVsYXRpdmUgZXJyb3Ig\naW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAgICAgICAgIG1heF9qIChhYnMoWFRSVUUo\naixpKSAtIFgoaixpKSkpCiAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t\nCiAgICAgICAgICAgICAgICAgbWF4X2ogYWJzKFgoaixpKSkKICAgIFRoZSBhcnJheSBpcyBpbmRl\neGVkIGJ5IHRoZSB0eXBlIG9mIGVycm9yIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZAogICAgYmVs\nb3cuIFRoZXJlIGN1cnJlbnRseSBhcmUgdXAgdG8gdGhyZWUgcGllY2VzIG9mIGluZm9ybWF0aW9u\nCiAgICByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKGksOikg\nY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQtaGFuZCBzaWRlLgogICAgVGhlIHNlY29u\nZCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKDosZXJyKSBjb250YWlucyB0aGUgZm9sbG93aW5nCiAg\nICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVzdC9kb24ndCB0cnVzdCIgYm9vbGVhbi4g\nVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9u\nIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAq\nIGRsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAiR3VhcmFudGVlZCIgZXJyb3IgYm91bmQ6\nIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAgICAgICAgICAgIGFsbW9zdCBjZXJ0YWlu\nbHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9yCiAgICAgICAgICAgICBz\nbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkCiAg\nICAgICAgICAgICBzcXJ0KG4pICogZGxhbWNoKCdFcHNpbG9uJykuIFRoaXMgZXJyb3IgYm91bmQg\nc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0ZWQgaWYgdGhlIHByZXZpb3VzIGJvb2xl\nYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlcjogRXN0\naW1hdGVkIG5vcm13aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIu\nICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBkbGFt\nY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAgICBlc3Rp\nbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAgICAgICAg\nICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5mKSkgZm9y\nIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgogICAgICAg\nICAgICAgTGV0IFogPSBTKkEsIHdoZXJlIFMgc2NhbGVzIGVhY2ggcm93IGJ5IGEgcG93ZXIgb2Yg\ndGhlCiAgICAgICAgICAgICByYWRpeCBzbyBhbGwgYWJzb2x1dGUgcm93IHN1bXMgb2YgWiBhcmUg\nYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFjayBXb3JraW5nIE5vdGUgMTY1IGZvciBmdXJ0\naGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4KXHBhcmFtW291dF0gRVJSX0JORFNf\nQ09NUAogICAgICAgICBFUlJfQk5EU19DT01QIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRp\nbWVuc2lvbiAoTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwg\ndGhpcyBhcnJheSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBi\nb3VuZHMgYW5kIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBjb21w\nb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFzIGZvbGxvd3M6CiAg\nICBDb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGluIHRoZSBpdGggc29sdXRpb24gdmVjdG9y\nOgogICAgICAgICAgICAgICAgICAgYWJzKFhUUlVFKGosaSkgLSBYKGosaSkpCiAgICAgICAgICAg\nIG1heF9qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAgICAgICAgICAgYWJz\nKFgoaixpKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSByaWdodC1oYW5kIHNpZGUg\naSAob24gd2hpY2ggdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGRlcGVuZHMp\nLCBhbmQgdGhlIHR5cGUgb2YgZXJyb3IKICAgIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZCBiZWxv\ndy4gVGhlcmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZQogICAgcGllY2VzIG9mIGluZm9ybWF0\naW9uIHJldHVybmVkIGZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZS4gSWYKICAgIGNvbXBvbmVudHdp\nc2UgYWNjdXJhY3kgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1TKDMpID0gMC4wKSwgdGhlbgogICAg\nRVJSX0JORFNfQ09NUCBpcyBub3QgYWNjZXNzZWQuICBJZiBOX0VSUl9CTkRTIC5MVC4gMywgdGhl\nbiBhdCBtb3N0CiAgICB0aGUgZmlyc3QgKDosTl9FUlJfQk5EUykgZW50cmllcyBhcmUgcmV0dXJu\nZWQuCiAgICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfQ09NUChpLDopIGNvcnJlc3BvbmRz\nIHRvIHRoZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBzZWNvbmQgaW5kZXggaW4g\nRVJSX0JORFNfQ09NUCg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2luZwogICAgdGhyZWUgZmll\nbGRzOgogICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xlYW4uIFRydXN0IHRoZSBh\nbnN3ZXIgaWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIgaXMg\nbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBkbGFtY2goJ0Vw\nc2lsb24nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJvdW5kOiBUaGUgZXN0aW1h\ndGVkIGZvcndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2VydGFpbmx5IHdpdGhpbiBh\nIGZhY3RvciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAgICAgc28gbG9uZyBhcyB0\naGUgbmV4dCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAg\nc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJvdW5kIHNob3VsZCBvbmx5\nCiAgICAgICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBib29sZWFuIGlzIHRydWUu\nCiAgICBlcnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6IEVzdGltYXRlZCBjb21w\nb25lbnR3aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIuICBDb21w\nYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBkbGFtY2goJ0Vw\nc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAgICBlc3RpbWF0ZSBp\ncyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAgICAgICAgICAgICBu\ndW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5mKSkgZm9yIHNvbWUK\nICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgogICAgICAgICAgICAg\nTGV0IFogPSBTKihBKmRpYWcoeCkpLCB3aGVyZSB4IGlzIHRoZSBzb2x1dGlvbiBmb3IgdGhlCiAg\nICAgICAgICAgICBjdXJyZW50IHJpZ2h0LWhhbmQgc2lkZSBhbmQgUyBzY2FsZXMgZWFjaCByb3cg\nb2YKICAgICAgICAgICAgIEEqZGlhZyh4KSBieSBhIHBvd2VyIG9mIHRoZSByYWRpeCBzbyBhbGwg\nYWJzb2x1dGUgcm93CiAgICAgICAgICAgICBzdW1zIG9mIFogYXJlIGFwcHJveGltYXRlbHkgMS4K\nICAgIFNlZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhlciBkZXRhaWxzIGFuZCBl\neHRyYQogICAgY2F1dGlvbnMuClxwYXJhbVtpbl0gTlBBUkFNUwogICAgICAgICBOUEFSQU1TIGlz\nIElOVEVHRVIKICAgIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgc2V0IGluIFBB\nUkFNUy4gIElmIC5MRS4gMCwgdGhlCiAgICBQQVJBTVMgYXJyYXkgaXMgbmV2ZXIgcmVmZXJlbmNl\nZCBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIHVzZWQuClxwYXJhbVtpbixvdXRdIFBBUkFNUwogICAg\nICAgICBQQVJBTVMgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIE5QQVJBTVMK\nICAgIFNwZWNpZmllcyBhbGdvcml0aG0gcGFyYW1ldGVycy4gIElmIGFuIGVudHJ5IGlzIC5MVC4g\nMC4wLCB0aGVuCiAgICB0aGF0IGVudHJ5IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVmYXVsdCB2YWx1\nZSB1c2VkIGZvciB0aGF0CiAgICBwYXJhbWV0ZXIuICBPbmx5IHBvc2l0aW9ucyB1cCB0byBOUEFS\nQU1TIGFyZSBhY2Nlc3NlZDsgZGVmYXVsdHMKICAgIGFyZSB1c2VkIGZvciBoaWdoZXItbnVtYmVy\nZWQgcGFyYW1ldGVycy4KICAgICAgUEFSQU1TKExBX0xJTlJYX0lUUkVGX0kgPSAxKSA6IFdoZXRo\nZXIgdG8gcGVyZm9ybSBpdGVyYXRpdmUKICAgICAgICAgICByZWZpbmVtZW50IG9yIG5vdC4KICAg\nICAgICBEZWZhdWx0OiAxLjBEKzAKICAgICAgICAgICA9IDAuMCA6IE5vIHJlZmluZW1lbnQgaXMg\ncGVyZm9ybWVkLCBhbmQgbm8gZXJyb3IgYm91bmRzIGFyZQogICAgICAgICAgICAgICAgICAgY29t\ncHV0ZWQuCiAgICAgICAgICAgPSAxLjAgOiBVc2UgdGhlIGRvdWJsZS1wcmVjaXNpb24gcmVmaW5l\nbWVudCBhbGdvcml0aG0sCiAgICAgICAgICAgICAgICAgICBwb3NzaWJseSB3aXRoIGRvdWJsZWQt\nc2luZ2xlIGNvbXB1dGF0aW9ucyBpZiB0aGUKICAgICAgICAgICAgICAgICAgIGNvbXBpbGF0aW9u\nIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgRE9VQkxFCiAgICAgICAgICAgICAgICAgICBQ\nUkVDSVNJT04uCiAgICAgICAgICAgICAob3RoZXIgdmFsdWVzIGFyZSByZXNlcnZlZCBmb3IgZnV0\ndXJlIHVzZSkKICAgICAgUEFSQU1TKExBX0xJTlJYX0lUSFJFU0hfSSA9IDIpIDogTWF4aW11bSBu\ndW1iZXIgb2YgcmVzaWR1YWwKICAgICAgICAgICBjb21wdXRhdGlvbnMgYWxsb3dlZCBmb3IgcmVm\naW5lbWVudC4KICAgICAgICBEZWZhdWx0OiAxMAogICAgICAgIEFnZ3Jlc3NpdmU6IFNldCB0byAx\nMDAgdG8gcGVybWl0IGNvbnZlcmdlbmNlIHVzaW5nIGFwcHJveGltYXRlCiAgICAgICAgICAgICAg\nICAgICAgZmFjdG9yaXphdGlvbnMgb3IgZmFjdG9yaXphdGlvbnMgb3RoZXIgdGhhbiBMVS4gSWYK\nICAgICAgICAgICAgICAgICAgICB0aGUgZmFjdG9yaXphdGlvbiB1c2VzIGEgdGVjaG5pcXVlIG90\naGVyIHRoYW4KICAgICAgICAgICAgICAgICAgICBHYXVzc2lhbiBlbGltaW5hdGlvbiwgdGhlIGd1\nYXJhbnRlZXMgaW4KICAgICAgICAgICAgICAgICAgICBlcnJfYm5kc19ub3JtIGFuZCBlcnJfYm5k\nc19jb21wIG1heSBubyBsb25nZXIgYmUKICAgICAgICAgICAgICAgICAgICB0cnVzdHdvcnRoeS4K\nICAgICAgUEFSQU1TKExBX0xJTlJYX0NXSVNFX0kgPSAzKSA6IEZsYWcgZGV0ZXJtaW5pbmcgaWYg\ndGhlIGNvZGUKICAgICAgICAgICB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIHNvbHV0aW9uIHdpdGgg\nc21hbGwgY29tcG9uZW50d2lzZQogICAgICAgICAgIHJlbGF0aXZlIGVycm9yIGluIHRoZSBkb3Vi\nbGUtcHJlY2lzaW9uIGFsZ29yaXRobS4gIFBvc2l0aXZlCiAgICAgICAgICAgaXMgdHJ1ZSwgMC4w\nIGlzIGZhbHNlLgogICAgICAgIERlZmF1bHQ6IDEuMCAoYXR0ZW1wdCBjb21wb25lbnR3aXNlIGNv\nbnZlcmdlbmNlKQpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgQ09NUExFWCoxNiBh\ncnJheSwgZGltZW5zaW9uICgyKk4pClxwYXJhbVtvdXRdIFJXT1JLCiAgICAgICAgIFJXT1JLIGlz\nIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBJTkZP\nCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICA9IDA6ICBTdWNjZXNzZnVsIGV4aXQuIFRo\nZSBzb2x1dGlvbiB0byBldmVyeSByaWdodC1oYW5kIHNpZGUgaXMKICAgICAgICBndWFyYW50ZWVk\nLgogICAgICA8IDA6ICBJZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxl\nZ2FsIHZhbHVlCiAgICAgID4gMCBhbmQgPD0gTjogIFUoSU5GTyxJTkZPKSBpcyBleGFjdGx5IHpl\ncm8uICBUaGUgZmFjdG9yaXphdGlvbgogICAgICAgIGhhcyBiZWVuIGNvbXBsZXRlZCwgYnV0IHRo\nZSBmYWN0b3IgVSBpcyBleGFjdGx5IHNpbmd1bGFyLCBzbwogICAgICAgIHRoZSBzb2x1dGlvbiBh\nbmQgZXJyb3IgYm91bmRzIGNvdWxkIG5vdCBiZSBjb21wdXRlZC4gUkNPTkQgPSAwCiAgICAgICAg\naXMgcmV0dXJuZWQuCiAgICAgID0gTitKOiBUaGUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byB0\naGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIG5vdCBndWFyYW50ZWVkLiBUaGUgc29s\ndXRpb25zIGNvcnJlc3BvbmRpbmcgdG8gb3RoZXIgcmlnaHQtCiAgICAgICAgaGFuZCBzaWRlcyBL\nIHdpdGggSyA+IEogbWF5IG5vdCBiZSBndWFyYW50ZWVkIGFzIHdlbGwsIGJ1dAogICAgICAgIG9u\nbHkgdGhlIGZpcnN0IHN1Y2ggcmlnaHQtaGFuZCBzaWRlIGlzIHJlcG9ydGVkLiBJZiBhIHNtYWxs\nCiAgICAgICAgY29tcG9uZW50d2lzZSBlcnJvciBpcyBub3QgcmVxdWVzdGVkIChQQVJBTVMoMykg\nPSAwLjApIHRoZW4KICAgICAgICB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcyB0aGUgZmlyc3Qg\nd2l0aCBhIG5vcm13aXNlIGVycm9yCiAgICAgICAgYm91bmQgdGhhdCBpcyBub3QgZ3VhcmFudGVl\nZCAodGhlIHNtYWxsZXN0IEogc3VjaAogICAgICAgIHRoYXQgRVJSX0JORFNfTk9STShKLDEpID0g\nMC4wKS4gQnkgZGVmYXVsdCAoUEFSQU1TKDMpID0gMS4wKQogICAgICAgIHRoZSBKdGggcmlnaHQt\naGFuZCBzaWRlIGlzIHRoZSBmaXJzdCB3aXRoIGVpdGhlciBhIG5vcm13aXNlIG9yCiAgICAgICAg\nY29tcG9uZW50d2lzZSBlcnJvciBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50ZWVkICh0aGUgc21h\nbGxlc3QKICAgICAgICBKIHN1Y2ggdGhhdCBlaXRoZXIgRVJSX0JORFNfTk9STShKLDEpID0gMC4w\nIG9yCiAgICAgICAgRVJSX0JORFNfQ09NUChKLDEpID0gMC4wKS4gU2VlIHRoZSBkZWZpbml0aW9u\nIG9mCiAgICAgICAgRVJSX0JORFNfTk9STSg6LDEpIGFuZCBFUlJfQk5EU19DT01QKDosMSkuIFRv\nIGdldCBpbmZvcm1hdGlvbgogICAgICAgIGFib3V0IGFsbCBvZiB0aGUgcmlnaHQtaGFuZCBzaWRl\ncyBjaGVjayBFUlJfQk5EU19OT1JNIG9yCiAgICAgICAgRVJSX0JORFNfQ09NUC4KQXV0aG9yczoK\nXGF1dGhvciBVbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBC\nZXJrZWxleSAKXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0\nZC4gClxkYXRlIEFwcmlsIDIwMTIKXGluZ3JvdXAgY29tcGxleDE2UE9jb21wdXRhdGlvbmFsCmgd\naB4pgXInAgAAfXIoAgAAKGghiWgiaCN1YmgtigKmAWguWA8AAAB6cG9yZnN4XzQyMi50eHR1Ymgv\nigKmAWgwWAYAAABwb3Jmc3hoLYoBQHViaBVoFl1oF4dScikCAAB9cioCAAAoaBpYCQAAAHN5bW1l\ndHJpY2gbWAQAAABmdWxsaBxYRgAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0\naW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudDsgRVFVRURoHWgeKYFyKwIAAH1yLAIAAChoIYlo\nImgjdWJoJFghAAAARG94eWdlbi9kb2NzL2h0bWwvc3N5cmZzeF84Zi5odG1saCVYAQAAAHNoJmgV\naCddaBeHUnItAgAAfXIuAgAAKGgqWJwxAAAgICBTU1lSRlNYIGltcHJvdmVzIHRoZSBjb21wdXRl\nZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKICAgZXF1YXRpb25zIHdoZW4gdGhlIGNv\nZWZmaWNpZW50IG1hdHJpeCBpcyBzeW1tZXRyaWMgaW5kZWZpbml0ZSwgYW5kCiAgIHByb3ZpZGVz\nIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzIGZvciB0aGUKICAgc29s\ndXRpb24uICBJbiBhZGRpdGlvbiB0byBub3Jtd2lzZSBlcnJvciBib3VuZCwgdGhlIGNvZGUgcHJv\ndmlkZXMKICAgbWF4aW11bSBjb21wb25lbnR3aXNlIGVycm9yIGJvdW5kIGlmIHBvc3NpYmxlLiAg\nU2VlIGNvbW1lbnRzIGZvcgogICBFUlJfQk5EU19OT1JNIGFuZCBFUlJfQk5EU19DT01QIGZvciBk\nZXRhaWxzIG9mIHRoZSBlcnJvciBib3VuZHMuCiAgIFRoZSBvcmlnaW5hbCBzeXN0ZW0gb2YgbGlu\nZWFyIGVxdWF0aW9ucyBtYXkgaGF2ZSBiZWVuIGVxdWlsaWJyYXRlZAogICBiZWZvcmUgY2FsbGlu\nZyB0aGlzIHJvdXRpbmUsIGFzIGRlc2NyaWJlZCBieSBhcmd1bWVudHMgRVFVRUQgYW5kIFMKICAg\nYmVsb3cuIEluIHRoaXMgY2FzZSwgdGhlIHNvbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgcmV0dXJu\nZWQgYXJlCiAgIGZvciB0aGUgb3JpZ2luYWwgdW5lcXVpbGlicmF0ZWQgc3lzdGVtLgpBcmd1bWVu\ndHM6CiAgICBTb21lIG9wdGlvbmFsIHBhcmFtZXRlcnMgYXJlIGJ1bmRsZWQgaW4gdGhlIFBBUkFN\nUyBhcnJheS4gIFRoZXNlCiAgICBzZXR0aW5ncyBkZXRlcm1pbmUgaG93IHJlZmluZW1lbnQgaXMg\ncGVyZm9ybWVkLCBidXQgb2Z0ZW4gdGhlCiAgICBkZWZhdWx0cyBhcmUgYWNjZXB0YWJsZS4gIElm\nIHRoZSBkZWZhdWx0cyBhcmUgYWNjZXB0YWJsZSwgdXNlcnMKICAgIGNhbiBwYXNzIE5QQVJBTVMg\nPSAwIHdoaWNoIHByZXZlbnRzIHRoZSBzb3VyY2UgY29kZSBmcm9tIGFjY2Vzc2luZwogICAgdGhl\nIFBBUkFNUyBhcmd1bWVudC4KXHBhcmFtW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hBUkFD\nVEVSKjEKICAgICAgPSAnVSc6ICBVcHBlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZDsKICAgICAg\nPSAnTCc6ICBMb3dlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZC4KXHBhcmFtW2luXSBFUVVFRAog\nICAgICAgICBFUVVFRCBpcyBDSEFSQUNURVIqMQogICAgU3BlY2lmaWVzIHRoZSBmb3JtIG9mIGVx\ndWlsaWJyYXRpb24gdGhhdCB3YXMgZG9uZSB0byBBCiAgICBiZWZvcmUgY2FsbGluZyB0aGlzIHJv\ndXRpbmUuIFRoaXMgaXMgbmVlZGVkIHRvIGNvbXB1dGUKICAgIHRoZSBzb2x1dGlvbiBhbmQgZXJy\nb3IgYm91bmRzIGNvcnJlY3RseS4KICAgICAgPSAnTic6ICBObyBlcXVpbGlicmF0aW9uCiAgICAg\nID0gJ1knOiAgQm90aCByb3cgYW5kIGNvbHVtbiBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBi\nZWVuCiAgICAgICAgICAgICAgcmVwbGFjZWQgYnkgZGlhZyhTKSAqIEEgKiBkaWFnKFMpLgogICAg\nICAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgQiBoYXMgYmVlbiBjaGFuZ2VkIGFjY29yZGlu\nZ2x5LgpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICBUaGUgb3JkZXIgb2Yg\ndGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJ\nTlRFR0VSCiAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1i\nZXIgb2YgY29sdW1ucwogICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxw\nYXJhbVtpbl0gQQogICAgICAgICBBIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTERBLE4pCiAg\nICBUaGUgc3ltbWV0cmljIG1hdHJpeCBBLiAgSWYgVVBMTyA9ICdVJywgdGhlIGxlYWRpbmcgTi1i\neS1OCiAgICB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgdXBwZXIgdHJp\nYW5ndWxhcgogICAgcGFydCBvZiB0aGUgbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkgbG93ZXIg\ndHJpYW5ndWxhcgogICAgcGFydCBvZiBBIGlzIG5vdCByZWZlcmVuY2VkLiAgSWYgVVBMTyA9ICdM\nJywgdGhlIGxlYWRpbmcKICAgIE4tYnktTiBsb3dlciB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250\nYWlucyB0aGUgbG93ZXIKICAgIHRyaWFuZ3VsYXIgcGFydCBvZiB0aGUgbWF0cml4IEEsIGFuZCB0\naGUgc3RyaWN0bHkgdXBwZXIKICAgIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGlzIG5vdCByZWZlcmVu\nY2VkLgpccGFyYW1baW5dIExEQQogICAgICAgICBMREEgaXMgSU5URUdFUgogICAgVGhlIGxlYWRp\nbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBLiAgTERBID49IG1heCgxLE4pLgpccGFyYW1baW5d\nIEFGCiAgICAgICAgIEFGIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTERBRixOKQogICAgVGhl\nIGZhY3RvcmVkIGZvcm0gb2YgdGhlIG1hdHJpeCBBLiAgQUYgY29udGFpbnMgdGhlIGJsb2NrCiAg\nICBkaWFnb25hbCBtYXRyaXggRCBhbmQgdGhlIG11bHRpcGxpZXJzIHVzZWQgdG8gb2J0YWluIHRo\nZQogICAgZmFjdG9yIFUgb3IgTCBmcm9tIHRoZSBmYWN0b3JpemF0aW9uIEEgPSBVKkQqVSoqVCBv\nciBBID0KICAgIEwqRCpMKipUIGFzIGNvbXB1dGVkIGJ5IFNTWVRSRi4KXHBhcmFtW2luXSBMREFG\nCiAgICAgICAgIExEQUYgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRo\nZSBhcnJheSBBRi4gIExEQUYgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gSVBJVgogICAgICAgICBJ\nUElWIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgIERldGFpbHMgb2YgdGhlIGlu\ndGVyY2hhbmdlcyBhbmQgdGhlIGJsb2NrIHN0cnVjdHVyZSBvZiBECiAgICBhcyBkZXRlcm1pbmVk\nIGJ5IFNTWVRSRi4KXHBhcmFtW2luLG91dF0gUwogICAgICAgICBTIGlzIFJFQUwgYXJyYXksIGRp\nbWVuc2lvbiAoTikKICAgIFRoZSBzY2FsZSBmYWN0b3JzIGZvciBBLiAgSWYgRVFVRUQgPSAnWScs\nIEEgaXMgbXVsdGlwbGllZCBvbgogICAgdGhlIGxlZnQgYW5kIHJpZ2h0IGJ5IGRpYWcoUykuICBT\nIGlzIGFuIGlucHV0IGFyZ3VtZW50IGlmIEZBQ1QgPQogICAgJ0YnOyBvdGhlcndpc2UsIFMgaXMg\nYW4gb3V0cHV0IGFyZ3VtZW50LiAgSWYgRkFDVCA9ICdGJyBhbmQgRVFVRUQKICAgID0gJ1knLCBl\nYWNoIGVsZW1lbnQgb2YgUyBtdXN0IGJlIHBvc2l0aXZlLiAgSWYgUyBpcyBvdXRwdXQsIGVhY2gK\nICAgIGVsZW1lbnQgb2YgUyBpcyBhIHBvd2VyIG9mIHRoZSByYWRpeC4gSWYgUyBpcyBpbnB1dCwg\nZWFjaCBlbGVtZW50CiAgICBvZiBTIHNob3VsZCBiZSBhIHBvd2VyIG9mIHRoZSByYWRpeCB0byBl\nbnN1cmUgYSByZWxpYWJsZSBzb2x1dGlvbgogICAgYW5kIGVycm9yIGVzdGltYXRlcy4gU2NhbGlu\nZyBieSBwb3dlcnMgb2YgdGhlIHJhZGl4IGRvZXMgbm90IGNhdXNlCiAgICByb3VuZGluZyBlcnJv\ncnMgdW5sZXNzIHRoZSByZXN1bHQgdW5kZXJmbG93cyBvciBvdmVyZmxvd3MuCiAgICBSb3VuZGlu\nZyBlcnJvcnMgZHVyaW5nIHNjYWxpbmcgbGVhZCB0byByZWZpbmluZyB3aXRoIGEgbWF0cml4IHRo\nYXQKICAgIGlzIG5vdCBlcXVpdmFsZW50IHRvIHRoZSBpbnB1dCBtYXRyaXgsIHByb2R1Y2luZyBl\ncnJvciBlc3RpbWF0ZXMKICAgIHRoYXQgbWF5IG5vdCBiZSByZWxpYWJsZS4KXHBhcmFtW2luXSBC\nCiAgICAgICAgIEIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykKICAgIFRoZSBy\naWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAgIExEQiBpcyBJ\nTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIuICBMREIgPj0g\nbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBSRUFMIGFycmF5LCBkaW1l\nbnNpb24gKExEWCxOUkhTKQogICAgT24gZW50cnksIHRoZSBzb2x1dGlvbiBtYXRyaXggWCwgYXMg\nY29tcHV0ZWQgYnkgU0dFVFJTLgogICAgT24gZXhpdCwgdGhlIGltcHJvdmVkIHNvbHV0aW9uIG1h\ndHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5URUdFUgogICAgVGhlIGxl\nYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1heCgxLE4pLgpccGFyYW1b\nb3V0XSBSQ09ORAogICAgICAgICBSQ09ORCBpcyBSRUFMCiAgICBSZWNpcHJvY2FsIHNjYWxlZCBj\nb25kaXRpb24gbnVtYmVyLiAgVGhpcyBpcyBhbiBlc3RpbWF0ZSBvZiB0aGUKICAgIHJlY2lwcm9j\nYWwgU2tlZWwgY29uZGl0aW9uIG51bWJlciBvZiB0aGUgbWF0cml4IEEgYWZ0ZXIKICAgIGVxdWls\naWJyYXRpb24gKGlmIGRvbmUpLiAgSWYgdGhpcyBpcyBsZXNzIHRoYW4gdGhlIG1hY2hpbmUKICAg\nIHByZWNpc2lvbiAoaW4gcGFydGljdWxhciwgaWYgaXQgaXMgemVybyksIHRoZSBtYXRyaXggaXMg\nc2luZ3VsYXIKICAgIHRvIHdvcmtpbmcgcHJlY2lzaW9uLiAgTm90ZSB0aGF0IHRoZSBlcnJvciBt\nYXkgc3RpbGwgYmUgc21hbGwgZXZlbgogICAgaWYgdGhpcyBudW1iZXIgaXMgdmVyeSBzbWFsbCBh\nbmQgdGhlIG1hdHJpeCBhcHBlYXJzIGlsbC0KICAgIGNvbmRpdGlvbmVkLgpccGFyYW1bb3V0XSBC\nRVJSCiAgICAgICAgIEJFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgQ29t\ncG9uZW50d2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvci4gIFRoaXMgaXMgdGhlCiAgICBjb21w\nb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24gdmVjdG9y\nIFgoaikKICAgIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluIGFueSBlbGVt\nZW50IG9mIEEgb3IgQiB0aGF0CiAgICBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBh\ncmFtW2luXSBOX0VSUl9CTkRTCiAgICAgICAgIE5fRVJSX0JORFMgaXMgSU5URUdFUgogICAgTnVt\nYmVyIG9mIGVycm9yIGJvdW5kcyB0byByZXR1cm4gZm9yIGVhY2ggcmlnaHQgaGFuZCBzaWRlCiAg\nICBhbmQgZWFjaCB0eXBlIChub3Jtd2lzZSBvciBjb21wb25lbnR3aXNlKS4gIFNlZSBFUlJfQk5E\nU19OT1JNIGFuZAogICAgRVJSX0JORFNfQ09NUCBiZWxvdy4KXHBhcmFtW291dF0gRVJSX0JORFNf\nTk9STQogICAgICAgICBFUlJfQk5EU19OT1JNIGlzIFJFQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJI\nUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhpcyBhcnJheSBj\nb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3VuZHMgYW5kIGNv\nbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBub3Jtd2lzZSByZWxhdGl2\nZSBlcnJvciwgd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dzOgogICAgTm9ybXdpc2UgcmVsYXRp\ndmUgZXJyb3IgaW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAgICAgICAgIG1heF9qIChh\nYnMoWFRSVUUoaixpKSAtIFgoaixpKSkpCiAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0t\nLS0tLS0tLS0tCiAgICAgICAgICAgICAgICAgbWF4X2ogYWJzKFgoaixpKSkKICAgIFRoZSBhcnJh\neSBpcyBpbmRleGVkIGJ5IHRoZSB0eXBlIG9mIGVycm9yIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJl\nZAogICAgYmVsb3cuIFRoZXJlIGN1cnJlbnRseSBhcmUgdXAgdG8gdGhyZWUgcGllY2VzIG9mIGlu\nZm9ybWF0aW9uCiAgICByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJfQk5EU19O\nT1JNKGksOikgY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQtaGFuZCBzaWRlLgogICAg\nVGhlIHNlY29uZCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKDosZXJyKSBjb250YWlucyB0aGUgZm9s\nbG93aW5nCiAgICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVzdC9kb24ndCB0cnVzdCIg\nYm9vbGVhbi4gVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAgICAgIHJlY2lwcm9jYWwg\nY29uZGl0aW9uIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAg\nc3FydChuKSAqIHNsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAiR3VhcmFudGVlZCIgZXJy\nb3IgYm91bmQ6IFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAgICAgICAgICAgIGFsbW9z\ndCBjZXJ0YWlubHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9yCiAgICAg\nICAgICAgICBzbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGhy\nZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykuIFRoaXMgZXJy\nb3IgYm91bmQgc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0ZWQgaWYgdGhlIHByZXZp\nb3VzIGJvb2xlYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0aW9uIG51\nbWJlcjogRXN0aW1hdGVkIG5vcm13aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlv\nbiBudW1iZXIuICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQo\nbikgKiBzbGFtY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAg\nICAgICBlc3RpbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9u\nCiAgICAgICAgICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFos\naW5mKSkgZm9yIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBa\nLgogICAgICAgICAgICAgTGV0IFogPSBTKkEsIHdoZXJlIFMgc2NhbGVzIGVhY2ggcm93IGJ5IGEg\ncG93ZXIgb2YgdGhlCiAgICAgICAgICAgICByYWRpeCBzbyBhbGwgYWJzb2x1dGUgcm93IHN1bXMg\nb2YgWiBhcmUgYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFjayBXb3JraW5nIE5vdGUgMTY1\nIGZvciBmdXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4KXHBhcmFtW291dF0g\nRVJSX0JORFNfQ09NUAogICAgICAgICBFUlJfQk5EU19DT01QIGlzIFJFQUwgYXJyYXksIGRpbWVu\nc2lvbiAoTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhp\ncyBhcnJheSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3Vu\nZHMgYW5kIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBjb21wb25l\nbnR3aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFzIGZvbGxvd3M6CiAgICBD\nb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGluIHRoZSBpdGggc29sdXRpb24gdmVjdG9yOgog\nICAgICAgICAgICAgICAgICAgYWJzKFhUUlVFKGosaSkgLSBYKGosaSkpCiAgICAgICAgICAgIG1h\neF9qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAgICAgICAgICAgYWJzKFgo\naixpKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSByaWdodC1oYW5kIHNpZGUgaSAo\nb24gd2hpY2ggdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGRlcGVuZHMpLCBh\nbmQgdGhlIHR5cGUgb2YgZXJyb3IKICAgIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZCBiZWxvdy4g\nVGhlcmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZQogICAgcGllY2VzIG9mIGluZm9ybWF0aW9u\nIHJldHVybmVkIGZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZS4gSWYKICAgIGNvbXBvbmVudHdpc2Ug\nYWNjdXJhY3kgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1TKDMpID0gMC4wKSwgdGhlbgogICAgRVJS\nX0JORFNfQ09NUCBpcyBub3QgYWNjZXNzZWQuICBJZiBOX0VSUl9CTkRTIC5MVC4gMywgdGhlbiBh\ndCBtb3N0CiAgICB0aGUgZmlyc3QgKDosTl9FUlJfQk5EUykgZW50cmllcyBhcmUgcmV0dXJuZWQu\nCiAgICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfQ09NUChpLDopIGNvcnJlc3BvbmRzIHRv\nIHRoZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBzZWNvbmQgaW5kZXggaW4gRVJS\nX0JORFNfQ09NUCg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2luZwogICAgdGhyZWUgZmllbGRz\nOgogICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xlYW4uIFRydXN0IHRoZSBhbnN3\nZXIgaWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIgaXMgbGVz\ncyB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2ls\nb24nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJvdW5kOiBUaGUgZXN0aW1hdGVk\nIGZvcndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2VydGFpbmx5IHdpdGhpbiBhIGZh\nY3RvciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAgICAgc28gbG9uZyBhcyB0aGUg\nbmV4dCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3Fy\ndChuKSAqIHNsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJvdW5kIHNob3VsZCBvbmx5CiAg\nICAgICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBib29sZWFuIGlzIHRydWUuCiAg\nICBlcnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6IEVzdGltYXRlZCBjb21wb25l\nbnR3aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIuICBDb21wYXJl\nZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2ls\nb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAgICBlc3RpbWF0ZSBpcyAi\nZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAgICAgICAgICAgICBudW1i\nZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5mKSkgZm9yIHNvbWUKICAg\nICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgogICAgICAgICAgICAgTGV0\nIFogPSBTKihBKmRpYWcoeCkpLCB3aGVyZSB4IGlzIHRoZSBzb2x1dGlvbiBmb3IgdGhlCiAgICAg\nICAgICAgICBjdXJyZW50IHJpZ2h0LWhhbmQgc2lkZSBhbmQgUyBzY2FsZXMgZWFjaCByb3cgb2YK\nICAgICAgICAgICAgIEEqZGlhZyh4KSBieSBhIHBvd2VyIG9mIHRoZSByYWRpeCBzbyBhbGwgYWJz\nb2x1dGUgcm93CiAgICAgICAgICAgICBzdW1zIG9mIFogYXJlIGFwcHJveGltYXRlbHkgMS4KICAg\nIFNlZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhlciBkZXRhaWxzIGFuZCBleHRy\nYQogICAgY2F1dGlvbnMuClxwYXJhbVtpbl0gTlBBUkFNUwogICAgICAgICBOUEFSQU1TIGlzIElO\nVEVHRVIKICAgIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgc2V0IGluIFBBUkFN\nUy4gIElmIC5MRS4gMCwgdGhlCiAgICBQQVJBTVMgYXJyYXkgaXMgbmV2ZXIgcmVmZXJlbmNlZCBh\nbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIHVzZWQuClxwYXJhbVtpbixvdXRdIFBBUkFNUwogICAgICAg\nICBQQVJBTVMgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIE5QQVJBTVMKICAgIFNwZWNpZmllcyBh\nbGdvcml0aG0gcGFyYW1ldGVycy4gIElmIGFuIGVudHJ5IGlzIC5MVC4gMC4wLCB0aGVuCiAgICB0\naGF0IGVudHJ5IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVmYXVsdCB2YWx1ZSB1c2VkIGZvciB0aGF0\nCiAgICBwYXJhbWV0ZXIuICBPbmx5IHBvc2l0aW9ucyB1cCB0byBOUEFSQU1TIGFyZSBhY2Nlc3Nl\nZDsgZGVmYXVsdHMKICAgIGFyZSB1c2VkIGZvciBoaWdoZXItbnVtYmVyZWQgcGFyYW1ldGVycy4K\nICAgICAgUEFSQU1TKExBX0xJTlJYX0lUUkVGX0kgPSAxKSA6IFdoZXRoZXIgdG8gcGVyZm9ybSBp\ndGVyYXRpdmUKICAgICAgICAgICByZWZpbmVtZW50IG9yIG5vdC4KICAgICAgICBEZWZhdWx0OiAx\nLjAKICAgICAgICAgICA9IDAuMCA6IE5vIHJlZmluZW1lbnQgaXMgcGVyZm9ybWVkLCBhbmQgbm8g\nZXJyb3IgYm91bmRzIGFyZQogICAgICAgICAgICAgICAgICAgY29tcHV0ZWQuCiAgICAgICAgICAg\nPSAxLjAgOiBVc2UgdGhlIGRvdWJsZS1wcmVjaXNpb24gcmVmaW5lbWVudCBhbGdvcml0aG0sCiAg\nICAgICAgICAgICAgICAgICBwb3NzaWJseSB3aXRoIGRvdWJsZWQtc2luZ2xlIGNvbXB1dGF0aW9u\ncyBpZiB0aGUKICAgICAgICAgICAgICAgICAgIGNvbXBpbGF0aW9uIGVudmlyb25tZW50IGRvZXMg\nbm90IHN1cHBvcnQgRE9VQkxFCiAgICAgICAgICAgICAgICAgICBQUkVDSVNJT04uCiAgICAgICAg\nICAgICAob3RoZXIgdmFsdWVzIGFyZSByZXNlcnZlZCBmb3IgZnV0dXJlIHVzZSkKICAgICAgUEFS\nQU1TKExBX0xJTlJYX0lUSFJFU0hfSSA9IDIpIDogTWF4aW11bSBudW1iZXIgb2YgcmVzaWR1YWwK\nICAgICAgICAgICBjb21wdXRhdGlvbnMgYWxsb3dlZCBmb3IgcmVmaW5lbWVudC4KICAgICAgICBE\nZWZhdWx0OiAxMAogICAgICAgIEFnZ3Jlc3NpdmU6IFNldCB0byAxMDAgdG8gcGVybWl0IGNvbnZl\ncmdlbmNlIHVzaW5nIGFwcHJveGltYXRlCiAgICAgICAgICAgICAgICAgICAgZmFjdG9yaXphdGlv\nbnMgb3IgZmFjdG9yaXphdGlvbnMgb3RoZXIgdGhhbiBMVS4gSWYKICAgICAgICAgICAgICAgICAg\nICB0aGUgZmFjdG9yaXphdGlvbiB1c2VzIGEgdGVjaG5pcXVlIG90aGVyIHRoYW4KICAgICAgICAg\nICAgICAgICAgICBHYXVzc2lhbiBlbGltaW5hdGlvbiwgdGhlIGd1YXJhbnRlZXMgaW4KICAgICAg\nICAgICAgICAgICAgICBlcnJfYm5kc19ub3JtIGFuZCBlcnJfYm5kc19jb21wIG1heSBubyBsb25n\nZXIgYmUKICAgICAgICAgICAgICAgICAgICB0cnVzdHdvcnRoeS4KICAgICAgUEFSQU1TKExBX0xJ\nTlJYX0NXSVNFX0kgPSAzKSA6IEZsYWcgZGV0ZXJtaW5pbmcgaWYgdGhlIGNvZGUKICAgICAgICAg\nICB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIHNvbHV0aW9uIHdpdGggc21hbGwgY29tcG9uZW50d2lz\nZQogICAgICAgICAgIHJlbGF0aXZlIGVycm9yIGluIHRoZSBkb3VibGUtcHJlY2lzaW9uIGFsZ29y\naXRobS4gIFBvc2l0aXZlCiAgICAgICAgICAgaXMgdHJ1ZSwgMC4wIGlzIGZhbHNlLgogICAgICAg\nIERlZmF1bHQ6IDEuMCAoYXR0ZW1wdCBjb21wb25lbnR3aXNlIGNvbnZlcmdlbmNlKQpccGFyYW1b\nb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uICg0Kk4pClxw\nYXJhbVtvdXRdIElXT1JLCiAgICAgICAgIElXT1JLIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lv\nbiAoTikKXHBhcmFtW291dF0gSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgPSAw\nOiAgU3VjY2Vzc2Z1bCBleGl0LiBUaGUgc29sdXRpb24gdG8gZXZlcnkgcmlnaHQtaGFuZCBzaWRl\nIGlzCiAgICAgICAgZ3VhcmFudGVlZC4KICAgICAgPCAwOiAgSWYgSU5GTyA9IC1pLCB0aGUgaS10\naCBhcmd1bWVudCBoYWQgYW4gaWxsZWdhbCB2YWx1ZQogICAgICA+IDAgYW5kIDw9IE46ICBVKElO\nRk8sSU5GTykgaXMgZXhhY3RseSB6ZXJvLiAgVGhlIGZhY3Rvcml6YXRpb24KICAgICAgICBoYXMg\nYmVlbiBjb21wbGV0ZWQsIGJ1dCB0aGUgZmFjdG9yIFUgaXMgZXhhY3RseSBzaW5ndWxhciwgc28K\nICAgICAgICB0aGUgc29sdXRpb24gYW5kIGVycm9yIGJvdW5kcyBjb3VsZCBub3QgYmUgY29tcHV0\nZWQuIFJDT05EID0gMAogICAgICAgIGlzIHJldHVybmVkLgogICAgICA9IE4rSjogVGhlIHNvbHV0\naW9uIGNvcnJlc3BvbmRpbmcgdG8gdGhlIEp0aCByaWdodC1oYW5kIHNpZGUgaXMKICAgICAgICBu\nb3QgZ3VhcmFudGVlZC4gVGhlIHNvbHV0aW9ucyBjb3JyZXNwb25kaW5nIHRvIG90aGVyIHJpZ2h0\nLQogICAgICAgIGhhbmQgc2lkZXMgSyB3aXRoIEsgPiBKIG1heSBub3QgYmUgZ3VhcmFudGVlZCBh\ncyB3ZWxsLCBidXQKICAgICAgICBvbmx5IHRoZSBmaXJzdCBzdWNoIHJpZ2h0LWhhbmQgc2lkZSBp\ncyByZXBvcnRlZC4gSWYgYSBzbWFsbAogICAgICAgIGNvbXBvbmVudHdpc2UgZXJyb3IgaXMgbm90\nIHJlcXVlc3RlZCAoUEFSQU1TKDMpID0gMC4wKSB0aGVuCiAgICAgICAgdGhlIEp0aCByaWdodC1o\nYW5kIHNpZGUgaXMgdGhlIGZpcnN0IHdpdGggYSBub3Jtd2lzZSBlcnJvcgogICAgICAgIGJvdW5k\nIHRoYXQgaXMgbm90IGd1YXJhbnRlZWQgKHRoZSBzbWFsbGVzdCBKIHN1Y2gKICAgICAgICB0aGF0\nIEVSUl9CTkRTX05PUk0oSiwxKSA9IDAuMCkuIEJ5IGRlZmF1bHQgKFBBUkFNUygzKSA9IDEuMCkK\nICAgICAgICB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcyB0aGUgZmlyc3Qgd2l0aCBlaXRoZXIg\nYSBub3Jtd2lzZSBvcgogICAgICAgIGNvbXBvbmVudHdpc2UgZXJyb3IgYm91bmQgdGhhdCBpcyBu\nb3QgZ3VhcmFudGVlZCAodGhlIHNtYWxsZXN0CiAgICAgICAgSiBzdWNoIHRoYXQgZWl0aGVyIEVS\nUl9CTkRTX05PUk0oSiwxKSA9IDAuMCBvcgogICAgICAgIEVSUl9CTkRTX0NPTVAoSiwxKSA9IDAu\nMCkuIFNlZSB0aGUgZGVmaW5pdGlvbiBvZgogICAgICAgIEVSUl9CTkRTX05PUk0oOiwxKSBhbmQg\nRVJSX0JORFNfQ09NUCg6LDEpLiBUbyBnZXQgaW5mb3JtYXRpb24KICAgICAgICBhYm91dCBhbGwg\nb2YgdGhlIHJpZ2h0LWhhbmQgc2lkZXMgY2hlY2sgRVJSX0JORFNfTk9STSBvcgogICAgICAgIEVS\nUl9CTkRTX0NPTVAuCkF1dGhvcnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9y\nIFVuaXYuIG9mIENhbGlmb3JuaWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8g\nRGVudmVyIApcYXV0aG9yIE5BRyBMdGQuIApcZGF0ZSBBcHJpbCAyMDEyClxpbmdyb3VwIHJlYWxT\nWWNvbXB1dGF0aW9uYWwKaB1oHimBci8CAAB9cjACAAAoaCGJaCJoI3ViaC2KAqcBaC5YDwAAAHNz\neXJmc3hfNDIzLnR4dHViaC+KAqcBaDBYBgAAAHN5cmZzeGgtigFBdWJoFWgWXWgXh1JyMQIAAH1y\nMgIAAChoGlgJAAAAc3ltbWV0cmljaBtYBAAAAGZ1bGxoHFhGAAAAZXJyb3IgYm91bmRzIGFuZCBi\nYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZpbmVtZW50OyBFUVVFRGgdaB4p\ngXIzAgAAfXI0AgAAKGghiWgiaCN1YmgkWCEAAABEb3h5Z2VuL2RvY3MvaHRtbC9kc3lyZnN4Xzhm\nLmh0bWxoJVgBAAAAZGgmaBVoJ11oF4dScjUCAAB9cjYCAAAoaCpYJzIAACAgIERTWVJGU1ggaW1w\ncm92ZXMgdGhlIGNvbXB1dGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgogICBlcXVh\ndGlvbnMgd2hlbiB0aGUgY29lZmZpY2llbnQgbWF0cml4IGlzIHN5bW1ldHJpYyBpbmRlZmluaXRl\nLCBhbmQKICAgcHJvdmlkZXMgZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0\nZXMgZm9yIHRoZQogICBzb2x1dGlvbi4gIEluIGFkZGl0aW9uIHRvIG5vcm13aXNlIGVycm9yIGJv\ndW5kLCB0aGUgY29kZSBwcm92aWRlcwogICBtYXhpbXVtIGNvbXBvbmVudHdpc2UgZXJyb3IgYm91\nbmQgaWYgcG9zc2libGUuICBTZWUgY29tbWVudHMgZm9yCiAgIEVSUl9CTkRTX05PUk0gYW5kIEVS\nUl9CTkRTX0NPTVAgZm9yIGRldGFpbHMgb2YgdGhlIGVycm9yIGJvdW5kcy4KICAgVGhlIG9yaWdp\nbmFsIHN5c3RlbSBvZiBsaW5lYXIgZXF1YXRpb25zIG1heSBoYXZlIGJlZW4gZXF1aWxpYnJhdGVk\nCiAgIGJlZm9yZSBjYWxsaW5nIHRoaXMgcm91dGluZSwgYXMgZGVzY3JpYmVkIGJ5IGFyZ3VtZW50\ncyBFUVVFRCBhbmQgUwogICBiZWxvdy4gSW4gdGhpcyBjYXNlLCB0aGUgc29sdXRpb24gYW5kIGVy\ncm9yIGJvdW5kcyByZXR1cm5lZCBhcmUKICAgZm9yIHRoZSBvcmlnaW5hbCB1bmVxdWlsaWJyYXRl\nZCBzeXN0ZW0uCkFyZ3VtZW50czoKICAgIFNvbWUgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgYnVu\nZGxlZCBpbiB0aGUgUEFSQU1TIGFycmF5LiAgVGhlc2UKICAgIHNldHRpbmdzIGRldGVybWluZSBo\nb3cgcmVmaW5lbWVudCBpcyBwZXJmb3JtZWQsIGJ1dCBvZnRlbiB0aGUKICAgIGRlZmF1bHRzIGFy\nZSBhY2NlcHRhYmxlLiAgSWYgdGhlIGRlZmF1bHRzIGFyZSBhY2NlcHRhYmxlLCB1c2VycwogICAg\nY2FuIHBhc3MgTlBBUkFNUyA9IDAgd2hpY2ggcHJldmVudHMgdGhlIHNvdXJjZSBjb2RlIGZyb20g\nYWNjZXNzaW5nCiAgICB0aGUgUEFSQU1TIGFyZ3VtZW50LgpccGFyYW1baW5dIFVQTE8KICAgICAg\nICAgVVBMTyBpcyBDSEFSQUNURVIqMQogICAgICA9ICdVJzogIFVwcGVyIHRyaWFuZ2xlIG9mIEEg\naXMgc3RvcmVkOwogICAgICA9ICdMJzogIExvd2VyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkLgpc\ncGFyYW1baW5dIEVRVUVECiAgICAgICAgIEVRVUVEIGlzIENIQVJBQ1RFUioxCiAgICBTcGVjaWZp\nZXMgdGhlIGZvcm0gb2YgZXF1aWxpYnJhdGlvbiB0aGF0IHdhcyBkb25lIHRvIEEKICAgIGJlZm9y\nZSBjYWxsaW5nIHRoaXMgcm91dGluZS4gVGhpcyBpcyBuZWVkZWQgdG8gY29tcHV0ZQogICAgdGhl\nIHNvbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgY29ycmVjdGx5LgogICAgICA9ICdOJzogIE5vIGVx\ndWlsaWJyYXRpb24KICAgICAgPSAnWSc6ICBCb3RoIHJvdyBhbmQgY29sdW1uIGVxdWlsaWJyYXRp\nb24sIGkuZS4sIEEgaGFzIGJlZW4KICAgICAgICAgICAgICByZXBsYWNlZCBieSBkaWFnKFMpICog\nQSAqIGRpYWcoUykuCiAgICAgICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBCIGhhcyBiZWVu\nIGNoYW5nZWQgYWNjb3JkaW5nbHkuClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIK\nICAgIFRoZSBvcmRlciBvZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJIUwog\nICAgICAgICBOUkhTIGlzIElOVEVHRVIKICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRl\ncywgaS5lLiwgdGhlIG51bWJlciBvZiBjb2x1bW5zCiAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQg\nWC4gIE5SSFMgPj0gMC4KXHBhcmFtW2luXSBBCiAgICAgICAgIEEgaXMgRE9VQkxFIFBSRUNJU0lP\nTiBhcnJheSwgZGltZW5zaW9uIChMREEsTikKICAgIFRoZSBzeW1tZXRyaWMgbWF0cml4IEEuICBJ\nZiBVUExPID0gJ1UnLCB0aGUgbGVhZGluZyBOLWJ5LU4KICAgIHVwcGVyIHRyaWFuZ3VsYXIgcGFy\ndCBvZiBBIGNvbnRhaW5zIHRoZSB1cHBlciB0cmlhbmd1bGFyCiAgICBwYXJ0IG9mIHRoZSBtYXRy\naXggQSwgYW5kIHRoZSBzdHJpY3RseSBsb3dlciB0cmlhbmd1bGFyCiAgICBwYXJ0IG9mIEEgaXMg\nbm90IHJlZmVyZW5jZWQuICBJZiBVUExPID0gJ0wnLCB0aGUgbGVhZGluZwogICAgTi1ieS1OIGxv\nd2VyIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGNvbnRhaW5zIHRoZSBsb3dlcgogICAgdHJpYW5ndWxh\nciBwYXJ0IG9mIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBzdHJpY3RseSB1cHBlcgogICAgdHJpYW5n\ndWxhciBwYXJ0IG9mIEEgaXMgbm90IHJlZmVyZW5jZWQuClxwYXJhbVtpbl0gTERBCiAgICAgICAg\nIExEQSBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEEu\nICBMREEgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gQUYKICAgICAgICAgQUYgaXMgRE9VQkxFIFBS\nRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChMREFGLE4pCiAgICBUaGUgZmFjdG9yZWQgZm9ybSBv\nZiB0aGUgbWF0cml4IEEuICBBRiBjb250YWlucyB0aGUgYmxvY2sKICAgIGRpYWdvbmFsIG1hdHJp\neCBEIGFuZCB0aGUgbXVsdGlwbGllcnMgdXNlZCB0byBvYnRhaW4gdGhlCiAgICBmYWN0b3IgVSBv\nciBMIGZyb20gdGhlIGZhY3Rvcml6YXRpb24gQSA9IFUqRCpVKipUIG9yIEEgPQogICAgTCpEKkwq\nKlQgYXMgY29tcHV0ZWQgYnkgRFNZVFJGLgpccGFyYW1baW5dIExEQUYKICAgICAgICAgTERBRiBp\ncyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEFGLiAgTERB\nRiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBJUElWCiAgICAgICAgIElQSVYgaXMgSU5URUdFUiBh\ncnJheSwgZGltZW5zaW9uIChOKQogICAgRGV0YWlscyBvZiB0aGUgaW50ZXJjaGFuZ2VzIGFuZCB0\naGUgYmxvY2sgc3RydWN0dXJlIG9mIEQKICAgIGFzIGRldGVybWluZWQgYnkgRFNZVFJGLgpccGFy\nYW1baW4sb3V0XSBTCiAgICAgICAgIFMgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5z\naW9uIChOKQogICAgVGhlIHNjYWxlIGZhY3RvcnMgZm9yIEEuICBJZiBFUVVFRCA9ICdZJywgQSBp\ncyBtdWx0aXBsaWVkIG9uCiAgICB0aGUgbGVmdCBhbmQgcmlnaHQgYnkgZGlhZyhTKS4gIFMgaXMg\nYW4gaW5wdXQgYXJndW1lbnQgaWYgRkFDVCA9CiAgICAnRic7IG90aGVyd2lzZSwgUyBpcyBhbiBv\ndXRwdXQgYXJndW1lbnQuICBJZiBGQUNUID0gJ0YnIGFuZCBFUVVFRAogICAgPSAnWScsIGVhY2gg\nZWxlbWVudCBvZiBTIG11c3QgYmUgcG9zaXRpdmUuICBJZiBTIGlzIG91dHB1dCwgZWFjaAogICAg\nZWxlbWVudCBvZiBTIGlzIGEgcG93ZXIgb2YgdGhlIHJhZGl4LiBJZiBTIGlzIGlucHV0LCBlYWNo\nIGVsZW1lbnQKICAgIG9mIFMgc2hvdWxkIGJlIGEgcG93ZXIgb2YgdGhlIHJhZGl4IHRvIGVuc3Vy\nZSBhIHJlbGlhYmxlIHNvbHV0aW9uCiAgICBhbmQgZXJyb3IgZXN0aW1hdGVzLiBTY2FsaW5nIGJ5\nIHBvd2VycyBvZiB0aGUgcmFkaXggZG9lcyBub3QgY2F1c2UKICAgIHJvdW5kaW5nIGVycm9ycyB1\nbmxlc3MgdGhlIHJlc3VsdCB1bmRlcmZsb3dzIG9yIG92ZXJmbG93cy4KICAgIFJvdW5kaW5nIGVy\ncm9ycyBkdXJpbmcgc2NhbGluZyBsZWFkIHRvIHJlZmluaW5nIHdpdGggYSBtYXRyaXggdGhhdAog\nICAgaXMgbm90IGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IG1hdHJpeCwgcHJvZHVjaW5nIGVycm9y\nIGVzdGltYXRlcwogICAgdGhhdCBtYXkgbm90IGJlIHJlbGlhYmxlLgpccGFyYW1baW5dIEIKICAg\nICAgICAgQiBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhTKQog\nICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAgICAg\nTERCIGlzIElOVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgQi4g\nIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIERPVUJMRSBQ\nUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICBPbiBlbnRyeSwgdGhlIHNv\nbHV0aW9uIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBieSBER0VUUlMuCiAgICBPbiBleGl0LCB0aGUg\naW1wcm92ZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBp\ncyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFgg\nPj0gbWF4KDEsTikuClxwYXJhbVtvdXRdIFJDT05ECiAgICAgICAgIFJDT05EIGlzIERPVUJMRSBQ\nUkVDSVNJT04KICAgIFJlY2lwcm9jYWwgc2NhbGVkIGNvbmRpdGlvbiBudW1iZXIuICBUaGlzIGlz\nIGFuIGVzdGltYXRlIG9mIHRoZQogICAgcmVjaXByb2NhbCBTa2VlbCBjb25kaXRpb24gbnVtYmVy\nIG9mIHRoZSBtYXRyaXggQSBhZnRlcgogICAgZXF1aWxpYnJhdGlvbiAoaWYgZG9uZSkuICBJZiB0\naGlzIGlzIGxlc3MgdGhhbiB0aGUgbWFjaGluZQogICAgcHJlY2lzaW9uIChpbiBwYXJ0aWN1bGFy\nLCBpZiBpdCBpcyB6ZXJvKSwgdGhlIG1hdHJpeCBpcyBzaW5ndWxhcgogICAgdG8gd29ya2luZyBw\ncmVjaXNpb24uICBOb3RlIHRoYXQgdGhlIGVycm9yIG1heSBzdGlsbCBiZSBzbWFsbCBldmVuCiAg\nICBpZiB0aGlzIG51bWJlciBpcyB2ZXJ5IHNtYWxsIGFuZCB0aGUgbWF0cml4IGFwcGVhcnMgaWxs\nLQogICAgY29uZGl0aW9uZWQuClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBET1VC\nTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMpCiAgICBDb21wb25lbnR3aXNlIHJl\nbGF0aXZlIGJhY2t3YXJkIGVycm9yLiAgVGhpcyBpcyB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVs\nYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBzb2x1dGlvbiB2ZWN0b3IgWChqKQogICAgKGku\nZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFuZ2UgaW4gYW55IGVsZW1lbnQgb2YgQSBvciBC\nIHRoYXQKICAgIG1ha2VzIFgoaikgYW4gZXhhY3Qgc29sdXRpb24pLgpccGFyYW1baW5dIE5fRVJS\nX0JORFMKICAgICAgICAgTl9FUlJfQk5EUyBpcyBJTlRFR0VSCiAgICBOdW1iZXIgb2YgZXJyb3Ig\nYm91bmRzIHRvIHJldHVybiBmb3IgZWFjaCByaWdodCBoYW5kIHNpZGUKICAgIGFuZCBlYWNoIHR5\ncGUgKG5vcm13aXNlIG9yIGNvbXBvbmVudHdpc2UpLiAgU2VlIEVSUl9CTkRTX05PUk0gYW5kCiAg\nICBFUlJfQk5EU19DT01QIGJlbG93LgpccGFyYW1bb3V0XSBFUlJfQk5EU19OT1JNCiAgICAgICAg\nIEVSUl9CTkRTX05PUk0gaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhT\nLCBOX0VSUl9CTkRTKQogICAgRm9yIGVhY2ggcmlnaHQtaGFuZCBzaWRlLCB0aGlzIGFycmF5IGNv\nbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0CiAgICB2YXJpb3VzIGVycm9yIGJvdW5kcyBhbmQgY29u\nZGl0aW9uIG51bWJlcnMgY29ycmVzcG9uZGluZyB0byB0aGUKICAgIG5vcm13aXNlIHJlbGF0aXZl\nIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFzIGZvbGxvd3M6CiAgICBOb3Jtd2lzZSByZWxhdGl2\nZSBlcnJvciBpbiB0aGUgaXRoIHNvbHV0aW9uIHZlY3RvcjoKICAgICAgICAgICAgbWF4X2ogKGFi\ncyhYVFJVRShqLGkpIC0gWChqLGkpKSkKICAgICAgICAgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0t\nLS0tLS0tLS0KICAgICAgICAgICAgICAgICBtYXhfaiBhYnMoWChqLGkpKQogICAgVGhlIGFycmF5\nIGlzIGluZGV4ZWQgYnkgdGhlIHR5cGUgb2YgZXJyb3IgaW5mb3JtYXRpb24gYXMgZGVzY3JpYmVk\nCiAgICBiZWxvdy4gVGhlcmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZSBwaWVjZXMgb2YgaW5m\nb3JtYXRpb24KICAgIHJldHVybmVkLgogICAgVGhlIGZpcnN0IGluZGV4IGluIEVSUl9CTkRTX05P\nUk0oaSw6KSBjb3JyZXNwb25kcyB0byB0aGUgaXRoCiAgICByaWdodC1oYW5kIHNpZGUuCiAgICBU\naGUgc2Vjb25kIGluZGV4IGluIEVSUl9CTkRTX05PUk0oOixlcnIpIGNvbnRhaW5zIHRoZSBmb2xs\nb3dpbmcKICAgIHRocmVlIGZpZWxkczoKICAgIGVyciA9IDEgIlRydXN0L2Rvbid0IHRydXN0IiBi\nb29sZWFuLiBUcnVzdCB0aGUgYW5zd2VyIGlmIHRoZQogICAgICAgICAgICAgcmVjaXByb2NhbCBj\nb25kaXRpb24gbnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBz\ncXJ0KG4pICogZGxhbWNoKCdFcHNpbG9uJykuCiAgICBlcnIgPSAyICJHdWFyYW50ZWVkIiBlcnJv\nciBib3VuZDogVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9yLAogICAgICAgICAgICAgYWxtb3N0\nIGNlcnRhaW5seSB3aXRoaW4gYSBmYWN0b3Igb2YgMTAgb2YgdGhlIHRydWUgZXJyb3IKICAgICAg\nICAgICAgIHNvIGxvbmcgYXMgdGhlIG5leHQgZW50cnkgaXMgZ3JlYXRlciB0aGFuIHRoZSB0aHJl\nc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBkbGFtY2goJ0Vwc2lsb24nKS4gVGhpcyBlcnJv\nciBib3VuZCBzaG91bGQgb25seQogICAgICAgICAgICAgYmUgdHJ1c3RlZCBpZiB0aGUgcHJldmlv\ndXMgYm9vbGVhbiBpcyB0cnVlLgogICAgZXJyID0gMyAgUmVjaXByb2NhbCBjb25kaXRpb24gbnVt\nYmVyOiBFc3RpbWF0ZWQgbm9ybXdpc2UKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9u\nIG51bWJlci4gIENvbXBhcmVkIHdpdGggdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChu\nKSAqIGRsYW1jaCgnRXBzaWxvbicpIHRvIGRldGVybWluZSBpZiB0aGUgZXJyb3IKICAgICAgICAg\nICAgIGVzdGltYXRlIGlzICJndWFyYW50ZWVkIi4gVGhlc2UgcmVjaXByb2NhbCBjb25kaXRpb24K\nICAgICAgICAgICAgIG51bWJlcnMgYXJlIDEgLyAobm9ybShaXnstMX0saW5mKSAqIG5vcm0oWixp\nbmYpKSBmb3Igc29tZQogICAgICAgICAgICAgYXBwcm9wcmlhdGVseSBzY2FsZWQgbWF0cml4IFou\nCiAgICAgICAgICAgICBMZXQgWiA9IFMqQSwgd2hlcmUgUyBzY2FsZXMgZWFjaCByb3cgYnkgYSBw\nb3dlciBvZiB0aGUKICAgICAgICAgICAgIHJhZGl4IHNvIGFsbCBhYnNvbHV0ZSByb3cgc3VtcyBv\nZiBaIGFyZSBhcHByb3hpbWF0ZWx5IDEuCiAgICBTZWUgTGFwYWNrIFdvcmtpbmcgTm90ZSAxNjUg\nZm9yIGZ1cnRoZXIgZGV0YWlscyBhbmQgZXh0cmEKICAgIGNhdXRpb25zLgpccGFyYW1bb3V0XSBF\nUlJfQk5EU19DT01QCiAgICAgICAgIEVSUl9CTkRTX0NPTVAgaXMgRE9VQkxFIFBSRUNJU0lPTiBh\ncnJheSwgZGltZW5zaW9uIChOUkhTLCBOX0VSUl9CTkRTKQogICAgRm9yIGVhY2ggcmlnaHQtaGFu\nZCBzaWRlLCB0aGlzIGFycmF5IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0CiAgICB2YXJpb3Vz\nIGVycm9yIGJvdW5kcyBhbmQgY29uZGl0aW9uIG51bWJlcnMgY29ycmVzcG9uZGluZyB0byB0aGUK\nICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJyb3IsIHdoaWNoIGlzIGRlZmluZWQgYXMgZm9s\nbG93czoKICAgIENvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJyb3IgaW4gdGhlIGl0aCBzb2x1dGlv\nbiB2ZWN0b3I6CiAgICAgICAgICAgICAgICAgICBhYnMoWFRSVUUoaixpKSAtIFgoaixpKSkKICAg\nICAgICAgICAgbWF4X2ogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICAgICAgICAgICAgICAgICAg\nICAgICBhYnMoWChqLGkpKQogICAgVGhlIGFycmF5IGlzIGluZGV4ZWQgYnkgdGhlIHJpZ2h0LWhh\nbmQgc2lkZSBpIChvbiB3aGljaCB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJyb3Ig\nZGVwZW5kcyksIGFuZCB0aGUgdHlwZSBvZiBlcnJvcgogICAgaW5mb3JtYXRpb24gYXMgZGVzY3Jp\nYmVkIGJlbG93LiBUaGVyZSBjdXJyZW50bHkgYXJlIHVwIHRvIHRocmVlCiAgICBwaWVjZXMgb2Yg\naW5mb3JtYXRpb24gcmV0dXJuZWQgZm9yIGVhY2ggcmlnaHQtaGFuZCBzaWRlLiBJZgogICAgY29t\ncG9uZW50d2lzZSBhY2N1cmFjeSBpcyBub3QgcmVxdWVzdGVkIChQQVJBTVMoMykgPSAwLjApLCB0\naGVuCiAgICBFUlJfQk5EU19DT01QIGlzIG5vdCBhY2Nlc3NlZC4gIElmIE5fRVJSX0JORFMgLkxU\nLiAzLCB0aGVuIGF0IG1vc3QKICAgIHRoZSBmaXJzdCAoOixOX0VSUl9CTkRTKSBlbnRyaWVzIGFy\nZSByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJfQk5EU19DT01QKGksOikgY29y\ncmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQtaGFuZCBzaWRlLgogICAgVGhlIHNlY29uZCBp\nbmRleCBpbiBFUlJfQk5EU19DT01QKDosZXJyKSBjb250YWlucyB0aGUgZm9sbG93aW5nCiAgICB0\naHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVzdC9kb24ndCB0cnVzdCIgYm9vbGVhbi4gVHJ1\nc3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51\nbWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRs\nYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAiR3VhcmFudGVlZCIgZXJyb3IgYm91bmQ6IFRo\nZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAgICAgICAgICAgIGFsbW9zdCBjZXJ0YWlubHkg\nd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9yCiAgICAgICAgICAgICBzbyBs\nb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkCiAgICAg\nICAgICAgICBzcXJ0KG4pICogZGxhbWNoKCdFcHNpbG9uJykuIFRoaXMgZXJyb3IgYm91bmQgc2hv\ndWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0ZWQgaWYgdGhlIHByZXZpb3VzIGJvb2xlYW4g\naXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlcjogRXN0aW1h\ndGVkIGNvbXBvbmVudHdpc2UKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJl\nci4gIENvbXBhcmVkIHdpdGggdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAqIGRs\nYW1jaCgnRXBzaWxvbicpIHRvIGRldGVybWluZSBpZiB0aGUgZXJyb3IKICAgICAgICAgICAgIGVz\ndGltYXRlIGlzICJndWFyYW50ZWVkIi4gVGhlc2UgcmVjaXByb2NhbCBjb25kaXRpb24KICAgICAg\nICAgICAgIG51bWJlcnMgYXJlIDEgLyAobm9ybShaXnstMX0saW5mKSAqIG5vcm0oWixpbmYpKSBm\nb3Igc29tZQogICAgICAgICAgICAgYXBwcm9wcmlhdGVseSBzY2FsZWQgbWF0cml4IFouCiAgICAg\nICAgICAgICBMZXQgWiA9IFMqKEEqZGlhZyh4KSksIHdoZXJlIHggaXMgdGhlIHNvbHV0aW9uIGZv\nciB0aGUKICAgICAgICAgICAgIGN1cnJlbnQgcmlnaHQtaGFuZCBzaWRlIGFuZCBTIHNjYWxlcyBl\nYWNoIHJvdyBvZgogICAgICAgICAgICAgQSpkaWFnKHgpIGJ5IGEgcG93ZXIgb2YgdGhlIHJhZGl4\nIHNvIGFsbCBhYnNvbHV0ZSByb3cKICAgICAgICAgICAgIHN1bXMgb2YgWiBhcmUgYXBwcm94aW1h\ndGVseSAxLgogICAgU2VlIExhcGFjayBXb3JraW5nIE5vdGUgMTY1IGZvciBmdXJ0aGVyIGRldGFp\nbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4KXHBhcmFtW2luXSBOUEFSQU1TCiAgICAgICAgIE5Q\nQVJBTVMgaXMgSU5URUdFUgogICAgU3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVycyBz\nZXQgaW4gUEFSQU1TLiAgSWYgLkxFLiAwLCB0aGUKICAgIFBBUkFNUyBhcnJheSBpcyBuZXZlciBy\nZWZlcmVuY2VkIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgdXNlZC4KXHBhcmFtW2luLG91dF0gUEFS\nQU1TCiAgICAgICAgIFBBUkFNUyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24g\nKE5QQVJBTVMpCiAgICBTcGVjaWZpZXMgYWxnb3JpdGhtIHBhcmFtZXRlcnMuICBJZiBhbiBlbnRy\neSBpcyAuTFQuIDAuMCwgdGhlbgogICAgdGhhdCBlbnRyeSB3aWxsIGJlIGZpbGxlZCB3aXRoIGRl\nZmF1bHQgdmFsdWUgdXNlZCBmb3IgdGhhdAogICAgcGFyYW1ldGVyLiAgT25seSBwb3NpdGlvbnMg\ndXAgdG8gTlBBUkFNUyBhcmUgYWNjZXNzZWQ7IGRlZmF1bHRzCiAgICBhcmUgdXNlZCBmb3IgaGln\naGVyLW51bWJlcmVkIHBhcmFtZXRlcnMuCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9JVFJFRl9JID0g\nMSkgOiBXaGV0aGVyIHRvIHBlcmZvcm0gaXRlcmF0aXZlCiAgICAgICAgICAgcmVmaW5lbWVudCBv\nciBub3QuCiAgICAgICAgRGVmYXVsdDogMS4wRCswCiAgICAgICAgICAgPSAwLjAgOiBObyByZWZp\nbmVtZW50IGlzIHBlcmZvcm1lZCwgYW5kIG5vIGVycm9yIGJvdW5kcyBhcmUKICAgICAgICAgICAg\nICAgICAgIGNvbXB1dGVkLgogICAgICAgICAgID0gMS4wIDogVXNlIHRoZSBkb3VibGUtcHJlY2lz\naW9uIHJlZmluZW1lbnQgYWxnb3JpdGhtLAogICAgICAgICAgICAgICAgICAgcG9zc2libHkgd2l0\naCBkb3VibGVkLXNpbmdsZSBjb21wdXRhdGlvbnMgaWYgdGhlCiAgICAgICAgICAgICAgICAgICBj\nb21waWxhdGlvbiBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IERPVUJMRQogICAgICAgICAg\nICAgICAgICAgUFJFQ0lTSU9OLgogICAgICAgICAgICAgKG90aGVyIHZhbHVlcyBhcmUgcmVzZXJ2\nZWQgZm9yIGZ1dHVyZSB1c2UpCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9JVEhSRVNIX0kgPSAyKSA6\nIE1heGltdW0gbnVtYmVyIG9mIHJlc2lkdWFsCiAgICAgICAgICAgY29tcHV0YXRpb25zIGFsbG93\nZWQgZm9yIHJlZmluZW1lbnQuCiAgICAgICAgRGVmYXVsdDogMTAKICAgICAgICBBZ2dyZXNzaXZl\nOiBTZXQgdG8gMTAwIHRvIHBlcm1pdCBjb252ZXJnZW5jZSB1c2luZyBhcHByb3hpbWF0ZQogICAg\nICAgICAgICAgICAgICAgIGZhY3Rvcml6YXRpb25zIG9yIGZhY3Rvcml6YXRpb25zIG90aGVyIHRo\nYW4gTFUuIElmCiAgICAgICAgICAgICAgICAgICAgdGhlIGZhY3Rvcml6YXRpb24gdXNlcyBhIHRl\nY2huaXF1ZSBvdGhlciB0aGFuCiAgICAgICAgICAgICAgICAgICAgR2F1c3NpYW4gZWxpbWluYXRp\nb24sIHRoZSBndWFyYW50ZWVzIGluCiAgICAgICAgICAgICAgICAgICAgZXJyX2JuZHNfbm9ybSBh\nbmQgZXJyX2JuZHNfY29tcCBtYXkgbm8gbG9uZ2VyIGJlCiAgICAgICAgICAgICAgICAgICAgdHJ1\nc3R3b3J0aHkuCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9DV0lTRV9JID0gMykgOiBGbGFnIGRldGVy\nbWluaW5nIGlmIHRoZSBjb2RlCiAgICAgICAgICAgd2lsbCBhdHRlbXB0IHRvIGZpbmQgYSBzb2x1\ndGlvbiB3aXRoIHNtYWxsIGNvbXBvbmVudHdpc2UKICAgICAgICAgICByZWxhdGl2ZSBlcnJvciBp\nbiB0aGUgZG91YmxlLXByZWNpc2lvbiBhbGdvcml0aG0uICBQb3NpdGl2ZQogICAgICAgICAgIGlz\nIHRydWUsIDAuMCBpcyBmYWxzZS4KICAgICAgICBEZWZhdWx0OiAxLjAgKGF0dGVtcHQgY29tcG9u\nZW50d2lzZSBjb252ZXJnZW5jZSkKXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIERP\nVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoNCpOKQpccGFyYW1bb3V0XSBJV09SSwog\nICAgICAgICBJV09SSyBpcyBJTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pClxwYXJhbVtvdXRd\nIElORk8KICAgICAgICAgSU5GTyBpcyBJTlRFR0VSCiAgICAgID0gMDogIFN1Y2Nlc3NmdWwgZXhp\ndC4gVGhlIHNvbHV0aW9uIHRvIGV2ZXJ5IHJpZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIGd1YXJh\nbnRlZWQuCiAgICAgIDwgMDogIElmIElORk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFu\nIGlsbGVnYWwgdmFsdWUKICAgICAgPiAwIGFuZCA8PSBOOiAgVShJTkZPLElORk8pIGlzIGV4YWN0\nbHkgemVyby4gIFRoZSBmYWN0b3JpemF0aW9uCiAgICAgICAgaGFzIGJlZW4gY29tcGxldGVkLCBi\ndXQgdGhlIGZhY3RvciBVIGlzIGV4YWN0bHkgc2luZ3VsYXIsIHNvCiAgICAgICAgdGhlIHNvbHV0\naW9uIGFuZCBlcnJvciBib3VuZHMgY291bGQgbm90IGJlIGNvbXB1dGVkLiBSQ09ORCA9IDAKICAg\nICAgICBpcyByZXR1cm5lZC4KICAgICAgPSBOK0o6IFRoZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5n\nIHRvIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzCiAgICAgICAgbm90IGd1YXJhbnRlZWQuIFRo\nZSBzb2x1dGlvbnMgY29ycmVzcG9uZGluZyB0byBvdGhlciByaWdodC0KICAgICAgICBoYW5kIHNp\nZGVzIEsgd2l0aCBLID4gSiBtYXkgbm90IGJlIGd1YXJhbnRlZWQgYXMgd2VsbCwgYnV0CiAgICAg\nICAgb25seSB0aGUgZmlyc3Qgc3VjaCByaWdodC1oYW5kIHNpZGUgaXMgcmVwb3J0ZWQuIElmIGEg\nc21hbGwKICAgICAgICBjb21wb25lbnR3aXNlIGVycm9yIGlzIG5vdCByZXF1ZXN0ZWQgKFBBUkFN\nUygzKSA9IDAuMCkgdGhlbgogICAgICAgIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzIHRoZSBm\naXJzdCB3aXRoIGEgbm9ybXdpc2UgZXJyb3IKICAgICAgICBib3VuZCB0aGF0IGlzIG5vdCBndWFy\nYW50ZWVkICh0aGUgc21hbGxlc3QgSiBzdWNoCiAgICAgICAgdGhhdCBFUlJfQk5EU19OT1JNKEos\nMSkgPSAwLjApLiBCeSBkZWZhdWx0IChQQVJBTVMoMykgPSAxLjApCiAgICAgICAgdGhlIEp0aCBy\naWdodC1oYW5kIHNpZGUgaXMgdGhlIGZpcnN0IHdpdGggZWl0aGVyIGEgbm9ybXdpc2Ugb3IKICAg\nICAgICBjb21wb25lbnR3aXNlIGVycm9yIGJvdW5kIHRoYXQgaXMgbm90IGd1YXJhbnRlZWQgKHRo\nZSBzbWFsbGVzdAogICAgICAgIEogc3VjaCB0aGF0IGVpdGhlciBFUlJfQk5EU19OT1JNKEosMSkg\nPSAwLjAgb3IKICAgICAgICBFUlJfQk5EU19DT01QKEosMSkgPSAwLjApLiBTZWUgdGhlIGRlZmlu\naXRpb24gb2YKICAgICAgICBFUlJfQk5EU19OT1JNKDosMSkgYW5kIEVSUl9CTkRTX0NPTVAoOiwx\nKS4gVG8gZ2V0IGluZm9ybWF0aW9uCiAgICAgICAgYWJvdXQgYWxsIG9mIHRoZSByaWdodC1oYW5k\nIHNpZGVzIGNoZWNrIEVSUl9CTkRTX05PUk0gb3IKICAgICAgICBFUlJfQk5EU19DT01QLgpBdXRo\nb3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRlbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9y\nbmlhIEJlcmtlbGV5IApcYXV0aG9yIFVuaXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBO\nQUcgTHRkLiAKXGRhdGUgQXByaWwgMjAxMgpcaW5ncm91cCBkb3VibGVTWWNvbXB1dGF0aW9uYWwK\naB1oHimBcjcCAAB9cjgCAAAoaCGJaCJoI3ViaC2KAqgBaC5YDwAAAGRzeXJmc3hfNDI0LnR4dHVi\naC+KAqgBaDBYBgAAAHN5cmZzeGgtigFCdWJoFWgWXWgXh1JyOQIAAH1yOgIAAChoGlgJAAAAc3lt\nbWV0cmljaBtYBAAAAGZ1bGxoHFhGAAAAZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBl\nc3RpbWF0ZXM7IGl0ZXJhdGl2ZSByZWZpbmVtZW50OyBFUVVFRGgdaB4pgXI7AgAAfXI8AgAAKGgh\niWgiaCN1YmgkWCEAAABEb3h5Z2VuL2RvY3MvaHRtbC9jc3lyZnN4XzhmLmh0bWxoJVgBAAAAY2gm\naBVoJ11oF4dScj0CAAB9cj4CAAAoaCpYrTEAACAgIENTWVJGU1ggaW1wcm92ZXMgdGhlIGNvbXB1\ndGVkIHNvbHV0aW9uIHRvIGEgc3lzdGVtIG9mIGxpbmVhcgogICBlcXVhdGlvbnMgd2hlbiB0aGUg\nY29lZmZpY2llbnQgbWF0cml4IGlzIHN5bW1ldHJpYyBpbmRlZmluaXRlLCBhbmQKICAgcHJvdmlk\nZXMgZXJyb3IgYm91bmRzIGFuZCBiYWNrd2FyZCBlcnJvciBlc3RpbWF0ZXMgZm9yIHRoZQogICBz\nb2x1dGlvbi4gIEluIGFkZGl0aW9uIHRvIG5vcm13aXNlIGVycm9yIGJvdW5kLCB0aGUgY29kZSBw\ncm92aWRlcwogICBtYXhpbXVtIGNvbXBvbmVudHdpc2UgZXJyb3IgYm91bmQgaWYgcG9zc2libGUu\nICBTZWUgY29tbWVudHMgZm9yCiAgIEVSUl9CTkRTX05PUk0gYW5kIEVSUl9CTkRTX0NPTVAgZm9y\nIGRldGFpbHMgb2YgdGhlIGVycm9yIGJvdW5kcy4KICAgVGhlIG9yaWdpbmFsIHN5c3RlbSBvZiBs\naW5lYXIgZXF1YXRpb25zIG1heSBoYXZlIGJlZW4gZXF1aWxpYnJhdGVkCiAgIGJlZm9yZSBjYWxs\naW5nIHRoaXMgcm91dGluZSwgYXMgZGVzY3JpYmVkIGJ5IGFyZ3VtZW50cyBFUVVFRCBhbmQgUwog\nICBiZWxvdy4gSW4gdGhpcyBjYXNlLCB0aGUgc29sdXRpb24gYW5kIGVycm9yIGJvdW5kcyByZXR1\ncm5lZCBhcmUKICAgZm9yIHRoZSBvcmlnaW5hbCB1bmVxdWlsaWJyYXRlZCBzeXN0ZW0uCkFyZ3Vt\nZW50czoKICAgIFNvbWUgb3B0aW9uYWwgcGFyYW1ldGVycyBhcmUgYnVuZGxlZCBpbiB0aGUgUEFS\nQU1TIGFycmF5LiAgVGhlc2UKICAgIHNldHRpbmdzIGRldGVybWluZSBob3cgcmVmaW5lbWVudCBp\ncyBwZXJmb3JtZWQsIGJ1dCBvZnRlbiB0aGUKICAgIGRlZmF1bHRzIGFyZSBhY2NlcHRhYmxlLiAg\nSWYgdGhlIGRlZmF1bHRzIGFyZSBhY2NlcHRhYmxlLCB1c2VycwogICAgY2FuIHBhc3MgTlBBUkFN\nUyA9IDAgd2hpY2ggcHJldmVudHMgdGhlIHNvdXJjZSBjb2RlIGZyb20gYWNjZXNzaW5nCiAgICB0\naGUgUEFSQU1TIGFyZ3VtZW50LgpccGFyYW1baW5dIFVQTE8KICAgICAgICAgVVBMTyBpcyBDSEFS\nQUNURVIqMQogICAgICA9ICdVJzogIFVwcGVyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkOwogICAg\nICA9ICdMJzogIExvd2VyIHRyaWFuZ2xlIG9mIEEgaXMgc3RvcmVkLgpccGFyYW1baW5dIEVRVUVE\nCiAgICAgICAgIEVRVUVEIGlzIENIQVJBQ1RFUioxCiAgICBTcGVjaWZpZXMgdGhlIGZvcm0gb2Yg\nZXF1aWxpYnJhdGlvbiB0aGF0IHdhcyBkb25lIHRvIEEKICAgIGJlZm9yZSBjYWxsaW5nIHRoaXMg\ncm91dGluZS4gVGhpcyBpcyBuZWVkZWQgdG8gY29tcHV0ZQogICAgdGhlIHNvbHV0aW9uIGFuZCBl\ncnJvciBib3VuZHMgY29ycmVjdGx5LgogICAgICA9ICdOJzogIE5vIGVxdWlsaWJyYXRpb24KICAg\nICAgPSAnWSc6ICBCb3RoIHJvdyBhbmQgY29sdW1uIGVxdWlsaWJyYXRpb24sIGkuZS4sIEEgaGFz\nIGJlZW4KICAgICAgICAgICAgICByZXBsYWNlZCBieSBkaWFnKFMpICogQSAqIGRpYWcoUykuCiAg\nICAgICAgICAgICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBCIGhhcyBiZWVuIGNoYW5nZWQgYWNjb3Jk\naW5nbHkuClxwYXJhbVtpbl0gTgogICAgICAgICBOIGlzIElOVEVHRVIKICAgIFRoZSBvcmRlciBv\nZiB0aGUgbWF0cml4IEEuICBOID49IDAuClxwYXJhbVtpbl0gTlJIUwogICAgICAgICBOUkhTIGlz\nIElOVEVHRVIKICAgIFRoZSBudW1iZXIgb2YgcmlnaHQgaGFuZCBzaWRlcywgaS5lLiwgdGhlIG51\nbWJlciBvZiBjb2x1bW5zCiAgICBvZiB0aGUgbWF0cmljZXMgQiBhbmQgWC4gIE5SSFMgPj0gMC4K\nXHBhcmFtW2luXSBBCiAgICAgICAgIEEgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREEs\nTikKICAgIFRoZSBzeW1tZXRyaWMgbWF0cml4IEEuICBJZiBVUExPID0gJ1UnLCB0aGUgbGVhZGlu\nZyBOLWJ5LU4KICAgIHVwcGVyIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGNvbnRhaW5zIHRoZSB1cHBl\nciB0cmlhbmd1bGFyCiAgICBwYXJ0IG9mIHRoZSBtYXRyaXggQSwgYW5kIHRoZSBzdHJpY3RseSBs\nb3dlciB0cmlhbmd1bGFyCiAgICBwYXJ0IG9mIEEgaXMgbm90IHJlZmVyZW5jZWQuICBJZiBVUExP\nID0gJ0wnLCB0aGUgbGVhZGluZwogICAgTi1ieS1OIGxvd2VyIHRyaWFuZ3VsYXIgcGFydCBvZiBB\nIGNvbnRhaW5zIHRoZSBsb3dlcgogICAgdHJpYW5ndWxhciBwYXJ0IG9mIHRoZSBtYXRyaXggQSwg\nYW5kIHRoZSBzdHJpY3RseSB1cHBlcgogICAgdHJpYW5ndWxhciBwYXJ0IG9mIEEgaXMgbm90IHJl\nZmVyZW5jZWQuClxwYXJhbVtpbl0gTERBCiAgICAgICAgIExEQSBpcyBJTlRFR0VSCiAgICBUaGUg\nbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEEuICBMREEgPj0gbWF4KDEsTikuClxwYXJh\nbVtpbl0gQUYKICAgICAgICAgQUYgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREFGLE4p\nCiAgICBUaGUgZmFjdG9yZWQgZm9ybSBvZiB0aGUgbWF0cml4IEEuICBBRiBjb250YWlucyB0aGUg\nYmxvY2sKICAgIGRpYWdvbmFsIG1hdHJpeCBEIGFuZCB0aGUgbXVsdGlwbGllcnMgdXNlZCB0byBv\nYnRhaW4gdGhlCiAgICBmYWN0b3IgVSBvciBMIGZyb20gdGhlIGZhY3Rvcml6YXRpb24gQSA9IFUq\nRCpVKipUIG9yIEEgPQogICAgTCpEKkwqKlQgYXMgY29tcHV0ZWQgYnkgU1NZVFJGLgpccGFyYW1b\naW5dIExEQUYKICAgICAgICAgTERBRiBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNp\nb24gb2YgdGhlIGFycmF5IEFGLiAgTERBRiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBJUElWCiAg\nICAgICAgIElQSVYgaXMgSU5URUdFUiBhcnJheSwgZGltZW5zaW9uIChOKQogICAgRGV0YWlscyBv\nZiB0aGUgaW50ZXJjaGFuZ2VzIGFuZCB0aGUgYmxvY2sgc3RydWN0dXJlIG9mIEQKICAgIGFzIGRl\ndGVybWluZWQgYnkgU1NZVFJGLgpccGFyYW1baW4sb3V0XSBTCiAgICAgICAgIFMgaXMgUkVBTCBh\ncnJheSwgZGltZW5zaW9uIChOKQogICAgVGhlIHNjYWxlIGZhY3RvcnMgZm9yIEEuICBJZiBFUVVF\nRCA9ICdZJywgQSBpcyBtdWx0aXBsaWVkIG9uCiAgICB0aGUgbGVmdCBhbmQgcmlnaHQgYnkgZGlh\nZyhTKS4gIFMgaXMgYW4gaW5wdXQgYXJndW1lbnQgaWYgRkFDVCA9CiAgICAnRic7IG90aGVyd2lz\nZSwgUyBpcyBhbiBvdXRwdXQgYXJndW1lbnQuICBJZiBGQUNUID0gJ0YnIGFuZCBFUVVFRAogICAg\nPSAnWScsIGVhY2ggZWxlbWVudCBvZiBTIG11c3QgYmUgcG9zaXRpdmUuICBJZiBTIGlzIG91dHB1\ndCwgZWFjaAogICAgZWxlbWVudCBvZiBTIGlzIGEgcG93ZXIgb2YgdGhlIHJhZGl4LiBJZiBTIGlz\nIGlucHV0LCBlYWNoIGVsZW1lbnQKICAgIG9mIFMgc2hvdWxkIGJlIGEgcG93ZXIgb2YgdGhlIHJh\nZGl4IHRvIGVuc3VyZSBhIHJlbGlhYmxlIHNvbHV0aW9uCiAgICBhbmQgZXJyb3IgZXN0aW1hdGVz\nLiBTY2FsaW5nIGJ5IHBvd2VycyBvZiB0aGUgcmFkaXggZG9lcyBub3QgY2F1c2UKICAgIHJvdW5k\naW5nIGVycm9ycyB1bmxlc3MgdGhlIHJlc3VsdCB1bmRlcmZsb3dzIG9yIG92ZXJmbG93cy4KICAg\nIFJvdW5kaW5nIGVycm9ycyBkdXJpbmcgc2NhbGluZyBsZWFkIHRvIHJlZmluaW5nIHdpdGggYSBt\nYXRyaXggdGhhdAogICAgaXMgbm90IGVxdWl2YWxlbnQgdG8gdGhlIGlucHV0IG1hdHJpeCwgcHJv\nZHVjaW5nIGVycm9yIGVzdGltYXRlcwogICAgdGhhdCBtYXkgbm90IGJlIHJlbGlhYmxlLgpccGFy\nYW1baW5dIEIKICAgICAgICAgQiBpcyBDT01QTEVYIGFycmF5LCBkaW1lbnNpb24gKExEQixOUkhT\nKQogICAgVGhlIHJpZ2h0IGhhbmQgc2lkZSBtYXRyaXggQi4KXHBhcmFtW2luXSBMREIKICAgICAg\nICAgTERCIGlzIElOVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkg\nQi4gIExEQiA+PSBtYXgoMSxOKS4KXHBhcmFtW2luLG91dF0gWAogICAgICAgICBYIGlzIENPTVBM\nRVggYXJyYXksIGRpbWVuc2lvbiAoTERYLE5SSFMpCiAgICBPbiBlbnRyeSwgdGhlIHNvbHV0aW9u\nIG1hdHJpeCBYLCBhcyBjb21wdXRlZCBieSBTR0VUUlMuCiAgICBPbiBleGl0LCB0aGUgaW1wcm92\nZWQgc29sdXRpb24gbWF0cml4IFguClxwYXJhbVtpbl0gTERYCiAgICAgICAgIExEWCBpcyBJTlRF\nR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IFguICBMRFggPj0gbWF4\nKDEsTikuClxwYXJhbVtvdXRdIFJDT05ECiAgICAgICAgIFJDT05EIGlzIFJFQUwKICAgIFJlY2lw\ncm9jYWwgc2NhbGVkIGNvbmRpdGlvbiBudW1iZXIuICBUaGlzIGlzIGFuIGVzdGltYXRlIG9mIHRo\nZQogICAgcmVjaXByb2NhbCBTa2VlbCBjb25kaXRpb24gbnVtYmVyIG9mIHRoZSBtYXRyaXggQSBh\nZnRlcgogICAgZXF1aWxpYnJhdGlvbiAoaWYgZG9uZSkuICBJZiB0aGlzIGlzIGxlc3MgdGhhbiB0\naGUgbWFjaGluZQogICAgcHJlY2lzaW9uIChpbiBwYXJ0aWN1bGFyLCBpZiBpdCBpcyB6ZXJvKSwg\ndGhlIG1hdHJpeCBpcyBzaW5ndWxhcgogICAgdG8gd29ya2luZyBwcmVjaXNpb24uICBOb3RlIHRo\nYXQgdGhlIGVycm9yIG1heSBzdGlsbCBiZSBzbWFsbCBldmVuCiAgICBpZiB0aGlzIG51bWJlciBp\ncyB2ZXJ5IHNtYWxsIGFuZCB0aGUgbWF0cml4IGFwcGVhcnMgaWxsLQogICAgY29uZGl0aW9uZWQu\nClxwYXJhbVtvdXRdIEJFUlIKICAgICAgICAgQkVSUiBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24g\nKE5SSFMpCiAgICBDb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yLiAgVGhpcyBp\ncyB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgYmFja3dhcmQgZXJyb3Igb2YgZWFjaCBz\nb2x1dGlvbiB2ZWN0b3IgWChqKQogICAgKGkuZS4sIHRoZSBzbWFsbGVzdCByZWxhdGl2ZSBjaGFu\nZ2UgaW4gYW55IGVsZW1lbnQgb2YgQSBvciBCIHRoYXQKICAgIG1ha2VzIFgoaikgYW4gZXhhY3Qg\nc29sdXRpb24pLgpccGFyYW1baW5dIE5fRVJSX0JORFMKICAgICAgICAgTl9FUlJfQk5EUyBpcyBJ\nTlRFR0VSCiAgICBOdW1iZXIgb2YgZXJyb3IgYm91bmRzIHRvIHJldHVybiBmb3IgZWFjaCByaWdo\ndCBoYW5kIHNpZGUKICAgIGFuZCBlYWNoIHR5cGUgKG5vcm13aXNlIG9yIGNvbXBvbmVudHdpc2Up\nLiAgU2VlIEVSUl9CTkRTX05PUk0gYW5kCiAgICBFUlJfQk5EU19DT01QIGJlbG93LgpccGFyYW1b\nb3V0XSBFUlJfQk5EU19OT1JNCiAgICAgICAgIEVSUl9CTkRTX05PUk0gaXMgUkVBTCBhcnJheSwg\nZGltZW5zaW9uIChOUkhTLCBOX0VSUl9CTkRTKQogICAgRm9yIGVhY2ggcmlnaHQtaGFuZCBzaWRl\nLCB0aGlzIGFycmF5IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0CiAgICB2YXJpb3VzIGVycm9y\nIGJvdW5kcyBhbmQgY29uZGl0aW9uIG51bWJlcnMgY29ycmVzcG9uZGluZyB0byB0aGUKICAgIG5v\ncm13aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFzIGZvbGxvd3M6CiAgICBO\nb3Jtd2lzZSByZWxhdGl2ZSBlcnJvciBpbiB0aGUgaXRoIHNvbHV0aW9uIHZlY3RvcjoKICAgICAg\nICAgICAgbWF4X2ogKGFicyhYVFJVRShqLGkpIC0gWChqLGkpKSkKICAgICAgICAgICAtLS0tLS0t\nLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAgICBtYXhfaiBhYnMoWChqLGkp\nKQogICAgVGhlIGFycmF5IGlzIGluZGV4ZWQgYnkgdGhlIHR5cGUgb2YgZXJyb3IgaW5mb3JtYXRp\nb24gYXMgZGVzY3JpYmVkCiAgICBiZWxvdy4gVGhlcmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJl\nZSBwaWVjZXMgb2YgaW5mb3JtYXRpb24KICAgIHJldHVybmVkLgogICAgVGhlIGZpcnN0IGluZGV4\nIGluIEVSUl9CTkRTX05PUk0oaSw6KSBjb3JyZXNwb25kcyB0byB0aGUgaXRoCiAgICByaWdodC1o\nYW5kIHNpZGUuCiAgICBUaGUgc2Vjb25kIGluZGV4IGluIEVSUl9CTkRTX05PUk0oOixlcnIpIGNv\nbnRhaW5zIHRoZSBmb2xsb3dpbmcKICAgIHRocmVlIGZpZWxkczoKICAgIGVyciA9IDEgIlRydXN0\nL2Rvbid0IHRydXN0IiBib29sZWFuLiBUcnVzdCB0aGUgYW5zd2VyIGlmIHRoZQogICAgICAgICAg\nICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyIGlzIGxlc3MgdGhhbiB0aGUgdGhyZXNob2xk\nCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykuCiAgICBlcnIgPSAyICJH\ndWFyYW50ZWVkIiBlcnJvciBib3VuZDogVGhlIGVzdGltYXRlZCBmb3J3YXJkIGVycm9yLAogICAg\nICAgICAgICAgYWxtb3N0IGNlcnRhaW5seSB3aXRoaW4gYSBmYWN0b3Igb2YgMTAgb2YgdGhlIHRy\ndWUgZXJyb3IKICAgICAgICAgICAgIHNvIGxvbmcgYXMgdGhlIG5leHQgZW50cnkgaXMgZ3JlYXRl\nciB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2ls\nb24nKS4gVGhpcyBlcnJvciBib3VuZCBzaG91bGQgb25seQogICAgICAgICAgICAgYmUgdHJ1c3Rl\nZCBpZiB0aGUgcHJldmlvdXMgYm9vbGVhbiBpcyB0cnVlLgogICAgZXJyID0gMyAgUmVjaXByb2Nh\nbCBjb25kaXRpb24gbnVtYmVyOiBFc3RpbWF0ZWQgbm9ybXdpc2UKICAgICAgICAgICAgIHJlY2lw\ncm9jYWwgY29uZGl0aW9uIG51bWJlci4gIENvbXBhcmVkIHdpdGggdGhlIHRocmVzaG9sZAogICAg\nICAgICAgICAgc3FydChuKSAqIHNsYW1jaCgnRXBzaWxvbicpIHRvIGRldGVybWluZSBpZiB0aGUg\nZXJyb3IKICAgICAgICAgICAgIGVzdGltYXRlIGlzICJndWFyYW50ZWVkIi4gVGhlc2UgcmVjaXBy\nb2NhbCBjb25kaXRpb24KICAgICAgICAgICAgIG51bWJlcnMgYXJlIDEgLyAobm9ybShaXnstMX0s\naW5mKSAqIG5vcm0oWixpbmYpKSBmb3Igc29tZQogICAgICAgICAgICAgYXBwcm9wcmlhdGVseSBz\nY2FsZWQgbWF0cml4IFouCiAgICAgICAgICAgICBMZXQgWiA9IFMqQSwgd2hlcmUgUyBzY2FsZXMg\nZWFjaCByb3cgYnkgYSBwb3dlciBvZiB0aGUKICAgICAgICAgICAgIHJhZGl4IHNvIGFsbCBhYnNv\nbHV0ZSByb3cgc3VtcyBvZiBaIGFyZSBhcHByb3hpbWF0ZWx5IDEuCiAgICBTZWUgTGFwYWNrIFdv\ncmtpbmcgTm90ZSAxNjUgZm9yIGZ1cnRoZXIgZGV0YWlscyBhbmQgZXh0cmEKICAgIGNhdXRpb25z\nLgpccGFyYW1bb3V0XSBFUlJfQk5EU19DT01QCiAgICAgICAgIEVSUl9CTkRTX0NPTVAgaXMgUkVB\nTCBhcnJheSwgZGltZW5zaW9uIChOUkhTLCBOX0VSUl9CTkRTKQogICAgRm9yIGVhY2ggcmlnaHQt\naGFuZCBzaWRlLCB0aGlzIGFycmF5IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0CiAgICB2YXJp\nb3VzIGVycm9yIGJvdW5kcyBhbmQgY29uZGl0aW9uIG51bWJlcnMgY29ycmVzcG9uZGluZyB0byB0\naGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJyb3IsIHdoaWNoIGlzIGRlZmluZWQgYXMg\nZm9sbG93czoKICAgIENvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJyb3IgaW4gdGhlIGl0aCBzb2x1\ndGlvbiB2ZWN0b3I6CiAgICAgICAgICAgICAgICAgICBhYnMoWFRSVUUoaixpKSAtIFgoaixpKSkK\nICAgICAgICAgICAgbWF4X2ogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLQogICAgICAgICAgICAgICAg\nICAgICAgICBhYnMoWChqLGkpKQogICAgVGhlIGFycmF5IGlzIGluZGV4ZWQgYnkgdGhlIHJpZ2h0\nLWhhbmQgc2lkZSBpIChvbiB3aGljaCB0aGUKICAgIGNvbXBvbmVudHdpc2UgcmVsYXRpdmUgZXJy\nb3IgZGVwZW5kcyksIGFuZCB0aGUgdHlwZSBvZiBlcnJvcgogICAgaW5mb3JtYXRpb24gYXMgZGVz\nY3JpYmVkIGJlbG93LiBUaGVyZSBjdXJyZW50bHkgYXJlIHVwIHRvIHRocmVlCiAgICBwaWVjZXMg\nb2YgaW5mb3JtYXRpb24gcmV0dXJuZWQgZm9yIGVhY2ggcmlnaHQtaGFuZCBzaWRlLiBJZgogICAg\nY29tcG9uZW50d2lzZSBhY2N1cmFjeSBpcyBub3QgcmVxdWVzdGVkIChQQVJBTVMoMykgPSAwLjAp\nLCB0aGVuCiAgICBFUlJfQk5EU19DT01QIGlzIG5vdCBhY2Nlc3NlZC4gIElmIE5fRVJSX0JORFMg\nLkxULiAzLCB0aGVuIGF0IG1vc3QKICAgIHRoZSBmaXJzdCAoOixOX0VSUl9CTkRTKSBlbnRyaWVz\nIGFyZSByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJfQk5EU19DT01QKGksOikg\nY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQtaGFuZCBzaWRlLgogICAgVGhlIHNlY29u\nZCBpbmRleCBpbiBFUlJfQk5EU19DT01QKDosZXJyKSBjb250YWlucyB0aGUgZm9sbG93aW5nCiAg\nICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVzdC9kb24ndCB0cnVzdCIgYm9vbGVhbi4g\nVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9u\nIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAq\nIHNsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAiR3VhcmFudGVlZCIgZXJyb3IgYm91bmQ6\nIFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAgICAgICAgICAgIGFsbW9zdCBjZXJ0YWlu\nbHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9yCiAgICAgICAgICAgICBz\nbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xkCiAg\nICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNpbG9uJykuIFRoaXMgZXJyb3IgYm91bmQg\nc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0ZWQgaWYgdGhlIHByZXZpb3VzIGJvb2xl\nYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlcjogRXN0\naW1hdGVkIGNvbXBvbmVudHdpc2UKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51\nbWJlci4gIENvbXBhcmVkIHdpdGggdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChuKSAq\nIHNsYW1jaCgnRXBzaWxvbicpIHRvIGRldGVybWluZSBpZiB0aGUgZXJyb3IKICAgICAgICAgICAg\nIGVzdGltYXRlIGlzICJndWFyYW50ZWVkIi4gVGhlc2UgcmVjaXByb2NhbCBjb25kaXRpb24KICAg\nICAgICAgICAgIG51bWJlcnMgYXJlIDEgLyAobm9ybShaXnstMX0saW5mKSAqIG5vcm0oWixpbmYp\nKSBmb3Igc29tZQogICAgICAgICAgICAgYXBwcm9wcmlhdGVseSBzY2FsZWQgbWF0cml4IFouCiAg\nICAgICAgICAgICBMZXQgWiA9IFMqKEEqZGlhZyh4KSksIHdoZXJlIHggaXMgdGhlIHNvbHV0aW9u\nIGZvciB0aGUKICAgICAgICAgICAgIGN1cnJlbnQgcmlnaHQtaGFuZCBzaWRlIGFuZCBTIHNjYWxl\ncyBlYWNoIHJvdyBvZgogICAgICAgICAgICAgQSpkaWFnKHgpIGJ5IGEgcG93ZXIgb2YgdGhlIHJh\nZGl4IHNvIGFsbCBhYnNvbHV0ZSByb3cKICAgICAgICAgICAgIHN1bXMgb2YgWiBhcmUgYXBwcm94\naW1hdGVseSAxLgogICAgU2VlIExhcGFjayBXb3JraW5nIE5vdGUgMTY1IGZvciBmdXJ0aGVyIGRl\ndGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4KXHBhcmFtW2luXSBOUEFSQU1TCiAgICAgICAg\nIE5QQVJBTVMgaXMgSU5URUdFUgogICAgU3BlY2lmaWVzIHRoZSBudW1iZXIgb2YgcGFyYW1ldGVy\ncyBzZXQgaW4gUEFSQU1TLiAgSWYgLkxFLiAwLCB0aGUKICAgIFBBUkFNUyBhcnJheSBpcyBuZXZl\nciByZWZlcmVuY2VkIGFuZCBkZWZhdWx0IHZhbHVlcyBhcmUgdXNlZC4KXHBhcmFtW2luLG91dF0g\nUEFSQU1TCiAgICAgICAgIFBBUkFNUyBpcyBSRUFMIGFycmF5LCBkaW1lbnNpb24gTlBBUkFNUwog\nICAgU3BlY2lmaWVzIGFsZ29yaXRobSBwYXJhbWV0ZXJzLiAgSWYgYW4gZW50cnkgaXMgLkxULiAw\nLjAsIHRoZW4KICAgIHRoYXQgZW50cnkgd2lsbCBiZSBmaWxsZWQgd2l0aCBkZWZhdWx0IHZhbHVl\nIHVzZWQgZm9yIHRoYXQKICAgIHBhcmFtZXRlci4gIE9ubHkgcG9zaXRpb25zIHVwIHRvIE5QQVJB\nTVMgYXJlIGFjY2Vzc2VkOyBkZWZhdWx0cwogICAgYXJlIHVzZWQgZm9yIGhpZ2hlci1udW1iZXJl\nZCBwYXJhbWV0ZXJzLgogICAgICBQQVJBTVMoTEFfTElOUlhfSVRSRUZfSSA9IDEpIDogV2hldGhl\nciB0byBwZXJmb3JtIGl0ZXJhdGl2ZQogICAgICAgICAgIHJlZmluZW1lbnQgb3Igbm90LgogICAg\nICAgIERlZmF1bHQ6IDEuMAogICAgICAgICAgID0gMC4wIDogTm8gcmVmaW5lbWVudCBpcyBwZXJm\nb3JtZWQsIGFuZCBubyBlcnJvciBib3VuZHMgYXJlCiAgICAgICAgICAgICAgICAgICBjb21wdXRl\nZC4KICAgICAgICAgICA9IDEuMCA6IFVzZSB0aGUgZG91YmxlLXByZWNpc2lvbiByZWZpbmVtZW50\nIGFsZ29yaXRobSwKICAgICAgICAgICAgICAgICAgIHBvc3NpYmx5IHdpdGggZG91YmxlZC1zaW5n\nbGUgY29tcHV0YXRpb25zIGlmIHRoZQogICAgICAgICAgICAgICAgICAgY29tcGlsYXRpb24gZW52\naXJvbm1lbnQgZG9lcyBub3Qgc3VwcG9ydCBET1VCTEUKICAgICAgICAgICAgICAgICAgIFBSRUNJ\nU0lPTi4KICAgICAgICAgICAgIChvdGhlciB2YWx1ZXMgYXJlIHJlc2VydmVkIGZvciBmdXR1cmUg\ndXNlKQogICAgICBQQVJBTVMoTEFfTElOUlhfSVRIUkVTSF9JID0gMikgOiBNYXhpbXVtIG51bWJl\nciBvZiByZXNpZHVhbAogICAgICAgICAgIGNvbXB1dGF0aW9ucyBhbGxvd2VkIGZvciByZWZpbmVt\nZW50LgogICAgICAgIERlZmF1bHQ6IDEwCiAgICAgICAgQWdncmVzc2l2ZTogU2V0IHRvIDEwMCB0\nbyBwZXJtaXQgY29udmVyZ2VuY2UgdXNpbmcgYXBwcm94aW1hdGUKICAgICAgICAgICAgICAgICAg\nICBmYWN0b3JpemF0aW9ucyBvciBmYWN0b3JpemF0aW9ucyBvdGhlciB0aGFuIExVLiBJZgogICAg\nICAgICAgICAgICAgICAgIHRoZSBmYWN0b3JpemF0aW9uIHVzZXMgYSB0ZWNobmlxdWUgb3RoZXIg\ndGhhbgogICAgICAgICAgICAgICAgICAgIEdhdXNzaWFuIGVsaW1pbmF0aW9uLCB0aGUgZ3VhcmFu\ndGVlcyBpbgogICAgICAgICAgICAgICAgICAgIGVycl9ibmRzX25vcm0gYW5kIGVycl9ibmRzX2Nv\nbXAgbWF5IG5vIGxvbmdlciBiZQogICAgICAgICAgICAgICAgICAgIHRydXN0d29ydGh5LgogICAg\nICBQQVJBTVMoTEFfTElOUlhfQ1dJU0VfSSA9IDMpIDogRmxhZyBkZXRlcm1pbmluZyBpZiB0aGUg\nY29kZQogICAgICAgICAgIHdpbGwgYXR0ZW1wdCB0byBmaW5kIGEgc29sdXRpb24gd2l0aCBzbWFs\nbCBjb21wb25lbnR3aXNlCiAgICAgICAgICAgcmVsYXRpdmUgZXJyb3IgaW4gdGhlIGRvdWJsZS1w\ncmVjaXNpb24gYWxnb3JpdGhtLiAgUG9zaXRpdmUKICAgICAgICAgICBpcyB0cnVlLCAwLjAgaXMg\nZmFsc2UuCiAgICAgICAgRGVmYXVsdDogMS4wIChhdHRlbXB0IGNvbXBvbmVudHdpc2UgY29udmVy\nZ2VuY2UpClxwYXJhbVtvdXRdIFdPUksKICAgICAgICAgV09SSyBpcyBDT01QTEVYIGFycmF5LCBk\naW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0gUldPUksKICAgICAgICAgUldPUksgaXMgUkVBTCBh\ncnJheSwgZGltZW5zaW9uICgyKk4pClxwYXJhbVtvdXRdIElORk8KICAgICAgICAgSU5GTyBpcyBJ\nTlRFR0VSCiAgICAgID0gMDogIFN1Y2Nlc3NmdWwgZXhpdC4gVGhlIHNvbHV0aW9uIHRvIGV2ZXJ5\nIHJpZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIGd1YXJhbnRlZWQuCiAgICAgIDwgMDogIElmIElO\nRk8gPSAtaSwgdGhlIGktdGggYXJndW1lbnQgaGFkIGFuIGlsbGVnYWwgdmFsdWUKICAgICAgPiAw\nIGFuZCA8PSBOOiAgVShJTkZPLElORk8pIGlzIGV4YWN0bHkgemVyby4gIFRoZSBmYWN0b3JpemF0\naW9uCiAgICAgICAgaGFzIGJlZW4gY29tcGxldGVkLCBidXQgdGhlIGZhY3RvciBVIGlzIGV4YWN0\nbHkgc2luZ3VsYXIsIHNvCiAgICAgICAgdGhlIHNvbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgY291\nbGQgbm90IGJlIGNvbXB1dGVkLiBSQ09ORCA9IDAKICAgICAgICBpcyByZXR1cm5lZC4KICAgICAg\nPSBOK0o6IFRoZSBzb2x1dGlvbiBjb3JyZXNwb25kaW5nIHRvIHRoZSBKdGggcmlnaHQtaGFuZCBz\naWRlIGlzCiAgICAgICAgbm90IGd1YXJhbnRlZWQuIFRoZSBzb2x1dGlvbnMgY29ycmVzcG9uZGlu\nZyB0byBvdGhlciByaWdodC0KICAgICAgICBoYW5kIHNpZGVzIEsgd2l0aCBLID4gSiBtYXkgbm90\nIGJlIGd1YXJhbnRlZWQgYXMgd2VsbCwgYnV0CiAgICAgICAgb25seSB0aGUgZmlyc3Qgc3VjaCBy\naWdodC1oYW5kIHNpZGUgaXMgcmVwb3J0ZWQuIElmIGEgc21hbGwKICAgICAgICBjb21wb25lbnR3\naXNlIGVycm9yIGlzIG5vdCByZXF1ZXN0ZWQgKFBBUkFNUygzKSA9IDAuMCkgdGhlbgogICAgICAg\nIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzIHRoZSBmaXJzdCB3aXRoIGEgbm9ybXdpc2UgZXJy\nb3IKICAgICAgICBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50ZWVkICh0aGUgc21hbGxlc3QgSiBz\ndWNoCiAgICAgICAgdGhhdCBFUlJfQk5EU19OT1JNKEosMSkgPSAwLjApLiBCeSBkZWZhdWx0IChQ\nQVJBTVMoMykgPSAxLjApCiAgICAgICAgdGhlIEp0aCByaWdodC1oYW5kIHNpZGUgaXMgdGhlIGZp\ncnN0IHdpdGggZWl0aGVyIGEgbm9ybXdpc2Ugb3IKICAgICAgICBjb21wb25lbnR3aXNlIGVycm9y\nIGJvdW5kIHRoYXQgaXMgbm90IGd1YXJhbnRlZWQgKHRoZSBzbWFsbGVzdAogICAgICAgIEogc3Vj\naCB0aGF0IGVpdGhlciBFUlJfQk5EU19OT1JNKEosMSkgPSAwLjAgb3IKICAgICAgICBFUlJfQk5E\nU19DT01QKEosMSkgPSAwLjApLiBTZWUgdGhlIGRlZmluaXRpb24gb2YKICAgICAgICBFUlJfQk5E\nU19OT1JNKDosMSkgYW5kIEVSUl9CTkRTX0NPTVAoOiwxKS4gVG8gZ2V0IGluZm9ybWF0aW9uCiAg\nICAgICAgYWJvdXQgYWxsIG9mIHRoZSByaWdodC1oYW5kIHNpZGVzIGNoZWNrIEVSUl9CTkRTX05P\nUk0gb3IKICAgICAgICBFUlJfQk5EU19DT01QLgpBdXRob3JzOgpcYXV0aG9yIFVuaXYuIG9mIFRl\nbm5lc3NlZSAKXGF1dGhvciBVbml2LiBvZiBDYWxpZm9ybmlhIEJlcmtlbGV5IApcYXV0aG9yIFVu\naXYuIG9mIENvbG9yYWRvIERlbnZlciAKXGF1dGhvciBOQUcgTHRkLiAKXGRhdGUgQXByaWwgMjAx\nMgpcaW5ncm91cCBjb21wbGV4U1ljb21wdXRhdGlvbmFsCmgdaB4pgXI/AgAAfXJAAgAAKGghiWgi\naCN1YmgtigKpAWguWA8AAABjc3lyZnN4XzQyNS50eHR1YmgvigKpAWgwWAYAAABzeXJmc3hoLYoB\nQ3ViaBVoFl1oF4dSckECAAB9ckICAAAoaBpYCQAAAHN5bW1ldHJpY2gbWAQAAABmdWxsaBxYRgAA\nAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVm\naW5lbWVudDsgRVFVRURoHWgeKYFyQwIAAH1yRAIAAChoIYloImgjdWJoJFghAAAARG94eWdlbi9k\nb2NzL2h0bWwvenN5cmZzeF84Zi5odG1saCVYAQAAAHpoJmgVaCddaBeHUnJFAgAAfXJGAgAAKGgq\nWBUyAAAgICBaU1lSRlNYIGltcHJvdmVzIHRoZSBjb21wdXRlZCBzb2x1dGlvbiB0byBhIHN5c3Rl\nbSBvZiBsaW5lYXIKICAgZXF1YXRpb25zIHdoZW4gdGhlIGNvZWZmaWNpZW50IG1hdHJpeCBpcyBz\neW1tZXRyaWMgaW5kZWZpbml0ZSwgYW5kCiAgIHByb3ZpZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFj\na3dhcmQgZXJyb3IgZXN0aW1hdGVzIGZvciB0aGUKICAgc29sdXRpb24uICBJbiBhZGRpdGlvbiB0\nbyBub3Jtd2lzZSBlcnJvciBib3VuZCwgdGhlIGNvZGUgcHJvdmlkZXMKICAgbWF4aW11bSBjb21w\nb25lbnR3aXNlIGVycm9yIGJvdW5kIGlmIHBvc3NpYmxlLiAgU2VlIGNvbW1lbnRzIGZvcgogICBF\nUlJfQk5EU19OT1JNIGFuZCBFUlJfQk5EU19DT01QIGZvciBkZXRhaWxzIG9mIHRoZSBlcnJvciBi\nb3VuZHMuCiAgIFRoZSBvcmlnaW5hbCBzeXN0ZW0gb2YgbGluZWFyIGVxdWF0aW9ucyBtYXkgaGF2\nZSBiZWVuIGVxdWlsaWJyYXRlZAogICBiZWZvcmUgY2FsbGluZyB0aGlzIHJvdXRpbmUsIGFzIGRl\nc2NyaWJlZCBieSBhcmd1bWVudHMgRVFVRUQgYW5kIFMKICAgYmVsb3cuIEluIHRoaXMgY2FzZSwg\ndGhlIHNvbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgcmV0dXJuZWQgYXJlCiAgIGZvciB0aGUgb3Jp\nZ2luYWwgdW5lcXVpbGlicmF0ZWQgc3lzdGVtLgpBcmd1bWVudHM6CiAgICBTb21lIG9wdGlvbmFs\nIHBhcmFtZXRlcnMgYXJlIGJ1bmRsZWQgaW4gdGhlIFBBUkFNUyBhcnJheS4gIFRoZXNlCiAgICBz\nZXR0aW5ncyBkZXRlcm1pbmUgaG93IHJlZmluZW1lbnQgaXMgcGVyZm9ybWVkLCBidXQgb2Z0ZW4g\ndGhlCiAgICBkZWZhdWx0cyBhcmUgYWNjZXB0YWJsZS4gIElmIHRoZSBkZWZhdWx0cyBhcmUgYWNj\nZXB0YWJsZSwgdXNlcnMKICAgIGNhbiBwYXNzIE5QQVJBTVMgPSAwIHdoaWNoIHByZXZlbnRzIHRo\nZSBzb3VyY2UgY29kZSBmcm9tIGFjY2Vzc2luZwogICAgdGhlIFBBUkFNUyBhcmd1bWVudC4KXHBh\ncmFtW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hBUkFDVEVSKjEKICAgICAgPSAnVSc6ICBV\ncHBlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZDsKICAgICAgPSAnTCc6ICBMb3dlciB0cmlhbmds\nZSBvZiBBIGlzIHN0b3JlZC4KXHBhcmFtW2luXSBFUVVFRAogICAgICAgICBFUVVFRCBpcyBDSEFS\nQUNURVIqMQogICAgU3BlY2lmaWVzIHRoZSBmb3JtIG9mIGVxdWlsaWJyYXRpb24gdGhhdCB3YXMg\nZG9uZSB0byBBCiAgICBiZWZvcmUgY2FsbGluZyB0aGlzIHJvdXRpbmUuIFRoaXMgaXMgbmVlZGVk\nIHRvIGNvbXB1dGUKICAgIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIGNvcnJlY3RseS4K\nICAgICAgPSAnTic6ICBObyBlcXVpbGlicmF0aW9uCiAgICAgID0gJ1knOiAgQm90aCByb3cgYW5k\nIGNvbHVtbiBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhhcyBiZWVuCiAgICAgICAgICAgICAgcmVw\nbGFjZWQgYnkgZGlhZyhTKSAqIEEgKiBkaWFnKFMpLgogICAgICAgICAgICAgIFRoZSByaWdodCBo\nYW5kIHNpZGUgQiBoYXMgYmVlbiBjaGFuZ2VkIGFjY29yZGluZ2x5LgpccGFyYW1baW5dIE4KICAg\nICAgICAgTiBpcyBJTlRFR0VSCiAgICBUaGUgb3JkZXIgb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAw\nLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBpcyBJTlRFR0VSCiAgICBUaGUgbnVtYmVy\nIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBudW1iZXIgb2YgY29sdW1ucwogICAgb2Yg\ndGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAuClxwYXJhbVtpbl0gQQogICAgICAgICBB\nIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTERBLE4pCiAgICBUaGUgc3ltbWV0cmlj\nIG1hdHJpeCBBLiAgSWYgVVBMTyA9ICdVJywgdGhlIGxlYWRpbmcgTi1ieS1OCiAgICB1cHBlciB0\ncmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgdXBwZXIgdHJpYW5ndWxhcgogICAgcGFy\ndCBvZiB0aGUgbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkgbG93ZXIgdHJpYW5ndWxhcgogICAg\ncGFydCBvZiBBIGlzIG5vdCByZWZlcmVuY2VkLiAgSWYgVVBMTyA9ICdMJywgdGhlIGxlYWRpbmcK\nICAgIE4tYnktTiBsb3dlciB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgbG93ZXIK\nICAgIHRyaWFuZ3VsYXIgcGFydCBvZiB0aGUgbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkgdXBw\nZXIKICAgIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGlzIG5vdCByZWZlcmVuY2VkLgpccGFyYW1baW5d\nIExEQQogICAgICAgICBMREEgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9m\nIHRoZSBhcnJheSBBLiAgTERBID49IG1heCgxLE4pLgpccGFyYW1baW5dIEFGCiAgICAgICAgIEFG\nIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTERBRixOKQogICAgVGhlIGZhY3RvcmVk\nIGZvcm0gb2YgdGhlIG1hdHJpeCBBLiAgQUYgY29udGFpbnMgdGhlIGJsb2NrCiAgICBkaWFnb25h\nbCBtYXRyaXggRCBhbmQgdGhlIG11bHRpcGxpZXJzIHVzZWQgdG8gb2J0YWluIHRoZQogICAgZmFj\ndG9yIFUgb3IgTCBmcm9tIHRoZSBmYWN0b3JpemF0aW9uIEEgPSBVKkQqVSoqVCBvciBBID0KICAg\nIEwqRCpMKipUIGFzIGNvbXB1dGVkIGJ5IERTWVRSRi4KXHBhcmFtW2luXSBMREFGCiAgICAgICAg\nIExEQUYgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBB\nRi4gIExEQUYgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gSVBJVgogICAgICAgICBJUElWIGlzIElO\nVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgIERldGFpbHMgb2YgdGhlIGludGVyY2hhbmdl\ncyBhbmQgdGhlIGJsb2NrIHN0cnVjdHVyZSBvZiBECiAgICBhcyBkZXRlcm1pbmVkIGJ5IERTWVRS\nRi4KXHBhcmFtW2luLG91dF0gUwogICAgICAgICBTIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXks\nIGRpbWVuc2lvbiAoTikKICAgIFRoZSBzY2FsZSBmYWN0b3JzIGZvciBBLiAgSWYgRVFVRUQgPSAn\nWScsIEEgaXMgbXVsdGlwbGllZCBvbgogICAgdGhlIGxlZnQgYW5kIHJpZ2h0IGJ5IGRpYWcoUyku\nICBTIGlzIGFuIGlucHV0IGFyZ3VtZW50IGlmIEZBQ1QgPQogICAgJ0YnOyBvdGhlcndpc2UsIFMg\naXMgYW4gb3V0cHV0IGFyZ3VtZW50LiAgSWYgRkFDVCA9ICdGJyBhbmQgRVFVRUQKICAgID0gJ1kn\nLCBlYWNoIGVsZW1lbnQgb2YgUyBtdXN0IGJlIHBvc2l0aXZlLiAgSWYgUyBpcyBvdXRwdXQsIGVh\nY2gKICAgIGVsZW1lbnQgb2YgUyBpcyBhIHBvd2VyIG9mIHRoZSByYWRpeC4gSWYgUyBpcyBpbnB1\ndCwgZWFjaCBlbGVtZW50CiAgICBvZiBTIHNob3VsZCBiZSBhIHBvd2VyIG9mIHRoZSByYWRpeCB0\nbyBlbnN1cmUgYSByZWxpYWJsZSBzb2x1dGlvbgogICAgYW5kIGVycm9yIGVzdGltYXRlcy4gU2Nh\nbGluZyBieSBwb3dlcnMgb2YgdGhlIHJhZGl4IGRvZXMgbm90IGNhdXNlCiAgICByb3VuZGluZyBl\ncnJvcnMgdW5sZXNzIHRoZSByZXN1bHQgdW5kZXJmbG93cyBvciBvdmVyZmxvd3MuCiAgICBSb3Vu\nZGluZyBlcnJvcnMgZHVyaW5nIHNjYWxpbmcgbGVhZCB0byByZWZpbmluZyB3aXRoIGEgbWF0cml4\nIHRoYXQKICAgIGlzIG5vdCBlcXVpdmFsZW50IHRvIHRoZSBpbnB1dCBtYXRyaXgsIHByb2R1Y2lu\nZyBlcnJvciBlc3RpbWF0ZXMKICAgIHRoYXQgbWF5IG5vdCBiZSByZWxpYWJsZS4KXHBhcmFtW2lu\nXSBCCiAgICAgICAgIEIgaXMgQ09NUExFWCoxNiBhcnJheSwgZGltZW5zaW9uIChMREIsTlJIUykK\nICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAgICAg\nIExEQiBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5IEIu\nICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBDT01QTEVY\nKjE2IGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgT24gZW50cnksIHRoZSBzb2x1dGlv\nbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgREdFVFJTLgogICAgT24gZXhpdCwgdGhlIGltcHJv\ndmVkIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5U\nRUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1h\neCgxLE4pLgpccGFyYW1bb3V0XSBSQ09ORAogICAgICAgICBSQ09ORCBpcyBET1VCTEUgUFJFQ0lT\nSU9OCiAgICBSZWNpcHJvY2FsIHNjYWxlZCBjb25kaXRpb24gbnVtYmVyLiAgVGhpcyBpcyBhbiBl\nc3RpbWF0ZSBvZiB0aGUKICAgIHJlY2lwcm9jYWwgU2tlZWwgY29uZGl0aW9uIG51bWJlciBvZiB0\naGUgbWF0cml4IEEgYWZ0ZXIKICAgIGVxdWlsaWJyYXRpb24gKGlmIGRvbmUpLiAgSWYgdGhpcyBp\ncyBsZXNzIHRoYW4gdGhlIG1hY2hpbmUKICAgIHByZWNpc2lvbiAoaW4gcGFydGljdWxhciwgaWYg\naXQgaXMgemVybyksIHRoZSBtYXRyaXggaXMgc2luZ3VsYXIKICAgIHRvIHdvcmtpbmcgcHJlY2lz\naW9uLiAgTm90ZSB0aGF0IHRoZSBlcnJvciBtYXkgc3RpbGwgYmUgc21hbGwgZXZlbgogICAgaWYg\ndGhpcyBudW1iZXIgaXMgdmVyeSBzbWFsbCBhbmQgdGhlIG1hdHJpeCBhcHBlYXJzIGlsbC0KICAg\nIGNvbmRpdGlvbmVkLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgRE9VQkxFIFBS\nRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIChOUkhTKQogICAgQ29tcG9uZW50d2lzZSByZWxhdGl2\nZSBiYWNrd2FyZCBlcnJvci4gIFRoaXMgaXMgdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZl\nIGJhY2t3YXJkIGVycm9yIG9mIGVhY2ggc29sdXRpb24gdmVjdG9yIFgoaikKICAgIChpLmUuLCB0\naGUgc21hbGxlc3QgcmVsYXRpdmUgY2hhbmdlIGluIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0\nCiAgICBtYWtlcyBYKGopIGFuIGV4YWN0IHNvbHV0aW9uKS4KXHBhcmFtW2luXSBOX0VSUl9CTkRT\nCiAgICAgICAgIE5fRVJSX0JORFMgaXMgSU5URUdFUgogICAgTnVtYmVyIG9mIGVycm9yIGJvdW5k\ncyB0byByZXR1cm4gZm9yIGVhY2ggcmlnaHQgaGFuZCBzaWRlCiAgICBhbmQgZWFjaCB0eXBlIChu\nb3Jtd2lzZSBvciBjb21wb25lbnR3aXNlKS4gIFNlZSBFUlJfQk5EU19OT1JNIGFuZAogICAgRVJS\nX0JORFNfQ09NUCBiZWxvdy4KXHBhcmFtW291dF0gRVJSX0JORFNfTk9STQogICAgICAgICBFUlJf\nQk5EU19OT1JNIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUywgTl9F\nUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZSwgdGhpcyBhcnJheSBjb250YWlu\ncyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJvciBib3VuZHMgYW5kIGNvbmRpdGlv\nbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBub3Jtd2lzZSByZWxhdGl2ZSBlcnJv\nciwgd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dzOgogICAgTm9ybXdpc2UgcmVsYXRpdmUgZXJy\nb3IgaW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAgICAgICAgIG1heF9qIChhYnMoWFRS\nVUUoaixpKSAtIFgoaixpKSkpCiAgICAgICAgICAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t\nLS0tCiAgICAgICAgICAgICAgICAgbWF4X2ogYWJzKFgoaixpKSkKICAgIFRoZSBhcnJheSBpcyBp\nbmRleGVkIGJ5IHRoZSB0eXBlIG9mIGVycm9yIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZAogICAg\nYmVsb3cuIFRoZXJlIGN1cnJlbnRseSBhcmUgdXAgdG8gdGhyZWUgcGllY2VzIG9mIGluZm9ybWF0\naW9uCiAgICByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKGks\nOikgY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQtaGFuZCBzaWRlLgogICAgVGhlIHNl\nY29uZCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKDosZXJyKSBjb250YWlucyB0aGUgZm9sbG93aW5n\nCiAgICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVzdC9kb24ndCB0cnVzdCIgYm9vbGVh\nbi4gVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAgICAgIHJlY2lwcm9jYWwgY29uZGl0\naW9uIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAgICAgc3FydChu\nKSAqIGRsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAiR3VhcmFudGVlZCIgZXJyb3IgYm91\nbmQ6IFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAgICAgICAgICAgIGFsbW9zdCBjZXJ0\nYWlubHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0cnVlIGVycm9yCiAgICAgICAgICAg\nICBzbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0ZXIgdGhhbiB0aGUgdGhyZXNob2xk\nCiAgICAgICAgICAgICBzcXJ0KG4pICogZGxhbWNoKCdFcHNpbG9uJykuIFRoaXMgZXJyb3IgYm91\nbmQgc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0ZWQgaWYgdGhlIHByZXZpb3VzIGJv\nb2xlYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlcjog\nRXN0aW1hdGVkIG5vcm13aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1i\nZXIuICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBk\nbGFtY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAgICBl\nc3RpbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAgICAg\nICAgICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5mKSkg\nZm9yIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgogICAg\nICAgICAgICAgTGV0IFogPSBTKkEsIHdoZXJlIFMgc2NhbGVzIGVhY2ggcm93IGJ5IGEgcG93ZXIg\nb2YgdGhlCiAgICAgICAgICAgICByYWRpeCBzbyBhbGwgYWJzb2x1dGUgcm93IHN1bXMgb2YgWiBh\ncmUgYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFjayBXb3JraW5nIE5vdGUgMTY1IGZvciBm\ndXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9ucy4KXHBhcmFtW291dF0gRVJSX0JO\nRFNfQ09NUAogICAgICAgICBFUlJfQk5EU19DT01QIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXks\nIGRpbWVuc2lvbiAoTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lk\nZSwgdGhpcyBhcnJheSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJv\nciBib3VuZHMgYW5kIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBj\nb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFzIGZvbGxvd3M6\nCiAgICBDb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGluIHRoZSBpdGggc29sdXRpb24gdmVj\ndG9yOgogICAgICAgICAgICAgICAgICAgYWJzKFhUUlVFKGosaSkgLSBYKGosaSkpCiAgICAgICAg\nICAgIG1heF9qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAgICAgICAgICAg\nYWJzKFgoaixpKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSByaWdodC1oYW5kIHNp\nZGUgaSAob24gd2hpY2ggdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGRlcGVu\nZHMpLCBhbmQgdGhlIHR5cGUgb2YgZXJyb3IKICAgIGluZm9ybWF0aW9uIGFzIGRlc2NyaWJlZCBi\nZWxvdy4gVGhlcmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZQogICAgcGllY2VzIG9mIGluZm9y\nbWF0aW9uIHJldHVybmVkIGZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZS4gSWYKICAgIGNvbXBvbmVu\ndHdpc2UgYWNjdXJhY3kgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1TKDMpID0gMC4wKSwgdGhlbgog\nICAgRVJSX0JORFNfQ09NUCBpcyBub3QgYWNjZXNzZWQuICBJZiBOX0VSUl9CTkRTIC5MVC4gMywg\ndGhlbiBhdCBtb3N0CiAgICB0aGUgZmlyc3QgKDosTl9FUlJfQk5EUykgZW50cmllcyBhcmUgcmV0\ndXJuZWQuCiAgICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfQ09NUChpLDopIGNvcnJlc3Bv\nbmRzIHRvIHRoZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBzZWNvbmQgaW5kZXgg\naW4gRVJSX0JORFNfQ09NUCg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2luZwogICAgdGhyZWUg\nZmllbGRzOgogICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xlYW4uIFRydXN0IHRo\nZSBhbnN3ZXIgaWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIg\naXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBkbGFtY2go\nJ0Vwc2lsb24nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJvdW5kOiBUaGUgZXN0\naW1hdGVkIGZvcndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2VydGFpbmx5IHdpdGhp\nbiBhIGZhY3RvciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAgICAgc28gbG9uZyBh\ncyB0aGUgbmV4dCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZAogICAgICAgICAg\nICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJvdW5kIHNob3VsZCBv\nbmx5CiAgICAgICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBib29sZWFuIGlzIHRy\ndWUuCiAgICBlcnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6IEVzdGltYXRlZCBj\nb21wb25lbnR3aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXIuICBD\nb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikgKiBkbGFtY2go\nJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAgICBlc3RpbWF0\nZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAgICAgICAgICAg\nICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5mKSkgZm9yIHNv\nbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgogICAgICAgICAg\nICAgTGV0IFogPSBTKihBKmRpYWcoeCkpLCB3aGVyZSB4IGlzIHRoZSBzb2x1dGlvbiBmb3IgdGhl\nCiAgICAgICAgICAgICBjdXJyZW50IHJpZ2h0LWhhbmQgc2lkZSBhbmQgUyBzY2FsZXMgZWFjaCBy\nb3cgb2YKICAgICAgICAgICAgIEEqZGlhZyh4KSBieSBhIHBvd2VyIG9mIHRoZSByYWRpeCBzbyBh\nbGwgYWJzb2x1dGUgcm93CiAgICAgICAgICAgICBzdW1zIG9mIFogYXJlIGFwcHJveGltYXRlbHkg\nMS4KICAgIFNlZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhlciBkZXRhaWxzIGFu\nZCBleHRyYQogICAgY2F1dGlvbnMuClxwYXJhbVtpbl0gTlBBUkFNUwogICAgICAgICBOUEFSQU1T\nIGlzIElOVEVHRVIKICAgIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRlcnMgc2V0IGlu\nIFBBUkFNUy4gIElmIC5MRS4gMCwgdGhlCiAgICBQQVJBTVMgYXJyYXkgaXMgbmV2ZXIgcmVmZXJl\nbmNlZCBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIHVzZWQuClxwYXJhbVtpbixvdXRdIFBBUkFNUwog\nICAgICAgICBQQVJBTVMgaXMgRE9VQkxFIFBSRUNJU0lPTiBhcnJheSwgZGltZW5zaW9uIE5QQVJB\nTVMKICAgIFNwZWNpZmllcyBhbGdvcml0aG0gcGFyYW1ldGVycy4gIElmIGFuIGVudHJ5IGlzIC5M\nVC4gMC4wLCB0aGVuCiAgICB0aGF0IGVudHJ5IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVmYXVsdCB2\nYWx1ZSB1c2VkIGZvciB0aGF0CiAgICBwYXJhbWV0ZXIuICBPbmx5IHBvc2l0aW9ucyB1cCB0byBO\nUEFSQU1TIGFyZSBhY2Nlc3NlZDsgZGVmYXVsdHMKICAgIGFyZSB1c2VkIGZvciBoaWdoZXItbnVt\nYmVyZWQgcGFyYW1ldGVycy4KICAgICAgUEFSQU1TKExBX0xJTlJYX0lUUkVGX0kgPSAxKSA6IFdo\nZXRoZXIgdG8gcGVyZm9ybSBpdGVyYXRpdmUKICAgICAgICAgICByZWZpbmVtZW50IG9yIG5vdC4K\nICAgICAgICBEZWZhdWx0OiAxLjBEKzAKICAgICAgICAgICA9IDAuMCA6IE5vIHJlZmluZW1lbnQg\naXMgcGVyZm9ybWVkLCBhbmQgbm8gZXJyb3IgYm91bmRzIGFyZQogICAgICAgICAgICAgICAgICAg\nY29tcHV0ZWQuCiAgICAgICAgICAgPSAxLjAgOiBVc2UgdGhlIGRvdWJsZS1wcmVjaXNpb24gcmVm\naW5lbWVudCBhbGdvcml0aG0sCiAgICAgICAgICAgICAgICAgICBwb3NzaWJseSB3aXRoIGRvdWJs\nZWQtc2luZ2xlIGNvbXB1dGF0aW9ucyBpZiB0aGUKICAgICAgICAgICAgICAgICAgIGNvbXBpbGF0\naW9uIGVudmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgRE9VQkxFCiAgICAgICAgICAgICAgICAg\nICBQUkVDSVNJT04uCiAgICAgICAgICAgICAob3RoZXIgdmFsdWVzIGFyZSByZXNlcnZlZCBmb3Ig\nZnV0dXJlIHVzZSkKICAgICAgUEFSQU1TKExBX0xJTlJYX0lUSFJFU0hfSSA9IDIpIDogTWF4aW11\nbSBudW1iZXIgb2YgcmVzaWR1YWwKICAgICAgICAgICBjb21wdXRhdGlvbnMgYWxsb3dlZCBmb3Ig\ncmVmaW5lbWVudC4KICAgICAgICBEZWZhdWx0OiAxMAogICAgICAgIEFnZ3Jlc3NpdmU6IFNldCB0\nbyAxMDAgdG8gcGVybWl0IGNvbnZlcmdlbmNlIHVzaW5nIGFwcHJveGltYXRlCiAgICAgICAgICAg\nICAgICAgICAgZmFjdG9yaXphdGlvbnMgb3IgZmFjdG9yaXphdGlvbnMgb3RoZXIgdGhhbiBMVS4g\nSWYKICAgICAgICAgICAgICAgICAgICB0aGUgZmFjdG9yaXphdGlvbiB1c2VzIGEgdGVjaG5pcXVl\nIG90aGVyIHRoYW4KICAgICAgICAgICAgICAgICAgICBHYXVzc2lhbiBlbGltaW5hdGlvbiwgdGhl\nIGd1YXJhbnRlZXMgaW4KICAgICAgICAgICAgICAgICAgICBlcnJfYm5kc19ub3JtIGFuZCBlcnJf\nYm5kc19jb21wIG1heSBubyBsb25nZXIgYmUKICAgICAgICAgICAgICAgICAgICB0cnVzdHdvcnRo\neS4KICAgICAgUEFSQU1TKExBX0xJTlJYX0NXSVNFX0kgPSAzKSA6IEZsYWcgZGV0ZXJtaW5pbmcg\naWYgdGhlIGNvZGUKICAgICAgICAgICB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIHNvbHV0aW9uIHdp\ndGggc21hbGwgY29tcG9uZW50d2lzZQogICAgICAgICAgIHJlbGF0aXZlIGVycm9yIGluIHRoZSBk\nb3VibGUtcHJlY2lzaW9uIGFsZ29yaXRobS4gIFBvc2l0aXZlCiAgICAgICAgICAgaXMgdHJ1ZSwg\nMC4wIGlzIGZhbHNlLgogICAgICAgIERlZmF1bHQ6IDEuMCAoYXR0ZW1wdCBjb21wb25lbnR3aXNl\nIGNvbnZlcmdlbmNlKQpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgQ09NUExFWCox\nNiBhcnJheSwgZGltZW5zaW9uICgyKk4pClxwYXJhbVtvdXRdIFJXT1JLCiAgICAgICAgIFJXT1JL\nIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBJ\nTkZPCiAgICAgICAgIElORk8gaXMgSU5URUdFUgogICAgICA9IDA6ICBTdWNjZXNzZnVsIGV4aXQu\nIFRoZSBzb2x1dGlvbiB0byBldmVyeSByaWdodC1oYW5kIHNpZGUgaXMKICAgICAgICBndWFyYW50\nZWVkLgogICAgICA8IDA6ICBJZiBJTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBp\nbGxlZ2FsIHZhbHVlCiAgICAgID4gMCBhbmQgPD0gTjogIFUoSU5GTyxJTkZPKSBpcyBleGFjdGx5\nIHplcm8uICBUaGUgZmFjdG9yaXphdGlvbgogICAgICAgIGhhcyBiZWVuIGNvbXBsZXRlZCwgYnV0\nIHRoZSBmYWN0b3IgVSBpcyBleGFjdGx5IHNpbmd1bGFyLCBzbwogICAgICAgIHRoZSBzb2x1dGlv\nbiBhbmQgZXJyb3IgYm91bmRzIGNvdWxkIG5vdCBiZSBjb21wdXRlZC4gUkNPTkQgPSAwCiAgICAg\nICAgaXMgcmV0dXJuZWQuCiAgICAgID0gTitKOiBUaGUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0\nbyB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcwogICAgICAgIG5vdCBndWFyYW50ZWVkLiBUaGUg\nc29sdXRpb25zIGNvcnJlc3BvbmRpbmcgdG8gb3RoZXIgcmlnaHQtCiAgICAgICAgaGFuZCBzaWRl\ncyBLIHdpdGggSyA+IEogbWF5IG5vdCBiZSBndWFyYW50ZWVkIGFzIHdlbGwsIGJ1dAogICAgICAg\nIG9ubHkgdGhlIGZpcnN0IHN1Y2ggcmlnaHQtaGFuZCBzaWRlIGlzIHJlcG9ydGVkLiBJZiBhIHNt\nYWxsCiAgICAgICAgY29tcG9uZW50d2lzZSBlcnJvciBpcyBub3QgcmVxdWVzdGVkIChQQVJBTVMo\nMykgPSAwLjApIHRoZW4KICAgICAgICB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcyB0aGUgZmly\nc3Qgd2l0aCBhIG5vcm13aXNlIGVycm9yCiAgICAgICAgYm91bmQgdGhhdCBpcyBub3QgZ3VhcmFu\ndGVlZCAodGhlIHNtYWxsZXN0IEogc3VjaAogICAgICAgIHRoYXQgRVJSX0JORFNfTk9STShKLDEp\nID0gMC4wKS4gQnkgZGVmYXVsdCAoUEFSQU1TKDMpID0gMS4wKQogICAgICAgIHRoZSBKdGggcmln\naHQtaGFuZCBzaWRlIGlzIHRoZSBmaXJzdCB3aXRoIGVpdGhlciBhIG5vcm13aXNlIG9yCiAgICAg\nICAgY29tcG9uZW50d2lzZSBlcnJvciBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50ZWVkICh0aGUg\nc21hbGxlc3QKICAgICAgICBKIHN1Y2ggdGhhdCBlaXRoZXIgRVJSX0JORFNfTk9STShKLDEpID0g\nMC4wIG9yCiAgICAgICAgRVJSX0JORFNfQ09NUChKLDEpID0gMC4wKS4gU2VlIHRoZSBkZWZpbml0\naW9uIG9mCiAgICAgICAgRVJSX0JORFNfTk9STSg6LDEpIGFuZCBFUlJfQk5EU19DT01QKDosMSku\nIFRvIGdldCBpbmZvcm1hdGlvbgogICAgICAgIGFib3V0IGFsbCBvZiB0aGUgcmlnaHQtaGFuZCBz\naWRlcyBjaGVjayBFUlJfQk5EU19OT1JNIG9yCiAgICAgICAgRVJSX0JORFNfQ09NUC4KQXV0aG9y\nczoKXGF1dGhvciBVbml2LiBvZiBUZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5p\nYSBCZXJrZWxleSAKXGF1dGhvciBVbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFH\nIEx0ZC4gClxkYXRlIEFwcmlsIDIwMTIKXGluZ3JvdXAgY29tcGxleDE2U1ljb21wdXRhdGlvbmFs\nCmgdaB4pgXJHAgAAfXJIAgAAKGghiWgiaCN1YmgtigKqAWguWA8AAAB6c3lyZnN4XzQyNi50eHR1\nYmgvigKqAWgwWAYAAABzeXJmc3hoLYoBRHViaBVoFl1oF4dSckkCAAB9ckoCAAAoaBpYCQAAAEhl\ncm1pdGlhbmgbWAQAAABmdWxsaBxYRgAAAGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3Ig\nZXN0aW1hdGVzOyBpdGVyYXRpdmUgcmVmaW5lbWVudDsgRVFVRURoHWgeKYFySwIAAH1yTAIAACho\nIYloImgjdWJoJFghAAAARG94eWdlbi9kb2NzL2h0bWwvY2hlcmZzeF84Zi5odG1saCVYAQAAAGNo\nJmgVaCddaBeHUnJNAgAAfXJOAgAAKGgqWK0xAAAgICBDSEVSRlNYIGltcHJvdmVzIHRoZSBjb21w\ndXRlZCBzb2x1dGlvbiB0byBhIHN5c3RlbSBvZiBsaW5lYXIKICAgZXF1YXRpb25zIHdoZW4gdGhl\nIGNvZWZmaWNpZW50IG1hdHJpeCBpcyBIZXJtaXRpYW4gaW5kZWZpbml0ZSwgYW5kCiAgIHByb3Zp\nZGVzIGVycm9yIGJvdW5kcyBhbmQgYmFja3dhcmQgZXJyb3IgZXN0aW1hdGVzIGZvciB0aGUKICAg\nc29sdXRpb24uICBJbiBhZGRpdGlvbiB0byBub3Jtd2lzZSBlcnJvciBib3VuZCwgdGhlIGNvZGUg\ncHJvdmlkZXMKICAgbWF4aW11bSBjb21wb25lbnR3aXNlIGVycm9yIGJvdW5kIGlmIHBvc3NpYmxl\nLiAgU2VlIGNvbW1lbnRzIGZvcgogICBFUlJfQk5EU19OT1JNIGFuZCBFUlJfQk5EU19DT01QIGZv\nciBkZXRhaWxzIG9mIHRoZSBlcnJvciBib3VuZHMuCiAgIFRoZSBvcmlnaW5hbCBzeXN0ZW0gb2Yg\nbGluZWFyIGVxdWF0aW9ucyBtYXkgaGF2ZSBiZWVuIGVxdWlsaWJyYXRlZAogICBiZWZvcmUgY2Fs\nbGluZyB0aGlzIHJvdXRpbmUsIGFzIGRlc2NyaWJlZCBieSBhcmd1bWVudHMgRVFVRUQgYW5kIFMK\nICAgYmVsb3cuIEluIHRoaXMgY2FzZSwgdGhlIHNvbHV0aW9uIGFuZCBlcnJvciBib3VuZHMgcmV0\ndXJuZWQgYXJlCiAgIGZvciB0aGUgb3JpZ2luYWwgdW5lcXVpbGlicmF0ZWQgc3lzdGVtLgpBcmd1\nbWVudHM6CiAgICBTb21lIG9wdGlvbmFsIHBhcmFtZXRlcnMgYXJlIGJ1bmRsZWQgaW4gdGhlIFBB\nUkFNUyBhcnJheS4gIFRoZXNlCiAgICBzZXR0aW5ncyBkZXRlcm1pbmUgaG93IHJlZmluZW1lbnQg\naXMgcGVyZm9ybWVkLCBidXQgb2Z0ZW4gdGhlCiAgICBkZWZhdWx0cyBhcmUgYWNjZXB0YWJsZS4g\nIElmIHRoZSBkZWZhdWx0cyBhcmUgYWNjZXB0YWJsZSwgdXNlcnMKICAgIGNhbiBwYXNzIE5QQVJB\nTVMgPSAwIHdoaWNoIHByZXZlbnRzIHRoZSBzb3VyY2UgY29kZSBmcm9tIGFjY2Vzc2luZwogICAg\ndGhlIFBBUkFNUyBhcmd1bWVudC4KXHBhcmFtW2luXSBVUExPCiAgICAgICAgIFVQTE8gaXMgQ0hB\nUkFDVEVSKjEKICAgICAgPSAnVSc6ICBVcHBlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZDsKICAg\nICAgPSAnTCc6ICBMb3dlciB0cmlhbmdsZSBvZiBBIGlzIHN0b3JlZC4KXHBhcmFtW2luXSBFUVVF\nRAogICAgICAgICBFUVVFRCBpcyBDSEFSQUNURVIqMQogICAgU3BlY2lmaWVzIHRoZSBmb3JtIG9m\nIGVxdWlsaWJyYXRpb24gdGhhdCB3YXMgZG9uZSB0byBBCiAgICBiZWZvcmUgY2FsbGluZyB0aGlz\nIHJvdXRpbmUuIFRoaXMgaXMgbmVlZGVkIHRvIGNvbXB1dGUKICAgIHRoZSBzb2x1dGlvbiBhbmQg\nZXJyb3IgYm91bmRzIGNvcnJlY3RseS4KICAgICAgPSAnTic6ICBObyBlcXVpbGlicmF0aW9uCiAg\nICAgID0gJ1knOiAgQm90aCByb3cgYW5kIGNvbHVtbiBlcXVpbGlicmF0aW9uLCBpLmUuLCBBIGhh\ncyBiZWVuCiAgICAgICAgICAgICAgcmVwbGFjZWQgYnkgZGlhZyhTKSAqIEEgKiBkaWFnKFMpLgog\nICAgICAgICAgICAgIFRoZSByaWdodCBoYW5kIHNpZGUgQiBoYXMgYmVlbiBjaGFuZ2VkIGFjY29y\nZGluZ2x5LgpccGFyYW1baW5dIE4KICAgICAgICAgTiBpcyBJTlRFR0VSCiAgICBUaGUgb3JkZXIg\nb2YgdGhlIG1hdHJpeCBBLiAgTiA+PSAwLgpccGFyYW1baW5dIE5SSFMKICAgICAgICAgTlJIUyBp\ncyBJTlRFR0VSCiAgICBUaGUgbnVtYmVyIG9mIHJpZ2h0IGhhbmQgc2lkZXMsIGkuZS4sIHRoZSBu\ndW1iZXIgb2YgY29sdW1ucwogICAgb2YgdGhlIG1hdHJpY2VzIEIgYW5kIFguICBOUkhTID49IDAu\nClxwYXJhbVtpbl0gQQogICAgICAgICBBIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERB\nLE4pCiAgICBUaGUgc3ltbWV0cmljIG1hdHJpeCBBLiAgSWYgVVBMTyA9ICdVJywgdGhlIGxlYWRp\nbmcgTi1ieS1OCiAgICB1cHBlciB0cmlhbmd1bGFyIHBhcnQgb2YgQSBjb250YWlucyB0aGUgdXBw\nZXIgdHJpYW5ndWxhcgogICAgcGFydCBvZiB0aGUgbWF0cml4IEEsIGFuZCB0aGUgc3RyaWN0bHkg\nbG93ZXIgdHJpYW5ndWxhcgogICAgcGFydCBvZiBBIGlzIG5vdCByZWZlcmVuY2VkLiAgSWYgVVBM\nTyA9ICdMJywgdGhlIGxlYWRpbmcKICAgIE4tYnktTiBsb3dlciB0cmlhbmd1bGFyIHBhcnQgb2Yg\nQSBjb250YWlucyB0aGUgbG93ZXIKICAgIHRyaWFuZ3VsYXIgcGFydCBvZiB0aGUgbWF0cml4IEEs\nIGFuZCB0aGUgc3RyaWN0bHkgdXBwZXIKICAgIHRyaWFuZ3VsYXIgcGFydCBvZiBBIGlzIG5vdCBy\nZWZlcmVuY2VkLgpccGFyYW1baW5dIExEQQogICAgICAgICBMREEgaXMgSU5URUdFUgogICAgVGhl\nIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBBLiAgTERBID49IG1heCgxLE4pLgpccGFy\nYW1baW5dIEFGCiAgICAgICAgIEFGIGlzIENPTVBMRVggYXJyYXksIGRpbWVuc2lvbiAoTERBRixO\nKQogICAgVGhlIGZhY3RvcmVkIGZvcm0gb2YgdGhlIG1hdHJpeCBBLiAgQUYgY29udGFpbnMgdGhl\nIGJsb2NrCiAgICBkaWFnb25hbCBtYXRyaXggRCBhbmQgdGhlIG11bHRpcGxpZXJzIHVzZWQgdG8g\nb2J0YWluIHRoZQogICAgZmFjdG9yIFUgb3IgTCBmcm9tIHRoZSBmYWN0b3JpemF0aW9uIEEgPSBV\nKkQqVSoqVCBvciBBID0KICAgIEwqRCpMKipUIGFzIGNvbXB1dGVkIGJ5IFNTWVRSRi4KXHBhcmFt\nW2luXSBMREFGCiAgICAgICAgIExEQUYgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5z\naW9uIG9mIHRoZSBhcnJheSBBRi4gIExEQUYgPj0gbWF4KDEsTikuClxwYXJhbVtpbl0gSVBJVgog\nICAgICAgICBJUElWIGlzIElOVEVHRVIgYXJyYXksIGRpbWVuc2lvbiAoTikKICAgIERldGFpbHMg\nb2YgdGhlIGludGVyY2hhbmdlcyBhbmQgdGhlIGJsb2NrIHN0cnVjdHVyZSBvZiBECiAgICBhcyBk\nZXRlcm1pbmVkIGJ5IFNTWVRSRi4KXHBhcmFtW2luLG91dF0gUwogICAgICAgICBTIGlzIFJFQUwg\nYXJyYXksIGRpbWVuc2lvbiAoTikKICAgIFRoZSBzY2FsZSBmYWN0b3JzIGZvciBBLiAgSWYgRVFV\nRUQgPSAnWScsIEEgaXMgbXVsdGlwbGllZCBvbgogICAgdGhlIGxlZnQgYW5kIHJpZ2h0IGJ5IGRp\nYWcoUykuICBTIGlzIGFuIGlucHV0IGFyZ3VtZW50IGlmIEZBQ1QgPQogICAgJ0YnOyBvdGhlcndp\nc2UsIFMgaXMgYW4gb3V0cHV0IGFyZ3VtZW50LiAgSWYgRkFDVCA9ICdGJyBhbmQgRVFVRUQKICAg\nID0gJ1knLCBlYWNoIGVsZW1lbnQgb2YgUyBtdXN0IGJlIHBvc2l0aXZlLiAgSWYgUyBpcyBvdXRw\ndXQsIGVhY2gKICAgIGVsZW1lbnQgb2YgUyBpcyBhIHBvd2VyIG9mIHRoZSByYWRpeC4gSWYgUyBp\ncyBpbnB1dCwgZWFjaCBlbGVtZW50CiAgICBvZiBTIHNob3VsZCBiZSBhIHBvd2VyIG9mIHRoZSBy\nYWRpeCB0byBlbnN1cmUgYSByZWxpYWJsZSBzb2x1dGlvbgogICAgYW5kIGVycm9yIGVzdGltYXRl\ncy4gU2NhbGluZyBieSBwb3dlcnMgb2YgdGhlIHJhZGl4IGRvZXMgbm90IGNhdXNlCiAgICByb3Vu\nZGluZyBlcnJvcnMgdW5sZXNzIHRoZSByZXN1bHQgdW5kZXJmbG93cyBvciBvdmVyZmxvd3MuCiAg\nICBSb3VuZGluZyBlcnJvcnMgZHVyaW5nIHNjYWxpbmcgbGVhZCB0byByZWZpbmluZyB3aXRoIGEg\nbWF0cml4IHRoYXQKICAgIGlzIG5vdCBlcXVpdmFsZW50IHRvIHRoZSBpbnB1dCBtYXRyaXgsIHBy\nb2R1Y2luZyBlcnJvciBlc3RpbWF0ZXMKICAgIHRoYXQgbWF5IG5vdCBiZSByZWxpYWJsZS4KXHBh\ncmFtW2luXSBCCiAgICAgICAgIEIgaXMgQ09NUExFWCBhcnJheSwgZGltZW5zaW9uIChMREIsTlJI\nUykKICAgIFRoZSByaWdodCBoYW5kIHNpZGUgbWF0cml4IEIuClxwYXJhbVtpbl0gTERCCiAgICAg\nICAgIExEQiBpcyBJTlRFR0VSCiAgICBUaGUgbGVhZGluZyBkaW1lbnNpb24gb2YgdGhlIGFycmF5\nIEIuICBMREIgPj0gbWF4KDEsTikuClxwYXJhbVtpbixvdXRdIFgKICAgICAgICAgWCBpcyBDT01Q\nTEVYIGFycmF5LCBkaW1lbnNpb24gKExEWCxOUkhTKQogICAgT24gZW50cnksIHRoZSBzb2x1dGlv\nbiBtYXRyaXggWCwgYXMgY29tcHV0ZWQgYnkgU0dFVFJTLgogICAgT24gZXhpdCwgdGhlIGltcHJv\ndmVkIHNvbHV0aW9uIG1hdHJpeCBYLgpccGFyYW1baW5dIExEWAogICAgICAgICBMRFggaXMgSU5U\nRUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBYLiAgTERYID49IG1h\neCgxLE4pLgpccGFyYW1bb3V0XSBSQ09ORAogICAgICAgICBSQ09ORCBpcyBSRUFMCiAgICBSZWNp\ncHJvY2FsIHNjYWxlZCBjb25kaXRpb24gbnVtYmVyLiAgVGhpcyBpcyBhbiBlc3RpbWF0ZSBvZiB0\naGUKICAgIHJlY2lwcm9jYWwgU2tlZWwgY29uZGl0aW9uIG51bWJlciBvZiB0aGUgbWF0cml4IEEg\nYWZ0ZXIKICAgIGVxdWlsaWJyYXRpb24gKGlmIGRvbmUpLiAgSWYgdGhpcyBpcyBsZXNzIHRoYW4g\ndGhlIG1hY2hpbmUKICAgIHByZWNpc2lvbiAoaW4gcGFydGljdWxhciwgaWYgaXQgaXMgemVybyks\nIHRoZSBtYXRyaXggaXMgc2luZ3VsYXIKICAgIHRvIHdvcmtpbmcgcHJlY2lzaW9uLiAgTm90ZSB0\naGF0IHRoZSBlcnJvciBtYXkgc3RpbGwgYmUgc21hbGwgZXZlbgogICAgaWYgdGhpcyBudW1iZXIg\naXMgdmVyeSBzbWFsbCBhbmQgdGhlIG1hdHJpeCBhcHBlYXJzIGlsbC0KICAgIGNvbmRpdGlvbmVk\nLgpccGFyYW1bb3V0XSBCRVJSCiAgICAgICAgIEJFUlIgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9u\nIChOUkhTKQogICAgQ29tcG9uZW50d2lzZSByZWxhdGl2ZSBiYWNrd2FyZCBlcnJvci4gIFRoaXMg\naXMgdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGJhY2t3YXJkIGVycm9yIG9mIGVhY2gg\nc29sdXRpb24gdmVjdG9yIFgoaikKICAgIChpLmUuLCB0aGUgc21hbGxlc3QgcmVsYXRpdmUgY2hh\nbmdlIGluIGFueSBlbGVtZW50IG9mIEEgb3IgQiB0aGF0CiAgICBtYWtlcyBYKGopIGFuIGV4YWN0\nIHNvbHV0aW9uKS4KXHBhcmFtW2luXSBOX0VSUl9CTkRTCiAgICAgICAgIE5fRVJSX0JORFMgaXMg\nSU5URUdFUgogICAgTnVtYmVyIG9mIGVycm9yIGJvdW5kcyB0byByZXR1cm4gZm9yIGVhY2ggcmln\naHQgaGFuZCBzaWRlCiAgICBhbmQgZWFjaCB0eXBlIChub3Jtd2lzZSBvciBjb21wb25lbnR3aXNl\nKS4gIFNlZSBFUlJfQk5EU19OT1JNIGFuZAogICAgRVJSX0JORFNfQ09NUCBiZWxvdy4KXHBhcmFt\nW291dF0gRVJSX0JORFNfTk9STQogICAgICAgICBFUlJfQk5EU19OT1JNIGlzIFJFQUwgYXJyYXks\nIGRpbWVuc2lvbiAoTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0LWhhbmQgc2lk\nZSwgdGhpcyBhcnJheSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFyaW91cyBlcnJv\nciBib3VuZHMgYW5kIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8gdGhlCiAgICBu\nb3Jtd2lzZSByZWxhdGl2ZSBlcnJvciwgd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dzOgogICAg\nTm9ybXdpc2UgcmVsYXRpdmUgZXJyb3IgaW4gdGhlIGl0aCBzb2x1dGlvbiB2ZWN0b3I6CiAgICAg\nICAgICAgIG1heF9qIChhYnMoWFRSVUUoaixpKSAtIFgoaixpKSkpCiAgICAgICAgICAgLS0tLS0t\nLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgICAgICAgICAgICAgICAgbWF4X2ogYWJzKFgoaixp\nKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSB0eXBlIG9mIGVycm9yIGluZm9ybWF0\naW9uIGFzIGRlc2NyaWJlZAogICAgYmVsb3cuIFRoZXJlIGN1cnJlbnRseSBhcmUgdXAgdG8gdGhy\nZWUgcGllY2VzIG9mIGluZm9ybWF0aW9uCiAgICByZXR1cm5lZC4KICAgIFRoZSBmaXJzdCBpbmRl\neCBpbiBFUlJfQk5EU19OT1JNKGksOikgY29ycmVzcG9uZHMgdG8gdGhlIGl0aAogICAgcmlnaHQt\naGFuZCBzaWRlLgogICAgVGhlIHNlY29uZCBpbmRleCBpbiBFUlJfQk5EU19OT1JNKDosZXJyKSBj\nb250YWlucyB0aGUgZm9sbG93aW5nCiAgICB0aHJlZSBmaWVsZHM6CiAgICBlcnIgPSAxICJUcnVz\ndC9kb24ndCB0cnVzdCIgYm9vbGVhbi4gVHJ1c3QgdGhlIGFuc3dlciBpZiB0aGUKICAgICAgICAg\nICAgIHJlY2lwcm9jYWwgY29uZGl0aW9uIG51bWJlciBpcyBsZXNzIHRoYW4gdGhlIHRocmVzaG9s\nZAogICAgICAgICAgICAgc3FydChuKSAqIHNsYW1jaCgnRXBzaWxvbicpLgogICAgZXJyID0gMiAi\nR3VhcmFudGVlZCIgZXJyb3IgYm91bmQ6IFRoZSBlc3RpbWF0ZWQgZm9yd2FyZCBlcnJvciwKICAg\nICAgICAgICAgIGFsbW9zdCBjZXJ0YWlubHkgd2l0aGluIGEgZmFjdG9yIG9mIDEwIG9mIHRoZSB0\ncnVlIGVycm9yCiAgICAgICAgICAgICBzbyBsb25nIGFzIHRoZSBuZXh0IGVudHJ5IGlzIGdyZWF0\nZXIgdGhhbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogc2xhbWNoKCdFcHNp\nbG9uJykuIFRoaXMgZXJyb3IgYm91bmQgc2hvdWxkIG9ubHkKICAgICAgICAgICAgIGJlIHRydXN0\nZWQgaWYgdGhlIHByZXZpb3VzIGJvb2xlYW4gaXMgdHJ1ZS4KICAgIGVyciA9IDMgIFJlY2lwcm9j\nYWwgY29uZGl0aW9uIG51bWJlcjogRXN0aW1hdGVkIG5vcm13aXNlCiAgICAgICAgICAgICByZWNp\ncHJvY2FsIGNvbmRpdGlvbiBudW1iZXIuICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAg\nICAgICAgICAgIHNxcnQobikgKiBzbGFtY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhl\nIGVycm9yCiAgICAgICAgICAgICBlc3RpbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lw\ncm9jYWwgY29uZGl0aW9uCiAgICAgICAgICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9\nLGluZikgKiBub3JtKFosaW5mKSkgZm9yIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkg\nc2NhbGVkIG1hdHJpeCBaLgogICAgICAgICAgICAgTGV0IFogPSBTKkEsIHdoZXJlIFMgc2NhbGVz\nIGVhY2ggcm93IGJ5IGEgcG93ZXIgb2YgdGhlCiAgICAgICAgICAgICByYWRpeCBzbyBhbGwgYWJz\nb2x1dGUgcm93IHN1bXMgb2YgWiBhcmUgYXBwcm94aW1hdGVseSAxLgogICAgU2VlIExhcGFjayBX\nb3JraW5nIE5vdGUgMTY1IGZvciBmdXJ0aGVyIGRldGFpbHMgYW5kIGV4dHJhCiAgICBjYXV0aW9u\ncy4KXHBhcmFtW291dF0gRVJSX0JORFNfQ09NUAogICAgICAgICBFUlJfQk5EU19DT01QIGlzIFJF\nQUwgYXJyYXksIGRpbWVuc2lvbiAoTlJIUywgTl9FUlJfQk5EUykKICAgIEZvciBlYWNoIHJpZ2h0\nLWhhbmQgc2lkZSwgdGhpcyBhcnJheSBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dAogICAgdmFy\naW91cyBlcnJvciBib3VuZHMgYW5kIGNvbmRpdGlvbiBudW1iZXJzIGNvcnJlc3BvbmRpbmcgdG8g\ndGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yLCB3aGljaCBpcyBkZWZpbmVkIGFz\nIGZvbGxvd3M6CiAgICBDb21wb25lbnR3aXNlIHJlbGF0aXZlIGVycm9yIGluIHRoZSBpdGggc29s\ndXRpb24gdmVjdG9yOgogICAgICAgICAgICAgICAgICAgYWJzKFhUUlVFKGosaSkgLSBYKGosaSkp\nCiAgICAgICAgICAgIG1heF9qIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0KICAgICAgICAgICAgICAg\nICAgICAgICAgYWJzKFgoaixpKSkKICAgIFRoZSBhcnJheSBpcyBpbmRleGVkIGJ5IHRoZSByaWdo\ndC1oYW5kIHNpZGUgaSAob24gd2hpY2ggdGhlCiAgICBjb21wb25lbnR3aXNlIHJlbGF0aXZlIGVy\ncm9yIGRlcGVuZHMpLCBhbmQgdGhlIHR5cGUgb2YgZXJyb3IKICAgIGluZm9ybWF0aW9uIGFzIGRl\nc2NyaWJlZCBiZWxvdy4gVGhlcmUgY3VycmVudGx5IGFyZSB1cCB0byB0aHJlZQogICAgcGllY2Vz\nIG9mIGluZm9ybWF0aW9uIHJldHVybmVkIGZvciBlYWNoIHJpZ2h0LWhhbmQgc2lkZS4gSWYKICAg\nIGNvbXBvbmVudHdpc2UgYWNjdXJhY3kgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1TKDMpID0gMC4w\nKSwgdGhlbgogICAgRVJSX0JORFNfQ09NUCBpcyBub3QgYWNjZXNzZWQuICBJZiBOX0VSUl9CTkRT\nIC5MVC4gMywgdGhlbiBhdCBtb3N0CiAgICB0aGUgZmlyc3QgKDosTl9FUlJfQk5EUykgZW50cmll\ncyBhcmUgcmV0dXJuZWQuCiAgICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfQ09NUChpLDop\nIGNvcnJlc3BvbmRzIHRvIHRoZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBzZWNv\nbmQgaW5kZXggaW4gRVJSX0JORFNfQ09NUCg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2luZwog\nICAgdGhyZWUgZmllbGRzOgogICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xlYW4u\nIFRydXN0IHRoZSBhbnN3ZXIgaWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlv\nbiBudW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikg\nKiBzbGFtY2goJ0Vwc2lsb24nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJvdW5k\nOiBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2VydGFp\nbmx5IHdpdGhpbiBhIGZhY3RvciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAgICAg\nc28gbG9uZyBhcyB0aGUgbmV4dCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9sZAog\nICAgICAgICAgICAgc3FydChuKSAqIHNsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJvdW5k\nIHNob3VsZCBvbmx5CiAgICAgICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBib29s\nZWFuIGlzIHRydWUuCiAgICBlcnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6IEVz\ndGltYXRlZCBjb21wb25lbnR3aXNlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRpdGlvbiBu\ndW1iZXIuICBDb21wYXJlZCB3aXRoIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQobikg\nKiBzbGFtY2goJ0Vwc2lsb24nKSB0byBkZXRlcm1pbmUgaWYgdGhlIGVycm9yCiAgICAgICAgICAg\nICBlc3RpbWF0ZSBpcyAiZ3VhcmFudGVlZCIuIFRoZXNlIHJlY2lwcm9jYWwgY29uZGl0aW9uCiAg\nICAgICAgICAgICBudW1iZXJzIGFyZSAxIC8gKG5vcm0oWl57LTF9LGluZikgKiBub3JtKFosaW5m\nKSkgZm9yIHNvbWUKICAgICAgICAgICAgIGFwcHJvcHJpYXRlbHkgc2NhbGVkIG1hdHJpeCBaLgog\nICAgICAgICAgICAgTGV0IFogPSBTKihBKmRpYWcoeCkpLCB3aGVyZSB4IGlzIHRoZSBzb2x1dGlv\nbiBmb3IgdGhlCiAgICAgICAgICAgICBjdXJyZW50IHJpZ2h0LWhhbmQgc2lkZSBhbmQgUyBzY2Fs\nZXMgZWFjaCByb3cgb2YKICAgICAgICAgICAgIEEqZGlhZyh4KSBieSBhIHBvd2VyIG9mIHRoZSBy\nYWRpeCBzbyBhbGwgYWJzb2x1dGUgcm93CiAgICAgICAgICAgICBzdW1zIG9mIFogYXJlIGFwcHJv\neGltYXRlbHkgMS4KICAgIFNlZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3IgZnVydGhlciBk\nZXRhaWxzIGFuZCBleHRyYQogICAgY2F1dGlvbnMuClxwYXJhbVtpbl0gTlBBUkFNUwogICAgICAg\nICBOUEFSQU1TIGlzIElOVEVHRVIKICAgIFNwZWNpZmllcyB0aGUgbnVtYmVyIG9mIHBhcmFtZXRl\ncnMgc2V0IGluIFBBUkFNUy4gIElmIC5MRS4gMCwgdGhlCiAgICBQQVJBTVMgYXJyYXkgaXMgbmV2\nZXIgcmVmZXJlbmNlZCBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIHVzZWQuClxwYXJhbVtpbixvdXRd\nIFBBUkFNUwogICAgICAgICBQQVJBTVMgaXMgUkVBTCBhcnJheSwgZGltZW5zaW9uIE5QQVJBTVMK\nICAgIFNwZWNpZmllcyBhbGdvcml0aG0gcGFyYW1ldGVycy4gIElmIGFuIGVudHJ5IGlzIC5MVC4g\nMC4wLCB0aGVuCiAgICB0aGF0IGVudHJ5IHdpbGwgYmUgZmlsbGVkIHdpdGggZGVmYXVsdCB2YWx1\nZSB1c2VkIGZvciB0aGF0CiAgICBwYXJhbWV0ZXIuICBPbmx5IHBvc2l0aW9ucyB1cCB0byBOUEFS\nQU1TIGFyZSBhY2Nlc3NlZDsgZGVmYXVsdHMKICAgIGFyZSB1c2VkIGZvciBoaWdoZXItbnVtYmVy\nZWQgcGFyYW1ldGVycy4KICAgICAgUEFSQU1TKExBX0xJTlJYX0lUUkVGX0kgPSAxKSA6IFdoZXRo\nZXIgdG8gcGVyZm9ybSBpdGVyYXRpdmUKICAgICAgICAgICByZWZpbmVtZW50IG9yIG5vdC4KICAg\nICAgICBEZWZhdWx0OiAxLjAKICAgICAgICAgICA9IDAuMCA6IE5vIHJlZmluZW1lbnQgaXMgcGVy\nZm9ybWVkLCBhbmQgbm8gZXJyb3IgYm91bmRzIGFyZQogICAgICAgICAgICAgICAgICAgY29tcHV0\nZWQuCiAgICAgICAgICAgPSAxLjAgOiBVc2UgdGhlIGRvdWJsZS1wcmVjaXNpb24gcmVmaW5lbWVu\ndCBhbGdvcml0aG0sCiAgICAgICAgICAgICAgICAgICBwb3NzaWJseSB3aXRoIGRvdWJsZWQtc2lu\nZ2xlIGNvbXB1dGF0aW9ucyBpZiB0aGUKICAgICAgICAgICAgICAgICAgIGNvbXBpbGF0aW9uIGVu\ndmlyb25tZW50IGRvZXMgbm90IHN1cHBvcnQgRE9VQkxFCiAgICAgICAgICAgICAgICAgICBQUkVD\nSVNJT04uCiAgICAgICAgICAgICAob3RoZXIgdmFsdWVzIGFyZSByZXNlcnZlZCBmb3IgZnV0dXJl\nIHVzZSkKICAgICAgUEFSQU1TKExBX0xJTlJYX0lUSFJFU0hfSSA9IDIpIDogTWF4aW11bSBudW1i\nZXIgb2YgcmVzaWR1YWwKICAgICAgICAgICBjb21wdXRhdGlvbnMgYWxsb3dlZCBmb3IgcmVmaW5l\nbWVudC4KICAgICAgICBEZWZhdWx0OiAxMAogICAgICAgIEFnZ3Jlc3NpdmU6IFNldCB0byAxMDAg\ndG8gcGVybWl0IGNvbnZlcmdlbmNlIHVzaW5nIGFwcHJveGltYXRlCiAgICAgICAgICAgICAgICAg\nICAgZmFjdG9yaXphdGlvbnMgb3IgZmFjdG9yaXphdGlvbnMgb3RoZXIgdGhhbiBMVS4gSWYKICAg\nICAgICAgICAgICAgICAgICB0aGUgZmFjdG9yaXphdGlvbiB1c2VzIGEgdGVjaG5pcXVlIG90aGVy\nIHRoYW4KICAgICAgICAgICAgICAgICAgICBHYXVzc2lhbiBlbGltaW5hdGlvbiwgdGhlIGd1YXJh\nbnRlZXMgaW4KICAgICAgICAgICAgICAgICAgICBlcnJfYm5kc19ub3JtIGFuZCBlcnJfYm5kc19j\nb21wIG1heSBubyBsb25nZXIgYmUKICAgICAgICAgICAgICAgICAgICB0cnVzdHdvcnRoeS4KICAg\nICAgUEFSQU1TKExBX0xJTlJYX0NXSVNFX0kgPSAzKSA6IEZsYWcgZGV0ZXJtaW5pbmcgaWYgdGhl\nIGNvZGUKICAgICAgICAgICB3aWxsIGF0dGVtcHQgdG8gZmluZCBhIHNvbHV0aW9uIHdpdGggc21h\nbGwgY29tcG9uZW50d2lzZQogICAgICAgICAgIHJlbGF0aXZlIGVycm9yIGluIHRoZSBkb3VibGUt\ncHJlY2lzaW9uIGFsZ29yaXRobS4gIFBvc2l0aXZlCiAgICAgICAgICAgaXMgdHJ1ZSwgMC4wIGlz\nIGZhbHNlLgogICAgICAgIERlZmF1bHQ6IDEuMCAoYXR0ZW1wdCBjb21wb25lbnR3aXNlIGNvbnZl\ncmdlbmNlKQpccGFyYW1bb3V0XSBXT1JLCiAgICAgICAgIFdPUksgaXMgQ09NUExFWCBhcnJheSwg\nZGltZW5zaW9uICgyKk4pClxwYXJhbVtvdXRdIFJXT1JLCiAgICAgICAgIFJXT1JLIGlzIFJFQUwg\nYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBJTkZPCiAgICAgICAgIElORk8gaXMg\nSU5URUdFUgogICAgICA9IDA6ICBTdWNjZXNzZnVsIGV4aXQuIFRoZSBzb2x1dGlvbiB0byBldmVy\neSByaWdodC1oYW5kIHNpZGUgaXMKICAgICAgICBndWFyYW50ZWVkLgogICAgICA8IDA6ICBJZiBJ\nTkZPID0gLWksIHRoZSBpLXRoIGFyZ3VtZW50IGhhZCBhbiBpbGxlZ2FsIHZhbHVlCiAgICAgID4g\nMCBhbmQgPD0gTjogIFUoSU5GTyxJTkZPKSBpcyBleGFjdGx5IHplcm8uICBUaGUgZmFjdG9yaXph\ndGlvbgogICAgICAgIGhhcyBiZWVuIGNvbXBsZXRlZCwgYnV0IHRoZSBmYWN0b3IgVSBpcyBleGFj\ndGx5IHNpbmd1bGFyLCBzbwogICAgICAgIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIGNv\ndWxkIG5vdCBiZSBjb21wdXRlZC4gUkNPTkQgPSAwCiAgICAgICAgaXMgcmV0dXJuZWQuCiAgICAg\nID0gTitKOiBUaGUgc29sdXRpb24gY29ycmVzcG9uZGluZyB0byB0aGUgSnRoIHJpZ2h0LWhhbmQg\nc2lkZSBpcwogICAgICAgIG5vdCBndWFyYW50ZWVkLiBUaGUgc29sdXRpb25zIGNvcnJlc3BvbmRp\nbmcgdG8gb3RoZXIgcmlnaHQtCiAgICAgICAgaGFuZCBzaWRlcyBLIHdpdGggSyA+IEogbWF5IG5v\ndCBiZSBndWFyYW50ZWVkIGFzIHdlbGwsIGJ1dAogICAgICAgIG9ubHkgdGhlIGZpcnN0IHN1Y2gg\ncmlnaHQtaGFuZCBzaWRlIGlzIHJlcG9ydGVkLiBJZiBhIHNtYWxsCiAgICAgICAgY29tcG9uZW50\nd2lzZSBlcnJvciBpcyBub3QgcmVxdWVzdGVkIChQQVJBTVMoMykgPSAwLjApIHRoZW4KICAgICAg\nICB0aGUgSnRoIHJpZ2h0LWhhbmQgc2lkZSBpcyB0aGUgZmlyc3Qgd2l0aCBhIG5vcm13aXNlIGVy\ncm9yCiAgICAgICAgYm91bmQgdGhhdCBpcyBub3QgZ3VhcmFudGVlZCAodGhlIHNtYWxsZXN0IEog\nc3VjaAogICAgICAgIHRoYXQgRVJSX0JORFNfTk9STShKLDEpID0gMC4wKS4gQnkgZGVmYXVsdCAo\nUEFSQU1TKDMpID0gMS4wKQogICAgICAgIHRoZSBKdGggcmlnaHQtaGFuZCBzaWRlIGlzIHRoZSBm\naXJzdCB3aXRoIGVpdGhlciBhIG5vcm13aXNlIG9yCiAgICAgICAgY29tcG9uZW50d2lzZSBlcnJv\nciBib3VuZCB0aGF0IGlzIG5vdCBndWFyYW50ZWVkICh0aGUgc21hbGxlc3QKICAgICAgICBKIHN1\nY2ggdGhhdCBlaXRoZXIgRVJSX0JORFNfTk9STShKLDEpID0gMC4wIG9yCiAgICAgICAgRVJSX0JO\nRFNfQ09NUChKLDEpID0gMC4wKS4gU2VlIHRoZSBkZWZpbml0aW9uIG9mCiAgICAgICAgRVJSX0JO\nRFNfTk9STSg6LDEpIGFuZCBFUlJfQk5EU19DT01QKDosMSkuIFRvIGdldCBpbmZvcm1hdGlvbgog\nICAgICAgIGFib3V0IGFsbCBvZiB0aGUgcmlnaHQtaGFuZCBzaWRlcyBjaGVjayBFUlJfQk5EU19O\nT1JNIG9yCiAgICAgICAgRVJSX0JORFNfQ09NUC4KQXV0aG9yczoKXGF1dGhvciBVbml2LiBvZiBU\nZW5uZXNzZWUgClxhdXRob3IgVW5pdi4gb2YgQ2FsaWZvcm5pYSBCZXJrZWxleSAKXGF1dGhvciBV\nbml2LiBvZiBDb2xvcmFkbyBEZW52ZXIgClxhdXRob3IgTkFHIEx0ZC4gClxkYXRlIEFwcmlsIDIw\nMTIKXGluZ3JvdXAgY29tcGxleEhFY29tcHV0YXRpb25hbApoHWgeKYFyTwIAAH1yUAIAAChoIYlo\nImgjdWJoLYoCqwFoLlgPAAAAY2hlcmZzeF80MjcudHh0dWJoL4oCqwFoMFgGAAAAaGVyZnN4aC2K\nAUV1YmgVaBZdaBeHUnJRAgAAfXJSAgAAKGgaWAkAAABIZXJtaXRpYW5oG1gEAAAAZnVsbGgcWEYA\nAABlcnJvciBib3VuZHMgYW5kIGJhY2t3YXJkIGVycm9yIGVzdGltYXRlczsgaXRlcmF0aXZlIHJl\nZmluZW1lbnQ7IEVRVUVEaB1oHimBclMCAAB9clQCAAAoaCGJaCJoI3ViaCRYIQAAAERveHlnZW4v\nZG9jcy9odG1sL3poZXJmc3hfOGYuaHRtbGglWAEAAAB6aCZoFWgnXWgXh1JyVQIAAH1yVgIAACho\nKlgVMgAAICAgWkhFUkZTWCBpbXByb3ZlcyB0aGUgY29tcHV0ZWQgc29sdXRpb24gdG8gYSBzeXN0\nZW0gb2YgbGluZWFyCiAgIGVxdWF0aW9ucyB3aGVuIHRoZSBjb2VmZmljaWVudCBtYXRyaXggaXMg\nSGVybWl0aWFuIGluZGVmaW5pdGUsIGFuZAogICBwcm92aWRlcyBlcnJvciBib3VuZHMgYW5kIGJh\nY2t3YXJkIGVycm9yIGVzdGltYXRlcyBmb3IgdGhlCiAgIHNvbHV0aW9uLiAgSW4gYWRkaXRpb24g\ndG8gbm9ybXdpc2UgZXJyb3IgYm91bmQsIHRoZSBjb2RlIHByb3ZpZGVzCiAgIG1heGltdW0gY29t\ncG9uZW50d2lzZSBlcnJvciBib3VuZCBpZiBwb3NzaWJsZS4gIFNlZSBjb21tZW50cyBmb3IKICAg\nRVJSX0JORFNfTk9STSBhbmQgRVJSX0JORFNfQ09NUCBmb3IgZGV0YWlscyBvZiB0aGUgZXJyb3Ig\nYm91bmRzLgogICBUaGUgb3JpZ2luYWwgc3lzdGVtIG9mIGxpbmVhciBlcXVhdGlvbnMgbWF5IGhh\ndmUgYmVlbiBlcXVpbGlicmF0ZWQKICAgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0aW5lLCBhcyBk\nZXNjcmliZWQgYnkgYXJndW1lbnRzIEVRVUVEIGFuZCBTCiAgIGJlbG93LiBJbiB0aGlzIGNhc2Us\nIHRoZSBzb2x1dGlvbiBhbmQgZXJyb3IgYm91bmRzIHJldHVybmVkIGFyZQogICBmb3IgdGhlIG9y\naWdpbmFsIHVuZXF1aWxpYnJhdGVkIHN5c3RlbS4KQXJndW1lbnRzOgogICAgU29tZSBvcHRpb25h\nbCBwYXJhbWV0ZXJzIGFyZSBidW5kbGVkIGluIHRoZSBQQVJBTVMgYXJyYXkuICBUaGVzZQogICAg\nc2V0dGluZ3MgZGV0ZXJtaW5lIGhvdyByZWZpbmVtZW50IGlzIHBlcmZvcm1lZCwgYnV0IG9mdGVu\nIHRoZQogICAgZGVmYXVsdHMgYXJlIGFjY2VwdGFibGUuICBJZiB0aGUgZGVmYXVsdHMgYXJlIGFj\nY2VwdGFibGUsIHVzZXJzCiAgICBjYW4gcGFzcyBOUEFSQU1TID0gMCB3aGljaCBwcmV2ZW50cyB0\naGUgc291cmNlIGNvZGUgZnJvbSBhY2Nlc3NpbmcKICAgIHRoZSBQQVJBTVMgYXJndW1lbnQuClxw\nYXJhbVtpbl0gVVBMTwogICAgICAgICBVUExPIGlzIENIQVJBQ1RFUioxCiAgICAgID0gJ1UnOiAg\nVXBwZXIgdHJpYW5nbGUgb2YgQSBpcyBzdG9yZWQ7CiAgICAgID0gJ0wnOiAgTG93ZXIgdHJpYW5n\nbGUgb2YgQSBpcyBzdG9yZWQuClxwYXJhbVtpbl0gRVFVRUQKICAgICAgICAgRVFVRUQgaXMgQ0hB\nUkFDVEVSKjEKICAgIFNwZWNpZmllcyB0aGUgZm9ybSBvZiBlcXVpbGlicmF0aW9uIHRoYXQgd2Fz\nIGRvbmUgdG8gQQogICAgYmVmb3JlIGNhbGxpbmcgdGhpcyByb3V0aW5lLiBUaGlzIGlzIG5lZWRl\nZCB0byBjb21wdXRlCiAgICB0aGUgc29sdXRpb24gYW5kIGVycm9yIGJvdW5kcyBjb3JyZWN0bHku\nCiAgICAgID0gJ04nOiAgTm8gZXF1aWxpYnJhdGlvbgogICAgICA9ICdZJzogIEJvdGggcm93IGFu\nZCBjb2x1bW4gZXF1aWxpYnJhdGlvbiwgaS5lLiwgQSBoYXMgYmVlbgogICAgICAgICAgICAgIHJl\ncGxhY2VkIGJ5IGRpYWcoUykgKiBBICogZGlhZyhTKS4KICAgICAgICAgICAgICBUaGUgcmlnaHQg\naGFuZCBzaWRlIEIgaGFzIGJlZW4gY2hhbmdlZCBhY2NvcmRpbmdseS4KXHBhcmFtW2luXSBOCiAg\nICAgICAgIE4gaXMgSU5URUdFUgogICAgVGhlIG9yZGVyIG9mIHRoZSBtYXRyaXggQS4gIE4gPj0g\nMC4KXHBhcmFtW2luXSBOUkhTCiAgICAgICAgIE5SSFMgaXMgSU5URUdFUgogICAgVGhlIG51bWJl\nciBvZiByaWdodCBoYW5kIHNpZGVzLCBpLmUuLCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMKICAgIG9m\nIHRoZSBtYXRyaWNlcyBCIGFuZCBYLiAgTlJIUyA+PSAwLgpccGFyYW1baW5dIEEKICAgICAgICAg\nQSBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQSxOKQogICAgVGhlIHN5bW1ldHJp\nYyBtYXRyaXggQS4gIElmIFVQTE8gPSAnVScsIHRoZSBsZWFkaW5nIE4tYnktTgogICAgdXBwZXIg\ndHJpYW5ndWxhciBwYXJ0IG9mIEEgY29udGFpbnMgdGhlIHVwcGVyIHRyaWFuZ3VsYXIKICAgIHBh\ncnQgb2YgdGhlIG1hdHJpeCBBLCBhbmQgdGhlIHN0cmljdGx5IGxvd2VyIHRyaWFuZ3VsYXIKICAg\nIHBhcnQgb2YgQSBpcyBub3QgcmVmZXJlbmNlZC4gIElmIFVQTE8gPSAnTCcsIHRoZSBsZWFkaW5n\nCiAgICBOLWJ5LU4gbG93ZXIgdHJpYW5ndWxhciBwYXJ0IG9mIEEgY29udGFpbnMgdGhlIGxvd2Vy\nCiAgICB0cmlhbmd1bGFyIHBhcnQgb2YgdGhlIG1hdHJpeCBBLCBhbmQgdGhlIHN0cmljdGx5IHVw\ncGVyCiAgICB0cmlhbmd1bGFyIHBhcnQgb2YgQSBpcyBub3QgcmVmZXJlbmNlZC4KXHBhcmFtW2lu\nXSBMREEKICAgICAgICAgTERBIGlzIElOVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBv\nZiB0aGUgYXJyYXkgQS4gIExEQSA+PSBtYXgoMSxOKS4KXHBhcmFtW2luXSBBRgogICAgICAgICBB\nRiBpcyBDT01QTEVYKjE2IGFycmF5LCBkaW1lbnNpb24gKExEQUYsTikKICAgIFRoZSBmYWN0b3Jl\nZCBmb3JtIG9mIHRoZSBtYXRyaXggQS4gIEFGIGNvbnRhaW5zIHRoZSBibG9jawogICAgZGlhZ29u\nYWwgbWF0cml4IEQgYW5kIHRoZSBtdWx0aXBsaWVycyB1c2VkIHRvIG9idGFpbiB0aGUKICAgIGZh\nY3RvciBVIG9yIEwgZnJvbSB0aGUgZmFjdG9yaXphdGlvbiBBID0gVSpEKlUqKlQgb3IgQSA9CiAg\nICBMKkQqTCoqVCBhcyBjb21wdXRlZCBieSBEU1lUUkYuClxwYXJhbVtpbl0gTERBRgogICAgICAg\nICBMREFGIGlzIElOVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkg\nQUYuICBMREFGID49IG1heCgxLE4pLgpccGFyYW1baW5dIElQSVYKICAgICAgICAgSVBJViBpcyBJ\nTlRFR0VSIGFycmF5LCBkaW1lbnNpb24gKE4pCiAgICBEZXRhaWxzIG9mIHRoZSBpbnRlcmNoYW5n\nZXMgYW5kIHRoZSBibG9jayBzdHJ1Y3R1cmUgb2YgRAogICAgYXMgZGV0ZXJtaW5lZCBieSBEU1lU\nUkYuClxwYXJhbVtpbixvdXRdIFMKICAgICAgICAgUyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5\nLCBkaW1lbnNpb24gKE4pCiAgICBUaGUgc2NhbGUgZmFjdG9ycyBmb3IgQS4gIElmIEVRVUVEID0g\nJ1knLCBBIGlzIG11bHRpcGxpZWQgb24KICAgIHRoZSBsZWZ0IGFuZCByaWdodCBieSBkaWFnKFMp\nLiAgUyBpcyBhbiBpbnB1dCBhcmd1bWVudCBpZiBGQUNUID0KICAgICdGJzsgb3RoZXJ3aXNlLCBT\nIGlzIGFuIG91dHB1dCBhcmd1bWVudC4gIElmIEZBQ1QgPSAnRicgYW5kIEVRVUVECiAgICA9ICdZ\nJywgZWFjaCBlbGVtZW50IG9mIFMgbXVzdCBiZSBwb3NpdGl2ZS4gIElmIFMgaXMgb3V0cHV0LCBl\nYWNoCiAgICBlbGVtZW50IG9mIFMgaXMgYSBwb3dlciBvZiB0aGUgcmFkaXguIElmIFMgaXMgaW5w\ndXQsIGVhY2ggZWxlbWVudAogICAgb2YgUyBzaG91bGQgYmUgYSBwb3dlciBvZiB0aGUgcmFkaXgg\ndG8gZW5zdXJlIGEgcmVsaWFibGUgc29sdXRpb24KICAgIGFuZCBlcnJvciBlc3RpbWF0ZXMuIFNj\nYWxpbmcgYnkgcG93ZXJzIG9mIHRoZSByYWRpeCBkb2VzIG5vdCBjYXVzZQogICAgcm91bmRpbmcg\nZXJyb3JzIHVubGVzcyB0aGUgcmVzdWx0IHVuZGVyZmxvd3Mgb3Igb3ZlcmZsb3dzLgogICAgUm91\nbmRpbmcgZXJyb3JzIGR1cmluZyBzY2FsaW5nIGxlYWQgdG8gcmVmaW5pbmcgd2l0aCBhIG1hdHJp\neCB0aGF0CiAgICBpcyBub3QgZXF1aXZhbGVudCB0byB0aGUgaW5wdXQgbWF0cml4LCBwcm9kdWNp\nbmcgZXJyb3IgZXN0aW1hdGVzCiAgICB0aGF0IG1heSBub3QgYmUgcmVsaWFibGUuClxwYXJhbVtp\nbl0gQgogICAgICAgICBCIGlzIENPTVBMRVgqMTYgYXJyYXksIGRpbWVuc2lvbiAoTERCLE5SSFMp\nCiAgICBUaGUgcmlnaHQgaGFuZCBzaWRlIG1hdHJpeCBCLgpccGFyYW1baW5dIExEQgogICAgICAg\nICBMREIgaXMgSU5URUdFUgogICAgVGhlIGxlYWRpbmcgZGltZW5zaW9uIG9mIHRoZSBhcnJheSBC\nLiAgTERCID49IG1heCgxLE4pLgpccGFyYW1baW4sb3V0XSBYCiAgICAgICAgIFggaXMgQ09NUExF\nWCoxNiBhcnJheSwgZGltZW5zaW9uIChMRFgsTlJIUykKICAgIE9uIGVudHJ5LCB0aGUgc29sdXRp\nb24gbWF0cml4IFgsIGFzIGNvbXB1dGVkIGJ5IERHRVRSUy4KICAgIE9uIGV4aXQsIHRoZSBpbXBy\nb3ZlZCBzb2x1dGlvbiBtYXRyaXggWC4KXHBhcmFtW2luXSBMRFgKICAgICAgICAgTERYIGlzIElO\nVEVHRVIKICAgIFRoZSBsZWFkaW5nIGRpbWVuc2lvbiBvZiB0aGUgYXJyYXkgWC4gIExEWCA+PSBt\nYXgoMSxOKS4KXHBhcmFtW291dF0gUkNPTkQKICAgICAgICAgUkNPTkQgaXMgRE9VQkxFIFBSRUNJ\nU0lPTgogICAgUmVjaXByb2NhbCBzY2FsZWQgY29uZGl0aW9uIG51bWJlci4gIFRoaXMgaXMgYW4g\nZXN0aW1hdGUgb2YgdGhlCiAgICByZWNpcHJvY2FsIFNrZWVsIGNvbmRpdGlvbiBudW1iZXIgb2Yg\ndGhlIG1hdHJpeCBBIGFmdGVyCiAgICBlcXVpbGlicmF0aW9uIChpZiBkb25lKS4gIElmIHRoaXMg\naXMgbGVzcyB0aGFuIHRoZSBtYWNoaW5lCiAgICBwcmVjaXNpb24gKGluIHBhcnRpY3VsYXIsIGlm\nIGl0IGlzIHplcm8pLCB0aGUgbWF0cml4IGlzIHNpbmd1bGFyCiAgICB0byB3b3JraW5nIHByZWNp\nc2lvbi4gIE5vdGUgdGhhdCB0aGUgZXJyb3IgbWF5IHN0aWxsIGJlIHNtYWxsIGV2ZW4KICAgIGlm\nIHRoaXMgbnVtYmVyIGlzIHZlcnkgc21hbGwgYW5kIHRoZSBtYXRyaXggYXBwZWFycyBpbGwtCiAg\nICBjb25kaXRpb25lZC4KXHBhcmFtW291dF0gQkVSUgogICAgICAgICBCRVJSIGlzIERPVUJMRSBQ\nUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiAoTlJIUykKICAgIENvbXBvbmVudHdpc2UgcmVsYXRp\ndmUgYmFja3dhcmQgZXJyb3IuICBUaGlzIGlzIHRoZQogICAgY29tcG9uZW50d2lzZSByZWxhdGl2\nZSBiYWNrd2FyZCBlcnJvciBvZiBlYWNoIHNvbHV0aW9uIHZlY3RvciBYKGopCiAgICAoaS5lLiwg\ndGhlIHNtYWxsZXN0IHJlbGF0aXZlIGNoYW5nZSBpbiBhbnkgZWxlbWVudCBvZiBBIG9yIEIgdGhh\ndAogICAgbWFrZXMgWChqKSBhbiBleGFjdCBzb2x1dGlvbikuClxwYXJhbVtpbl0gTl9FUlJfQk5E\nUwogICAgICAgICBOX0VSUl9CTkRTIGlzIElOVEVHRVIKICAgIE51bWJlciBvZiBlcnJvciBib3Vu\nZHMgdG8gcmV0dXJuIGZvciBlYWNoIHJpZ2h0IGhhbmQgc2lkZQogICAgYW5kIGVhY2ggdHlwZSAo\nbm9ybXdpc2Ugb3IgY29tcG9uZW50d2lzZSkuICBTZWUgRVJSX0JORFNfTk9STSBhbmQKICAgIEVS\nUl9CTkRTX0NPTVAgYmVsb3cuClxwYXJhbVtvdXRdIEVSUl9CTkRTX05PUk0KICAgICAgICAgRVJS\nX0JORFNfTk9STSBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKE5SSFMsIE5f\nRVJSX0JORFMpCiAgICBGb3IgZWFjaCByaWdodC1oYW5kIHNpZGUsIHRoaXMgYXJyYXkgY29udGFp\nbnMgaW5mb3JtYXRpb24gYWJvdXQKICAgIHZhcmlvdXMgZXJyb3IgYm91bmRzIGFuZCBjb25kaXRp\nb24gbnVtYmVycyBjb3JyZXNwb25kaW5nIHRvIHRoZQogICAgbm9ybXdpc2UgcmVsYXRpdmUgZXJy\nb3IsIHdoaWNoIGlzIGRlZmluZWQgYXMgZm9sbG93czoKICAgIE5vcm13aXNlIHJlbGF0aXZlIGVy\ncm9yIGluIHRoZSBpdGggc29sdXRpb24gdmVjdG9yOgogICAgICAgICAgICBtYXhfaiAoYWJzKFhU\nUlVFKGosaSkgLSBYKGosaSkpKQogICAgICAgICAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0t\nLS0tLQogICAgICAgICAgICAgICAgIG1heF9qIGFicyhYKGosaSkpCiAgICBUaGUgYXJyYXkgaXMg\naW5kZXhlZCBieSB0aGUgdHlwZSBvZiBlcnJvciBpbmZvcm1hdGlvbiBhcyBkZXNjcmliZWQKICAg\nIGJlbG93LiBUaGVyZSBjdXJyZW50bHkgYXJlIHVwIHRvIHRocmVlIHBpZWNlcyBvZiBpbmZvcm1h\ndGlvbgogICAgcmV0dXJuZWQuCiAgICBUaGUgZmlyc3QgaW5kZXggaW4gRVJSX0JORFNfTk9STShp\nLDopIGNvcnJlc3BvbmRzIHRvIHRoZSBpdGgKICAgIHJpZ2h0LWhhbmQgc2lkZS4KICAgIFRoZSBz\nZWNvbmQgaW5kZXggaW4gRVJSX0JORFNfTk9STSg6LGVycikgY29udGFpbnMgdGhlIGZvbGxvd2lu\nZwogICAgdGhyZWUgZmllbGRzOgogICAgZXJyID0gMSAiVHJ1c3QvZG9uJ3QgdHJ1c3QiIGJvb2xl\nYW4uIFRydXN0IHRoZSBhbnN3ZXIgaWYgdGhlCiAgICAgICAgICAgICByZWNpcHJvY2FsIGNvbmRp\ndGlvbiBudW1iZXIgaXMgbGVzcyB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAgICAgIHNxcnQo\nbikgKiBkbGFtY2goJ0Vwc2lsb24nKS4KICAgIGVyciA9IDIgIkd1YXJhbnRlZWQiIGVycm9yIGJv\ndW5kOiBUaGUgZXN0aW1hdGVkIGZvcndhcmQgZXJyb3IsCiAgICAgICAgICAgICBhbG1vc3QgY2Vy\ndGFpbmx5IHdpdGhpbiBhIGZhY3RvciBvZiAxMCBvZiB0aGUgdHJ1ZSBlcnJvcgogICAgICAgICAg\nICAgc28gbG9uZyBhcyB0aGUgbmV4dCBlbnRyeSBpcyBncmVhdGVyIHRoYW4gdGhlIHRocmVzaG9s\nZAogICAgICAgICAgICAgc3FydChuKSAqIGRsYW1jaCgnRXBzaWxvbicpLiBUaGlzIGVycm9yIGJv\ndW5kIHNob3VsZCBvbmx5CiAgICAgICAgICAgICBiZSB0cnVzdGVkIGlmIHRoZSBwcmV2aW91cyBi\nb29sZWFuIGlzIHRydWUuCiAgICBlcnIgPSAzICBSZWNpcHJvY2FsIGNvbmRpdGlvbiBudW1iZXI6\nIEVzdGltYXRlZCBub3Jtd2lzZQogICAgICAgICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVt\nYmVyLiAgQ29tcGFyZWQgd2l0aCB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICog\nZGxhbWNoKCdFcHNpbG9uJykgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlcnJvcgogICAgICAgICAgICAg\nZXN0aW1hdGUgaXMgImd1YXJhbnRlZWQiLiBUaGVzZSByZWNpcHJvY2FsIGNvbmRpdGlvbgogICAg\nICAgICAgICAgbnVtYmVycyBhcmUgMSAvIChub3JtKFpeey0xfSxpbmYpICogbm9ybShaLGluZikp\nIGZvciBzb21lCiAgICAgICAgICAgICBhcHByb3ByaWF0ZWx5IHNjYWxlZCBtYXRyaXggWi4KICAg\nICAgICAgICAgIExldCBaID0gUypBLCB3aGVyZSBTIHNjYWxlcyBlYWNoIHJvdyBieSBhIHBvd2Vy\nIG9mIHRoZQogICAgICAgICAgICAgcmFkaXggc28gYWxsIGFic29sdXRlIHJvdyBzdW1zIG9mIFog\nYXJlIGFwcHJveGltYXRlbHkgMS4KICAgIFNlZSBMYXBhY2sgV29ya2luZyBOb3RlIDE2NSBmb3Ig\nZnVydGhlciBkZXRhaWxzIGFuZCBleHRyYQogICAgY2F1dGlvbnMuClxwYXJhbVtvdXRdIEVSUl9C\nTkRTX0NPTVAKICAgICAgICAgRVJSX0JORFNfQ09NUCBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5\nLCBkaW1lbnNpb24gKE5SSFMsIE5fRVJSX0JORFMpCiAgICBGb3IgZWFjaCByaWdodC1oYW5kIHNp\nZGUsIHRoaXMgYXJyYXkgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQKICAgIHZhcmlvdXMgZXJy\nb3IgYm91bmRzIGFuZCBjb25kaXRpb24gbnVtYmVycyBjb3JyZXNwb25kaW5nIHRvIHRoZQogICAg\nY29tcG9uZW50d2lzZSByZWxhdGl2ZSBlcnJvciwgd2hpY2ggaXMgZGVmaW5lZCBhcyBmb2xsb3dz\nOgogICAgQ29tcG9uZW50d2lzZSByZWxhdGl2ZSBlcnJvciBpbiB0aGUgaXRoIHNvbHV0aW9uIHZl\nY3RvcjoKICAgICAgICAgICAgICAgICAgIGFicyhYVFJVRShqLGkpIC0gWChqLGkpKQogICAgICAg\nICAgICBtYXhfaiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tCiAgICAgICAgICAgICAgICAgICAgICAg\nIGFicyhYKGosaSkpCiAgICBUaGUgYXJyYXkgaXMgaW5kZXhlZCBieSB0aGUgcmlnaHQtaGFuZCBz\naWRlIGkgKG9uIHdoaWNoIHRoZQogICAgY29tcG9uZW50d2lzZSByZWxhdGl2ZSBlcnJvciBkZXBl\nbmRzKSwgYW5kIHRoZSB0eXBlIG9mIGVycm9yCiAgICBpbmZvcm1hdGlvbiBhcyBkZXNjcmliZWQg\nYmVsb3cuIFRoZXJlIGN1cnJlbnRseSBhcmUgdXAgdG8gdGhyZWUKICAgIHBpZWNlcyBvZiBpbmZv\ncm1hdGlvbiByZXR1cm5lZCBmb3IgZWFjaCByaWdodC1oYW5kIHNpZGUuIElmCiAgICBjb21wb25l\nbnR3aXNlIGFjY3VyYWN5IGlzIG5vdCByZXF1ZXN0ZWQgKFBBUkFNUygzKSA9IDAuMCksIHRoZW4K\nICAgIEVSUl9CTkRTX0NPTVAgaXMgbm90IGFjY2Vzc2VkLiAgSWYgTl9FUlJfQk5EUyAuTFQuIDMs\nIHRoZW4gYXQgbW9zdAogICAgdGhlIGZpcnN0ICg6LE5fRVJSX0JORFMpIGVudHJpZXMgYXJlIHJl\ndHVybmVkLgogICAgVGhlIGZpcnN0IGluZGV4IGluIEVSUl9CTkRTX0NPTVAoaSw6KSBjb3JyZXNw\nb25kcyB0byB0aGUgaXRoCiAgICByaWdodC1oYW5kIHNpZGUuCiAgICBUaGUgc2Vjb25kIGluZGV4\nIGluIEVSUl9CTkRTX0NPTVAoOixlcnIpIGNvbnRhaW5zIHRoZSBmb2xsb3dpbmcKICAgIHRocmVl\nIGZpZWxkczoKICAgIGVyciA9IDEgIlRydXN0L2Rvbid0IHRydXN0IiBib29sZWFuLiBUcnVzdCB0\naGUgYW5zd2VyIGlmIHRoZQogICAgICAgICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVy\nIGlzIGxlc3MgdGhhbiB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogZGxhbWNo\nKCdFcHNpbG9uJykuCiAgICBlcnIgPSAyICJHdWFyYW50ZWVkIiBlcnJvciBib3VuZDogVGhlIGVz\ndGltYXRlZCBmb3J3YXJkIGVycm9yLAogICAgICAgICAgICAgYWxtb3N0IGNlcnRhaW5seSB3aXRo\naW4gYSBmYWN0b3Igb2YgMTAgb2YgdGhlIHRydWUgZXJyb3IKICAgICAgICAgICAgIHNvIGxvbmcg\nYXMgdGhlIG5leHQgZW50cnkgaXMgZ3JlYXRlciB0aGFuIHRoZSB0aHJlc2hvbGQKICAgICAgICAg\nICAgIHNxcnQobikgKiBkbGFtY2goJ0Vwc2lsb24nKS4gVGhpcyBlcnJvciBib3VuZCBzaG91bGQg\nb25seQogICAgICAgICAgICAgYmUgdHJ1c3RlZCBpZiB0aGUgcHJldmlvdXMgYm9vbGVhbiBpcyB0\ncnVlLgogICAgZXJyID0gMyAgUmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyOiBFc3RpbWF0ZWQg\nY29tcG9uZW50d2lzZQogICAgICAgICAgICAgcmVjaXByb2NhbCBjb25kaXRpb24gbnVtYmVyLiAg\nQ29tcGFyZWQgd2l0aCB0aGUgdGhyZXNob2xkCiAgICAgICAgICAgICBzcXJ0KG4pICogZGxhbWNo\nKCdFcHNpbG9uJykgdG8gZGV0ZXJtaW5lIGlmIHRoZSBlcnJvcgogICAgICAgICAgICAgZXN0aW1h\ndGUgaXMgImd1YXJhbnRlZWQiLiBUaGVzZSByZWNpcHJvY2FsIGNvbmRpdGlvbgogICAgICAgICAg\nICAgbnVtYmVycyBhcmUgMSAvIChub3JtKFpeey0xfSxpbmYpICogbm9ybShaLGluZikpIGZvciBz\nb21lCiAgICAgICAgICAgICBhcHByb3ByaWF0ZWx5IHNjYWxlZCBtYXRyaXggWi4KICAgICAgICAg\nICAgIExldCBaID0gUyooQSpkaWFnKHgpKSwgd2hlcmUgeCBpcyB0aGUgc29sdXRpb24gZm9yIHRo\nZQogICAgICAgICAgICAgY3VycmVudCByaWdodC1oYW5kIHNpZGUgYW5kIFMgc2NhbGVzIGVhY2gg\ncm93IG9mCiAgICAgICAgICAgICBBKmRpYWcoeCkgYnkgYSBwb3dlciBvZiB0aGUgcmFkaXggc28g\nYWxsIGFic29sdXRlIHJvdwogICAgICAgICAgICAgc3VtcyBvZiBaIGFyZSBhcHByb3hpbWF0ZWx5\nIDEuCiAgICBTZWUgTGFwYWNrIFdvcmtpbmcgTm90ZSAxNjUgZm9yIGZ1cnRoZXIgZGV0YWlscyBh\nbmQgZXh0cmEKICAgIGNhdXRpb25zLgpccGFyYW1baW5dIE5QQVJBTVMKICAgICAgICAgTlBBUkFN\nUyBpcyBJTlRFR0VSCiAgICBTcGVjaWZpZXMgdGhlIG51bWJlciBvZiBwYXJhbWV0ZXJzIHNldCBp\nbiBQQVJBTVMuICBJZiAuTEUuIDAsIHRoZQogICAgUEFSQU1TIGFycmF5IGlzIG5ldmVyIHJlZmVy\nZW5jZWQgYW5kIGRlZmF1bHQgdmFsdWVzIGFyZSB1c2VkLgpccGFyYW1baW4sb3V0XSBQQVJBTVMK\nICAgICAgICAgUEFSQU1TIGlzIERPVUJMRSBQUkVDSVNJT04gYXJyYXksIGRpbWVuc2lvbiBOUEFS\nQU1TCiAgICBTcGVjaWZpZXMgYWxnb3JpdGhtIHBhcmFtZXRlcnMuICBJZiBhbiBlbnRyeSBpcyAu\nTFQuIDAuMCwgdGhlbgogICAgdGhhdCBlbnRyeSB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlZmF1bHQg\ndmFsdWUgdXNlZCBmb3IgdGhhdAogICAgcGFyYW1ldGVyLiAgT25seSBwb3NpdGlvbnMgdXAgdG8g\nTlBBUkFNUyBhcmUgYWNjZXNzZWQ7IGRlZmF1bHRzCiAgICBhcmUgdXNlZCBmb3IgaGlnaGVyLW51\nbWJlcmVkIHBhcmFtZXRlcnMuCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9JVFJFRl9JID0gMSkgOiBX\naGV0aGVyIHRvIHBlcmZvcm0gaXRlcmF0aXZlCiAgICAgICAgICAgcmVmaW5lbWVudCBvciBub3Qu\nCiAgICAgICAgRGVmYXVsdDogMS4wRCswCiAgICAgICAgICAgPSAwLjAgOiBObyByZWZpbmVtZW50\nIGlzIHBlcmZvcm1lZCwgYW5kIG5vIGVycm9yIGJvdW5kcyBhcmUKICAgICAgICAgICAgICAgICAg\nIGNvbXB1dGVkLgogICAgICAgICAgID0gMS4wIDogVXNlIHRoZSBkb3VibGUtcHJlY2lzaW9uIHJl\nZmluZW1lbnQgYWxnb3JpdGhtLAogICAgICAgICAgICAgICAgICAgcG9zc2libHkgd2l0aCBkb3Vi\nbGVkLXNpbmdsZSBjb21wdXRhdGlvbnMgaWYgdGhlCiAgICAgICAgICAgICAgICAgICBjb21waWxh\ndGlvbiBlbnZpcm9ubWVudCBkb2VzIG5vdCBzdXBwb3J0IERPVUJMRQogICAgICAgICAgICAgICAg\nICAgUFJFQ0lTSU9OLgogICAgICAgICAgICAgKG90aGVyIHZhbHVlcyBhcmUgcmVzZXJ2ZWQgZm9y\nIGZ1dHVyZSB1c2UpCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9JVEhSRVNIX0kgPSAyKSA6IE1heGlt\ndW0gbnVtYmVyIG9mIHJlc2lkdWFsCiAgICAgICAgICAgY29tcHV0YXRpb25zIGFsbG93ZWQgZm9y\nIHJlZmluZW1lbnQuCiAgICAgICAgRGVmYXVsdDogMTAKICAgICAgICBBZ2dyZXNzaXZlOiBTZXQg\ndG8gMTAwIHRvIHBlcm1pdCBjb252ZXJnZW5jZSB1c2luZyBhcHByb3hpbWF0ZQogICAgICAgICAg\nICAgICAgICAgIGZhY3Rvcml6YXRpb25zIG9yIGZhY3Rvcml6YXRpb25zIG90aGVyIHRoYW4gTFUu\nIElmCiAgICAgICAgICAgICAgICAgICAgdGhlIGZhY3Rvcml6YXRpb24gdXNlcyBhIHRlY2huaXF1\nZSBvdGhlciB0aGFuCiAgICAgICAgICAgICAgICAgICAgR2F1c3NpYW4gZWxpbWluYXRpb24sIHRo\nZSBndWFyYW50ZWVzIGluCiAgICAgICAgICAgICAgICAgICAgZXJyX2JuZHNfbm9ybSBhbmQgZXJy\nX2JuZHNfY29tcCBtYXkgbm8gbG9uZ2VyIGJlCiAgICAgICAgICAgICAgICAgICAgdHJ1c3R3b3J0\naHkuCiAgICAgIFBBUkFNUyhMQV9MSU5SWF9DV0lTRV9JID0gMykgOiBGbGFnIGRldGVybWluaW5n\nIGlmIHRoZSBjb2RlCiAgICAgICAgICAgd2lsbCBhdHRlbXB0IHRvIGZpbmQgYSBzb2x1dGlvbiB3\naXRoIHNtYWxsIGNvbXBvbmVudHdpc2UKICAgICAgICAgICByZWxhdGl2ZSBlcnJvciBpbiB0aGUg\nZG91YmxlLXByZWNpc2lvbiBhbGdvcml0aG0uICBQb3NpdGl2ZQogICAgICAgICAgIGlzIHRydWUs\nIDAuMCBpcyBmYWxzZS4KICAgICAgICBEZWZhdWx0OiAxLjAgKGF0dGVtcHQgY29tcG9uZW50d2lz\nZSBjb252ZXJnZW5jZSkKXHBhcmFtW291dF0gV09SSwogICAgICAgICBXT1JLIGlzIENPTVBMRVgq\nMTYgYXJyYXksIGRpbWVuc2lvbiAoMipOKQpccGFyYW1bb3V0XSBSV09SSwogICAgICAgICBSV09S\nSyBpcyBET1VCTEUgUFJFQ0lTSU9OIGFycmF5LCBkaW1lbnNpb24gKDIqTikKXHBhcmFtW291dF0g\nSU5GTwogICAgICAgICBJTkZPIGlzIElOVEVHRVIKICAgICAgPSAwOiAgU3VjY2Vzc2Z1bCBleGl0\nLiBUaGUgc29sdXRpb24gdG8gZXZlcnkgcmlnaHQtaGFuZCBzaWRlIGlzCiAgICAgICAgZ3VhcmFu\ndGVlZC4KICAgICAgPCAwOiAgSWYgSU5GTyA9IC1pLCB0aGUgaS10aCBhcmd1bWVudCBoYWQgYW4g\naWxsZWdhbCB2YWx1ZQogICAgICA+IDAgYW5kIDw9IE46ICBVKElORk8sSU5GTykgaXMgZXhhY3Rs\neSB6ZXJvLiAgVGhlIGZhY3Rvcml6YXRpb24KICAgICAgICBoYXMgYmVlbiBjb21wbGV0ZWQsIGJ1\ndCB0aGUgZmFjdG9yIFUgaXMgZXhhY3RseSBzaW5ndWxhciwgc28KICAgICAgICB0aGUgc29sdXRp\nb24gYW5kIGVycm9yIGJvdW5kcyBjb3VsZCBub3QgYmUgY29tcHV0ZWQuIFJDT05EID0gMAogICAg\nICAgIGlzIHJldHVybmVkLgogICAgICA9IE4rSjogVGhlIHNvbHV0aW9uIGNvcnJlc3BvbmRpbmcg\ndG8gdGhlIEp0aCByaWdodC1oYW5kIHNpZGUgaXMKICAgICAgICBub3QgZ3VhcmFudGVlZC4gVGhl\nIHNvbHV0aW9ucyBjb3JyZXNwb25kaW5nIHRvIG90aGVyIHJpZ2h0LQogICAgICAgIGhhbmQgc2lk\nZXMgSyB3aXRoIEsgPiBKIG1heSBub3QgYmUgZ3VhcmFudGVlZCBhcyB3ZWxsLCBidXQKICAgICAg\nICBvbmx5IHRoZSBmaXJzdCBzdWNoIHJpZ2h0LWhhbmQgc2lkZSBpcyByZXBvcnRlZC4gSWYgYSBz\nbWFsbAogICAgICAgIGNvbXBvbmVudHdpc2UgZXJyb3IgaXMgbm90IHJlcXVlc3RlZCAoUEFSQU1T\nKDMpID0gMC4wKSB0aGVuCiAgICAgICAgdGhlIEp0aCByaWdodC1oYW5kIHNpZGUgaXMgdGhlIGZp\ncnN0IHdpdGggYSBub3Jtd2lzZSBlcnJvcgogICAgICAgIGJvdW5kIHRoYXQgaXMgbm90IGd1YXJh\nbnRlZWQgKHRoZSBzbWFsbGVzdCBKIHN1Y2gKICAgICAgICB0aGF0IEVSUl9CTkRTX05PUk0oSiwx\nKSA9IDAuMCkuIEJ5IGRlZmF1bHQgKFBBUkFNUygzKSA9IDEuMCkKICAgICAgICB0aGUgSnRoIHJp\nZ2h0LWhhbmQgc2lkZSBpcyB0aGUgZmlyc3Qgd2l0aCBlaXRoZXIgYSBub3Jtd2lzZSBvcgogICAg\nICAgIGNvbXBvbmVudHdpc2UgZXJyb3IgYm91bmQgdGhhdCBpcyBub3QgZ3VhcmFudGVlZCAodGhl\nIHNtYWxsZXN0CiAgICAgICAgSiBzdWNoIHRoYXQgZWl0aGVyIEVSUl9CTkRTX05PUk0oSiwxKSA9\nIDAuMCBvcgogICAgICAgIEVSUl9CTkRTX0NPTVAoSiwxKSA9IDAuMCkuIFNlZSB0aGUgZGVmaW5p\ndGlvbiBvZgogICAgICAgIEVSUl9CTkRTX05PUk0oOiwxKSBhbmQgRVJSX0JORFNfQ09NUCg6LDEp\nLiBUbyBnZXQgaW5mb3JtYXRpb24KICAgICAgICBhYm91dCBhbGwgb2YgdGhlIHJpZ2h0LWhhbmQg\nc2lkZXMgY2hlY2sgRVJSX0JORFNfTk9STSBvcgogICAgICAgIEVSUl9CTkRTX0NPTVAuCkF1dGhv\ncnM6ClxhdXRob3IgVW5pdi4gb2YgVGVubmVzc2VlIApcYXV0aG9yIFVuaXYuIG9mIENhbGlmb3Ju\naWEgQmVya2VsZXkgClxhdXRob3IgVW5pdi4gb2YgQ29sb3JhZG8gRGVudmVyIApcYXV0aG9yIE5B\nRyBMdGQuIApcZGF0ZSBBcHJpbCAyMDEyClxpbmdyb3VwIGNvbXBsZXgxNkhFY29tcHV0YXRpb25h\nbApoHWgeKYFyVwIAAH1yWAIAAChoIYloImgjdWJoLYoCrAFoLlgPAAAAemhlcmZzeF80MjgudHh0\ndWJoL4oCrAFoMFgGAAAAaGVyZnN4aC2KAUZ1YmVVDl9wcmVmZXRjaF9kb25lclkCAACJVQpfZm9y\nX3dyaXRlcloCAACJVQVxdWVyeXJbAgAAY2RqYW5nby5kYi5tb2RlbHMuc3FsLnF1ZXJ5ClF1ZXJ5\nCnJcAgAAKYFyXQIAAH1yXgIAAChVFWFnZ3JlZ2F0ZV9zZWxlY3RfbWFza3JfAgAATlUXX2FnZ3Jl\nZ2F0ZV9zZWxlY3RfY2FjaGVyYAIAAE5VBWV4dHJhcmECAABjZGphbmdvLnV0aWxzLmRhdGFzdHJ1\nY3R1cmVzClNvcnRlZERpY3QKcmICAAApgXJjAgAAfXJkAgAAVQhrZXlPcmRlcnJlAgAAXXNiVQhq\nb2luX21hcHJmAgAAfXJnAgAAKE5VKENvbXB1dGF0aW9uYWxfbGluZWFyZXF1YXRpb25fZXJyb3Jf\nYm91bmRyaAIAAE5OdHJpAgAAamgCAACFc1UVcmVsYXRlZF9zZWxlY3RfZmllbGRzcmoCAABdVQxl\neHRyYV90YWJsZXNyawIAAClVBnNlbGVjdHJsAgAAXXJtAgAAVQtxdW90ZV9jYWNoZXJuAgAAfXJv\nAgAAVQxyZXZfam9pbl9tYXBycAIAAH1ycQIAAGpoAgAAamkCAABzVQx1c2VkX2FsaWFzZXNycgIA\nAGNfX2J1aWx0aW5fXwpzZXQKcnMCAABdcnQCAABqaAIAAGGFUnJ1AgAAVQhvcmRlcl9ieXJ2AgAA\nXXJ3AgAAVQhkaXN0aW5jdHJ4AgAAiVUOZHVwZV9hdm9pZGFuY2VyeQIAAH1yegIAAFUQZGVmYXVs\ndF9vcmRlcmluZ3J7AgAAiFUIZ3JvdXBfYnlyfAIAAE5VEXNlbGVjdF9mb3JfdXBkYXRlcn0CAACJ\nVQ5zZWxlY3RfcmVsYXRlZHJ+AgAAiVUQZGVmZXJyZWRfbG9hZGluZ3J/AgAAanMCAABdhVJygAIA\nAIiGcoECAABVDXNlbGVjdF9maWVsZHNyggIAAF1VCWFsaWFzX21hcHKDAgAAfXKEAgAAamgCAAAo\namgCAABqaAIAAE5OTk6JdHNVCW1heF9kZXB0aHKFAgAASwVVEXN0YW5kYXJkX29yZGVyaW5ncoYC\nAACIVQ5leHRyYV9vcmRlcl9ieXKHAgAAKVUPZGlzdGluY3RfZmllbGRzcogCAABdcokCAABVBnRh\nYmxlc3KKAgAAXXKLAgAAamgCAABhVQphZ2dyZWdhdGVzcowCAABqYgIAACmBco0CAAB9co4CAABq\nZQIAAF1zYlURZXh0cmFfc2VsZWN0X21hc2tyjwIAAE5VGHNlbGVjdF9mb3JfdXBkYXRlX25vd2Fp\ndHKQAgAAiVUTX2V4dHJhX3NlbGVjdF9jYWNoZXKRAgAATlUIbG93X21hcmtykgIAAEsAVQ5hbGlh\nc19yZWZjb3VudHKTAgAAamICAAApgXKUAgAAamgCAABLAXN9cpUCAABqZQIAAF1ylgIAAGpoAgAA\nYXNiVRNyZWxhdGVkX3NlbGVjdF9jb2xzcpcCAABdVQxkZWZhdWx0X2NvbHNymAIAAIhVEG9yZGVy\naW5nX2FsaWFzZXNymQIAAF1ymgIAAFUGaGF2aW5ncpsCAABjZGphbmdvLmRiLm1vZGVscy5zcWwu\nd2hlcmUKV2hlcmVOb2RlCnKcAgAAKYFynQIAAH1yngIAAChVCWNvbm5lY3RvcnKfAgAAVQNBTkRy\noAIAAFUHbmVnYXRlZHKhAgAAiVUIY2hpbGRyZW5yogIAAF1VD3N1YnRyZWVfcGFyZW50c3KjAgAA\nXXViVRlpbmNsdWRlZF9pbmhlcml0ZWRfbW9kZWxzcqQCAAB9cqUCAABOamgCAABzVQl0YWJsZV9t\nYXBypgIAAH1ypwIAAGpoAgAAXXKoAgAAamgCAABhc1ULd2hlcmVfY2xhc3NyqQIAAGqcAgAAVQVt\nb2RlbHKqAgAAaBZVBXdoZXJlcqsCAABqnAIAACmBcqwCAAB9cq0CAAAoap8CAABqoAIAAGqhAgAA\niWqiAgAAXXKuAgAAapwCAAApgXKvAgAAfXKwAgAAKGqfAgAAaqACAABqoQIAAIlqogIAAF1ysQIA\nAGqcAgAAKYFysgIAAH1yswIAAChqnwIAAGqgAgAAaqECAACJaqICAABdcrQCAAAoY2RqYW5nby5k\nYi5tb2RlbHMuc3FsLndoZXJlCkNvbnN0cmFpbnQKcrUCAAApgXK2AgAAfXK3AgAAKFUFYWxpYXNy\nuAIAAGpoAgAAaqoCAABoFlUKZmllbGRfbmFtZXK5AgAAaBxVA2NvbHK6AgAAaBx1YlUJaWNvbnRh\naW5ziFgFAAAAZXJyb3JyuwIAAHRyvAIAAGFqowIAAF11YmFqowIAAF11YmFqowIAAF11YlUJaGln\naF9tYXJrcr0CAABOVRBmaWx0ZXJfaXNfc3RpY2t5cr4CAACJdWJqqgIAAGgWVRlfcHJlZmV0Y2hf\ncmVsYXRlZF9sb29rdXBzcr8CAABdcsACAAB1YlUSX2F1dGhfdXNlcl9iYWNrZW5kVSlkamFuZ28u\nY29udHJpYi5hdXRoLmJhY2tlbmRzLk1vZGVsQmFja2VuZFUTbm90U2VsZWN0ZWRSb3V0aW5lc2gO\nVRBzZWxlY3RlZFJvdXRpbmVzXVUKdXNlclNjcmlwdFUAVQdxdWVyaWVzXXLBAgAAY2RqYW5nby5k\nYi5tb2RlbHMucXVlcnlfdXRpbHMKUQpywgIAACmBcsMCAAB9csQCAAAoap8CAABqoAIAAGqhAgAA\niWqiAgAAXXLFAgAAVRBub3Rlc19faWNvbnRhaW5zcsYCAABquwIAAIZyxwIAAGFqowIAAF11YmFV\nE1F1ZXN0aW9uX21hdHJpeHR5cGVdcsgCAAAoWAMAAABTUERyyQIAAFgDAAAAU1BEcsoCAABldS4=\n','2012-10-05 14:52:49');
/*!40000 ALTER TABLE `django_session` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `driver_linearequation_driver`
--

DROP TABLE IF EXISTS `driver_linearequation_driver`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `driver_linearequation_driver` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Driver_linearequation_driver_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=103 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `driver_linearequation_driver`
--

LOCK TABLES `driver_linearequation_driver` WRITE;
/*!40000 ALTER TABLE `driver_linearequation_driver` DISABLE KEYS */;
INSERT INTO `driver_linearequation_driver` VALUES (1,'s','gesv','general','full','Doxygen/docs/html/sgesv_8f.html','driver simple; solve A*X = B only',1),(2,'d','gesv','general','full','Doxygen/docs/html/dgesv_8f.html','driver simple; solve A*X = B only',2),(3,'c','gesv','general','full','Doxygen/docs/html/cgesv_8f.html','driver simple; solve A*X = B only',3),(4,'z','gesv','general','full','Doxygen/docs/html/zgesv_8f.html','driver simple; solve A*X = B only',4),(5,'s','gbsv','general','band','Doxygen/docs/html/sgbsv_8f.html','driver simple; solve A*X = B only',5),(6,'d','gbsv','general','band','Doxygen/docs/html/dgbsv_8f.html','driver simple; solve A*X = B only',6),(7,'c','gbsv','general','band','Doxygen/docs/html/cgbsv_8f.html','driver simple; solve A*X = B only',7),(8,'z','gbsv','general','band','Doxygen/docs/html/zgbsv_8f.html','driver simple; solve A*X = B only',8),(9,'s','gtsv','general','tridiagonal','Doxygen/docs/html/sgtsv_8f.html','driver simple; solve A*X = B only; Transpose',9),(10,'d','gtsv','general','tridiagonal','Doxygen/docs/html/dgtsv_8f.html','driver simple; solve A*X = B only; Transpose',10),(11,'c','gtsv','general','tridiagonal','Doxygen/docs/html/cgtsv_8f.html','driver simple; solve A*X = B only; Transpose',11),(12,'z','gtsv','general','tridiagonal','Doxygen/docs/html/zgtsv_8f.html','driver simple; solve A*X = B only; Transpose',12),(13,'c','hesv','Hermitian','full','Doxygen/docs/html/chesv_8f.html','driver simple; solve A*X = B only',13),(14,'z','hesv','Hermitian','full','Doxygen/docs/html/zhesv_8f.html','driver simple; solve A*X = B only',14),(15,'c','hpsv','Hermitian','packed','Doxygen/docs/html/chpsv_8f.html','driver simple; solve A*X = B only',15),(16,'z','hpsv','Hermitian','packed','Doxygen/docs/html/zhpsv_8f.html','driver simple; solve A*X = B only',16),(17,'s','posv','SPD','full','Doxygen/docs/html/sposv_8f.html','driver simple; solve A*X = B only',17),(18,'d','posv','SPD','full','Doxygen/docs/html/dposv_8f.html','driver simple; solve A*X = B only',18),(19,'c','posv','HPD','full','Doxygen/docs/html/cposv_8f.html','driver simple; solve A*X = B only',19),(20,'z','posv','HPD','full','Doxygen/docs/html/zposv_8f.html','driver simple; solve A*X = B only',20),(21,'s','pbsv','SPD','band','Doxygen/docs/html/spbsv_8f.html','driver simple; solve A*X = B only',21),(22,'d','pbsv','SPD','band','Doxygen/docs/html/dpbsv_8f.html','driver simple; solve A*X = B only',22),(23,'c','pbsv','HPD','band','Doxygen/docs/html/cpbsv_8f.html','driver simple; solve A*X = B only',23),(24,'z','pbsv','HPD','band','Doxygen/docs/html/zpbsv_8f.html','driver simple; solve A*X = B only',24),(25,'s','ppsv','SPD','packed','Doxygen/docs/html/sppsv_8f.html','driver simple; solve A*X = B only',25),(26,'d','ppsv','SPD','packed','Doxygen/docs/html/dppsv_8f.html','driver simple; solve A*X = B only',26),(27,'c','ppsv','HPD','packed','Doxygen/docs/html/cppsv_8f.html','driver simple; solve A*X = B only',27),(28,'z','ppsv','HPD','packed','Doxygen/docs/html/zppsv_8f.html','driver simple; solve A*X = B only',28),(29,'s','ptsv','SPD','tridiagonal','Doxygen/docs/html/sptsv_8f.html','driver simple; solve A*X = B only',29),(30,'d','ptsv','SPD','tridiagonal','Doxygen/docs/html/dptsv_8f.html','driver simple; solve A*X = B only',30),(31,'c','ptsv','HPD','tridiagonal','Doxygen/docs/html/cptsv_8f.html','driver simple; solve A*X = B only',31),(32,'z','ptsv','HPD','tridiagonal','Doxygen/docs/html/zptsv_8f.html','driver simple; solve A*X = B only',32),(33,'s','sysv','symmetric','full','Doxygen/docs/html/ssysv_8f.html','driver simple; solve A*X = B only',33),(34,'d','sysv','symmetric','full','Doxygen/docs/html/dsysv_8f.html','driver simple; solve A*X = B only',34),(35,'c','sysv','symmetric','full','Doxygen/docs/html/csysv_8f.html','driver simple; solve A*X = B only',35),(36,'z','sysv','symmetric','full','Doxygen/docs/html/zsysv_8f.html','driver simple; solve A*X = B only',36),(37,'s','spsv','symmetric','packed','Doxygen/docs/html/sspsv_8f.html','driver simple; solve A*X = B only',37),(38,'d','spsv','symmetric','packed','Doxygen/docs/html/dspsv_8f.html','driver simple; solve A*X = B only',38),(39,'c','spsv','symmetric','packed','Doxygen/docs/html/cspsv_8f.html','driver simple; solve A*X = B only',39),(40,'z','spsv','symmetric','packed','Doxygen/docs/html/zspsv_8f.html','driver simple; solve A*X = B only',40),(41,'d','sgesv','general','full','Doxygen/docs/html/dsgesv_8f.html','driver simple; solve A*X = B only; refinement',329),(42,'z','cgesv','general','full','Doxygen/docs/html/zcgesv_8f.html','driver simple; solve A*X = B only; refinement',330),(43,'d','sposv','SPD','full','Doxygen/docs/html/dsposv_8f.html','driver simple; solve A*X = B only; refinement',331),(44,'z','cposv','SPD','full','Doxygen/docs/html/zcposv_8f.html','driver simple; solve A*X = B only; refinement',332),(45,'s','gesvx','general','full','Doxygen/docs/html/sgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',41),(46,'d','gesvx','general','full','Doxygen/docs/html/dgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',42),(47,'c','gesvx','general','full','Doxygen/docs/html/cgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',43),(48,'z','gesvx','general','full','Doxygen/docs/html/zgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',44),(49,'s','gbsvx','general','band','Doxygen/docs/html/sgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',45),(50,'d','gbsvx','general','band','Doxygen/docs/html/dgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',46),(51,'c','gbsvx','general','band','Doxygen/docs/html/cgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',47),(52,'z','gbsvx','general','band','Doxygen/docs/html/zgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',48),(53,'s','gtsvx','general','tridiagonal','Doxygen/docs/html/sgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',49),(54,'d','gtsvx','general','tridiagonal','Doxygen/docs/html/dgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',50),(55,'c','gtsvx','general','tridiagonal','Doxygen/docs/html/cgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',51),(56,'z','gtsvx','general','tridiagonal','Doxygen/docs/html/zgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',52),(57,'c','hesvx','Hermitian','full','Doxygen/docs/html/chesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',53),(58,'z','hesvx','Hermitian','full','Doxygen/docs/html/zhesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',54),(59,'c','hpsvx','Hermitian','packed','Doxygen/docs/html/chpsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',55),(60,'z','hpsvx','Hermitian','packed','Doxygen/docs/html/zhpsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',56),(61,'s','posvx','SPD','full','Doxygen/docs/html/sposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',57),(62,'d','posvx','SPD','full','Doxygen/docs/html/dposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',58),(63,'c','posvx','HPD','full','Doxygen/docs/html/cposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',59),(64,'z','posvx','HPD','full','Doxygen/docs/html/zposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',60),(65,'s','pbsvx','SPD','band','Doxygen/docs/html/spbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',61),(66,'d','pbsvx','SPD','band','Doxygen/docs/html/dpbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',62),(67,'c','pbsvx','HPD','band','Doxygen/docs/html/cpbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',63),(68,'z','pbsvx','HPD','band','Doxygen/docs/html/zpbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',64),(69,'s','ppsvx','SPD','packed','Doxygen/docs/html/sppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',65),(70,'d','ppsvx','SPD','packed','Doxygen/docs/html/dppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',66),(71,'c','ppsvx','HPD','packed','Doxygen/docs/html/cppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',67),(72,'z','ppsvx','HPD','packed','Doxygen/docs/html/zppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',68),(73,'s','ptsvx','SPD','tridiagonal','Doxygen/docs/html/sptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',69),(74,'d','ptsvx','SPD','tridiagonal','Doxygen/docs/html/dptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',70),(75,'c','ptsvx','HPD','tridiagonal','Doxygen/docs/html/cptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',71),(76,'z','ptsvx','HPD','tridiagonal','Doxygen/docs/html/zptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',72),(77,'s','sysvx','symmetric','full','Doxygen/docs/html/ssysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',73),(78,'d','sysvx','symmetric','full','Doxygen/docs/html/dsysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',74),(79,'c','sysvx','symmetric','full','Doxygen/docs/html/csysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',75),(80,'z','sysvx','symmetric','full','Doxygen/docs/html/zsysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',76),(81,'s','spsvx','symmetric','packed','Doxygen/docs/html/sspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',77),(82,'d','spsvx','symmetric','packed','Doxygen/docs/html/dspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',78),(83,'c','spsvx','symmetric','packed','Doxygen/docs/html/cspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',79),(84,'z','spsvx','symmetric','packed','Doxygen/docs/html/zspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',80),(85,'s','gesvxx','general','full','Doxygen/docs/html/sgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',343),(86,'d','gesvxx','general','full','Doxygen/docs/html/dgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',344),(87,'c','gesvxx','general','full','Doxygen/docs/html/cgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',345),(88,'z','gesvxx','general','full','Doxygen/docs/html/zgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',346),(89,'s','gbsvxx','general','band','Doxygen/docs/html/sgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',347),(90,'d','gbsvxx','general','band','Doxygen/docs/html/dgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',348),(91,'c','gbsvxx','general','band','Doxygen/docs/html/cgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',349),(92,'z','gbsvxx','general','band','Doxygen/docs/html/zgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',350),(93,'s','posvxx','SPD','full','Doxygen/docs/html/sposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',351),(94,'d','posvxx','SPD','full','Doxygen/docs/html/dposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',352),(95,'c','posvxx','SPD','full','Doxygen/docs/html/cposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',353),(96,'z','posvxx','SPD','full','Doxygen/docs/html/zposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',354),(97,'s','sysvxx','symmetric','full','Doxygen/docs/html/ssysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',355),(98,'d','sysvxx','symmetric','full','Doxygen/docs/html/dsysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',356),(99,'c','sysvxx','symmetric','full','Doxygen/docs/html/csysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',357),(100,'z','sysvxx','symmetric','full','Doxygen/docs/html/zsysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',358),(101,'c','hesvxx','Hermitian','full','Doxygen/docs/html/chesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',359),(102,'z','hesvxx','Hermitian','full','Doxygen/docs/html/zhesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',360);
/*!40000 ALTER TABLE `driver_linearequation_driver` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `driver_linearequation_expert`
--

DROP TABLE IF EXISTS `driver_linearequation_expert`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `driver_linearequation_expert` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Driver_linearequation_expert_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=59 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `driver_linearequation_expert`
--

LOCK TABLES `driver_linearequation_expert` WRITE;
/*!40000 ALTER TABLE `driver_linearequation_expert` DISABLE KEYS */;
INSERT INTO `driver_linearequation_expert` VALUES (1,'s','gesvx','general','full','Doxygen/docs/html/sgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',41),(2,'d','gesvx','general','full','Doxygen/docs/html/dgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',42),(3,'c','gesvx','general','full','Doxygen/docs/html/cgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',43),(4,'z','gesvx','general','full','Doxygen/docs/html/zgesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',44),(5,'s','gbsvx','general','band','Doxygen/docs/html/sgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',45),(6,'d','gbsvx','general','band','Doxygen/docs/html/dgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',46),(7,'c','gbsvx','general','band','Doxygen/docs/html/cgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',47),(8,'z','gbsvx','general','band','Doxygen/docs/html/zgbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',48),(9,'s','gtsvx','general','tridiagonal','Doxygen/docs/html/sgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',49),(10,'d','gtsvx','general','tridiagonal','Doxygen/docs/html/dgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',50),(11,'c','gtsvx','general','tridiagonal','Doxygen/docs/html/cgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',51),(12,'z','gtsvx','general','tridiagonal','Doxygen/docs/html/zgtsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Transpose',52),(13,'c','hesvx','Hermitian','full','Doxygen/docs/html/chesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',53),(14,'z','hesvx','Hermitian','full','Doxygen/docs/html/zhesvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',54),(15,'c','hpsvx','Hermitian','packed','Doxygen/docs/html/chpsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',55),(16,'z','hpsvx','Hermitian','packed','Doxygen/docs/html/zhpsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',56),(17,'s','posvx','SPD','full','Doxygen/docs/html/sposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',57),(18,'d','posvx','SPD','full','Doxygen/docs/html/dposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',58),(19,'c','posvx','HPD','full','Doxygen/docs/html/cposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',59),(20,'z','posvx','HPD','full','Doxygen/docs/html/zposvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',60),(21,'s','pbsvx','SPD','band','Doxygen/docs/html/spbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',61),(22,'d','pbsvx','SPD','band','Doxygen/docs/html/dpbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',62),(23,'c','pbsvx','HPD','band','Doxygen/docs/html/cpbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',63),(24,'z','pbsvx','HPD','band','Doxygen/docs/html/zpbsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',64),(25,'s','ppsvx','SPD','packed','Doxygen/docs/html/sppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',65),(26,'d','ppsvx','SPD','packed','Doxygen/docs/html/dppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',66),(27,'c','ppsvx','HPD','packed','Doxygen/docs/html/cppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',67),(28,'z','ppsvx','HPD','packed','Doxygen/docs/html/zppsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',68),(29,'s','ptsvx','SPD','tridiagonal','Doxygen/docs/html/sptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',69),(30,'d','ptsvx','SPD','tridiagonal','Doxygen/docs/html/dptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',70),(31,'c','ptsvx','HPD','tridiagonal','Doxygen/docs/html/cptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',71),(32,'z','ptsvx','HPD','tridiagonal','Doxygen/docs/html/zptsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',72),(33,'s','sysvx','symmetric','full','Doxygen/docs/html/ssysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',73),(34,'d','sysvx','symmetric','full','Doxygen/docs/html/dsysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',74),(35,'c','sysvx','symmetric','full','Doxygen/docs/html/csysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',75),(36,'z','sysvx','symmetric','full','Doxygen/docs/html/zsysvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',76),(37,'s','spsvx','symmetric','packed','Doxygen/docs/html/sspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',77),(38,'d','spsvx','symmetric','packed','Doxygen/docs/html/dspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',78),(39,'c','spsvx','symmetric','packed','Doxygen/docs/html/cspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',79),(40,'z','spsvx','symmetric','packed','Doxygen/docs/html/zspsvx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor',80),(41,'s','gesvxx','general','full','Doxygen/docs/html/sgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',343),(42,'d','gesvxx','general','full','Doxygen/docs/html/dgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',344),(43,'c','gesvxx','general','full','Doxygen/docs/html/cgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',345),(44,'z','gesvxx','general','full','Doxygen/docs/html/zgesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',346),(45,'s','gbsvxx','general','band','Doxygen/docs/html/sgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',347),(46,'d','gbsvxx','general','band','Doxygen/docs/html/dgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',348),(47,'c','gbsvxx','general','band','Doxygen/docs/html/cgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',349),(48,'z','gbsvxx','general','band','Doxygen/docs/html/zgbsvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate; Transpose',350),(49,'s','posvxx','SPD','full','Doxygen/docs/html/sposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',351),(50,'d','posvxx','SPD','full','Doxygen/docs/html/dposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',352),(51,'c','posvxx','SPD','full','Doxygen/docs/html/cposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',353),(52,'z','posvxx','SPD','full','Doxygen/docs/html/zposvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',354),(53,'s','sysvxx','symmetric','full','Doxygen/docs/html/ssysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',355),(54,'d','sysvxx','symmetric','full','Doxygen/docs/html/dsysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',356),(55,'c','sysvxx','symmetric','full','Doxygen/docs/html/csysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',357),(56,'z','sysvxx','symmetric','full','Doxygen/docs/html/zsysvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',358),(57,'c','hesvxx','Hermitian','full','Doxygen/docs/html/chesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',359),(58,'z','hesvxx','Hermitian','full','Doxygen/docs/html/zhesvxx_8f.html','driver expert; solve A*X = B; Condition Number; Error Bounds; Refine; Factor; Equilibrate',360);
/*!40000 ALTER TABLE `driver_linearequation_expert` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `driver_linearequation_simple`
--

DROP TABLE IF EXISTS `driver_linearequation_simple`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `driver_linearequation_simple` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `thePrecision` varchar(20) NOT NULL,
  `routineName` varchar(30) NOT NULL,
  `matrixType` varchar(20) NOT NULL,
  `storageType` varchar(20) NOT NULL,
  `url` varchar(200) NOT NULL,
  `notes` varchar(225) NOT NULL,
  `info_id` int(11) NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Driver_linearequation_simple_369e409c` (`info_id`)
) ENGINE=MyISAM AUTO_INCREMENT=45 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `driver_linearequation_simple`
--

LOCK TABLES `driver_linearequation_simple` WRITE;
/*!40000 ALTER TABLE `driver_linearequation_simple` DISABLE KEYS */;
INSERT INTO `driver_linearequation_simple` VALUES (1,'s','gesv','general','full','Doxygen/docs/html/sgesv_8f.html','driver simple; solve A*X = B only',1),(2,'d','gesv','general','full','Doxygen/docs/html/dgesv_8f.html','driver simple; solve A*X = B only',2),(3,'c','gesv','general','full','Doxygen/docs/html/cgesv_8f.html','driver simple; solve A*X = B only',3),(4,'z','gesv','general','full','Doxygen/docs/html/zgesv_8f.html','driver simple; solve A*X = B only',4),(5,'s','gbsv','general','band','Doxygen/docs/html/sgbsv_8f.html','driver simple; solve A*X = B only',5),(6,'d','gbsv','general','band','Doxygen/docs/html/dgbsv_8f.html','driver simple; solve A*X = B only',6),(7,'c','gbsv','general','band','Doxygen/docs/html/cgbsv_8f.html','driver simple; solve A*X = B only',7),(8,'z','gbsv','general','band','Doxygen/docs/html/zgbsv_8f.html','driver simple; solve A*X = B only',8),(9,'s','gtsv','general','tridiagonal','Doxygen/docs/html/sgtsv_8f.html','driver simple; solve A*X = B only; Transpose',9),(10,'d','gtsv','general','tridiagonal','Doxygen/docs/html/dgtsv_8f.html','driver simple; solve A*X = B only; Transpose',10),(11,'c','gtsv','general','tridiagonal','Doxygen/docs/html/cgtsv_8f.html','driver simple; solve A*X = B only; Transpose',11),(12,'z','gtsv','general','tridiagonal','Doxygen/docs/html/zgtsv_8f.html','driver simple; solve A*X = B only; Transpose',12),(13,'c','hesv','Hermitian','full','Doxygen/docs/html/chesv_8f.html','driver simple; solve A*X = B only',13),(14,'z','hesv','Hermitian','full','Doxygen/docs/html/zhesv_8f.html','driver simple; solve A*X = B only',14),(15,'c','hpsv','Hermitian','packed','Doxygen/docs/html/chpsv_8f.html','driver simple; solve A*X = B only',15),(16,'z','hpsv','Hermitian','packed','Doxygen/docs/html/zhpsv_8f.html','driver simple; solve A*X = B only',16),(17,'s','posv','SPD','full','Doxygen/docs/html/sposv_8f.html','driver simple; solve A*X = B only',17),(18,'d','posv','SPD','full','Doxygen/docs/html/dposv_8f.html','driver simple; solve A*X = B only',18),(19,'c','posv','HPD','full','Doxygen/docs/html/cposv_8f.html','driver simple; solve A*X = B only',19),(20,'z','posv','HPD','full','Doxygen/docs/html/zposv_8f.html','driver simple; solve A*X = B only',20),(21,'s','pbsv','SPD','band','Doxygen/docs/html/spbsv_8f.html','driver simple; solve A*X = B only',21),(22,'d','pbsv','SPD','band','Doxygen/docs/html/dpbsv_8f.html','driver simple; solve A*X = B only',22),(23,'c','pbsv','HPD','band','Doxygen/docs/html/cpbsv_8f.html','driver simple; solve A*X = B only',23),(24,'z','pbsv','HPD','band','Doxygen/docs/html/zpbsv_8f.html','driver simple; solve A*X = B only',24),(25,'s','ppsv','SPD','packed','Doxygen/docs/html/sppsv_8f.html','driver simple; solve A*X = B only',25),(26,'d','ppsv','SPD','packed','Doxygen/docs/html/dppsv_8f.html','driver simple; solve A*X = B only',26),(27,'c','ppsv','HPD','packed','Doxygen/docs/html/cppsv_8f.html','driver simple; solve A*X = B only',27),(28,'z','ppsv','HPD','packed','Doxygen/docs/html/zppsv_8f.html','driver simple; solve A*X = B only',28),(29,'s','ptsv','SPD','tridiagonal','Doxygen/docs/html/sptsv_8f.html','driver simple; solve A*X = B only',29),(30,'d','ptsv','SPD','tridiagonal','Doxygen/docs/html/dptsv_8f.html','driver simple; solve A*X = B only',30),(31,'c','ptsv','HPD','tridiagonal','Doxygen/docs/html/cptsv_8f.html','driver simple; solve A*X = B only',31),(32,'z','ptsv','HPD','tridiagonal','Doxygen/docs/html/zptsv_8f.html','driver simple; solve A*X = B only',32),(33,'s','sysv','symmetric','full','Doxygen/docs/html/ssysv_8f.html','driver simple; solve A*X = B only',33),(34,'d','sysv','symmetric','full','Doxygen/docs/html/dsysv_8f.html','driver simple; solve A*X = B only',34),(35,'c','sysv','symmetric','full','Doxygen/docs/html/csysv_8f.html','driver simple; solve A*X = B only',35),(36,'z','sysv','symmetric','full','Doxygen/docs/html/zsysv_8f.html','driver simple; solve A*X = B only',36),(37,'s','spsv','symmetric','packed','Doxygen/docs/html/sspsv_8f.html','driver simple; solve A*X = B only',37),(38,'d','spsv','symmetric','packed','Doxygen/docs/html/dspsv_8f.html','driver simple; solve A*X = B only',38),(39,'c','spsv','symmetric','packed','Doxygen/docs/html/cspsv_8f.html','driver simple; solve A*X = B only',39),(40,'z','spsv','symmetric','packed','Doxygen/docs/html/zspsv_8f.html','driver simple; solve A*X = B only',40),(41,'d','sgesv','general','full','Doxygen/docs/html/dsgesv_8f.html','driver simple; solve A*X = B only; refinement',329),(42,'z','cgesv','general','full','Doxygen/docs/html/zcgesv_8f.html','driver simple; solve A*X = B only; refinement',330),(43,'d','sposv','SPD','full','Doxygen/docs/html/dsposv_8f.html','driver simple; solve A*X = B only; refinement',331),(44,'z','cposv','SPD','full','Doxygen/docs/html/zcposv_8f.html','driver simple; solve A*X = B only; refinement',332);
/*!40000 ALTER TABLE `driver_linearequation_simple` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `registration_registrationprofile`
--

DROP TABLE IF EXISTS `registration_registrationprofile`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!40101 SET character_set_client = utf8 */;
CREATE TABLE `registration_registrationprofile` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `user_id` int(11) NOT NULL,
  `activation_key` varchar(40) NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_id` (`user_id`)
) ENGINE=MyISAM AUTO_INCREMENT=31 DEFAULT CHARSET=latin1;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `registration_registrationprofile`
--

LOCK TABLES `registration_registrationprofile` WRITE;
/*!40000 ALTER TABLE `registration_registrationprofile` DISABLE KEYS */;
INSERT INTO `registration_registrationprofile` VALUES (30,32,'ALREADY_ACTIVATED');
/*!40000 ALTER TABLE `registration_registrationprofile` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2012-09-21 15:07:34
