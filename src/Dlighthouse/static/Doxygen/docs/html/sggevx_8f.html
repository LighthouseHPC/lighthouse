<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Lighthouse: lapack/sggevx.f File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!--<div id="titlearea">
</div>-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_42b7da8b2ebcfce3aea4b69198a0a9ad.html">lapack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">sggevx.f File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a47ddf03d427ec3f9346253132c26cf96"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sggevx_8f.html#a47ddf03d427ec3f9346253132c26cf96">sggevx</a> (BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, B, LDB, ALPHAR, ALPHAI, BETA, VL, LDVL, VR, LDVR, ILO, IHI, LSCALE, RSCALE, ABNRM, BBNRM, RCONDE, RCONDV, WORK, LWORK, IWORK, BWORK, INFO)</td></tr>
<tr class="memdesc:a47ddf03d427ec3f9346253132c26cf96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b> SGGEVX computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices</b>  <a href="#a47ddf03d427ec3f9346253132c26cf96"></a><br/></td></tr>
<tr class="separator:a47ddf03d427ec3f9346253132c26cf96"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a class="anchor" id="a47ddf03d427ec3f9346253132c26cf96"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine sggevx </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>BALANC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>JOBVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>SENSE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( lda, * )&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldb, * )&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDB</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>ALPHAI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>BETA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvl, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvr, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>ILO</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>IHI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>LSCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RSCALE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>ABNRM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real&#160;</td>
          <td class="paramname"><em>BBNRM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCONDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>RCONDV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, dimension( * )&#160;</td>
          <td class="paramname"><em>BWORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b> SGGEVX computes the eigenvalues and, optionally, the left and/or right eigenvectors for GE matrices</b> </p>
 
 Download SGGEVX + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/sggevx.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/sggevx.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/sggevx.f"> 
 [TXT]</a>
  <dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SGGEVX computes for a pair of N-by-N real nonsymmetric matrices (A,B)
 the generalized eigenvalues, and optionally, the left and/or right
 generalized eigenvectors.

 Optionally also, it computes a balancing transformation to improve
 the conditioning of the eigenvalues and eigenvectors (ILO, IHI,
 LSCALE, RSCALE, ABNRM, and BBNRM), reciprocal condition numbers for
 the eigenvalues (RCONDE), and reciprocal condition numbers for the
 right eigenvectors (RCONDV).

 A generalized eigenvalue for a pair of matrices (A,B) is a scalar
 lambda or a ratio alpha/beta = lambda, such that A - lambda*B is
 singular. It is usually represented as the pair (alpha,beta), as
 there is a reasonable interpretation for beta=0, and even for both
 being zero.

 The right eigenvector v(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

                  A * v(j) = lambda(j) * B * v(j) .

 The left eigenvector u(j) corresponding to the eigenvalue lambda(j)
 of (A,B) satisfies

                  u(j)**H * A  = lambda(j) * u(j)**H * B.

 where u(j)**H is the conjugate-transpose of u(j).</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">BALANC</td><td><pre class="fragment">          BALANC is CHARACTER*1
          Specifies the balance option to be performed.
          = 'N':  do not diagonally scale or permute;
          = 'P':  permute only;
          = 'S':  scale only;
          = 'B':  both permute and scale.
          Computed reciprocal condition numbers will be for the
          matrices after permuting and/or balancing. Permuting does
          not change condition numbers (in exact arithmetic), but
          balancing does.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBVL</td><td><pre class="fragment">          JOBVL is CHARACTER*1
          = 'N':  do not compute the left generalized eigenvectors;
          = 'V':  compute the left generalized eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">JOBVR</td><td><pre class="fragment">          JOBVR is CHARACTER*1
          = 'N':  do not compute the right generalized eigenvectors;
          = 'V':  compute the right generalized eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">SENSE</td><td><pre class="fragment">          SENSE is CHARACTER*1
          Determines which reciprocal condition numbers are computed.
          = 'N': none are computed;
          = 'E': computed for eigenvalues only;
          = 'V': computed for eigenvectors only;
          = 'B': computed for eigenvalues and eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrices A, B, VL, and VR.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">A</td><td><pre class="fragment">          A is REAL array, dimension (LDA, N)
          On entry, the matrix A in the pair (A,B).
          On exit, A has been overwritten. If JOBVL='V' or JOBVR='V'
          or both, then A contains the first part of the real Schur
          form of the "balanced" versions of the input A and B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDA</td><td><pre class="fragment">          LDA is INTEGER
          The leading dimension of A.  LDA &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">B</td><td><pre class="fragment">          B is REAL array, dimension (LDB, N)
          On entry, the matrix B in the pair (A,B).
          On exit, B has been overwritten. If JOBVL='V' or JOBVR='V'
          or both, then B contains the second part of the real Schur
          form of the "balanced" versions of the input A and B.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDB</td><td><pre class="fragment">          LDB is INTEGER
          The leading dimension of B.  LDB &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHAR</td><td><pre class="fragment">          ALPHAR is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ALPHAI</td><td><pre class="fragment">          ALPHAI is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BETA</td><td><pre class="fragment">          BETA is REAL array, dimension (N)
          On exit, (ALPHAR(j) + ALPHAI(j)*i)/BETA(j), j=1,...,N, will
          be the generalized eigenvalues.  If ALPHAI(j) is zero, then
          the j-th eigenvalue is real; if positive, then the j-th and
          (j+1)-st eigenvalues are a complex conjugate pair, with
          ALPHAI(j+1) negative.

          Note: the quotients ALPHAR(j)/BETA(j) and ALPHAI(j)/BETA(j)
          may easily over- or underflow, and BETA(j) may even be zero.
          Thus, the user should avoid naively computing the ratio
          ALPHA/BETA. However, ALPHAR and ALPHAI will be always less
          than and usually comparable with norm(A) in magnitude, and
          BETA always less than and usually comparable with norm(B).</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is REAL array, dimension (LDVL,N)
          If JOBVL = 'V', the left eigenvectors u(j) are stored one
          after another in the columns of VL, in the same order as
          their eigenvalues. If the j-th eigenvalue is real, then
          u(j) = VL(:,j), the j-th column of VL. If the j-th and
          (j+1)-th eigenvalues form a complex conjugate pair, then
          u(j) = VL(:,j)+i*VL(:,j+1) and u(j+1) = VL(:,j)-i*VL(:,j+1).
          Each eigenvector will be scaled so the largest component have
          abs(real part) + abs(imag. part) = 1.
          Not referenced if JOBVL = 'N'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVL</td><td><pre class="fragment">          LDVL is INTEGER
          The leading dimension of the matrix VL. LDVL &gt;= 1, and
          if JOBVL = 'V', LDVL &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is REAL array, dimension (LDVR,N)
          If JOBVR = 'V', the right eigenvectors v(j) are stored one
          after another in the columns of VR, in the same order as
          their eigenvalues. If the j-th eigenvalue is real, then
          v(j) = VR(:,j), the j-th column of VR. If the j-th and
          (j+1)-th eigenvalues form a complex conjugate pair, then
          v(j) = VR(:,j)+i*VR(:,j+1) and v(j+1) = VR(:,j)-i*VR(:,j+1).
          Each eigenvector will be scaled so the largest component have
          abs(real part) + abs(imag. part) = 1.
          Not referenced if JOBVR = 'N'.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVR</td><td><pre class="fragment">          LDVR is INTEGER
          The leading dimension of the matrix VR. LDVR &gt;= 1, and
          if JOBVR = 'V', LDVR &gt;= N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ILO</td><td><pre class="fragment">          ILO is INTEGER</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IHI</td><td><pre class="fragment">          IHI is INTEGER
          ILO and IHI are integer values such that on exit
          A(i,j) = 0 and B(i,j) = 0 if i &gt; j and
          j = 1,...,ILO-1 or i = IHI+1,...,N.
          If BALANC = 'N' or 'S', ILO = 1 and IHI = N.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">LSCALE</td><td><pre class="fragment">          LSCALE is REAL array, dimension (N)
          Details of the permutations and scaling factors applied
          to the left side of A and B.  If PL(j) is the index of the
          row interchanged with row j, and DL(j) is the scaling
          factor applied to row j, then
            LSCALE(j) = PL(j)  for j = 1,...,ILO-1
                      = DL(j)  for j = ILO,...,IHI
                      = PL(j)  for j = IHI+1,...,N.
          The order in which the interchanges are made is N to IHI+1,
          then 1 to ILO-1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RSCALE</td><td><pre class="fragment">          RSCALE is REAL array, dimension (N)
          Details of the permutations and scaling factors applied
          to the right side of A and B.  If PR(j) is the index of the
          column interchanged with column j, and DR(j) is the scaling
          factor applied to column j, then
            RSCALE(j) = PR(j)  for j = 1,...,ILO-1
                      = DR(j)  for j = ILO,...,IHI
                      = PR(j)  for j = IHI+1,...,N
          The order in which the interchanges are made is N to IHI+1,
          then 1 to ILO-1.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">ABNRM</td><td><pre class="fragment">          ABNRM is REAL
          The one-norm of the balanced matrix A.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BBNRM</td><td><pre class="fragment">          BBNRM is REAL
          The one-norm of the balanced matrix B.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCONDE</td><td><pre class="fragment">          RCONDE is REAL array, dimension (N)
          If SENSE = 'E' or 'B', the reciprocal condition numbers of
          the eigenvalues, stored in consecutive elements of the array.
          For a complex conjugate pair of eigenvalues two consecutive
          elements of RCONDE are set to the same value. Thus RCONDE(j),
          RCONDV(j), and the j-th columns of VL and VR all correspond
          to the j-th eigenpair.
          If SENSE = 'N' or 'V', RCONDE is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">RCONDV</td><td><pre class="fragment">          RCONDV is REAL array, dimension (N)
          If SENSE = 'V' or 'B', the estimated reciprocal condition
          numbers of the eigenvectors, stored in consecutive elements
          of the array. For a complex eigenvector two consecutive
          elements of RCONDV are set to the same value. If the
          eigenvalues cannot be reordered to compute RCONDV(j),
          RCONDV(j) is set to 0; this can only occur when the true
          value would be very small anyway.
          If SENSE = 'N' or 'E', RCONDV is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension (MAX(1,LWORK))
          On exit, if INFO = 0, WORK(1) returns the optimal LWORK.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LWORK</td><td><pre class="fragment">          LWORK is INTEGER
          The dimension of the array WORK. LWORK &gt;= max(1,2*N).
          If BALANC = 'S' or 'B', or JOBVL = 'V', or JOBVR = 'V',
          LWORK &gt;= max(1,6*N).
          If SENSE = 'E', LWORK &gt;= max(1,10*N).
          If SENSE = 'V' or 'B', LWORK &gt;= 2*N*N+8*N+16.

          If LWORK = -1, then a workspace query is assumed; the routine
          only calculates the optimal size of the WORK array, returns
          this value as the first entry of the WORK array, and no error
          message related to LWORK is issued by XERBLA.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IWORK</td><td><pre class="fragment">          IWORK is INTEGER array, dimension (N+6)
          If SENSE = 'E', IWORK is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">BWORK</td><td><pre class="fragment">          BWORK is LOGICAL array, dimension (N)
          If SENSE = 'N', BWORK is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value.
          = 1,...,N:
                The QZ iteration failed.  No eigenvectors have been
                calculated, but ALPHAR(j), ALPHAI(j), and BETA(j)
                should be correct for j=INFO+1,...,N.
          &gt; N:  =N+1: other than QZ iteration failed in SHGEQZ.
                =N+2: error return from STGEVC.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>April 2012 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  Balancing a matrix pair (A,B) includes, first, permuting rows and
  columns to isolate eigenvalues, second, applying diagonal similarity
  transformation to the rows and columns to make the rows and columns
  as close in norm as possible. The computed reciprocal condition
  numbers correspond to the balanced matrix. Permuting rows and columns
  will not change the condition numbers (in exact arithmetic) but
  diagonal scaling will.  For further explanation of balancing, see
  section 4.11.1.2 of LAPACK Users' Guide.

  An approximate error bound on the chordal distance between the i-th
  computed generalized eigenvalue w and the corresponding exact
  eigenvalue lambda is

       chord(w, lambda) &lt;= EPS * norm(ABNRM, BBNRM) / RCONDE(I)

  An approximate error bound for the angle between the i-th computed
  eigenvector VL(i) or VR(i) is given by

       EPS * norm(ABNRM, BBNRM) / DIF(i).

  For further explanation of the reciprocal condition numbers RCONDE
  and RCONDV, see section 4.11 of LAPACK User's Guide.</pre> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 14 2014 18:28:49 for Lighthouse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
