  <dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> CGBSVXX uses the LU factorization to compute the solution to a complex system of linear equations  A * X = B,  where A is an N-by-N matrix and X and B are N-by-NRHS matrices. If requested, both normwise and maximum componentwise error bounds are returned. CGBSVXX will return a solution with a tiny guaranteed error (O(eps) where eps is the working machine precision) unless the matrix is very ill-conditioned, in which case a warning is returned. Relevant condition numbers also are calculated and returned. CGBSVXX accepts user-provided factorizations and equilibration factors; see the definitions of the FACT and EQUED options. Solving with refinement and using a factorization from a previous CGBSVXX call will also produce a solution with either O(eps) errors or warnings, but we cannot make that claim for general user-provided factorizations and equilibration factors if they differ from what CGBSVXX would itself produce.<dl class="section user"><dt>Description: </dt><dd><pre class="fragment"> The following steps are performed: 1. If FACT = 'E', real scaling factors are computed to equilibrate the system:TRANS = 'N':  diag(R)*A*diag(C)  *inv(diag(C))*X = diag(R)*BTRANS = 'T': (diag(R)*A*diag(C))**T *inv(diag(R))*X = diag(C)*BTRANS = 'C': (diag(R)*A*diag(C))**H *inv(diag(R))*X = diag(C)*B Whether or not the system will be equilibrated depends on the scaling of the matrix A, but if equilibration is used, A is overwritten by diag(R)*A*diag(C) and B by diag(R)*B (if TRANS='N') or diag(C)*B (if TRANS = 'T' or 'C'). 2. If FACT = 'N' or 'E', the LU decomposition is used to factor the matrix A (after equilibration if FACT = 'E') asA = P * L * U, where P is a permutation matrix, L is a unit lower triangular matrix, and U is upper triangular. 3. If some U(i,i)=0, so that U is exactly singular, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A (see argument RCOND). If the reciprocal of the condition number is less than machine precision, the routine still goes on to solve for X and compute error bounds as described below. 4. The system of equations is solved for X using the factored form of A. 5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero), the routine will use iterative refinement to try to get a small error and error bounds.  Refinement calculates the residual to at least twice the working precision. 6. If equilibration was used, the matrix X is premultiplied by diag(C) (if TRANS = 'N') or diag(R) (if TRANS = 'T' or 'C') so that it solves the original system before equilibration.</pre> <pre class="fragment">  Some optional parameters are bundled in the PARAMS array.  These  settings determine how refinement is performed, but often the  defaults are acceptable.  If the defaults are acceptable, users  can pass NPARAMS = 0 which prevents the source code from accessing  the PARAMS argument.</pre></dd></dl>