  <dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SPOSVXX uses the Cholesky factorization A = U**T*U or A = L*L**T to compute the solution to a real system of linear equations A * X = B, where A is an N-by-N symmetric positive definite matrix and X and B are N-by-NRHS matrices. If requested, both normwise and maximum componentwise error bounds are returned. SPOSVXX will return a solution with a tiny guaranteed error (O(eps) where eps is the working machine precision) unless the matrix is very ill-conditioned, in which case a warning is returned. Relevant condition numbers also are calculated and returned. SPOSVXX accepts user-provided factorizations and equilibration factors; see the definitions of the FACT and EQUED options. Solving with refinement and using a factorization from a previous SPOSVXX call will also produce a solution with either O(eps) errors or warnings, but we cannot make that claim for general user-provided factorizations and equilibration factors if they differ from what SPOSVXX would itself produce.<dl class="section user"><dt>Description: </dt><dd><pre class="fragment"> The following steps are performed: 1. If FACT = 'E', real scaling factors are computed to equilibrate the system:diag(S)*A*diag(S)  *inv(diag(S))*X = diag(S)*B Whether or not the system will be equilibrated depends on the scaling of the matrix A, but if equilibration is used, A is overwritten by diag(S)*A*diag(S) and B by diag(S)*B. 2. If FACT = 'N' or 'E', the Cholesky decomposition is used to factor the matrix A (after equilibration if FACT = 'E') as A = U**T* U,  if UPLO = 'U', or A = L * L**T,  if UPLO = 'L', where U is an upper triangular matrix and L is a lower triangular matrix. 3. If the leading i-by-i principal minor is not positive definite, then the routine returns with INFO = i. Otherwise, the factored form of A is used to estimate the condition number of the matrix A (see argument RCOND).  If the reciprocal of the condition number is less than machine precision, the routine still goes on to solve for X and compute error bounds as described below. 4. The system of equations is solved for X using the factored form of A. 5. By default (unless PARAMS(LA_LINRX_ITREF_I) is set to zero), the routine will use iterative refinement to try to get a small error and error bounds.  Refinement calculates the residual to at least twice the working precision. 6. If equilibration was used, the matrix X is premultiplied by diag(S) so that it solves the original system before equilibration.</pre> <pre class="fragment">  Some optional parameters are bundled in the PARAMS array.  These  settings determine how refinement is performed, but often the  defaults are acceptable.  If the defaults are acceptable, users  can pass NPARAMS = 0 which prevents the source code from accessing  the PARAMS argument.</pre></dd></dl>