<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>Lighthouse: lapack/shsein.f File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="tabs.css" rel="stylesheet" type="text/css" />
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!--<div id="titlearea">
</div>-->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.2 -->
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_42b7da8b2ebcfce3aea4b69198a0a9ad.html">lapack</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions/Subroutines</a>  </div>
  <div class="headertitle">
<div class="title">shsein.f File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:afeb8d3b5107a64ac1edb3f9d2925435f"><td class="memItemLeft" align="right" valign="top">subroutine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="shsein_8f.html#afeb8d3b5107a64ac1edb3f9d2925435f">shsein</a> (SIDE, EIGSRC, INITV, SELECT, N, H, LDH, WR, WI, VL, LDVL, VR, LDVR, MM, M, WORK, IFAILL, IFAILR, INFO)</td></tr>
<tr class="memdesc:afeb8d3b5107a64ac1edb3f9d2925435f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><b>SHSEIN</b>  <a href="#afeb8d3b5107a64ac1edb3f9d2925435f"></a><br/></td></tr>
<tr class="separator:afeb8d3b5107a64ac1edb3f9d2925435f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function/Subroutine Documentation</h2>
<a class="anchor" id="afeb8d3b5107a64ac1edb3f9d2925435f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine shsein </td>
          <td>(</td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>SIDE</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>EIGSRC</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character&#160;</td>
          <td class="paramname"><em>INITV</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, dimension( * )&#160;</td>
          <td class="paramname"><em>SELECT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldh, * )&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WI</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvl, * )&#160;</td>
          <td class="paramname"><em>VL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( ldvr, * )&#160;</td>
          <td class="paramname"><em>VR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>LDVR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>MM</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real, dimension( * )&#160;</td>
          <td class="paramname"><em>WORK</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IFAILL</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension( * )&#160;</td>
          <td class="paramname"><em>IFAILR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer&#160;</td>
          <td class="paramname"><em>INFO</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><b>SHSEIN</b> </p>
 
 Download SHSEIN + dependencies 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.tgz?format=tgz&filename=/lapack/lapack_routine/shsein.f"> 
 [TGZ]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.zip?format=zip&filename=/lapack/lapack_routine/shsein.f"> 
 [ZIP]</a> 
 <a href="http://www.netlib.org/cgi-bin/netlibfiles.txt?format=txt&filename=/lapack/lapack_routine/shsein.f"> 
 [TXT]</a>
  <dl class="section user"><dt>Purpose: </dt><dd><pre class="fragment"> SHSEIN uses inverse iteration to find specified right and/or left
 eigenvectors of a real upper Hessenberg matrix H.

 The right eigenvector x and the left eigenvector y of the matrix H
 corresponding to an eigenvalue w are defined by:

              H * x = w * x,     y**h * H = w * y**h

 where y**h denotes the conjugate transpose of the vector y.</pre> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">SIDE</td><td><pre class="fragment">          SIDE is CHARACTER*1
          = 'R': compute right eigenvectors only;
          = 'L': compute left eigenvectors only;
          = 'B': compute both right and left eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">EIGSRC</td><td><pre class="fragment">          EIGSRC is CHARACTER*1
          Specifies the source of eigenvalues supplied in (WR,WI):
          = 'Q': the eigenvalues were found using SHSEQR; thus, if
                 H has zero subdiagonal elements, and so is
                 block-triangular, then the j-th eigenvalue can be
                 assumed to be an eigenvalue of the block containing
                 the j-th row/column.  This property allows SHSEIN to
                 perform inverse iteration on just one diagonal block.
          = 'N': no assumptions are made on the correspondence
                 between eigenvalues and diagonal blocks.  In this
                 case, SHSEIN must always perform inverse iteration
                 using the whole matrix H.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">INITV</td><td><pre class="fragment">          INITV is CHARACTER*1
          = 'N': no initial vectors are supplied;
          = 'U': user-supplied initial vectors are stored in the arrays
                 VL and/or VR.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">SELECT</td><td><pre class="fragment">          SELECT is LOGICAL array, dimension (N)
          Specifies the eigenvectors to be computed. To select the
          real eigenvector corresponding to a real eigenvalue WR(j),
          SELECT(j) must be set to .TRUE.. To select the complex
          eigenvector corresponding to a complex eigenvalue
          (WR(j),WI(j)), with complex conjugate (WR(j+1),WI(j+1)),
          either SELECT(j) or SELECT(j+1) or both must be set to
          .TRUE.; then on exit SELECT(j) is .TRUE. and SELECT(j+1) is
          .FALSE..</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">N</td><td><pre class="fragment">          N is INTEGER
          The order of the matrix H.  N &gt;= 0.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">H</td><td><pre class="fragment">          H is REAL array, dimension (LDH,N)
          The upper Hessenberg matrix H.
          If a NaN is detected in H, the routine will return with INFO=-6.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDH</td><td><pre class="fragment">          LDH is INTEGER
          The leading dimension of the array H.  LDH &gt;= max(1,N).</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">WR</td><td><pre class="fragment">          WR is REAL array, dimension (N)</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">WI</td><td><pre class="fragment">          WI is REAL array, dimension (N)

          On entry, the real and imaginary parts of the eigenvalues of
          H; a complex conjugate pair of eigenvalues must be stored in
          consecutive elements of WR and WI.
          On exit, WR may have been altered since close eigenvalues
          are perturbed slightly in searching for independent
          eigenvectors.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VL</td><td><pre class="fragment">          VL is REAL array, dimension (LDVL,MM)
          On entry, if INITV = 'U' and SIDE = 'L' or 'B', VL must
          contain starting vectors for the inverse iteration for the
          left eigenvectors; the starting vector for each eigenvector
          must be in the same column(s) in which the eigenvector will
          be stored.
          On exit, if SIDE = 'L' or 'B', the left eigenvectors
          specified by SELECT will be stored consecutively in the
          columns of VL, in the same order as their eigenvalues. A
          complex eigenvector corresponding to a complex eigenvalue is
          stored in two consecutive columns, the first holding the real
          part and the second the imaginary part.
          If SIDE = 'R', VL is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVL</td><td><pre class="fragment">          LDVL is INTEGER
          The leading dimension of the array VL.
          LDVL &gt;= max(1,N) if SIDE = 'L' or 'B'; LDVL &gt;= 1 otherwise.</pre></td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">VR</td><td><pre class="fragment">          VR is REAL array, dimension (LDVR,MM)
          On entry, if INITV = 'U' and SIDE = 'R' or 'B', VR must
          contain starting vectors for the inverse iteration for the
          right eigenvectors; the starting vector for each eigenvector
          must be in the same column(s) in which the eigenvector will
          be stored.
          On exit, if SIDE = 'R' or 'B', the right eigenvectors
          specified by SELECT will be stored consecutively in the
          columns of VR, in the same order as their eigenvalues. A
          complex eigenvector corresponding to a complex eigenvalue is
          stored in two consecutive columns, the first holding the real
          part and the second the imaginary part.
          If SIDE = 'L', VR is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">LDVR</td><td><pre class="fragment">          LDVR is INTEGER
          The leading dimension of the array VR.
          LDVR &gt;= max(1,N) if SIDE = 'R' or 'B'; LDVR &gt;= 1 otherwise.</pre></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">MM</td><td><pre class="fragment">          MM is INTEGER
          The number of columns in the arrays VL and/or VR. MM &gt;= M.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">M</td><td><pre class="fragment">          M is INTEGER
          The number of columns in the arrays VL and/or VR required to
          store the eigenvectors; each selected real eigenvector
          occupies one column and each selected complex eigenvector
          occupies two columns.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">WORK</td><td><pre class="fragment">          WORK is REAL array, dimension ((N+2)*N)</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IFAILL</td><td><pre class="fragment">          IFAILL is INTEGER array, dimension (MM)
          If SIDE = 'L' or 'B', IFAILL(i) = j &gt; 0 if the left
          eigenvector in the i-th column of VL (corresponding to the
          eigenvalue w(j)) failed to converge; IFAILL(i) = 0 if the
          eigenvector converged satisfactorily. If the i-th and (i+1)th
          columns of VL hold a complex eigenvector, then IFAILL(i) and
          IFAILL(i+1) are set to the same value.
          If SIDE = 'R', IFAILL is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">IFAILR</td><td><pre class="fragment">          IFAILR is INTEGER array, dimension (MM)
          If SIDE = 'R' or 'B', IFAILR(i) = j &gt; 0 if the right
          eigenvector in the i-th column of VR (corresponding to the
          eigenvalue w(j)) failed to converge; IFAILR(i) = 0 if the
          eigenvector converged satisfactorily. If the i-th and (i+1)th
          columns of VR hold a complex eigenvector, then IFAILR(i) and
          IFAILR(i+1) are set to the same value.
          If SIDE = 'L', IFAILR is not referenced.</pre></td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">INFO</td><td><pre class="fragment">          INFO is INTEGER
          = 0:  successful exit
          &lt; 0:  if INFO = -i, the i-th argument had an illegal value
          &gt; 0:  if INFO = i, i is the number of eigenvectors which
                failed to converge; see IFAILL and IFAILR for further
                details.</pre> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section author"><dt>Author</dt><dd>Univ. of Tennessee </dd>
<dd>
Univ. of California Berkeley </dd>
<dd>
Univ. of Colorado Denver </dd>
<dd>
NAG Ltd. </dd></dl>
<dl class="section date"><dt>Date</dt><dd>November 2013 </dd></dl>
<dl class="section user"><dt>Further Details: </dt><dd><pre class="fragment">  Each eigenvector is normalized so that the element of largest
  magnitude has magnitude 1; here the magnitude of a complex number
  (x,y) is taken to be |x|+|y|.</pre> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 14 2014 18:28:49 for Lighthouse by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.2
</small></address>
</body>
</html>
